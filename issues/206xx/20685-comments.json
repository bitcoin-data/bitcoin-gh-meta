[
   {
      "author_association" : "MEMBER",
      "body" : "Awesome work, concept ACK.",
      "created_at" : "2020-12-17T15:36:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747514698",
      "id" : 747514698,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0NzUxNDY5OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-17T15:36:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747514698",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19461 (multiprocess: Add bitcoin-gui -ipcconnect option by ryanofsky)\n* #19460 (multiprocess: Add bitcoin-wallet -ipcconnect option by ryanofsky)\n* #19288 (fuzz: Add fuzzing harness for TorController by practicalswift)\n* #19160 (multiprocess: Add basic spawn and IPC support by ryanofsky)\n* #16365 (Log RPC parameters (arguments) if -debug=rpcparams by LarryRuane)\n* #10102 ([experimental] Multiprocess bitcoin by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-12-17T20:13:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747675535",
      "id" : 747675535,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0NzY3NTUzNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-22T05:58:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747675535",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\n----------\r\n\r\nOnce this is enabled, we should clearly communicate that using a non-popular overlay has privacy/security side-effects",
      "created_at" : "2020-12-18T09:05:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747959538",
      "id" : 747959538,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0Nzk1OTUzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-18T09:05:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747959538",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@vasild Nice work!\r\n\r\nI like the abstraction  (`Sock`) you've added on top of the socket API. I'm adding something similar in #19203 (see `MockableSocket` and `FuzzedSocket`) to allow for fuzzing the more low-level parts of our networking code (in this specific case a regression fuzz harness for CVE-2017-18350).\r\n\r\nIf you have time: please check that PR out. It would be great if your socket abstraction also covered the needs of the the \"fuzzed socket\" use case. Ideally I'd like to implement my low-level networking code fuzzers using your socket abstraction (something along the lines of `class FuzzedSock : public Sock`) :)\r\n\r\nAside from of the I2P work I think your socket abstraction would be valuable on a stand-alone PR basis :)",
      "created_at" : "2020-12-18T15:09:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-748139978",
      "id" : 748139978,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0ODEzOTk3OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-18T15:10:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/748139978",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549152178"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549152178"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Q: in case `retval` contains the maximum allowed data shouldn't it get out of the loop?  I mean, I know this is how the previous version of this method worked but I would like to understand why is this how it is.  ",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-27T18:58:17Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549152178",
      "id" : 549152178,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1MjE3OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/readwritefile.cpp",
      "position" : 29,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549152178",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549154854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549154854"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Non-cpp programmer question: is this idiomatically valid?\r\n \r\n```suggestion\r\nbool WriteBinaryFile(const fs::path &filename, const std::string &data)\r\n{\r\n    FILE *f = fsbridge::fopen(filename, \"wb\");\r\n    if (f == nullptr)\r\n        return false;\r\n    if (fwrite(data.data(), 1, data.size(), f) == data.size()) {\r\n        return fclose(f) == 0;\r\n    }        \r\n    fclose(f);\r\n    return false;\r\n}\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-27T19:26:46Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n+{\n+    FILE *f = fsbridge::fopen(filename, \"wb\");\n+    if (f == nullptr)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    if (fclose(f) != 0) {\n+        return false;\n+    }\n+    return true;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549154854",
      "id" : 549154854,
      "line" : 47,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1NDg1NA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : 34,
      "path" : "src/util/readwritefile.cpp",
      "position" : 47,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : 34,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549154854",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549161698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549161698"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This makes `my`, `my=`, `my==` and so on until `my=====` all equivalent. Is this ok? I would have expected partial padding to be invalid.\r\n",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-27T20:43:01Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549161698",
      "id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE2MTY5OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549161698",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549430723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549430723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Build warning here, logical AND of equal expressions [-Wlogical-op]\r\n",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-28T17:48:58Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549430723",
      "id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMDcyMw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559240653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549430723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549475623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549475623"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Clarification: I am asking this because if this is allow then invalid addresses could be allowed by `SetSpecial`, I mean, something like `udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna=.b32.i2p` would be okay.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-28T20:20:53Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549475623",
      "id" : 549475623,
      "in_reply_to_id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3NTYyMw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 559290249,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549475623",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-12-28T23:05:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-751890774",
      "id" : 751890774,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MTg5MDc3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-28T23:05:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/751890774",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549614683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549614683"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, it should get out of the loop and it does due to `retval.size() <= maxsize`.\r\n\r\nIt is true that if `maxsize==10` and `fread()` returns 7 bytes and then 5 bytes, this function will return a `retval` that contains 12 bytes, exceeding `maxsize`. This is also how it works in `master` right now.\r\n\r\nFor the purposes of this PR it suffices to move `ReadBinaryFile()` out of `torcontrol.cpp` so that it can be reused by other code. So I tried to keep changes to the minimum - moved the function and only fixed a gross bug (commit `util: fix ReadBinaryFile() returning partial contents`).",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-29T08:27:05Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549614683",
      "id" : 549614683,
      "in_reply_to_id" : 549152178,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDY4Mw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/readwritefile.cpp",
      "position" : 29,
      "pull_request_review_id" : 559425900,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549614683",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549615177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549615177"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, those are the same. I guess, when writing new code, it would be a matter of taste which one to use.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-29T08:28:46Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n+{\n+    FILE *f = fsbridge::fopen(filename, \"wb\");\n+    if (f == nullptr)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    if (fclose(f) != 0) {\n+        return false;\n+    }\n+    return true;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549615177",
      "id" : 549615177,
      "in_reply_to_id" : 549154854,
      "line" : 47,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTE3Nw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : 34,
      "path" : "src/util/readwritefile.cpp",
      "position" : 47,
      "pull_request_review_id" : 559426489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : 34,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549615177",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "a0dc3a2d3...188ba34b4: rebased to resolve conflicts with `master`",
      "created_at" : "2020-12-29T09:40:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752013415",
      "id" : 752013415,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjAxMzQxNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T09:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752013415",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549640692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549640692"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this on Windows? Which compiler version? Is it upset that `WSAEAGAIN` equals to `WSAEWOULDBLOCK` and so we end up doing something like `err != 5 && err != 5`?\r\n\r\nI checked that gcc 10.2.1, 9.3.0 and 8.4.0 don't emit the warning if we do `err != 5 && err != 6 && err != 5`, so I just reordered the expressions as a simple fixup ro this. Will include in the next push.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-29T09:51:27Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549640692",
      "id" : 549640692,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY0MDY5Mg==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559456309,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549640692",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549650863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549650863"
         }
      },
      "author_association" : "MEMBER",
      "body" : "gcc Debian 10.2.1",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-29T10:22:54Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549650863",
      "id" : 549650863,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY1MDg2Mw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559468253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549650863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "188ba34b4...f0577c4d7:\r\n* disallow partial padding when decoding `.b32.i2p` addresses\r\n* fix gcc warning ~~(hopefully)~~",
      "created_at" : "2020-12-29T12:59:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752066569",
      "id" : 752066569,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjA2NjU2OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T18:00:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752066569",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549695916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549695916"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed in f0577c4?",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-29T13:00:49Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549695916",
      "id" : 549695916,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY5NTkxNg==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559522075,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549695916",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549699366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549699366"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hah, good catch! It occurred to me that we need not to support decoding base32 strings without padding in general and instead we can append `====` to the 52 chars before `.b32.i2p` and decode it as padded base32 string.\r\n\r\nThis simplifies this PR as I dropped one commit from it: `util: support DecodeBase32() without padding`. Also, added a check that the address is 52 base32 chars since we expect that adding 4 `=` symbols will make it multiple of 8. You suggested such a check [elsewhere](https://github.com/bitcoin/bitcoin/pull/20254#discussion_r543586946).",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-29T13:11:46Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549699366",
      "id" : 549699366,
      "in_reply_to_id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY5OTM2Ng==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 559525983,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549699366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "f0577c4d7...2ae504c4b: allow uppercase and mixedcase I2P addresses, [suggestion](https://github.com/bitcoin/bitcoin/pull/20254#discussion_r544431918)",
      "created_at" : "2020-12-29T13:27:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752074602",
      "id" : 752074602,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjA3NDYwMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T13:27:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752074602",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549765748"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549765748"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, thank you -- tested that it is fixed in 188ba34 and in 2ae504c",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-29T16:23:46Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549765748",
      "id" : 549765748,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NTc0OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559605596,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549765748",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341889"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341889"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Time ago Winsock used to have problems with peeking from sockets. According to the KB article below (old) `recv` with `MSG_PEEK`:\r\n\r\n> The peek operation will report the number of bytes up until the first buffer boundary. The bytes remaining in the other boundaries might never be reported, resulting in an incorrect count of data **for code algorithms that depend upon the peek values to be accurate**. Subsequent peek attempts will not reveal the \"hidden\" data, which can still be received from the buffers.\r\n\r\nI don't know if this is still a problem with winsock2 but even in that case it is probably not a problem this algorithm doesn't depend on the accuracy of the `peek_ret` value. Anyway, something to have in mind.\r\n\r\nhttps://mskb.pkisolutions.com/kb/192599",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-30T22:14:44Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341889",
      "id" : 550341889,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MTg4OQ==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1144,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560216246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341889",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341913"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that in case it reaches the deadline it should throw because otherwise the timeout will be infringed.\r\n```c++\r\nif (now >= deadline)\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-30T22:14:53Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = recv(socket, buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;\n+\n+            data.append(buf, buf + append_len);\n+\n+            if (terminator_found) {\n+                return data;\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now > deadline) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341913",
      "id" : 550341913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MTkxMw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1186,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560216246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341913",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550496783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550496783"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, even if the behavior is still the same, we are fine with it.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-31T14:43:30Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550496783",
      "id" : 550496783,
      "in_reply_to_id" : 550341889,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ5Njc4Mw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1144,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560396665,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550496783",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550497443"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550497443"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, and also `SendComplete()` uses `>=`. Changed.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2020-12-31T14:46:43Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = recv(socket, buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;\n+\n+            data.append(buf, buf + append_len);\n+\n+            if (terminator_found) {\n+                return data;\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now > deadline) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550497443",
      "id" : 550497443,
      "in_reply_to_id" : 550341913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ5NzQ0Mw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1186,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560401527,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550497443",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "2ae504c4b...9445dd490: consider it a timeout if the current time is exactly equal to the deadline",
      "created_at" : "2020-12-31T14:47:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752978740",
      "id" : 752978740,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1Mjk3ODc0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-31T14:47:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752978740",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-02T13:32:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-753474301",
      "id" : 753474301,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MzQ3NDMwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-02T13:32:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/753474301",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Do we actually want to share our address, though? I would think an anonymous connection is strictly better?",
      "created_at" : "2021-01-03T00:22:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-753548139",
      "id" : 753548139,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MzU0ODEzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-03T00:22:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/753548139",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Do we actually want to share our address, though?\r\n\r\nIn I2P, like in IP, connections have \"source address\".\r\n\r\n> I would think an anonymous connection is strictly better?\r\n\r\nWhy? In a P2P network peers are supposed to connect to each other, right? Not hide from each other? If we don't want connections to us, then we don't listen on the I2P address (`-i2pacceptincoming=0`) and nobody can reach back.",
      "created_at" : "2021-01-08T13:39:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-756760413",
      "id" : 756760413,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1Njc2MDQxMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-08T13:39:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/756760413",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "9445dd490...1cced4679: rebase due to conflicts",
      "created_at" : "2021-01-09T12:25:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-757141983",
      "id" : 757141983,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NzE0MTk4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-09T12:25:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/757141983",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nðµï¸ @harding @hebasto have been requested to review this pull request as specified in the REVIEWERS file.",
      "created_at" : "2021-01-13T11:46:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-759396675",
      "id" : 759396675,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1OTM5NjY3NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-13T11:46:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/759396675",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556654746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556654746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this is unnecessary.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-13T16:22:32Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556654746",
      "id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY1NDc0Ng==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556654746",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556661171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556661171"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What if no `VALUE` is received?",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-13T16:30:59Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556661171",
      "id" : 556661171,
      "line" : 189,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY2MTE3MQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 189,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 189,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556661171",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556670261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556670261"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If there is some kind of `startsWith` function i think it would be better.  ",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-13T16:42:52Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556670261",
      "id" : 556670261,
      "line" : 247,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3MDI2MQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 247,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 247,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556670261",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556675792"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556675792"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems correct to assume that `RESULT` is always returned but in one place in the i2p code I can see this:\r\n\r\n```c++\r\n} else if (ARG_IS(0,\"NAMING\") &&\r\n           ARG_IS(1, \"REPLY\")) {\r\n    if(NULL == (arg = ARG_FIND(\"RESULT\"))) {\r\n        SAMLOGS(\"Naming reply with no result\");\r\n       return 0;\r\n   }\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-13T16:50:23Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556675792",
      "id" : 556675792,
      "line" : 266,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3NTc5Mg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 266,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 266,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556675792",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556676518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556676518"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The `Reply` class could have a `isOk()` function, what do you think?",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-13T16:51:28Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556676518",
      "id" : 556676518,
      "line" : 266,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3NjUxOA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 266,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 266,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556676518",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558233662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558233662"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You mean the incremental wait time or just this line?",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-15T11:02:14Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558233662",
      "id" : 558233662,
      "in_reply_to_id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMzY2Mg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 569162831,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558233662",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558236009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558236009"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Then we will get an exception which is properly handled. Do you see any problems?",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-15T11:06:35Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558236009",
      "id" : 558236009,
      "in_reply_to_id" : 556661171,
      "line" : 189,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzNjAwOQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 189,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 189,
      "pull_request_review_id" : 569165674,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558236009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558275516"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558275516"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, if no `RESULT` is present then this function will throw an exception, which is ok. I think we should expect any reply from the I2P proxy, including malicious one.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-15T12:29:55Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558275516",
      "id" : 558275516,
      "in_reply_to_id" : 556675792,
      "line" : 266,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI3NTUxNg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 266,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 266,
      "pull_request_review_id" : 569217931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558275516",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558276418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558276418"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it is not worth to add `isOk()` method because it would be used in just one place - here and `reply.Get(\"RESULT\") != \"OK\"` is readable enough.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-15T12:31:44Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558276418",
      "id" : 558276418,
      "in_reply_to_id" : 556676518,
      "line" : 266,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI3NjQxOA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 266,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 266,
      "pull_request_review_id" : 569219166,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558276418",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558332601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558332601"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, I don't see any problem, it is just that I didn't see the exception handling.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-15T14:13:59Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558332601",
      "id" : 558332601,
      "in_reply_to_id" : 556661171,
      "line" : 189,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMzMjYwMQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 189,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 189,
      "pull_request_review_id" : 569293442,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558332601",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558335104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558335104"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Just this line because the next line is a `return true;` ",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-15T14:17:58Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558335104",
      "id" : 558335104,
      "in_reply_to_id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMzNTEwNA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 569296700,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558335104",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. This builds and runs cleanly. If anyone is running an i2p service, ping me on irc to try connecting to each other.",
      "created_at" : "2021-01-15T16:38:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761048965",
      "id" : 761048965,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTA0ODk2NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-15T16:38:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761048965",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559052032"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559052032"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i'd use `default: 1`, not \"true\"",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-16T23:23:32Z",
      "diff_hunk" : "@@ -447,7 +447,9 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-maxtimeadjustment\", strprintf(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\", DEFAULT_MAX_TIME_ADJUSTMENT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-maxuploadtarget=<n>\", strprintf(\"Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: %d)\", DEFAULT_MAX_UPLOAD_TARGET), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-onion=<ip:port>\", \"Use separate SOCKS5 proxy to reach peers via Tor onion services, set -noonion to disable (default: -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-    argsman.AddArg(\"-onlynet=<net>\", \"Make outgoing connections only through network <net> (ipv4, ipv6 or onion). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2psam=<ip:port>\", \"I2P SAM proxy to reach I2P peers and accept I2P connections (default: none)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2pacceptincoming\", \"If set and -i2psam is also set then incoming I2P connections are accepted via the SAM proxy. If this is not set but -i2psam is set then only outgoing connections will be made to the I2P network. Ignored if -i2psam is not set. Notice that listening for incoming I2P connections is done through the SAM proxy, not by binding to a local address and port (default: true)\", ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559052032",
      "id" : 559052032,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA1MjAzMg==",
      "original_commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "original_line" : 451,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 569974581,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559052032",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "We have an I2P-to-I2P Bitcoin network connection up this Sunday morning. EDIT: 2 connections :tada: \r\n\r\n![Screenshot from 2021-01-17 13-40-57](https://user-images.githubusercontent.com/2415484/104843271-a380ed00-58c1-11eb-8052-cecc354fc6bc.png)\r\n\r\nIf helpful, I added the following setting to `~/.bitcoin/bitcoin.conf`\r\n```\r\ni2psam=127.0.0.1:7656\r\n```\r\n ",
      "created_at" : "2021-01-17T11:53:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761799484",
      "id" : 761799484,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTc5OTQ4NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:44:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761799484",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "It needs to be anonymous others wise i2p address will never work fully\nOn Sun, Jan 17, 2021 at 6:55 AM Jon Atack <notifications@github.com> wrote:\n\n> We have an I2P-to-I2P Bitcoin network connection up this Sunday morning.\n>\n> [image: Screenshot from 2021-01-17 11-41-47]\n> <https://user-images.githubusercontent.com/2415484/104839627-3027ad00-58ba-11eb-8cc6-8c572d222561.png>\n>\n> If helpful, I added the following settings to ~/.bitcoin/bitcoin.conf\n>\n> i2psam=127.0.0.1:7656\n> i2pacceptincoming=1\n>\n> â\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761799484>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ASPKBM7LRCYPKYZKNVKG6GLS2LF4RANCNFSM4U7TL45Q>\n> .\n>\n",
      "created_at" : "2021-01-17T12:01:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761800688",
      "id" : 761800688,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgwMDY4OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:01:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761800688",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/77504691?v=4",
         "events_url" : "https://api.github.com/users/mshalabi1990/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mshalabi1990/followers",
         "following_url" : "https://api.github.com/users/mshalabi1990/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mshalabi1990/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mshalabi1990",
         "id" : 77504691,
         "login" : "mshalabi1990",
         "node_id" : "MDQ6VXNlcjc3NTA0Njkx",
         "organizations_url" : "https://api.github.com/users/mshalabi1990/orgs",
         "received_events_url" : "https://api.github.com/users/mshalabi1990/received_events",
         "repos_url" : "https://api.github.com/users/mshalabi1990/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mshalabi1990/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mshalabi1990/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mshalabi1990"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "It needs to be annymous to full work or else it will never work fully decentralized ",
      "created_at" : "2021-01-17T12:03:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761800993",
      "id" : 761800993,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgwMDk5Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:03:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761800993",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/77504691?v=4",
         "events_url" : "https://api.github.com/users/mshalabi1990/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mshalabi1990/followers",
         "following_url" : "https://api.github.com/users/mshalabi1990/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mshalabi1990/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mshalabi1990",
         "id" : 77504691,
         "login" : "mshalabi1990",
         "node_id" : "MDQ6VXNlcjc3NTA0Njkx",
         "organizations_url" : "https://api.github.com/users/mshalabi1990/orgs",
         "received_events_url" : "https://api.github.com/users/mshalabi1990/received_events",
         "repos_url" : "https://api.github.com/users/mshalabi1990/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mshalabi1990/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mshalabi1990/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mshalabi1990"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559171894"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559171894"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "[`HasPrefix()`](https://github.com/bitcoin/bitcoin/blob/30e664dcce1a9adb9ba9a29e4f0cf809767870dd/src/util/string.h#L82-L88) is a good candidate, would need some enchanting.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-17T12:07:05Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559171894",
      "id" : 559171894,
      "in_reply_to_id" : 556670261,
      "line" : 247,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MTg5NA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 247,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 247,
      "pull_request_review_id" : 570050987,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559171894",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172021"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ok :)",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-17T12:07:50Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172021",
      "id" : 559172021,
      "in_reply_to_id" : 556661171,
      "line" : 189,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MjAyMQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 189,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 189,
      "pull_request_review_id" : 570051048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172021",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172712"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You are right, removed!",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-17T12:13:45Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172712",
      "id" : 559172712,
      "in_reply_to_id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MjcxMg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 570051545,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172712",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559173945"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559173945"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Changed.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-17T12:24:09Z",
      "diff_hunk" : "@@ -447,7 +447,9 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-maxtimeadjustment\", strprintf(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\", DEFAULT_MAX_TIME_ADJUSTMENT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-maxuploadtarget=<n>\", strprintf(\"Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: %d)\", DEFAULT_MAX_UPLOAD_TARGET), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-onion=<ip:port>\", \"Use separate SOCKS5 proxy to reach peers via Tor onion services, set -noonion to disable (default: -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-    argsman.AddArg(\"-onlynet=<net>\", \"Make outgoing connections only through network <net> (ipv4, ipv6 or onion). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2psam=<ip:port>\", \"I2P SAM proxy to reach I2P peers and accept I2P connections (default: none)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2pacceptincoming\", \"If set and -i2psam is also set then incoming I2P connections are accepted via the SAM proxy. If this is not set but -i2psam is set then only outgoing connections will be made to the I2P network. Ignored if -i2psam is not set. Notice that listening for incoming I2P connections is done through the SAM proxy, not by binding to a local address and port (default: true)\", ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559173945",
      "id" : 559173945,
      "in_reply_to_id" : 559052032,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3Mzk0NQ==",
      "original_commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "original_line" : 451,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 570052304,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559173945",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "1cced4679...45e571315: rebase and address suggestions",
      "created_at" : "2021-01-17T12:24:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761803815",
      "id" : 761803815,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgwMzgxNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:24:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761803815",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559199774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559199774"
         }
      },
      "author_association" : "MEMBER",
      "body" : "clang formatting nit here and just above\r\n```suggestion\r\n        if (!(pollfd_entry.revents & (POLLERR | POLLHUP))) {\r\n```",
      "commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "created_at" : "2021-01-17T15:50:10Z",
      "diff_hunk" : "@@ -613,6 +616,120 @@ SOCKET CreateSocket(const CService &addrConnect)\n     return hSocket;\n }\n \n+#ifdef USE_POLL\n+void SocketEvents(Sockets& sockets,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    std::unordered_map<SOCKET, struct pollfd> pollfds;\n+\n+    for (SOCKET socket_id : sockets.recv) {\n+        pollfds[socket_id].fd = socket_id;\n+        pollfds[socket_id].events |= POLLIN;\n+    }\n+\n+    for (SOCKET socket_id : sockets.send) {\n+        pollfds[socket_id].fd = socket_id;\n+        pollfds[socket_id].events |= POLLOUT;\n+    }\n+\n+    for (SOCKET socket_id : sockets.err) {\n+        pollfds[socket_id].fd = socket_id;\n+        // These flags are ignored, but we set them for clarity\n+        pollfds[socket_id].events |= POLLERR|POLLHUP;\n+    }\n+\n+    std::vector<struct pollfd> vpollfds;\n+    vpollfds.reserve(pollfds.size());\n+    for (auto it : pollfds) {\n+        vpollfds.push_back(std::move(it.second));\n+    }\n+\n+    if (poll(vpollfds.data(), vpollfds.size(), timeout.count()) < 0) return;\n+\n+    if (interrupt) {\n+        return;\n+    }\n+\n+    for (struct pollfd pollfd_entry : vpollfds) {\n+        if (!(pollfd_entry.revents & POLLIN)) {\n+            sockets.recv.erase(pollfd_entry.fd);\n+        }\n+        if (!(pollfd_entry.revents & POLLOUT)) {\n+            sockets.send.erase(pollfd_entry.fd);\n+        }\n+        if (!(pollfd_entry.revents & (POLLERR|POLLHUP))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559199774",
      "id" : 559199774,
      "line" : 661,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE5OTc3NA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 661,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 120,
      "pull_request_review_id" : 570069439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-17T18:12:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559199774",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Stepping through the commits and building one-by-one.\r\n\r\nIn 87ebd74 `SocketEvents()` `interrupt` is used like an \"in\" param but it is passed by reference like an \"out\" param\r\n```diff\r\n+++ b/src/net.h\r\n@@ -1069,8 +1069,9 @@ private:\r\n      * @param[in,out] sockets When the function is called this is expected to contain the\r\n      * sockets that should be checked for readiness. Upon return only ready sockets are\r\n      * left in it (non-ready sockets are removed).\r\n+     * @param[in] interrupt Cancel the operation if this is signaled.\r\n      */\r\n-    void SocketEvents(Sockets& sockets);\r\n+    void SocketEvents(Sockets& sockets, CThreadInterrupt& interrupt);\r\n```\r\n",
      "created_at" : "2021-01-17T16:11:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761836549",
      "id" : 761836549,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgzNjU0OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T16:11:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761836549",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Starting from ad56288e9b2f, it seems the various `std::chrono::milliseconds timeout` params can be passed by value.",
      "created_at" : "2021-01-17T16:42:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761841535",
      "id" : 761841535,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTg0MTUzNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T16:42:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761841535",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559213448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559213448"
         }
      },
      "author_association" : "MEMBER",
      "body" : "782de68a7008a\r\n```suggestion\r\n    const CAddress addr_bind = GetBindAddress(socket);\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-17T17:37:38Z",
      "diff_hunk" : "@@ -1013,26 +1028,44 @@ bool CConnman::AttemptToEvictConnection()\n void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+    SOCKET socket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n     CAddress addr;\n-    int nInbound = 0;\n-    int nMaxInbound = nMaxConnections - m_max_outbound;\n \n-    if (hSocket != INVALID_SOCKET) {\n-        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-            LogPrintf(\"Warning: Unknown socket family\\n\");\n+    if (socket == INVALID_SOCKET) {\n+        const int nErr = WSAGetLastError();\n+        if (nErr != WSAEWOULDBLOCK) {\n+            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n         }\n+        return;\n+    }\n+\n+    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n+        LogPrintf(\"Warning: Unknown socket family\\n\");\n     }\n \n-    NetPermissionFlags permissionFlags = NetPermissionFlags::PF_NONE;\n-    hListenSocket.AddSocketPermissionFlags(permissionFlags);\n-    AddWhitelistPermissionFlags(permissionFlags, addr);\n-    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_ISIMPLICIT)) {\n-        NetPermissions::ClearFlag(permissionFlags, PF_ISIMPLICIT);\n-        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permissionFlags, PF_FORCERELAY);\n-        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permissionFlags, PF_RELAY);\n-        NetPermissions::AddFlag(permissionFlags, PF_MEMPOOL);\n-        NetPermissions::AddFlag(permissionFlags, PF_NOBAN);\n+    const CAddress& addr_bind = GetBindAddress(socket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559213448",
      "id" : 559213448,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIxMzQ0OA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 1046,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 570069439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559213448",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Consider dropping a3b33637f as the renaming is to a generic name that is less useful for searching for the variable in the code (false positives go from none to many), or renaming to a more unique name but the current one seems fine; this isn't new code.\r\n\r\nEdit: same feedback for ccc5966a; consider dropping the change or using a slightly less generic name, like `permission_flags`. This isn't new code, so you aren't required to rename the variables.",
      "created_at" : "2021-01-17T17:59:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761852969",
      "id" : 761852969,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTg1Mjk2OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T18:11:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761852969",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229369"
         }
      },
      "author_association" : "MEMBER",
      "body" : "484dc6559 suggest adding quotes and/or removing the trailing \".\" (if you add quotes here, maybe also line 298)\r\n```suggestion\r\n    // I2P addresses that we support consist of 52 base32 characters + \".b32.i2p\"\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-17T19:48:42Z",
      "diff_hunk" : "@@ -275,6 +284,33 @@ bool CNetAddr::SetSpecial(const std::string& str)\n     return false;\n }\n \n+bool CNetAddr::SetI2P(const std::string& str)\n+{\n+    // I2P addresses that we support consist of 52 base32 characters + .b32.i2p.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229369",
      "id" : 559229369,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIyOTM2OQ==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 289,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/netaddress.cpp",
      "position" : null,
      "pull_request_review_id" : 570088398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229369",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "484dc65591b perhaps a few additional sanity checks\r\n```diff\r\n@@ -321,6 +321,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\r\n     BOOST_REQUIRE(addr.IsTor());\r\n \r\n+    BOOST_CHECK(!addr.IsI2P());\r\n     BOOST_CHECK(!addr.IsBindAny());\r\n     BOOST_CHECK(addr.IsAddrV1Compatible());\r\n     BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\r\n@@ -331,6 +332,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\r\n     BOOST_REQUIRE(addr.IsTor());\r\n \r\n+    BOOST_CHECK(!addr.IsI2P());\r\n     BOOST_CHECK(!addr.IsBindAny());\r\n     BOOST_CHECK(!addr.IsAddrV1Compatible());\r\n     BOOST_CHECK_EQUAL(addr.ToString(), torv3_addr);\r\n@@ -357,6 +359,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\r\n     BOOST_REQUIRE(addr.IsI2P());\r\n \r\n+    BOOST_CHECK(!addr.IsTor());\r\n     BOOST_CHECK(!addr.IsBindAny());\r\n     BOOST_CHECK(!addr.IsAddrV1Compatible());\r\n     BOOST_CHECK_EQUAL(addr.ToString(), ToLower(i2p_addr));\r\n```\r\n",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-17T19:52:18Z",
      "diff_hunk" : "@@ -351,6 +351,34 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     // TOR, invalid base32\n     BOOST_CHECK(!addr.SetSpecial(std::string{\"mf*g zak.onion\"}));\n \n+    // I2P\n+    const char* i2p_addr = \"UDHDrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.I2P\";\n+    BOOST_REQUIRE(addr.SetSpecial(i2p_addr));\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsI2P());\n+\n+    BOOST_CHECK(!addr.IsBindAny());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229820",
      "id" : 559229820,
      "line" : 364,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIyOTgyMA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 364,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/test/net_tests.cpp",
      "position" : 27,
      "pull_request_review_id" : 570088398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK. Built and working with no major issues.",
      "created_at" : "2021-01-18T07:45:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762052790",
      "id" : 762052790,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjA1Mjc5MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-18T07:45:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762052790",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3072149?v=4",
         "events_url" : "https://api.github.com/users/duncandean/events{/privacy}",
         "followers_url" : "https://api.github.com/users/duncandean/followers",
         "following_url" : "https://api.github.com/users/duncandean/following{/other_user}",
         "gists_url" : "https://api.github.com/users/duncandean/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/duncandean",
         "id" : 3072149,
         "login" : "duncandean",
         "node_id" : "MDQ6VXNlcjMwNzIxNDk=",
         "organizations_url" : "https://api.github.com/users/duncandean/orgs",
         "received_events_url" : "https://api.github.com/users/duncandean/received_events",
         "repos_url" : "https://api.github.com/users/duncandean/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/duncandean/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/duncandean/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/duncandean"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "45e571315...b49a4a06e: address review suggestions\r\n\r\n> SocketEvents() interrupt is used like an \"in\" param but it is passed by reference like an \"out\" param\r\n\r\nThe `sleep_for()` method of `CThreadInterrupt` is not `const`, thus the variable is passed by non-`const` reference. I changed the comment to say `@param[in,out]`.\r\n\r\n> Starting from ad56288, it seems the various std::chrono::milliseconds timeout params can be passed by value.\r\n\r\nI am not sure those are trivial types like `int`, `double`, etc. Thus I pass them by `const` reference.\r\n\r\n> Consider dropping a3b3363 as the renaming...\r\n\r\nDropped the two renames, reducing the size of this PR.\r\n\r\nNote: if the above were posted as \"review comments\" attached to some line, then the replies would be next to them and also they could be hidden/collapsed once resolved.",
      "created_at" : "2021-01-18T16:04:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762340697",
      "id" : 762340697,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjM0MDY5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-18T16:13:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762340697",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559673351"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559673351"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added, thanks!",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-18T16:13:56Z",
      "diff_hunk" : "@@ -351,6 +351,34 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     // TOR, invalid base32\n     BOOST_CHECK(!addr.SetSpecial(std::string{\"mf*g zak.onion\"}));\n \n+    // I2P\n+    const char* i2p_addr = \"UDHDrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.I2P\";\n+    BOOST_REQUIRE(addr.SetSpecial(i2p_addr));\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsI2P());\n+\n+    BOOST_CHECK(!addr.IsBindAny());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559673351",
      "id" : 559673351,
      "in_reply_to_id" : 559229820,
      "line" : 364,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3MzM1MQ==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 364,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/test/net_tests.cpp",
      "position" : 27,
      "pull_request_review_id" : 570629149,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559673351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675066"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added quotes, but left the dot.\r\n\r\n```cpp\r\n// Comments start with a capital letter and end with a dot, like real sentences.\r\n```\r\n\r\n```cpp\r\n// Comments start with a capital letter and end with a dot, like real sentences. This\r\n// makes it easy to extend with another sentence.\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-18T16:16:53Z",
      "diff_hunk" : "@@ -275,6 +284,33 @@ bool CNetAddr::SetSpecial(const std::string& str)\n     return false;\n }\n \n+bool CNetAddr::SetI2P(const std::string& str)\n+{\n+    // I2P addresses that we support consist of 52 base32 characters + .b32.i2p.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675066",
      "id" : 559675066,
      "in_reply_to_id" : 559229369,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NTA2Ng==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 289,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/netaddress.cpp",
      "position" : null,
      "pull_request_review_id" : 570631381,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675066",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675424"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675424"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-01-18T16:17:27Z",
      "diff_hunk" : "@@ -1013,26 +1028,44 @@ bool CConnman::AttemptToEvictConnection()\n void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+    SOCKET socket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n     CAddress addr;\n-    int nInbound = 0;\n-    int nMaxInbound = nMaxConnections - m_max_outbound;\n \n-    if (hSocket != INVALID_SOCKET) {\n-        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-            LogPrintf(\"Warning: Unknown socket family\\n\");\n+    if (socket == INVALID_SOCKET) {\n+        const int nErr = WSAGetLastError();\n+        if (nErr != WSAEWOULDBLOCK) {\n+            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n         }\n+        return;\n+    }\n+\n+    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n+        LogPrintf(\"Warning: Unknown socket family\\n\");\n     }\n \n-    NetPermissionFlags permissionFlags = NetPermissionFlags::PF_NONE;\n-    hListenSocket.AddSocketPermissionFlags(permissionFlags);\n-    AddWhitelistPermissionFlags(permissionFlags, addr);\n-    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_ISIMPLICIT)) {\n-        NetPermissions::ClearFlag(permissionFlags, PF_ISIMPLICIT);\n-        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permissionFlags, PF_FORCERELAY);\n-        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permissionFlags, PF_RELAY);\n-        NetPermissions::AddFlag(permissionFlags, PF_MEMPOOL);\n-        NetPermissions::AddFlag(permissionFlags, PF_NOBAN);\n+    const CAddress& addr_bind = GetBindAddress(socket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675424",
      "id" : 559675424,
      "in_reply_to_id" : 559213448,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NTQyNA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 1046,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 570631811,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675424",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "A few notes:\r\n\r\n* We use SAM version 3.1 (`HELLO VERSION MIN=3.1 MAX=3.1`) because it is the maximum supported by the C++ i2p daemon (as of i2pd 2.35.0).\r\n\r\n* Ports seem to be ignored, so I default them to `8333`. [SAM 3.2](https://geti2p.net/en/docs/api/samv3) defines `FROM_PORT` and `TO_PORT`, but we use SAM 3.1. As a consequence we can connect to any port on a given I2P address - once we listen on `foo.b32.i2p`, a peer can connect to us on `foo.b32.i2p:8333`, `foo.b32.i2p:1234`, `foo.b32.i2p:80`, etc.\r\n\r\n* ~~`RemoveLocal()` is not called if the connection to the I2P daemon dies, e.g. the I2P daemon is shut down. In order to stop advertising our I2P address (via other connections, if we have such ones, e.g. IPv4) we need to do that. Probably `Session::Accept()` needs to be split to two methods: `Session:Listen()` and `Session::Accept()`.~~ [Fixed](https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765239583).",
      "created_at" : "2021-01-18T16:40:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762360140",
      "id" : 762360140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjM2MDE0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T08:59:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762360140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I am not sure those are trivial types like `int`, `double`, etc. Thus I pass them by `const` reference.\r\n\r\nIIUC according to https://en.cppreference.com/w/cpp/chrono/duration \"The only data stored in a duration is a tick count of type Rep\": `std::chrono::milliseconds | duration</*signed integer type of at least 45 bits*/, std::milli>`. If that is correct, it would be nice to avoid a situation like with CAmounts, which are a cheaply copied value but are passed around by reference to const all over this codebase, presumably because early on someone thought it wasn't cheap and then that style was replicated in code changes down the line. Not a huge issue but we may as well start off on the right foot.\r\n\r\n",
      "created_at" : "2021-01-18T23:53:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762519047",
      "id" : 762519047,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjUxOTA0Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-23T16:51:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762519047",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yes, @leonardojobim connected to me and saw the addnode remove issue, thanks for confirming. @vasild and I encountered it as well.",
      "created_at" : "2021-01-20T10:23:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-763501409",
      "id" : 763501409,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MzUwMTQwOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-20T10:23:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/763501409",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "b49a4a06e...39021d931:\r\n\r\n* Split the `Accept()` method to `Listen()` and `Accept()`, so that the caller from `net.cpp` can do `AddLocal()` when we are listening and `RemoveLocal()` when listening fails (e.g. the I2P proxy is shut down).\r\n\r\n* Do not `AddLocal()` after we connect to a I2P peer - should only do this when listening. As a result the newly added function `AddLocalIfNotKnown()` is not needed and thus dropped.\r\n\r\n* After a failure to listen, accept or connect - check whether the control socket is still connected and if not, then destroy the session. This is not strictly necessary, but makes us detect a possible I2P proxy shutdown earlier.\r\n\r\n* If `-listen=0` is given, then soft-flip `-i2pacceptincoming` from `1` to `0`. Still, if `-listen=0 -i2pacceptincoming=1` is explicitly given, then allow that as there is no technical reason it would not work as expected (listen for and accept only I2P connections).\r\n",
      "created_at" : "2021-01-22T08:41:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765239583",
      "id" : 765239583,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NTIzOTU4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T08:41:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/765239583",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "39021d931...7da1e29fc: rebase due to conflicts",
      "created_at" : "2021-01-22T13:25:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765393582",
      "id" : 765393582,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NTM5MzU4Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T13:25:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/765393582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-22T13:26:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765394346",
      "id" : 765394346,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NTM5NDM0Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T13:26:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/765394346",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-26T11:12:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-767474130",
      "id" : 767474130,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NzQ3NDEzMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T11:12:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767474130",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm still testing this on one of my nodes. It is working great. I've had a few connections to other I2P peers.\r\n\r\nI'm testing with the Java implementation of I2P, it has some typical java problems like high CPU and memory use. Compared to Tor at least. Of course, this is not the fault of this PR :slightly_smiling_face: \r\n\r\nAnother thing (that @jonatack) noted is that I2P has higher latency than Tor onion services. At least I suppose this is an inherent problem with I2P and not the code here. Network latency is not generally a problem for bitcoin but as eviction decisions are made based on (among other things) ping times. This might be something to look into, but not necessarily in this PR, as a first step *adding I2P support* at all is a good and self-contained change.\r\n",
      "created_at" : "2021-01-26T11:37:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-767486499",
      "id" : 767486499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NzQ4NjQ5OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T11:44:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767486499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Another thing (that @jonatack) noted is that I2P has higher latency than Tor onion services. At least I suppose this is an inherent problem with I2P and not the code here. Network latency is not generally a problem for bitcoin but as eviction decisions are made based on (among other things) ping times. This might be something to look into, but not necessarily in this PR.\r\n\r\nWorking on this either for #20197 or a follow-up. \r\n",
      "created_at" : "2021-01-26T13:06:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-767529236",
      "id" : 767529236,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NzUyOTIzNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T13:06:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767529236",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "utACK 7da1e29fcc8a4fdff19f24d5be501ce4c0eeaa21",
      "created_at" : "2021-01-28T14:33:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-769104690",
      "id" : 769104690,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2OTEwNDY5MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-28T14:33:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/769104690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "7da1e29fc...08d0c27d7: rebase due to conflicts",
      "created_at" : "2021-01-29T10:38:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-769725377",
      "id" : 769725377,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2OTcyNTM3Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-29T10:38:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/769725377",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "08d0c27d7...2caf1bff3: pass `std::chrono` variables by value instead of by const reference, as per [suggestion](https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762519047). Thanks, @jonatack!",
      "created_at" : "2021-01-29T10:41:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-769726722",
      "id" : 769726722,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2OTcyNjcyMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-29T10:41:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/769726722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'd like to help move this forward. Is this pull independent of #20788?",
      "created_at" : "2021-02-03T17:15:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-772674683",
      "id" : 772674683,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3MjY3NDY4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-03T17:15:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/772674683",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "This PR is independent of #20788. However, #20788 was born as a subset of this PR because it adds goodness independently of this PR.  Some of the suggestions made there and here (drop commits with renames, for example) have been made here but not in #20788 yet. Anyway, imo i think merging #20788 first could help to reduce the size of this one. ",
      "created_at" : "2021-02-04T02:56:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-772988859",
      "id" : 772988859,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3Mjk4ODg1OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-04T02:56:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/772988859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@lontivero thank you, that is very helpful; will finishing reviewing here then as it is ahead of #20788 in its updates. @vasild you can drop my -netinfo commit now that #20764 is merged, sorry for the rebase (but it is now i2p-ready :sunglasses:) ",
      "created_at" : "2021-02-05T15:13:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-774093064",
      "id" : 774093064,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3NDA5MzA2NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-05T15:16:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/774093064",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-02-05T15:17:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-774095351",
      "id" : 774095351,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3NDA5NTM1MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-05T15:17:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/774095351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Per my conversation with @jonatack on Clubhouse, this i2p router that some Monero contributors have created may be of use: https://github.com/i2p-zero/i2p-zero\r\n\r\nIt's VERY lightweight, even compared to i2pd and the full i2p router, implements SAM, and bundles a JVM.",
      "created_at" : "2021-02-05T15:48:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-774114960",
      "id" : 774114960,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3NDExNDk2MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-05T15:48:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/774114960",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1944293?v=4",
         "events_url" : "https://api.github.com/users/fluffypony/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fluffypony/followers",
         "following_url" : "https://api.github.com/users/fluffypony/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fluffypony/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fluffypony",
         "id" : 1944293,
         "login" : "fluffypony",
         "node_id" : "MDQ6VXNlcjE5NDQyOTM=",
         "organizations_url" : "https://api.github.com/users/fluffypony/orgs",
         "received_events_url" : "https://api.github.com/users/fluffypony/received_events",
         "repos_url" : "https://api.github.com/users/fluffypony/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fluffypony/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fluffypony/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fluffypony"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "2caf1bff3...2f71ee2b2: rebase due to conflicts and drop the last commit `cli: add i2p network to -netinfo` because an enhanced version of it is now in `master` via #20764.\r\n\r\n@jonatack, excellent, reducing the size of this PR! Getting #20788 merged will reduce it further.",
      "created_at" : "2021-02-06T13:52:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-774480735",
      "id" : 774480735,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3NDQ4MDczNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-06T13:52:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/774480735",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-02-11T13:11:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-777445523",
      "id" : 777445523,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3NzQ0NTUyMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-11T13:11:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/777445523",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Noting here some IRC discussions on installing I2P as a reference for later, e.g. a future `doc/i2p.md`, or for people looking to install it:\r\n\r\n- http://www.erisian.com.au/bitcoin-core-dev/log-2021-02-09.html#l-609\r\n- http://www.erisian.com.au/bitcoin-core-dev/log-2021-02-10.html#l-207\r\n- http://www.erisian.com.au/bitcoin-core-dev/log-2021-02-10.html#l-482",
      "created_at" : "2021-02-11T13:26:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-777455470",
      "id" : 777455470,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3NzQ1NTQ3MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-11T13:26:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/777455470",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "2f71ee2b2...a456bd3f2:\r\n\r\n* Remove the `Sock` definition from this PR as it is now [merged](https://github.com/bitcoin/bitcoin/pull/20788) in `master`.\r\n* Do not extract `CConnman::SocketEvents()` as a standalone function since it is not needed anymore - in all places we wait for an event on one socket and for this we can use `Sock::Wait()`.\r\n* [Extend](https://github.com/bitcoin/bitcoin/pull/20788#issuecomment-778617207) `Sock::Wait()` to report to the caller whether a timeout occurred or one of the requested events.\r\n* Add `SendComplete()` and `RecvUntilTerminator()` as `Sock` methods instead of as standalone functions whose first argument is the socket.\r\n* When generating our pub/priv keys (aka I2P destination) use `7` instead of `EdDSA_SHA512_Ed25519` since i2pd <2.24.0 only understand the numeric one (thanks to @sdaftuar for nailing this!)\r\n",
      "created_at" : "2021-02-13T13:17:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-778617984",
      "id" : 778617984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3ODYxNzk4NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-13T13:17:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/778617984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated my I2P-using node to the new version (a456bd3f296f18e463e36048c866c404b69363b6) for testing.",
      "created_at" : "2021-02-13T22:37:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-778688034",
      "id" : 778688034,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3ODY4ODAzNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-13T22:37:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/778688034",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Testing a Clang 9 build of a456bd3f296f18e463e36048c866c404b69363b6 with i2pd 2.35 did not work\r\n```\r\n2021-02-13T23:31:35Z I2P: SAM session created: session id=86eaxxaxxxx, my address=zsxwyo6qcn3chqzwxnseusqgsnuw3maqnztkiypyfxtyxxxxxxxx.b32.i2p:8333\r\n2021-02-13T23:31:35Z AddLocal(zsxwyo6qcn3chqzwxnseusqgsnuw3maqnztkiypyfxtyxxxxxxxx.b32.i2p:8333,2)\r\nIllegal instruction\r\n```\r\n```\r\nDebian 5.10.13-1 (2021-02-06) x86_64 GNU/Linux\r\n```\r\n```\r\ni2pd version 2.35.0 (0.9.48)\r\nBoost version 1.74.0\r\nOpenSSL 1.1.1i  8 Dec 2020\r\n```\r\nMade two further attempts with the same result :crying_cat_face:...it's after 1 am and I have not yet looked into the code changes since the last push, but then built with the same config on 2f71ee2b2 (previous push) and it's working again...:cat: \r\n",
      "created_at" : "2021-02-14T00:20:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-778698152",
      "id" : 778698152,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3ODY5ODE1Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-14T00:20:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/778698152",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> 2021-02-13T23:31:35Z AddLocal(zsxwyo6qcn3chqzwxnseusqgsnuw3maqnztkiypyfxtyxxxxxxxx.b32.i2p:8333,2)\r\n> Illegal instruction\r\n\r\nCan you give a gdb backtrace please? With disassembly (`disass`) at the crash location, if possible. The post common cause of Illegal Instruction is your compiler generating extension instructions that the specific CPU can't handle. I don't understand how it could be introduced here though.",
      "created_at" : "2021-02-14T10:53:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-778760608",
      "id" : 778760608,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3ODc2MDYwOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-14T10:53:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/778760608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Hm, gdb didn't hit the issue (I'll try again) but valgrind did.\r\n```\r\n2021-02-14T14:45:19Z New outbound peer connected: version: 70015, blocks=670586, peer=1, peeraddr=144.76.81.194:8333 (outbound-full-relay)\r\n2021-02-14T14:45:39Z I2P: SAM session created: session id=qqqq, my address=qqqq.b32.i2p:8333\r\n2021-02-14T14:45:41Z UpdateTip: new best=00000000000000000009e0b532bf3ff388c9d7c4489b0bcf2631f75195609c57 height=670580 version=0x3fff0000 log2_work=92.668088 tx=616177992 date='2021-02-14T13:15:07Z' progress=0.999969 cache=1.5MiB(10863txo)\r\n2021-02-14T14:45:41Z AddLocal(qqqq.b32.i2p:8333,2)\r\n==5137== valgrind: Unrecognised instruction at address 0x17e85a.\r\n==5137==    at 0x17E85A: CConnman::ConnectNode(CAddress, char const*, bool, ConnectionType) (net.cpp:437)\r\n==5137==    by 0x188529: CConnman::OpenNetworkConnection(CAddress const&, bool, CSemaphoreGrant*, char const*, ConnectionType) (net.cpp:2152)\r\n==5137==    by 0x192136: CConnman::ThreadOpenAddedConnections() (net.cpp:2119)\r\n==5137==    by 0x1AABAD: __invoke_impl<void, void (CConnman::*&)(), CConnman *&> (invoke.h:73)\r\n==5137==    by 0x1AABAD: __invoke<void (CConnman::*&)(), CConnman *&> (invoke.h:95)\r\n==5137==    by 0x1AABAD: __call<void, 0> (functional:416)\r\n==5137==    by 0x1AABAD: operator()<, void> (functional:499)\r\n==5137==    by 0x1AABAD: __invoke_impl<void, std::_Bind<void (CConnman::*(CConnman *))()> &> (invoke.h:60)\r\n==5137==    by 0x1AABAD: __invoke_r<void, std::_Bind<void (CConnman::*(CConnman *))()> &> (invoke.h:110)\r\n==5137==    by 0x1AABAD: std::_Function_handler<void (), std::_Bind<void (CConnman::*(CConnman*))()> >::_M_invoke(std::_Any_data const&) (std_function.h:291)\r\n==5137==    by 0x16A038: operator() (std_function.h:622)\r\n==5137==    by 0x16A038: void TraceThread<std::function<void ()> >(char const*, std::function<void ()>) (system.h:470)\r\n==5137==    by 0x1AAD7F: __invoke_impl<void, void (*)(const char *, std::function<void ()>), const char *, std::function<void ()> > (invoke.h:60)\r\n==5137==    by 0x1AAD7F: __invoke<void (*)(const char *, std::function<void ()>), const char *, std::function<void ()> > (invoke.h:95)\r\n==5137==    by 0x1AAD7F: _M_invoke<0, 1, 2> (thread:264)\r\n==5137==    by 0x1AAD7F: operator() (thread:271)\r\n==5137==    by 0x1AAD7F: std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > > >::_M_run() (thread:215)\r\n==5137==    by 0x4DE1ECF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28)\r\n==5137==    by 0x4875EA6: start_thread (pthread_create.c:477)\r\n==5137==    by 0x513DDEE: clone (clone.S:95)\r\n==5137== Your program just tried to execute an instruction that Valgrind\r\n==5137== did not recognise.  There are two possible reasons for this.\r\n==5137== 1. Your program has a bug and erroneously jumped to a non-code\r\n==5137==    location.  If you are running Memcheck and you just saw a\r\n==5137==    warning about a bad jump, it's probably your program's fault.\r\n==5137== 2. The instruction is legitimate but Valgrind doesn't handle it,\r\n==5137==    i.e. it's Valgrind's fault.  If you think this is the case or\r\n==5137==    you are not sure, please let us know and we'll try to fix it.\r\n==5137== Either way, Valgrind will now raise a SIGILL signal which will\r\n==5137== probably kill your program.\r\n==5137== \r\n==5137== Process terminating with default action of signal 4 (SIGILL)\r\n==5137==  Illegal opcode at address 0x17E85A\r\n==5137==    at 0x17E85A: CConnman::ConnectNode(CAddress, char const*, bool, ConnectionType) (net.cpp:437)\r\n==5137==    by 0x188529: CConnman::OpenNetworkConnection(CAddress const&, bool, CSemaphoreGrant*, char const*, ConnectionType) (net.cpp:2152)\r\n==5137==    by 0x192136: CConnman::ThreadOpenAddedConnections() (net.cpp:2119)\r\n==5137==    by 0x1AABAD: __invoke_impl<void, void (CConnman::*&)(), CConnman *&> (invoke.h:73)\r\n==5137==    by 0x1AABAD: __invoke<void (CConnman::*&)(), CConnman *&> (invoke.h:95)\r\n==5137==    by 0x1AABAD: __call<void, 0> (functional:416)\r\n==5137==    by 0x1AABAD: operator()<, void> (functional:499)\r\n==5137==    by 0x1AABAD: __invoke_impl<void, std::_Bind<void (CConnman::*(CConnman *))()> &> (invoke.h:60)\r\n==5137==    by 0x1AABAD: __invoke_r<void, std::_Bind<void (CConnman::*(CConnman *))()> &> (invoke.h:110)\r\n==5137==    by 0x1AABAD: std::_Function_handler<void (), std::_Bind<void (CConnman::*(CConnman*))()> >::_M_invoke(std::_Any_data const&) (std_function.h:291)\r\n==5137==    by 0x16A038: operator() (std_function.h:622)\r\n==5137==    by 0x16A038: void TraceThread<std::function<void ()> >(char const*, std::function<void ()>) (system.h:470)\r\n==5137==    by 0x1AAD7F: __invoke_impl<void, void (*)(const char *, std::function<void ()>), const char *, std::function<void ()> > (invoke.h:60)\r\n==5137==    by 0x1AAD7F: __invoke<void (*)(const char *, std::function<void ()>), const char *, std::function<void ()> > (invoke.h:95)\r\n==5137==    by 0x1AAD7F: _M_invoke<0, 1, 2> (thread:264)\r\n==5137==    by 0x1AAD7F: operator() (thread:271)\r\n==5137==    by 0x1AAD7F: std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > > >::_M_run() (thread:215)\r\n==5137==    by 0x4DE1ECF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28)\r\n==5137==    by 0x4875EA6: start_thread (pthread_create.c:477)\r\n==5137==    by 0x513DDEE: clone (clone.S:95)\r\n==5137== \r\n==5137== HEAP SUMMARY:\r\n==5137==     in use at exit: 238,728,213 bytes in 1,629,048 blocks\r\n==5137==   total heap usage: 9,884,111 allocs, 8,255,063 frees, 4,818,980,752 bytes allocated\r\n==5137== \r\n==5137== LEAK SUMMARY:\r\n==5137==    definitely lost: 562,000 bytes in 138 blocks\r\n==5137==    indirectly lost: 0 bytes in 0 blocks\r\n==5137==      possibly lost: 7,987,784 bytes in 414 blocks\r\n==5137==    still reachable: 230,178,429 bytes in 1,628,496 blocks\r\n==5137==                       of which reachable via heuristic:\r\n==5137==                         length64           : 213,760 bytes in 360 blocks\r\n==5137==                         newarray           : 72 bytes in 1 blocks\r\n==5137==         suppressed: 0 bytes in 0 blocks\r\n==5137== Rerun with --leak-check=full to see details of leaked memory\r\n==5137== \r\n==5137== Use --track-origins=yes to see where uninitialised values come from\r\n==5137== For lists of detected and suppressed errors, rerun with: -s\r\n==5137== ERROR SUMMARY: 9 errors from 1 contexts (suppressed: 0 from 0)\r\nIllegal instruction\r\n```\r\n",
      "created_at" : "2021-02-14T14:54:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-778789023",
      "id" : 778789023,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3ODc4OTAyMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-14T14:54:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/778789023",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Ok, hit it with gdb\r\n\r\n```gdb\r\n2021-02-14T15:33:36Z I2P: SAM session created: session id=qqqq, my address=h3r6bkn4...q.b32.i2p:8333\r\n2021-02-14T15:33:36Z AddLocal(h3r6bkn4...q.b32.i2p:8333,2)\r\n\r\nThread 18 \"b-addcon\" received signal SIGSEGV, Segmentation fault.\r\n[Switching to Thread 0x7fff39ed7700 (LWP 54120)]\r\n0x0000555555621ede in CConnman::ConnectNode (this=0x5555566e3ec0, addrConnect=..., \r\n    pszDest=0x7fff28002e50 \"h3r6bkn4...q.b32.i2p\", fCountFailure=false, conn_type=ConnectionType::MANUAL) at net.cpp:437\r\n437\t                *sock = std::move(conn.sock);\r\n```\r\n\r\n<details><summary>backtrace</summary><p>\r\n\r\n```gdb\r\n(gdb) bt\r\n#0  0x0000555555621ede in CConnman::ConnectNode (this=0x5555566e3ec0, addrConnect=..., \r\n    pszDest=0x7fff28002e50 \"qqqq.b32.i2p\", fCountFailure=false, conn_type=ConnectionType::MANUAL) at net.cpp:437\r\n#1  0x0000555555629c1e in CConnman::OpenNetworkConnection (this=0x5555566e3ec0, addrConnect=..., fCountFailure=false, grantOutbound=0x7fff39ed6830, \r\n    pszDest=0x7fff28002e50 \"qqqq.b32.i2p\", conn_type=ConnectionType::MANUAL) at net.cpp:2152\r\n#2  0x000055555563195a in CConnman::ThreadOpenAddedConnections (this=0x5555566e3ec0) at net.cpp:2119\r\n#3  0x00005555556902c8 in std::__invoke_impl<void, void (CConnman::*&)(), CConnman*&> (\r\n    __f=@0x5555603a3f60: (void (CConnman::*)(CConnman * const)) 0x5555556317c0 <CConnman::ThreadOpenAddedConnections()>, __t=@0x5555603a3f70: 0x5555566e3ec0)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:73\r\n#4  0x0000555555690163 in std::__invoke<void (CConnman::*&)(), CConnman*&> (\r\n    __fn=@0x5555603a3f60: (void (CConnman::*)(CConnman * const)) 0x5555556317c0 <CConnman::ThreadOpenAddedConnections()>, __args=@0x5555603a3f70: 0x5555566e3ec0)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:95\r\n#5  0x00005555556900f4 in std::_Bind<void (CConnman::*(CConnman*))()>::__call<void, , 0ul>(std::tuple<>&&, std::_Index_tuple<0ul>) (this=0x5555603a3f60, __args=...)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/functional:416\r\n#6  0x0000555555690077 in std::_Bind<void (CConnman::*(CConnman*))()>::operator()<, void>() (this=0x5555603a3f60)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/functional:499\r\n#7  0x000055555568ffce in std::__invoke_impl<void, std::_Bind<void (CConnman::*(CConnman*))()>&>(std::__invoke_other, std::_Bind<void (CConnman::*(CConnman*))()>&) (\r\n    __f=...) at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:60\r\n#8  0x000055555568ff1e in std::__invoke_r<void, std::_Bind<void (CConnman::*(CConnman*))()>&>(std::_Bind<void (CConnman::*(CConnman*))()>&) (__fn=...)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:110\r\n#9  0x000055555568fbae in std::_Function_handler<void (), std::_Bind<void (CConnman::*(CConnman*))()> >::_M_invoke(std::_Any_data const&) (__functor=...)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:291\r\n#10 0x0000555555614dff in std::function<void ()>::operator()() const (this=0x7fff39ed6b48)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622\r\n#11 0x00005555555d4f40 in TraceThread<std::function<void ()> >(char const*, std::function<void ()>) (name=0x55555611dc37 \"addcon\", func=...) at ./util/system.h:470\r\n#12 0x0000555555691182 in std::__invoke_impl<void, void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> >(std::__invoke_other, void (*&&)(char const*, std::function<void ()>), char const*&&, std::function<void ()>&&) (\r\n    __f=@0x5555603a41f0: 0x5555555d4eb0 <TraceThread<std::function<void ()> >(char const*, std::function<void ()>)>, __args=..., __args=...)\r\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:60\r\n#13 0x0000555555690f78 in std::__invoke<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> >(void (*&&)(char const*, std::function<void ()>), char const*&&, std::function<void ()>&&) (__fn=@0x5555603a41f0: 0x5555555d4eb0 <TraceThread<std::function<void ()> >(char const*, std::function<void ()>)>, \r\n    __args=..., __args=...) at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:95\r\n#14 0x0000555555690eff in std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > >::_M_invoke<0ul, 1ul, 2ul>(std::_Index_tuple<0ul, 1ul, 2ul>) (this=0x5555603a41c8) at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/thread:264\r\n#15 0x0000555555690e66 in std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > >::operator()() (\r\n    this=0x5555603a41c8) at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/thread:271\r\n#16 0x00005555556909ed in std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > > >::_M_run() (this=0x5555603a41c0) at /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/thread:215\r\n#17 0x00007ffff79ffed0 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6\r\n#18 0x00007ffff7f8aea7 in start_thread (arg=<optimized out>) at pthread_create.c:477\r\n#19 0x00007ffff7709def in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95\r\n```\r\n</p></details>\r\n\r\n<details><summary>disassembly</summary><p>\r\n\r\n```gdb\r\n(gdb) disass /m\r\nDump of assembler code for function _ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType:\r\n377\t{\r\n   0x0000555555621490 <+0>:\tendbr64 \r\n   0x0000555555621494 <+4>:\tpush   %rbp\r\n   0x0000555555621495 <+5>:\tmov    %rsp,%rbp\r\n   0x0000555555621498 <+8>:\tsub    $0x620,%rsp\r\n   0x000055555562149f <+15>:\tmov    %fs:0x28,%rax\r\n   0x00005555556214a8 <+24>:\tmov    %rax,-0x8(%rbp)\r\n   0x00005555556214ac <+28>:\tmov    %rdi,-0x3c8(%rbp)\r\n   0x00005555556214b3 <+35>:\tmov    %rdx,-0x340(%rbp)\r\n   0x00005555556214ba <+42>:\tand    $0x1,%cl\r\n   0x00005555556214bd <+45>:\tmov    %cl,-0x3c9(%rbp)\r\n   0x00005555556214c3 <+51>:\tmov    %r8d,-0x3d0(%rbp)\r\n   0x00005555556214ca <+58>:\tmov    -0x3c8(%rbp),%rax\r\n\r\n378\t    assert(conn_type != ConnectionType::INBOUND);\r\n   0x00005555556214d1 <+65>:\tcmpl   $0x0,-0x3d0(%rbp)\r\n   0x00005555556214d8 <+72>:\tmov    %rsi,-0x428(%rbp)\r\n   0x00005555556214df <+79>:\tmov    %rax,-0x430(%rbp)\r\n   0x00005555556214e6 <+86>:\tje     0x5555556214f1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+97>\r\n   0x00005555556214ec <+92>:\tjmp    0x555555621510 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+128>\r\n   0x00005555556214f1 <+97>:\tlea    0xafb9c5(%rip),%rdi        # 0x55555611cebd\r\n   0x00005555556214f8 <+104>:\tlea    0xb26cd2(%rip),%rsi        # 0x5555561481d1\r\n   0x00005555556214ff <+111>:\tmov    $0x17a,%edx\r\n   0x0000555555621504 <+116>:\tlea    0xafb9d7(%rip),%rcx        # 0x55555611cee2\r\n   0x000055555562150b <+123>:\tcall   0x555555581490 <__assert_fail@plt>\r\n\r\n379\t\r\n380\t    if (pszDest == nullptr) {\r\n   0x0000555555621510 <+128>:\tcmpq   $0x0,-0x340(%rbp)\r\n   0x0000555555621518 <+136>:\tjne    0x5555556215e4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+340>\r\n   0x000055555562151e <+142>:\tmov    -0x428(%rbp),%rax\r\n\r\n381\t        if (IsLocal(addrConnect))\r\n   0x0000555555621525 <+149>:\tmov    %rax,%rdi\r\n   0x0000555555621528 <+152>:\tcall   0x555555620940 <_Z7IsLocalRK8CService>\r\n   0x000055555562152d <+157>:\ttest   $0x1,%al\r\n   0x000055555562152f <+159>:\tjne    0x55555562153a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+170>\r\n   0x0000555555621535 <+165>:\tjmp    0x55555562154a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+186>\r\n\r\n382\t            return nullptr;\r\n   0x000055555562153a <+170>:\tmovq   $0x0,-0x3c0(%rbp)\r\n   0x0000555555621545 <+181>:\tjmp    0x5555556228fd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5229>\r\n   0x000055555562154a <+186>:\tlea    -0x30(%rbp),%rax\r\n\r\n383\t\r\n384\t        // Look for an existing connection\r\n385\t        CNode* pnode = FindNode(static_cast<CService>(addrConnect));\r\n   0x000055555562154e <+190>:\tmov    %rax,%rdi\r\n   0x0000555555621551 <+193>:\tmov    -0x428(%rbp),%rsi\r\n   0x0000555555621558 <+200>:\tmov    %rax,-0x438(%rbp)\r\n   0x000055555562155f <+207>:\tcall   0x5555555d5980 <_ZN8CServiceC2ERKS_>\r\n   0x0000555555621564 <+212>:\tmov    -0x430(%rbp),%rdi\r\n   0x000055555562156b <+219>:\tmov    -0x438(%rbp),%rsi\r\n   0x0000555555621572 <+226>:\tcall   0x555555620fe0 <_ZN8CConnman8FindNodeERK8CService>\r\n   0x0000555555621577 <+231>:\tmov    %rax,-0x440(%rbp)\r\n   0x000055555562157e <+238>:\tjmp    0x555555621583 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+243>\r\n   0x0000555555621583 <+243>:\tlea    -0x30(%rbp),%rdi\r\n   0x0000555555621587 <+247>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x000055555562158c <+252>:\tmov    -0x440(%rbp),%rax\r\n   0x0000555555621593 <+259>:\tmov    %rax,-0x3d8(%rbp)\r\n   0x00005555556215d1 <+321>:\tlea    -0x30(%rbp),%rdi\r\n   0x00005555556215d5 <+325>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x00005555556215da <+330>:\tjmp    0x555555622931 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5281>\r\n   0x0000555555622931 <+5281>:\tmov    -0x3e0(%rbp),%rdi\r\n   0x0000555555622938 <+5288>:\tcall   0x5555555821a0 <_Unwind_Resume@plt>\r\n   0x000055555562293d <+5293>:\tcall   0x5555555817d0 <__stack_chk_fail@plt>\r\n   0x0000555555622942:\tnopw   %cs:0x0(%rax,%rax,1)\r\n   0x000055555562294c:\tnopl   0x0(%rax)\r\n\r\n386\t        if (pnode)\r\n   0x000055555562159a <+266>:\tcmpq   $0x0,-0x3d8(%rbp)\r\n   0x00005555556215a2 <+274>:\tje     0x5555556215df <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+335>\r\n\r\n387\t        {\r\n388\t            LogPrintf(\"Failed to open new connection, already connected\\n\");\r\n   0x00005555556215a8 <+280>:\tlea    0xafb97e(%rip),%rdi        # 0x55555611cf2d\r\n   0x00005555556215af <+287>:\tcall   0x555555622950 <_ZL9LogPrintfIJEEvPKcDpRKT_>\r\n\r\n389\t            return nullptr;\r\n   0x00005555556215b4 <+292>:\tmovq   $0x0,-0x3c0(%rbp)\r\n   0x00005555556215bf <+303>:\tjmp    0x5555556228fd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5229>\r\n\r\n390\t        }\r\n391\t    }\r\n   0x00005555556215df <+335>:\tjmp    0x5555556215e4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+340>\r\n\r\n392\t\r\n393\t    /// debug print\r\n394\t    LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\r\n   0x00005555556215e4 <+340>:\tjmp    0x5555556215e9 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+345>\r\n   0x00005555556215e9 <+345>:\tmov    $0x1,%edi\r\n   0x00005555556215ee <+350>:\tcall   0x55555561fd20 <_ZL17LogAcceptCategoryN5BCLog8LogFlagsE>\r\n   0x00005555556215f3 <+355>:\ttest   $0x1,%al\r\n   0x00005555556215f5 <+357>:\tjne    0x555555621600 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+368>\r\n   0x00005555556215fb <+363>:\tjmp    0x5555556217a1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+785>\r\n   0x0000555555621600 <+368>:\tmov    -0x340(%rbp),%rax\r\n   0x0000555555621607 <+375>:\tmovb   $0x0,-0x3e5(%rbp)\r\n   0x000055555562160e <+382>:\tcmp    $0x0,%rax\r\n   0x0000555555621612 <+386>:\tje     0x555555621664 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+468>\r\n   0x0000555555621618 <+392>:\tmov    -0x340(%rbp),%rsi\r\n   0x000055555562161f <+399>:\tlea    -0x348(%rbp),%rax\r\n   0x0000555555621626 <+406>:\tmov    %rax,%rdi\r\n   0x0000555555621629 <+409>:\tmov    %rsi,-0x448(%rbp)\r\n   0x0000555555621630 <+416>:\tmov    %rax,-0x450(%rbp)\r\n   0x0000555555621637 <+423>:\tcall   0x555555582c40 <_ZNSaIcEC1Ev@plt>\r\n   0x000055555562163c <+428>:\tmovb   $0x1,-0x3e5(%rbp)\r\n   0x0000555555621643 <+435>:\tlea    -0x50(%rbp),%rdi\r\n   0x0000555555621647 <+439>:\tmov    -0x448(%rbp),%rsi\r\n   0x000055555562164e <+446>:\tmov    -0x450(%rbp),%rdx\r\n   0x0000555555621655 <+453>:\tcall   0x55555559c0c0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2IS3_EEPKcRKS3_>\r\n   0x000055555562165a <+458>:\tjmp    0x55555562165f <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+463>\r\n   0x000055555562165f <+463>:\tjmp    0x55555562167e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+494>\r\n   0x0000555555621664 <+468>:\tlea    -0x50(%rbp),%rdi\r\n   0x0000555555621668 <+472>:\tmov    -0x428(%rbp),%rsi\r\n   0x000055555562166f <+479>:\tcall   0x555555eaef60 <_ZNK8CService8ToStringB5cxx11Ev>\r\n   0x0000555555621674 <+484>:\tjmp    0x555555621679 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+489>\r\n   0x0000555555621679 <+489>:\tjmp    0x55555562167e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+494>\r\n   0x000055555562167e <+494>:\tcmpq   $0x0,-0x340(%rbp)\r\n   0x0000555555621686 <+502>:\tje     0x55555562169c <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+524>\r\n   0x000055555562168c <+508>:\txorps  %xmm0,%xmm0\r\n   0x000055555562168f <+511>:\tmovsd  %xmm0,-0x458(%rbp)\r\n   0x0000555555621697 <+519>:\tjmp    0x5555556216fe <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+622>\r\n   0x000055555562169c <+524>:\tcall   0x5555559d35f0 <_Z15GetAdjustedTimev>\r\n   0x00005555556216a1 <+529>:\tmov    %rax,-0x460(%rbp)\r\n   0x00005555556216a8 <+536>:\tjmp    0x5555556216ad <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+541>\r\n   0x00005555556216ad <+541>:\tmov    -0x428(%rbp),%rax\r\n   0x00005555556216b4 <+548>:\tmov    0x24(%rax),%ecx\r\n   0x00005555556216b7 <+551>:\tmov    %ecx,%edx\r\n   0x00005555556216b9 <+553>:\tmov    -0x460(%rbp),%rsi\r\n   0x00005555556216c0 <+560>:\tsub    %rdx,%rsi\r\n   0x00005555556216c3 <+563>:\tseto   %dil\r\n   0x00005555556216c7 <+567>:\txor    $0xff,%dil\r\n   0x00005555556216cb <+571>:\ttest   $0x1,%dil\r\n   0x00005555556216cf <+575>:\tmov    %rsi,-0x468(%rbp)\r\n   0x00005555556216d6 <+582>:\tjne    0x5555556216de <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+590>\r\n   0x00005555556216dc <+588>:\tud2    \r\n   0x00005555556216de <+590>:\tmovsd  0xafb552(%rip),%xmm0        # 0x55555611cc38\r\n   0x00005555556216e6 <+598>:\tmov    -0x468(%rbp),%rax\r\n   0x00005555556216ed <+605>:\tcvtsi2sd %rax,%xmm1\r\n   0x00005555556216f2 <+610>:\tdivsd  %xmm0,%xmm1\r\n   0x00005555556216f6 <+614>:\tmovsd  %xmm1,-0x458(%rbp)\r\n   0x00005555556216fe <+622>:\tmovsd  -0x458(%rbp),%xmm0\r\n   0x0000555555621706 <+630>:\tmovsd  %xmm0,-0x350(%rbp)\r\n   0x000055555562170e <+638>:\tlea    0xafb84a(%rip),%rdi        # 0x55555611cf5f\r\n   0x0000555555621715 <+645>:\tlea    -0x50(%rbp),%rsi\r\n   0x0000555555621719 <+649>:\tlea    -0x350(%rbp),%rdx\r\n   0x0000555555621720 <+656>:\tcall   0x555555622c30 <_ZL9LogPrintfIJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEvPKcDpRKT_>\r\n   0x0000555555621725 <+661>:\tjmp    0x55555562172a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+666>\r\n   0x000055555562172a <+666>:\tlea    -0x50(%rbp),%rdi\r\n   0x000055555562172e <+670>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555621733 <+675>:\ttestb  $0x1,-0x3e5(%rbp)\r\n   0x000055555562173a <+682>:\tjne    0x555555621745 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+693>\r\n   0x0000555555621740 <+688>:\tjmp    0x555555621751 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+705>\r\n   0x0000555555621745 <+693>:\tlea    -0x348(%rbp),%rdi\r\n   0x000055555562174c <+700>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x0000555555621751 <+705>:\tjmp    0x5555556217a1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+785>\r\n   0x0000555555621775 <+741>:\tlea    -0x50(%rbp),%rdi\r\n   0x0000555555621779 <+745>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x000055555562177e <+750>:\ttestb  $0x1,-0x3e5(%rbp)\r\n   0x0000555555621785 <+757>:\tjne    0x555555621790 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+768>\r\n   0x000055555562178b <+763>:\tjmp    0x55555562179c <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+780>\r\n   0x0000555555621790 <+768>:\tlea    -0x348(%rbp),%rdi\r\n   0x0000555555621797 <+775>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x000055555562179c <+780>:\tjmp    0x555555622931 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5281>\r\n   0x00005555556217a1 <+785>:\tjmp    0x5555556217a6 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+790>\r\n\r\n395\t        pszDest ? pszDest : addrConnect.ToString(),\r\n396\t        pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\r\n397\t\r\n398\t    // Resolve\r\n399\t    const int default_port = Params().GetDefaultPort();\r\n   0x00005555556217a6 <+790>:\tcall   0x555555e7b5b0 <_Z6Paramsv>\r\n   0x00005555556217ab <+795>:\tmov    %rax,%rdi\r\n   0x00005555556217ae <+798>:\tcall   0x5555555cf590 <_ZNK12CChainParams14GetDefaultPortEv>\r\n   0x00005555556217b3 <+803>:\tmov    %eax,-0x3ec(%rbp)\r\n\r\n400\t    if (pszDest) {\r\n   0x00005555556217b9 <+809>:\tcmpq   $0x0,-0x340(%rbp)\r\n   0x00005555556217c1 <+817>:\tje     0x555555621d13 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2179>\r\n   0x00005555556217c7 <+823>:\tlea    -0x368(%rbp),%rdi\r\n\r\n401\t        std::vector<CService> resolved;\r\n   0x00005555556217ce <+830>:\tcall   0x5555555ed810 <_ZNSt6vectorI8CServiceSaIS0_EEC2Ev>\r\n\r\n402\t        if (Lookup(pszDest, resolved,  default_port, fNameLookup && !HaveNameProxy(), 256) && !resolved.empty()) {\r\n   0x00005555556217d3 <+835>:\tmov    -0x340(%rbp),%rsi\r\n   0x00005555556217da <+842>:\tlea    -0x370(%rbp),%rax\r\n   0x00005555556217e1 <+849>:\tmov    %rax,%rdi\r\n   0x00005555556217e4 <+852>:\tmov    %rsi,-0x470(%rbp)\r\n   0x00005555556217eb <+859>:\tmov    %rax,-0x478(%rbp)\r\n   0x00005555556217f2 <+866>:\tcall   0x555555582c40 <_ZNSaIcEC1Ev@plt>\r\n   0x00005555556217f7 <+871>:\tlea    -0x70(%rbp),%rdi\r\n   0x00005555556217fb <+875>:\tmov    -0x470(%rbp),%rsi\r\n   0x0000555555621802 <+882>:\tmov    -0x478(%rbp),%rdx\r\n   0x0000555555621809 <+889>:\tcall   0x55555559c0c0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2IS3_EEPKcRKS3_>\r\n   0x000055555562180e <+894>:\tjmp    0x555555621813 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+899>\r\n   0x0000555555621813 <+899>:\txor    %eax,%eax\r\n   0x0000555555621815 <+901>:\tlea    0xedae88(%rip),%rcx        # 0x5555564fc6a4 <fNameLookup>\r\n   0x000055555562181c <+908>:\tmov    -0x3ec(%rbp),%edx\r\n   0x0000555555621822 <+914>:\ttestb  $0x1,(%rcx)\r\n   0x0000555555621825 <+917>:\tmov    %edx,-0x47c(%rbp)\r\n   0x000055555562182b <+923>:\tmov    %al,-0x47d(%rbp)\r\n   0x0000555555621831 <+929>:\tje     0x555555621855 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+965>\r\n   0x0000555555621837 <+935>:\tcall   0x555555eb8110 <_Z13HaveNameProxyv>\r\n   0x000055555562183c <+940>:\tmov    %al,-0x47e(%rbp)\r\n   0x0000555555621842 <+946>:\tjmp    0x555555621847 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+951>\r\n   0x0000555555621847 <+951>:\tmov    -0x47e(%rbp),%al\r\n   0x000055555562184d <+957>:\txor    $0xff,%al\r\n   0x000055555562184f <+959>:\tmov    %al,-0x47d(%rbp)\r\n   0x0000555555621855 <+965>:\tmov    -0x47d(%rbp),%al\r\n   0x000055555562185b <+971>:\tmovzbl %al,%ecx\r\n   0x000055555562185e <+974>:\tand    $0x1,%ecx\r\n   0x0000555555621861 <+977>:\tlea    -0x70(%rbp),%rdi\r\n   0x0000555555621865 <+981>:\tlea    -0x368(%rbp),%rsi\r\n   0x000055555562186c <+988>:\tmov    $0x100,%r8d\r\n   0x0000555555621872 <+994>:\tmov    -0x47c(%rbp),%edx\r\n   0x0000555555621878 <+1000>:\tcall   0x555555eb6560 <_Z6LookupRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt6vectorI8CServiceSaIS8_EEibj>\r\n   0x000055555562187d <+1005>:\tmov    %al,-0x47f(%rbp)\r\n   0x0000555555621883 <+1011>:\tjmp    0x555555621888 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1016>\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n   0x0000555555621888 <+1016>:\txor    %eax,%eax\r\n   0x000055555562188a <+1018>:\tmov    -0x47f(%rbp),%cl\r\n   0x0000555555621890 <+1024>:\ttest   $0x1,%cl\r\n   0x0000555555621893 <+1027>:\tmov    %al,-0x480(%rbp)\r\n   0x0000555555621899 <+1033>:\tjne    0x5555556218a4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1044>\r\n   0x000055555562189f <+1039>:\tjmp    0x5555556218b8 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1064>\r\n   0x00005555556218a4 <+1044>:\tlea    -0x368(%rbp),%rdi\r\n   0x00005555556218ab <+1051>:\tcall   0x5555555d5830 <_ZNKSt6vectorI8CServiceSaIS0_EE5emptyEv>\r\n   0x00005555556218b0 <+1056>:\txor    $0xff,%al\r\n   0x00005555556218b2 <+1058>:\tmov    %al,-0x480(%rbp)\r\n   0x00005555556218b8 <+1064>:\tmov    -0x480(%rbp),%al\r\n   0x00005555556218be <+1070>:\tlea    -0x70(%rbp),%rdi\r\n   0x00005555556218c2 <+1074>:\tmov    %al,-0x481(%rbp)\r\n   0x00005555556218c8 <+1080>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x00005555556218cd <+1085>:\tlea    -0x370(%rbp),%rdi\r\n   0x00005555556218d4 <+1092>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x00005555556218d9 <+1097>:\tmov    -0x481(%rbp),%al\r\n   0x00005555556218df <+1103>:\ttest   $0x1,%al\r\n   0x00005555556218e1 <+1105>:\tjne    0x5555556218ec <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1116>\r\n   0x00005555556218e7 <+1111>:\tjmp    0x555555621ccf <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2111>\r\n   0x00005555556218ec <+1116>:\tlea    -0x368(%rbp),%rax\r\n   0x0000555555621a37 <+1447>:\tlea    -0x70(%rbp),%rdi\r\n   0x0000555555621a3b <+1451>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555621a40 <+1456>:\tlea    -0x370(%rbp),%rdi\r\n   0x0000555555621a47 <+1463>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x0000555555621a4c <+1468>:\tjmp    0x555555621d02 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2162>\r\n\r\n403\t            addrConnect = CAddress(resolved[GetRand(resolved.size())], NODE_NONE);\r\n   0x00005555556218f3 <+1123>:\tmov    %rax,%rdi\r\n   0x00005555556218f6 <+1126>:\tmov    %rax,-0x490(%rbp)\r\n   0x00005555556218fd <+1133>:\tcall   0x5555555d59f0 <_ZNKSt6vectorI8CServiceSaIS0_EE4sizeEv>\r\n   0x0000555555621902 <+1138>:\tmov    %rax,%rdi\r\n   0x0000555555621905 <+1141>:\tcall   0x555555f58ff0 <_Z7GetRandm>\r\n   0x000055555562190a <+1146>:\tmov    -0x490(%rbp),%rdi\r\n   0x0000555555621911 <+1153>:\tmov    %rax,%rsi\r\n   0x0000555555621914 <+1156>:\tcall   0x55555563e7c0 <_ZNSt6vectorI8CServiceSaIS0_EEixEm>\r\n   0x0000555555621919 <+1161>:\tlea    -0xc8(%rbp),%rdi\r\n   0x0000555555621920 <+1168>:\tmov    %rax,%rsi\r\n   0x0000555555621923 <+1171>:\tcall   0x5555555d5980 <_ZN8CServiceC2ERKS_>\r\n   0x0000555555621928 <+1176>:\tjmp    0x55555562192d <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1181>\r\n   0x000055555562192d <+1181>:\txor    %eax,%eax\r\n   0x000055555562192f <+1183>:\tmov    %eax,%edx\r\n   0x0000555555621931 <+1185>:\tlea    -0xa0(%rbp),%rdi\r\n   0x0000555555621938 <+1192>:\tlea    -0xc8(%rbp),%rsi\r\n   0x000055555562193f <+1199>:\tcall   0x55555563ddb0 <_ZN8CAddressC2E8CService12ServiceFlags>\r\n   0x0000555555621944 <+1204>:\tjmp    0x555555621949 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1209>\r\n   0x0000555555621949 <+1209>:\tlea    -0xa0(%rbp),%rsi\r\n   0x0000555555621950 <+1216>:\tmov    -0x428(%rbp),%rdi\r\n   0x0000555555621957 <+1223>:\tcall   0x55555563de20 <_ZN8CAddressaSEOS_>\r\n   0x000055555562195c <+1228>:\tjmp    0x555555621961 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1233>\r\n   0x0000555555621961 <+1233>:\tlea    -0xa0(%rbp),%rdi\r\n   0x0000555555621968 <+1240>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x000055555562196d <+1245>:\tlea    -0xc8(%rbp),%rdi\r\n   0x0000555555621974 <+1252>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x0000555555621979 <+1257>:\tmov    -0x428(%rbp),%rdi\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n   0x0000555555621a82 <+1522>:\tlea    -0xa0(%rbp),%rdi\r\n   0x0000555555621a89 <+1529>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x0000555555621a8e <+1534>:\tlea    -0xc8(%rbp),%rdi\r\n   0x0000555555621a95 <+1541>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x0000555555621a9a <+1546>:\tjmp    0x555555621d02 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2162>\r\n\r\n404\t            if (!addrConnect.IsValid()) {\r\n   0x0000555555621980 <+1264>:\tcall   0x555555eaba70 <_ZNK8CNetAddr7IsValidEv>\r\n   0x0000555555621985 <+1269>:\tmov    %al,-0x491(%rbp)\r\n   0x000055555562198b <+1275>:\tjmp    0x555555621990 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1280>\r\n   0x0000555555621990 <+1280>:\tmov    -0x491(%rbp),%al\r\n   0x0000555555621996 <+1286>:\ttest   $0x1,%al\r\n   0x0000555555621998 <+1288>:\tjne    0x555555621ae1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1617>\r\n   0x000055555562199e <+1294>:\tjmp    0x5555556219a3 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1299>\r\n\r\n405\t                LogPrint(BCLog::NET, \"Resolver returned invalid address %s for %s\\n\", addrConnect.ToString(), pszDest);\r\n   0x00005555556219a3 <+1299>:\tjmp    0x5555556219a8 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1304>\r\n   0x00005555556219a8 <+1304>:\tmov    $0x1,%edi\r\n   0x00005555556219ad <+1309>:\tcall   0x55555561fd20 <_ZL17LogAcceptCategoryN5BCLog8LogFlagsE>\r\n   0x00005555556219b2 <+1314>:\tmov    %al,-0x492(%rbp)\r\n   0x00005555556219b8 <+1320>:\tjmp    0x5555556219bd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1325>\r\n   0x00005555556219bd <+1325>:\tmov    -0x492(%rbp),%al\r\n   0x00005555556219c3 <+1331>:\ttest   $0x1,%al\r\n   0x00005555556219c5 <+1333>:\tjne    0x5555556219d0 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1344>\r\n   0x00005555556219cb <+1339>:\tjmp    0x555555621abd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1581>\r\n   0x00005555556219d0 <+1344>:\tlea    -0xe8(%rbp),%rdi\r\n   0x00005555556219d7 <+1351>:\tmov    -0x428(%rbp),%rsi\r\n   0x00005555556219de <+1358>:\tcall   0x555555eaef60 <_ZNK8CService8ToStringB5cxx11Ev>\r\n   0x00005555556219e3 <+1363>:\tjmp    0x5555556219e8 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1368>\r\n   0x00005555556219e8 <+1368>:\tlea    0xafb597(%rip),%rdi        # 0x55555611cf86\r\n   0x00005555556219ef <+1375>:\tlea    -0xe8(%rbp),%rsi\r\n   0x00005555556219f6 <+1382>:\tlea    -0x340(%rbp),%rdx\r\n   0x00005555556219fd <+1389>:\tcall   0x555555622f20 <_ZL9LogPrintfIJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKcEEvS7_DpRKT_>\r\n   0x0000555555621a02 <+1394>:\tjmp    0x555555621a07 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1399>\r\n   0x0000555555621a07 <+1399>:\tlea    -0xe8(%rbp),%rdi\r\n   0x0000555555621a0e <+1406>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555621a13 <+1411>:\tjmp    0x555555621abd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1581>\r\n   0x0000555555621aac <+1564>:\tlea    -0xe8(%rbp),%rdi\r\n   0x0000555555621ab3 <+1571>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555621ab8 <+1576>:\tjmp    0x555555621d02 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2162>\r\n   0x0000555555621abd <+1581>:\tjmp    0x555555621ac2 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1586>\r\n   0x0000555555621ac2 <+1586>:\tjmp    0x555555621ac7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1591>\r\n\r\n406\t                return nullptr;\r\n   0x0000555555621ac7 <+1591>:\tmovq   $0x0,-0x3c0(%rbp)\r\n   0x0000555555621ad2 <+1602>:\tmovl   $0x1,-0x3f0(%rbp)\r\n   0x0000555555621adc <+1612>:\tjmp    0x555555621cd9 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2121>\r\n   0x0000555555621ae1 <+1617>:\tmov    -0x430(%rbp),%rax\r\n\r\n407\t            }\r\n408\t            // It is possible that we already have a connection to the IP/port pszDest resolved to.\r\n409\t            // In that case, drop the connection that was just created, and return the existing CNode instead.\r\n410\t            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\r\n411\t            // name catch this early.\r\n412\t            LOCK(cs_vNodes);\r\n   0x0000555555621ae8 <+1624>:\tadd    $0x50370,%rax\r\n   0x0000555555621aee <+1630>:\tlea    0xafb3be(%rip),%rdx        # 0x55555611ceb3\r\n   0x0000555555621af5 <+1637>:\tlea    0xb266d5(%rip),%rcx        # 0x5555561481d1\r\n   0x0000555555621afc <+1644>:\tlea    -0x338(%rbp),%rdi\r\n   0x0000555555621b03 <+1651>:\tmov    $0x19c,%r8d\r\n   0x0000555555621b09 <+1657>:\txor    %r9d,%r9d\r\n   0x0000555555621b0c <+1660>:\tmov    %rax,%rsi\r\n   0x0000555555621b0f <+1663>:\tcall   0x5555555cd8e0 <_ZN10UniqueLockI14AnnotatedMixinISt15recursive_mutexESt11unique_lockIS1_EEC2ERS2_PKcS8_ib>\r\n   0x0000555555621b14 <+1668>:\tjmp    0x555555621b19 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1673>\r\n   0x0000555555621b19 <+1673>:\tlea    -0x110(%rbp),%rdi\r\n   0x0000555555621b20 <+1680>:\tmov    -0x428(%rbp),%rsi\r\n\r\n413\t            CNode* pnode = FindNode(static_cast<CService>(addrConnect));\r\n   0x0000555555621b27 <+1687>:\tcall   0x5555555d5980 <_ZN8CServiceC2ERKS_>\r\n   0x0000555555621b2c <+1692>:\tjmp    0x555555621b31 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1697>\r\n   0x0000555555621b31 <+1697>:\tlea    -0x110(%rbp),%rsi\r\n   0x0000555555621b38 <+1704>:\tmov    -0x430(%rbp),%rdi\r\n   0x0000555555621b3f <+1711>:\tcall   0x555555620fe0 <_ZN8CConnman8FindNodeERK8CService>\r\n   0x0000555555621b44 <+1716>:\tmov    %rax,-0x4a0(%rbp)\r\n   0x0000555555621b4b <+1723>:\tjmp    0x555555621b50 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1728>\r\n   0x0000555555621b50 <+1728>:\tlea    -0x110(%rbp),%rdi\r\n   0x0000555555621b57 <+1735>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x0000555555621b5c <+1740>:\tmov    -0x4a0(%rbp),%rax\r\n   0x0000555555621b63 <+1747>:\tmov    %rax,-0x3f8(%rbp)\r\n   0x0000555555621c43 <+1971>:\tlea    -0x110(%rbp),%rdi\r\n   0x0000555555621c4a <+1978>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x0000555555621c4f <+1983>:\tjmp    0x555555621cbe <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2094>\r\n\r\n414\t            if (pnode)\r\n   0x0000555555621b6a <+1754>:\tcmpq   $0x0,-0x3f8(%rbp)\r\n   0x0000555555621b72 <+1762>:\tje     0x555555621c90 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2048>\r\n\r\n415\t            {\r\n416\t                pnode->MaybeSetAddrName(std::string(pszDest));\r\n   0x0000555555621b78 <+1768>:\tmov    -0x3f8(%rbp),%rdi\r\n   0x0000555555621b7f <+1775>:\tmov    -0x340(%rbp),%rsi\r\n   0x0000555555621b86 <+1782>:\tlea    -0x378(%rbp),%rax\r\n   0x0000555555621b8d <+1789>:\tmov    %rdi,-0x4a8(%rbp)\r\n   0x0000555555621b94 <+1796>:\tmov    %rax,%rdi\r\n   0x0000555555621b97 <+1799>:\tmov    %rsi,-0x4b0(%rbp)\r\n   0x0000555555621b9e <+1806>:\tmov    %rax,-0x4b8(%rbp)\r\n   0x0000555555621ba5 <+1813>:\tcall   0x555555582c40 <_ZNSaIcEC1Ev@plt>\r\n   0x0000555555621baa <+1818>:\tlea    -0x130(%rbp),%rdi\r\n   0x0000555555621bb1 <+1825>:\tmov    -0x4b0(%rbp),%rsi\r\n   0x0000555555621bb8 <+1832>:\tmov    -0x4b8(%rbp),%rdx\r\n   0x0000555555621bbf <+1839>:\tcall   0x55555559c0c0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2IS3_EEPKcRKS3_>\r\n   0x0000555555621bc4 <+1844>:\tjmp    0x555555621bc9 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1849>\r\n   0x0000555555621bc9 <+1849>:\tlea    -0x130(%rbp),%rsi\r\n   0x0000555555621bd0 <+1856>:\tmov    -0x4a8(%rbp),%rdi\r\n   0x0000555555621bd7 <+1863>:\tcall   0x555555623210 <_ZN5CNode16MaybeSetAddrNameERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE>\r\n   0x0000555555621bdc <+1868>:\tjmp    0x555555621be1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1873>\r\n   0x0000555555621be1 <+1873>:\tlea    -0x130(%rbp),%rdi\r\n   0x0000555555621be8 <+1880>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555621bed <+1885>:\tlea    -0x378(%rbp),%rdi\r\n   0x0000555555621bf4 <+1892>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n   0x0000555555621c73 <+2019>:\tlea    -0x130(%rbp),%rdi\r\n   0x0000555555621c7a <+2026>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555621c7f <+2031>:\tlea    -0x378(%rbp),%rdi\r\n   0x0000555555621c86 <+2038>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x0000555555621c8b <+2043>:\tjmp    0x555555621cbe <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2094>\r\n\r\n417\t                LogPrintf(\"Failed to open new connection, already connected\\n\");\r\n   0x0000555555621bf9 <+1897>:\tlea    0xafb32d(%rip),%rdi        # 0x55555611cf2d\r\n   0x0000555555621c00 <+1904>:\tcall   0x555555622950 <_ZL9LogPrintfIJEEvPKcDpRKT_>\r\n   0x0000555555621c05 <+1909>:\tjmp    0x555555621c0a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1914>\r\n\r\n418\t                return nullptr;\r\n   0x0000555555621c0a <+1914>:\tmovq   $0x0,-0x3c0(%rbp)\r\n   0x0000555555621c15 <+1925>:\tmovl   $0x1,-0x3f0(%rbp)\r\n   0x0000555555621c1f <+1935>:\tjmp    0x555555621c9a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2058>\r\n\r\n419\t            }\r\n420\t        }\r\n   0x0000555555621c90 <+2048>:\tmovl   $0x0,-0x3f0(%rbp)\r\n   0x0000555555621c9a <+2058>:\tlea    -0x338(%rbp),%rdi\r\n   0x0000555555621ca1 <+2065>:\tcall   0x5555555cd9c0 <_ZN10UniqueLockI14AnnotatedMixinISt15recursive_mutexESt11unique_lockIS1_EED2Ev>\r\n   0x0000555555621ca6 <+2070>:\tmov    -0x3f0(%rbp),%eax\r\n   0x0000555555621cac <+2076>:\ttest   %eax,%eax\r\n   0x0000555555621cae <+2078>:\tjne    0x555555621cd9 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2121>\r\n   0x0000555555621cb4 <+2084>:\tjmp    0x555555621cb9 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2089>\r\n   0x0000555555621cb9 <+2089>:\tjmp    0x555555621ccf <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2111>\r\n   0x0000555555621cbe <+2094>:\tlea    -0x338(%rbp),%rdi\r\n   0x0000555555621cc5 <+2101>:\tcall   0x5555555cd9c0 <_ZN10UniqueLockI14AnnotatedMixinISt15recursive_mutexESt11unique_lockIS1_EED2Ev>\r\n   0x0000555555621cca <+2106>:\tjmp    0x555555621d02 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2162>\r\n\r\n421\t    }\r\n   0x0000555555621ccf <+2111>:\tmovl   $0x0,-0x3f0(%rbp)\r\n   0x0000555555621cd9 <+2121>:\tlea    -0x368(%rbp),%rdi\r\n   0x0000555555621ce0 <+2128>:\tcall   0x5555555efee0 <_ZNSt6vectorI8CServiceSaIS0_EED2Ev>\r\n   0x0000555555621ce5 <+2133>:\tmov    -0x3f0(%rbp),%eax\r\n   0x0000555555621ceb <+2139>:\ttest   %eax,%eax\r\n   0x0000555555621ced <+2141>:\tje     0x555555621cfd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2157>\r\n   0x0000555555621cf3 <+2147>:\tjmp    0x555555621cf8 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2152>\r\n   0x0000555555621cf8 <+2152>:\tjmp    0x5555556228fd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5229>\r\n   0x0000555555621cfd <+2157>:\tjmp    0x555555621d13 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2179>\r\n   0x0000555555621d02 <+2162>:\tlea    -0x368(%rbp),%rdi\r\n   0x0000555555621d09 <+2169>:\tcall   0x5555555efee0 <_ZNSt6vectorI8CServiceSaIS0_EED2Ev>\r\n   0x0000555555621d0e <+2174>:\tjmp    0x555555622931 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5281>\r\n\r\n422\t\r\n423\t    // Connect\r\n424\t    bool connected = false;\r\n   0x0000555555621d13 <+2179>:\tmovb   $0x0,-0x3f9(%rbp)\r\n   0x0000555555621d1a <+2186>:\tlea    -0x380(%rbp),%rdi\r\n\r\n425\t    std::unique_ptr<Sock> sock;\r\n   0x0000555555621d21 <+2193>:\tcall   0x55555563e820 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EEC2IS2_vEEv>\r\n   0x0000555555621d26 <+2198>:\tlea    -0x160(%rbp),%rdi\r\n\r\n426\t    proxyType proxy;\r\n   0x0000555555621d2d <+2205>:\tcall   0x55555563e880 <_ZN9proxyTypeC2Ev>\r\n   0x0000555555621d32 <+2210>:\tjmp    0x555555621d37 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2215>\r\n   0x0000555555621d37 <+2215>:\tlea    -0x190(%rbp),%rdi\r\n\r\n427\t    CAddress addr_bind;\r\n   0x0000555555621d3e <+2222>:\tcall   0x55555563e8e0 <_ZN8CAddressC2Ev>\r\n   0x0000555555621d43 <+2227>:\tjmp    0x555555621d48 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2232>\r\n   0x0000555555621d48 <+2232>:\tlea    -0x190(%rbp),%rdi\r\n\r\n428\t    assert(!addr_bind.IsValid());\r\n   0x0000555555621d4f <+2239>:\tcall   0x555555eaba70 <_ZNK8CNetAddr7IsValidEv>\r\n   0x0000555555621d54 <+2244>:\tmov    %al,-0x4b9(%rbp)\r\n   0x0000555555621d5a <+2250>:\tjmp    0x555555621d5f <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2255>\r\n   0x0000555555621d5f <+2255>:\tmov    -0x4b9(%rbp),%al\r\n   0x0000555555621d65 <+2261>:\txor    $0xff,%al\r\n   0x0000555555621d67 <+2263>:\ttest   $0x1,%al\r\n   0x0000555555621d69 <+2265>:\tjne    0x555555621d74 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2276>\r\n   0x0000555555621d6f <+2271>:\tjmp    0x555555621d79 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2281>\r\n   0x0000555555621d74 <+2276>:\tjmp    0x555555621dce <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2366>\r\n   0x0000555555621d79 <+2281>:\tlea    0xafb233(%rip),%rdi        # 0x55555611cfb3\r\n   0x0000555555621d80 <+2288>:\tlea    0xb2644a(%rip),%rsi        # 0x5555561481d1\r\n   0x0000555555621d87 <+2295>:\tmov    $0x1ac,%edx\r\n   0x0000555555621d8c <+2300>:\tlea    0xafb14f(%rip),%rcx        # 0x55555611cee2\r\n   0x0000555555621d93 <+2307>:\tcall   0x555555581490 <__assert_fail@plt>\r\n\r\n429\t\r\n430\t    if (addrConnect.IsValid()) {\r\n=> 0x0000555555621dd5 <+2373>:\tcall   0x555555eaba70 <_ZNK8CNetAddr7IsValidEv>\r\n   0x0000555555621dda <+2378>:\tmov    %al,-0x4ba(%rbp)\r\n   0x0000555555621de0 <+2384>:\tjmp    0x555555621de5 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2389>\r\n   0x0000555555621de5 <+2389>:\tmov    -0x4ba(%rbp),%al\r\n   0x0000555555621deb <+2395>:\ttest   $0x1,%al\r\n   0x0000555555621ded <+2397>:\tjne    0x555555621df8 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2408>\r\n   0x0000555555621df3 <+2403>:\tjmp    0x5555556222e1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3665>\r\n\r\n431\t        bool proxyConnectionFailed = false;\r\n   0x0000555555621df8 <+2408>:\tmovb   $0x0,-0x381(%rbp)\r\n   0x0000555555621dff <+2415>:\tmov    -0x428(%rbp),%rdi\r\n\r\n432\t\r\n433\t        if (addrConnect.GetNetwork() == NET_I2P && m_i2p_sam_session.get() != nullptr) {\r\n   0x0000555555621e06 <+2422>:\tcall   0x555555eabf20 <_ZNK8CNetAddr10GetNetworkEv>\r\n   0x0000555555621e0b <+2427>:\tmov    %eax,-0x4c0(%rbp)\r\n   0x0000555555621e11 <+2433>:\tjmp    0x555555621e16 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2438>\r\n   0x0000555555621e16 <+2438>:\tmov    -0x4c0(%rbp),%eax\r\n   0x0000555555621e1c <+2444>:\tcmp    $0x4,%eax\r\n   0x0000555555621e1f <+2447>:\tjne    0x555555621fcf <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2879>\r\n   0x0000555555621e25 <+2453>:\tmov    -0x430(%rbp),%rax\r\n   0x0000555555621e2c <+2460>:\tadd    $0x50518,%rax\r\n   0x0000555555621e32 <+2466>:\tmov    %rax,%rdi\r\n   0x0000555555621e35 <+2469>:\tcall   0x55555563e950 <_ZNKSt10unique_ptrIN3i2p3sam7SessionESt14default_deleteIS2_EE3getEv>\r\n   0x0000555555621e3a <+2474>:\tcmp    $0x0,%rax\r\n   0x0000555555621e3e <+2478>:\tje     0x555555621fcf <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2879>\r\n   0x0000555555621e44 <+2484>:\tlea    -0x1f0(%rbp),%rdi\r\n\r\n434\t            i2p::Connection conn;\r\n   0x0000555555621e4b <+2491>:\tcall   0x55555563e9b0 <_ZN3i2p10ConnectionC2Ev>\r\n   0x0000555555621e50 <+2496>:\tjmp    0x555555621e55 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2501>\r\n   0x0000555555621e55 <+2501>:\tmov    -0x430(%rbp),%rax\r\n\r\n435\t            if (m_i2p_sam_session->Connect(addrConnect, conn, proxyConnectionFailed)) {\r\n   0x0000555555621e5c <+2508>:\tadd    $0x50518,%rax\r\n   0x0000555555621e62 <+2514>:\tmov    %rax,%rdi\r\n   0x0000555555621e65 <+2517>:\tcall   0x55555563ea70 <_ZNKSt10unique_ptrIN3i2p3sam7SessionESt14default_deleteIS2_EEptEv>\r\n   0x0000555555621e6a <+2522>:\tlea    -0x1f0(%rbp),%rdx\r\n   0x0000555555621e71 <+2529>:\tlea    -0x381(%rbp),%rcx\r\n   0x0000555555621e78 <+2536>:\tmov    %rax,%rdi\r\n   0x0000555555621e7b <+2539>:\tmov    -0x428(%rbp),%rsi\r\n   0x0000555555621e82 <+2546>:\tcall   0x555555b78370 <_ZN3i2p3sam7Session7ConnectERK8CServiceRNS_10ConnectionERb>\r\n   0x0000555555621e87 <+2551>:\tmov    %al,-0x4c1(%rbp)\r\n   0x0000555555621e8d <+2557>:\tjmp    0x555555621e92 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2562>\r\n   0x0000555555621e92 <+2562>:\tmov    -0x4c1(%rbp),%al\r\n   0x0000555555621e98 <+2568>:\ttest   $0x1,%al\r\n   0x0000555555621e9a <+2570>:\tjne    0x555555621ea5 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2581>\r\n   0x0000555555621ea0 <+2576>:\tjmp    0x555555621fad <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2845>\r\n\r\n436\t                connected = true;\r\n   0x0000555555621ea5 <+2581>:\tmovb   $0x1,-0x3f9(%rbp)\r\n   0x0000555555621eac <+2588>:\tlea    -0x1f0(%rbp),%rdi\r\n\r\n437\t                *sock = std::move(conn.sock);\r\n   0x0000555555621eb3 <+2595>:\tcall   0x55555563eac0 <_ZSt4moveIR4SockEONSt16remove_referenceIT_E4typeEOS3_>\r\n   0x0000555555621eb8 <+2600>:\tlea    -0x380(%rbp),%rdi\r\n   0x0000555555621ebf <+2607>:\tmov    %rax,-0x4d0(%rbp)\r\n   0x0000555555621ec6 <+2614>:\tcall   0x55555563eb10 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEdeEv>\r\n   0x0000555555621ecb <+2619>:\tmov    %rax,-0x4d8(%rbp)\r\n   0x0000555555621ed2 <+2626>:\tjmp    0x555555621ed7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2631>\r\n   0x0000555555621ed7 <+2631>:\tmov    -0x4d8(%rbp),%rax\r\n   0x0000555555621ede <+2638>:\tmov    (%rax),%rcx\r\n   0x0000555555621ee1 <+2641>:\tmov    0x10(%rcx),%rcx\r\n   0x0000555555621ee5 <+2645>:\tmov    %rax,%rdi\r\n   0x0000555555621ee8 <+2648>:\tmov    -0x4d0(%rbp),%rsi\r\n   0x0000555555621eef <+2655>:\tcall   *%rcx\r\n   0x0000555555621ef1 <+2657>:\tjmp    0x555555621ef6 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2662>\r\n\r\n438\t                addr_bind = CAddress{conn.me, NODE_NONE};\r\n   0x0000555555621ef6 <+2662>:\tlea    -0x1e0(%rbp),%rsi\r\n   0x0000555555621efd <+2669>:\tlea    -0x248(%rbp),%rdi\r\n   0x0000555555621f04 <+2676>:\tcall   0x5555555d5980 <_ZN8CServiceC2ERKS_>\r\n   0x0000555555621f09 <+2681>:\tjmp    0x555555621f0e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2686>\r\n   0x0000555555621f0e <+2686>:\txor    %eax,%eax\r\n   0x0000555555621f10 <+2688>:\tmov    %eax,%edx\r\n   0x0000555555621f12 <+2690>:\tlea    -0x220(%rbp),%rdi\r\n   0x0000555555621f19 <+2697>:\tlea    -0x248(%rbp),%rsi\r\n   0x0000555555621f20 <+2704>:\tcall   0x55555563ddb0 <_ZN8CAddressC2E8CService12ServiceFlags>\r\n   0x0000555555621f25 <+2709>:\tjmp    0x555555621f2a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2714>\r\n   0x0000555555621f2a <+2714>:\tlea    -0x190(%rbp),%rdi\r\n   0x0000555555621f31 <+2721>:\tlea    -0x220(%rbp),%rsi\r\n   0x0000555555621f38 <+2728>:\tcall   0x55555563de20 <_ZN8CAddressaSEOS_>\r\n   0x0000555555621f3d <+2733>:\tjmp    0x555555621f42 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2738>\r\n   0x0000555555621f42 <+2738>:\tlea    -0x220(%rbp),%rdi\r\n   0x0000555555621f49 <+2745>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x0000555555621f4e <+2750>:\tlea    -0x248(%rbp),%rdi\r\n   0x0000555555621f55 <+2757>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x0000555555621f90 <+2816>:\tlea    -0x220(%rbp),%rdi\r\n   0x0000555555621f97 <+2823>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x0000555555621f9c <+2828>:\tlea    -0x248(%rbp),%rdi\r\n   0x0000555555621fa3 <+2835>:\tcall   0x5555555d3b20 <_ZN8CServiceD2Ev>\r\n   0x0000555555621fa8 <+2840>:\tjmp    0x555555621fbe <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2862>\r\n\r\n439\t            }\r\n   0x0000555555621f5a <+2762>:\tjmp    0x555555621fad <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2845>\r\n\r\n440\t        } else if (GetProxy(addrConnect.GetNetwork(), proxy)) {\r\n   0x0000555555621fad <+2845>:\tlea    -0x1f0(%rbp),%rdi\r\n   0x0000555555621fb4 <+2852>:\tcall   0x55555563eb60 <_ZN3i2p10ConnectionD2Ev>\r\n   0x0000555555621fb9 <+2857>:\tjmp    0x55555562225e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3534>\r\n   0x0000555555621fbe <+2862>:\tlea    -0x1f0(%rbp),%rdi\r\n   0x0000555555621fc5 <+2869>:\tcall   0x55555563eb60 <_ZN3i2p10ConnectionD2Ev>\r\n   0x0000555555621fca <+2874>:\tjmp    0x5555556228d4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5188>\r\n   0x0000555555621fcf <+2879>:\tmov    -0x428(%rbp),%rdi\r\n   0x0000555555621fd6 <+2886>:\tcall   0x555555eabf20 <_ZNK8CNetAddr10GetNetworkEv>\r\n   0x0000555555621fdb <+2891>:\tmov    %eax,-0x4dc(%rbp)\r\n   0x0000555555621fe1 <+2897>:\tjmp    0x555555621fe6 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2902>\r\n   0x0000555555621fe6 <+2902>:\tlea    -0x160(%rbp),%rsi\r\n   0x0000555555621fed <+2909>:\tmov    -0x4dc(%rbp),%edi\r\n   0x0000555555621ff3 <+2915>:\tcall   0x555555eb7dd0 <_Z8GetProxy7NetworkR9proxyType>\r\n   0x0000555555621ff8 <+2920>:\tmov    %al,-0x4dd(%rbp)\r\n   0x0000555555621ffe <+2926>:\tjmp    0x555555622003 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2931>\r\n   0x0000555555622003 <+2931>:\tmov    -0x4dd(%rbp),%al\r\n   0x0000555555622009 <+2937>:\ttest   $0x1,%al\r\n   0x000055555562200b <+2939>:\tjne    0x555555622016 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2950>\r\n   0x0000555555622011 <+2945>:\tjmp    0x55555562215a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3274>\r\n\r\n441\t            sock = CreateSock(proxy.proxy);\r\n   0x0000555555622016 <+2950>:\tlea    0xee2773(%rip),%rsi        # 0x555556504790 <CreateSock>\r\n   0x000055555562201d <+2957>:\tlea    -0x390(%rbp),%rdi\r\n   0x0000555555622024 <+2964>:\tlea    -0x160(%rbp),%rdx\r\n   0x000055555562202b <+2971>:\tcall   0x55555563ebd0 <_ZNKSt8functionIFSt10unique_ptrI4SockSt14default_deleteIS1_EERK8CServiceEEclES7_>\r\n   0x0000555555622030 <+2976>:\tjmp    0x555555622035 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2981>\r\n   0x0000555555622035 <+2981>:\tlea    -0x380(%rbp),%rdi\r\n   0x000055555562203c <+2988>:\tlea    -0x390(%rbp),%rsi\r\n   0x0000555555622043 <+2995>:\tcall   0x55555563ec80 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EEaSEOS3_>\r\n   0x0000555555622048 <+3000>:\tlea    -0x390(%rbp),%rdi\r\n   0x000055555562204f <+3007>:\tmov    %rax,-0x4e8(%rbp)\r\n   0x0000555555622056 <+3014>:\tcall   0x55555563ece0 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EED2Ev>\r\n\r\n442\t            if (!sock) {\r\n   0x000055555562205b <+3019>:\tlea    -0x380(%rbp),%rdi\r\n   0x0000555555622062 <+3026>:\tcall   0x55555563ed90 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEcvbEv>\r\n   0x0000555555622067 <+3031>:\ttest   $0x1,%al\r\n   0x0000555555622069 <+3033>:\tjne    0x555555622089 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3065>\r\n\r\n443\t                return nullptr;\r\n   0x000055555562206f <+3039>:\tmovq   $0x0,-0x3c0(%rbp)\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n   0x000055555562207a <+3050>:\tmovl   $0x1,-0x3f0(%rbp)\r\n   0x0000555555622084 <+3060>:\tjmp    0x5555556228ab <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5147>\r\n   0x0000555555622089 <+3065>:\tlea    -0x268(%rbp),%rdi\r\n   0x0000555555622090 <+3072>:\tmov    -0x428(%rbp),%rsi\r\n\r\n444\t            }\r\n445\t            connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(),\r\n   0x0000555555622097 <+3079>:\tcall   0x555555eabfc0 <_ZNK8CNetAddr10ToStringIPB5cxx11Ev>\r\n   0x000055555562209c <+3084>:\tjmp    0x5555556220a1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3089>\r\n   0x00005555556220a1 <+3089>:\tmov    -0x428(%rbp),%rdi\r\n   0x00005555556220a8 <+3096>:\tcall   0x555555eae740 <_ZNK8CService7GetPortEv>\r\n   0x00005555556220ad <+3101>:\tmov    %ax,-0x4ea(%rbp)\r\n   0x00005555556220b4 <+3108>:\tjmp    0x5555556220b9 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3113>\r\n   0x00005555556220b9 <+3113>:\tmov    -0x4ea(%rbp),%ax\r\n   0x00005555556220c0 <+3120>:\tmovzwl %ax,%edx\r\n   0x00005555556220c3 <+3123>:\tlea    -0x380(%rbp),%rdi\r\n   0x00005555556220ca <+3130>:\tmov    %edx,-0x4f0(%rbp)\r\n   0x000055555562210d <+3197>:\tcall   0x555555eb8320 <_Z19ConnectThroughProxyRK9proxyTypeRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiRK4SockiRb>\r\n   0x0000555555622112 <+3202>:\tmov    %al,-0x4f9(%rbp)\r\n   0x0000555555622118 <+3208>:\tjmp    0x55555562211d <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3213>\r\n   0x000055555562211d <+3213>:\tmov    -0x4f9(%rbp),%al\r\n   0x0000555555622123 <+3219>:\tand    $0x1,%al\r\n   0x0000555555622125 <+3221>:\tmov    %al,-0x3f9(%rbp)\r\n   0x000055555562212b <+3227>:\tlea    -0x268(%rbp),%rdi\r\n   0x0000555555622132 <+3234>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555622149 <+3257>:\tlea    -0x268(%rbp),%rdi\r\n   0x0000555555622150 <+3264>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555622155 <+3269>:\tjmp    0x5555556228d4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5188>\r\n\r\n446\t                                            *sock, nConnectTimeout, proxyConnectionFailed);\r\n   0x00005555556220d0 <+3136>:\tcall   0x55555563eb10 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEdeEv>\r\n   0x00005555556220d5 <+3141>:\tmov    %rax,-0x4f8(%rbp)\r\n   0x00005555556220dc <+3148>:\tjmp    0x5555556220e1 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3153>\r\n   0x00005555556220e1 <+3153>:\tlea    0xeda5b8(%rip),%rax        # 0x5555564fc6a0 <nConnectTimeout>\r\n   0x00005555556220e8 <+3160>:\tmov    (%rax),%r8d\r\n   0x00005555556220eb <+3163>:\tlea    -0x160(%rbp),%rdi\r\n   0x00005555556220f2 <+3170>:\tlea    -0x268(%rbp),%rsi\r\n   0x00005555556220f9 <+3177>:\tlea    -0x381(%rbp),%r9\r\n   0x0000555555622100 <+3184>:\tmov    -0x4f0(%rbp),%edx\r\n   0x0000555555622106 <+3190>:\tmov    -0x4f8(%rbp),%rcx\r\n\r\n447\t        } else {\r\n   0x0000555555622137 <+3239>:\tjmp    0x555555622259 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3529>\r\n\r\n448\t            // no proxy needed (none set for target network)\r\n449\t            sock = CreateSock(addrConnect);\r\n   0x000055555562215a <+3274>:\tlea    0xee262f(%rip),%rsi        # 0x555556504790 <CreateSock>\r\n   0x0000555555622161 <+3281>:\tlea    -0x398(%rbp),%rdi\r\n   0x0000555555622168 <+3288>:\tmov    -0x428(%rbp),%rdx\r\n   0x000055555562216f <+3295>:\tcall   0x55555563ebd0 <_ZNKSt8functionIFSt10unique_ptrI4SockSt14default_deleteIS1_EERK8CServiceEEclES7_>\r\n   0x0000555555622174 <+3300>:\tjmp    0x555555622179 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3305>\r\n   0x0000555555622179 <+3305>:\tlea    -0x380(%rbp),%rdi\r\n   0x0000555555622180 <+3312>:\tlea    -0x398(%rbp),%rsi\r\n   0x0000555555622187 <+3319>:\tcall   0x55555563ec80 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EEaSEOS3_>\r\n   0x000055555562218c <+3324>:\tlea    -0x398(%rbp),%rdi\r\n   0x0000555555622193 <+3331>:\tmov    %rax,-0x508(%rbp)\r\n   0x000055555562219a <+3338>:\tcall   0x55555563ece0 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EED2Ev>\r\n\r\n450\t            if (!sock) {\r\n   0x000055555562219f <+3343>:\tlea    -0x380(%rbp),%rdi\r\n   0x00005555556221a6 <+3350>:\tcall   0x55555563ed90 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEcvbEv>\r\n   0x00005555556221ab <+3355>:\ttest   $0x1,%al\r\n   0x00005555556221ad <+3357>:\tjne    0x5555556221cd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3389>\r\n\r\n451\t                return nullptr;\r\n   0x00005555556221b3 <+3363>:\tmovq   $0x0,-0x3c0(%rbp)\r\n   0x00005555556221be <+3374>:\tmovl   $0x1,-0x3f0(%rbp)\r\n   0x00005555556221c8 <+3384>:\tjmp    0x5555556228ab <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5147>\r\n   0x00005555556221cd <+3389>:\tmov    -0x428(%rbp),%rax\r\n   0x00005555556221d4 <+3396>:\tlea    -0x380(%rbp),%rdi\r\n   0x00005555556221db <+3403>:\tmov    %rax,-0x510(%rbp)\r\n\r\n452\t            }\r\n453\t            connected = ConnectSocketDirectly(addrConnect, sock->Get(), nConnectTimeout,\r\n   0x00005555556221e2 <+3410>:\tcall   0x55555563edf0 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEptEv>\r\n   0x00005555556221e7 <+3415>:\tmov    (%rax),%rcx\r\n   0x00005555556221ea <+3418>:\tmov    0x18(%rcx),%rcx\r\n   0x00005555556221ee <+3422>:\tmov    %rax,%rdi\r\n   0x00005555556221f1 <+3425>:\tcall   *%rcx\r\n   0x00005555556221f3 <+3427>:\tmov    %eax,-0x514(%rbp)\r\n   0x00005555556221f9 <+3433>:\tjmp    0x5555556221fe <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3438>\r\n   0x00005555556221fe <+3438>:\tmov    -0x514(%rbp),%eax\r\n   0x0000555555622204 <+3444>:\tmov    %eax,-0x39c(%rbp)\r\n   0x000055555562220a <+3450>:\tlea    0xeda48f(%rip),%rcx        # 0x5555564fc6a0 <nConnectTimeout>\r\n   0x0000555555622211 <+3457>:\tmov    (%rcx),%edx\r\n   0x0000555555622220 <+3472>:\tmovzbl %dil,%ecx\r\n   0x0000555555622224 <+3476>:\tlea    -0x39c(%rbp),%r8\r\n   0x000055555562222b <+3483>:\tmov    -0x510(%rbp),%rdi\r\n   0x0000555555622232 <+3490>:\tmov    %esi,-0x518(%rbp)\r\n   0x0000555555622238 <+3496>:\tmov    %r8,%rsi\r\n   0x000055555562223b <+3499>:\tcall   0x555555eb71f0 <_Z21ConnectSocketDirectlyRK8CServiceRKjib>\r\n   0x0000555555622240 <+3504>:\tmov    %al,-0x519(%rbp)\r\n   0x0000555555622246 <+3510>:\tjmp    0x55555562224b <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3515>\r\n   0x000055555562224b <+3515>:\tmov    -0x519(%rbp),%al\r\n   0x0000555555622251 <+3521>:\tand    $0x1,%al\r\n   0x0000555555622253 <+3523>:\tmov    %al,-0x3f9(%rbp)\r\n   0x0000555555622259 <+3529>:\tjmp    0x55555562225e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3534>\r\n\r\n454\t                                              conn_type == ConnectionType::MANUAL);\r\n   0x0000555555622213 <+3459>:\tmov    -0x3d0(%rbp),%esi\r\n   0x0000555555622219 <+3465>:\tsub    $0x2,%esi\r\n   0x000055555562221c <+3468>:\tsete   %dil\r\n\r\n455\t        }\r\n456\t        if (!proxyConnectionFailed) {\r\n   0x000055555562225e <+3534>:\ttestb  $0x1,-0x381(%rbp)\r\n   0x0000555555622265 <+3541>:\tjne    0x5555556222dc <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3660>\r\n   0x000055555562226b <+3547>:\tmov    -0x430(%rbp),%rax\r\n\r\n457\t            // If a connection to the node was attempted, and failure (if any) is not caused by a problem connecting to\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n458\t            // the proxy, mark this as an attempt.\r\n459\t            addrman.Attempt(addrConnect, fCountFailure);\r\n   0x0000555555622272 <+3554>:\tadd    $0xc0,%rax\r\n   0x0000555555622278 <+3560>:\tmov    -0x428(%rbp),%rcx\r\n   0x000055555562227f <+3567>:\tmov    -0x3c9(%rbp),%dl\r\n   0x0000555555622285 <+3573>:\tmov    %rax,-0x528(%rbp)\r\n   0x000055555562228c <+3580>:\tmov    %rcx,-0x530(%rbp)\r\n   0x0000555555622293 <+3587>:\tmov    %dl,-0x531(%rbp)\r\n   0x0000555555622299 <+3593>:\tcall   0x5555559d35f0 <_Z15GetAdjustedTimev>\r\n   0x000055555562229e <+3598>:\tmov    %rax,-0x540(%rbp)\r\n   0x00005555556222a5 <+3605>:\tjmp    0x5555556222aa <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3610>\r\n   0x00005555556222aa <+3610>:\tmov    -0x531(%rbp),%al\r\n   0x00005555556222b0 <+3616>:\tmovzbl %al,%ecx\r\n   0x00005555556222b3 <+3619>:\tand    $0x1,%ecx\r\n   0x00005555556222b6 <+3622>:\tmov    -0x528(%rbp),%rdi\r\n   0x00005555556222bd <+3629>:\tmov    -0x530(%rbp),%rsi\r\n   0x00005555556222c4 <+3636>:\tmov    %ecx,%edx\r\n   0x00005555556222c6 <+3638>:\tmov    -0x540(%rbp),%rcx\r\n   0x00005555556222cd <+3645>:\tcall   0x55555563ee40 <_ZN8CAddrMan7AttemptERK8CServicebl>\r\n   0x00005555556222d2 <+3650>:\tjmp    0x5555556222d7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3655>\r\n\r\n460\t        }\r\n   0x00005555556222d7 <+3655>:\tjmp    0x5555556222dc <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3660>\r\n\r\n461\t    } else if (pszDest && GetNameProxy(proxy)) {\r\n   0x00005555556222dc <+3660>:\tjmp    0x5555556224fc <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4204>\r\n   0x00005555556222e1 <+3665>:\tcmpq   $0x0,-0x340(%rbp)\r\n   0x00005555556222e9 <+3673>:\tje     0x5555556224f7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4199>\r\n   0x00005555556222ef <+3679>:\tlea    -0x160(%rbp),%rdi\r\n   0x00005555556222f6 <+3686>:\tcall   0x555555eb8020 <_Z12GetNameProxyR9proxyType>\r\n   0x00005555556222fb <+3691>:\tmov    %al,-0x541(%rbp)\r\n   0x0000555555622301 <+3697>:\tjmp    0x555555622306 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3702>\r\n   0x0000555555622306 <+3702>:\tmov    -0x541(%rbp),%al\r\n   0x000055555562230c <+3708>:\ttest   $0x1,%al\r\n   0x000055555562230e <+3710>:\tjne    0x555555622319 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3721>\r\n   0x0000555555622314 <+3716>:\tjmp    0x5555556224f7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4199>\r\n\r\n462\t        sock = CreateSock(proxy.proxy);\r\n   0x0000555555622319 <+3721>:\tlea    0xee2470(%rip),%rsi        # 0x555556504790 <CreateSock>\r\n   0x0000555555622320 <+3728>:\tlea    -0x3a8(%rbp),%rdi\r\n   0x0000555555622327 <+3735>:\tlea    -0x160(%rbp),%rdx\r\n   0x000055555562232e <+3742>:\tcall   0x55555563ebd0 <_ZNKSt8functionIFSt10unique_ptrI4SockSt14default_deleteIS1_EERK8CServiceEEclES7_>\r\n   0x0000555555622333 <+3747>:\tjmp    0x555555622338 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3752>\r\n   0x0000555555622338 <+3752>:\tlea    -0x380(%rbp),%rdi\r\n   0x000055555562233f <+3759>:\tlea    -0x3a8(%rbp),%rsi\r\n   0x0000555555622346 <+3766>:\tcall   0x55555563ec80 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EEaSEOS3_>\r\n   0x000055555562234b <+3771>:\tlea    -0x3a8(%rbp),%rdi\r\n   0x0000555555622352 <+3778>:\tmov    %rax,-0x550(%rbp)\r\n   0x0000555555622359 <+3785>:\tcall   0x55555563ece0 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EED2Ev>\r\n\r\n463\t        if (!sock) {\r\n   0x000055555562235e <+3790>:\tlea    -0x380(%rbp),%rdi\r\n   0x0000555555622365 <+3797>:\tcall   0x55555563ed90 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEcvbEv>\r\n   0x000055555562236a <+3802>:\ttest   $0x1,%al\r\n   0x000055555562236c <+3804>:\tjne    0x55555562238c <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3836>\r\n\r\n464\t            return nullptr;\r\n   0x0000555555622372 <+3810>:\tmovq   $0x0,-0x3c0(%rbp)\r\n   0x000055555562237d <+3821>:\tmovl   $0x1,-0x3f0(%rbp)\r\n   0x0000555555622387 <+3831>:\tjmp    0x5555556228ab <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5147>\r\n   0x000055555562238c <+3836>:\tlea    -0x288(%rbp),%rdi\r\n\r\n465\t        }\r\n466\t        std::string host;\r\n   0x0000555555622393 <+3843>:\tcall   0x555555581920 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev@plt>\r\n\r\n467\t        int port = default_port;\r\n   0x0000555555622398 <+3848>:\tmov    -0x3ec(%rbp),%eax\r\n   0x000055555562239e <+3854>:\tmov    %eax,-0x3ac(%rbp)\r\n\r\n468\t        SplitHostPort(std::string(pszDest), port, host);\r\n   0x00005555556223a4 <+3860>:\tmov    -0x340(%rbp),%rsi\r\n   0x00005555556223ab <+3867>:\tlea    -0x3b0(%rbp),%rcx\r\n   0x00005555556223b2 <+3874>:\tmov    %rcx,%rdi\r\n   0x00005555556223b5 <+3877>:\tmov    %rsi,-0x558(%rbp)\r\n   0x00005555556223bc <+3884>:\tmov    %rcx,-0x560(%rbp)\r\n   0x00005555556223c3 <+3891>:\tcall   0x555555582c40 <_ZNSaIcEC1Ev@plt>\r\n   0x00005555556223c8 <+3896>:\tlea    -0x2a8(%rbp),%rdi\r\n   0x00005555556223cf <+3903>:\tmov    -0x558(%rbp),%rsi\r\n   0x00005555556223d6 <+3910>:\tmov    -0x560(%rbp),%rdx\r\n   0x00005555556223dd <+3917>:\tcall   0x55555559c0c0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2IS3_EEPKcRKS3_>\r\n   0x00005555556223e2 <+3922>:\tjmp    0x5555556223e7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3927>\r\n   0x00005555556223e7 <+3927>:\tlea    -0x2a8(%rbp),%rdi\r\n   0x00005555556223ee <+3934>:\tlea    -0x3ac(%rbp),%rsi\r\n   0x00005555556223f5 <+3941>:\tlea    -0x288(%rbp),%rdx\r\n   0x00005555556223fc <+3948>:\tcall   0x555555fa7de0 <_Z13SplitHostPortNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERiRS4_>\r\n   0x0000555555622401 <+3953>:\tjmp    0x555555622406 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+3958>\r\n   0x0000555555622406 <+3958>:\tlea    -0x2a8(%rbp),%rdi\r\n   0x000055555562240d <+3965>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555622412 <+3970>:\tlea    -0x3b0(%rbp),%rdi\r\n   0x0000555555622419 <+3977>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x00005555556224bc <+4140>:\tlea    -0x2a8(%rbp),%rdi\r\n   0x00005555556224c3 <+4147>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x00005555556224c8 <+4152>:\tlea    -0x3b0(%rbp),%rdi\r\n   0x00005555556224cf <+4159>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x00005555556224d4 <+4164>:\tjmp    0x5555556224e6 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4182>\r\n\r\n469\t        bool proxyConnectionFailed;\r\n470\t        connected = ConnectThroughProxy(proxy, host, port, *sock, nConnectTimeout,\r\n   0x000055555562241e <+3982>:\tmov    -0x3ac(%rbp),%edx\r\n   0x0000555555622424 <+3988>:\tlea    -0x380(%rbp),%rdi\r\n   0x000055555562242b <+3995>:\tmov    %edx,-0x564(%rbp)\r\n   0x0000555555622431 <+4001>:\tcall   0x55555563eb10 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEdeEv>\r\n   0x0000555555622436 <+4006>:\tmov    %rax,-0x570(%rbp)\r\n   0x000055555562243d <+4013>:\tjmp    0x555555622442 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4018>\r\n   0x0000555555622442 <+4018>:\tlea    0xeda257(%rip),%rax        # 0x5555564fc6a0 <nConnectTimeout>\r\n   0x0000555555622449 <+4025>:\tmov    (%rax),%r8d\r\n   0x000055555562244c <+4028>:\tlea    -0x160(%rbp),%rdi\r\n   0x0000555555622453 <+4035>:\tlea    -0x288(%rbp),%rsi\r\n   0x000055555562245a <+4042>:\tlea    -0x3b1(%rbp),%r9\r\n   0x0000555555622461 <+4049>:\tmov    -0x564(%rbp),%edx\r\n   0x0000555555622467 <+4055>:\tmov    -0x570(%rbp),%rcx\r\n   0x000055555562246e <+4062>:\tcall   0x555555eb8320 <_Z19ConnectThroughProxyRK9proxyTypeRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiRK4SockiRb>\r\n   0x0000555555622473 <+4067>:\tmov    %al,-0x571(%rbp)\r\n   0x0000555555622479 <+4073>:\tjmp    0x55555562247e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4078>\r\n   0x000055555562247e <+4078>:\tmov    -0x571(%rbp),%al\r\n   0x0000555555622484 <+4084>:\tand    $0x1,%al\r\n   0x0000555555622486 <+4086>:\tmov    %al,-0x3f9(%rbp)\r\n\r\n471\t                                        proxyConnectionFailed);\r\n472\t    }\r\n   0x000055555562248c <+4092>:\tlea    -0x288(%rbp),%rdi\r\n   0x0000555555622493 <+4099>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x0000555555622498 <+4104>:\tjmp    0x5555556224f7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4199>\r\n   0x00005555556224e6 <+4182>:\tlea    -0x288(%rbp),%rdi\r\n   0x00005555556224ed <+4189>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x00005555556224f2 <+4194>:\tjmp    0x5555556228d4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5188>\r\n   0x00005555556224f7 <+4199>:\tjmp    0x5555556224fc <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4204>\r\n\r\n473\t    if (!connected) {\r\n   0x00005555556224fc <+4204>:\ttestb  $0x1,-0x3f9(%rbp)\r\n   0x0000555555622503 <+4211>:\tjne    0x555555622523 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4243>\r\n\r\n474\t        return nullptr;\r\n   0x0000555555622509 <+4217>:\tmovq   $0x0,-0x3c0(%rbp)\r\n   0x0000555555622514 <+4228>:\tmovl   $0x1,-0x3f0(%rbp)\r\n   0x000055555562251e <+4238>:\tjmp    0x5555556228ab <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5147>\r\n   0x0000555555622523 <+4243>:\tmov    -0x430(%rbp),%rdi\r\n\r\n475\t    }\r\n476\t\r\n477\t    // Add node\r\n478\t    NodeId id = GetNewNodeId();\r\n   0x000055555562252a <+4250>:\tcall   0x5555556232f0 <_ZN8CConnman12GetNewNodeIdEv>\r\n   0x000055555562252f <+4255>:\tmov    %rax,-0x580(%rbp)\r\n   0x0000555555622536 <+4262>:\tjmp    0x55555562253b <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4267>\r\n   0x000055555562253b <+4267>:\tmov    -0x580(%rbp),%rax\r\n   0x0000555555622542 <+4274>:\tmov    %rax,-0x408(%rbp)\r\n   0x0000555555622549 <+4281>:\tlea    -0x2d8(%rbp),%rdi\r\n   0x0000555555622550 <+4288>:\tmovabs $0xd93e69e2bbfa5735,%rdx\r\n   0x000055555562255a <+4298>:\tmov    -0x430(%rbp),%rsi\r\n\r\n479\t    uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\r\n   0x0000555555622561 <+4305>:\tcall   0x555555623400 <_ZNK8CConnman26GetDeterministicRandomizerEm>\r\n   0x0000555555622566 <+4310>:\tjmp    0x55555562256b <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4315>\r\n   0x000055555562256b <+4315>:\tmov    -0x408(%rbp),%rsi\r\n   0x0000555555622572 <+4322>:\tlea    -0x2d8(%rbp),%rdi\r\n   0x0000555555622579 <+4329>:\tcall   0x55555601ba30 <_ZN10CSipHasher5WriteEm>\r\n   0x000055555562257e <+4334>:\tmov    %rax,-0x588(%rbp)\r\n   0x0000555555622585 <+4341>:\tjmp    0x55555562258a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4346>\r\n   0x000055555562258a <+4346>:\tmov    -0x588(%rbp),%rdi\r\n   0x0000555555622591 <+4353>:\tcall   0x55555601c070 <_ZNK10CSipHasher8FinalizeEv>\r\n   0x0000555555622596 <+4358>:\tmov    %rax,-0x590(%rbp)\r\n   0x000055555562259d <+4365>:\tjmp    0x5555556225a2 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4370>\r\n   0x00005555556225a2 <+4370>:\tmov    -0x590(%rbp),%rax\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n   0x00005555556225a9 <+4377>:\tmov    %rax,-0x410(%rbp)\r\n   0x00005555556225b0 <+4384>:\tlea    -0x190(%rbp),%rdi\r\n\r\n480\t    if (!addr_bind.IsValid()) {\r\n   0x00005555556225b7 <+4391>:\tcall   0x555555eaba70 <_ZNK8CNetAddr7IsValidEv>\r\n   0x00005555556225bc <+4396>:\tmov    %al,-0x591(%rbp)\r\n   0x00005555556225c2 <+4402>:\tjmp    0x5555556225c7 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4407>\r\n   0x00005555556225c7 <+4407>:\tmov    -0x591(%rbp),%al\r\n   0x00005555556225cd <+4413>:\ttest   $0x1,%al\r\n   0x00005555556225cf <+4415>:\tjne    0x55555562265b <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4555>\r\n   0x00005555556225d5 <+4421>:\tjmp    0x5555556225da <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4426>\r\n   0x00005555556225da <+4426>:\tlea    -0x380(%rbp),%rdi\r\n\r\n481\t        addr_bind = GetBindAddress(sock->Get());\r\n   0x00005555556225e1 <+4433>:\tcall   0x55555563edf0 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEptEv>\r\n   0x00005555556225e6 <+4438>:\tmov    (%rax),%rcx\r\n   0x00005555556225e9 <+4441>:\tmov    0x18(%rcx),%rcx\r\n   0x00005555556225ed <+4445>:\tmov    %rax,%rdi\r\n   0x00005555556225f0 <+4448>:\tcall   *%rcx\r\n   0x00005555556225f2 <+4450>:\tmov    %eax,-0x598(%rbp)\r\n   0x00005555556225f8 <+4456>:\tjmp    0x5555556225fd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4461>\r\n   0x00005555556225fd <+4461>:\tlea    -0x308(%rbp),%rdi\r\n   0x0000555555622604 <+4468>:\tmov    -0x598(%rbp),%esi\r\n   0x000055555562260a <+4474>:\tcall   0x5555556234a0 <_ZL14GetBindAddressj>\r\n   0x000055555562260f <+4479>:\tjmp    0x555555622614 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4484>\r\n   0x0000555555622614 <+4484>:\tlea    -0x190(%rbp),%rdi\r\n   0x000055555562261b <+4491>:\tlea    -0x308(%rbp),%rsi\r\n   0x0000555555622622 <+4498>:\tcall   0x55555563de20 <_ZN8CAddressaSEOS_>\r\n   0x0000555555622627 <+4503>:\tjmp    0x55555562262c <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4508>\r\n   0x000055555562262c <+4508>:\tlea    -0x308(%rbp),%rdi\r\n   0x0000555555622633 <+4515>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x000055555562264a <+4538>:\tlea    -0x308(%rbp),%rdi\r\n   0x0000555555622651 <+4545>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x0000555555622656 <+4550>:\tjmp    0x5555556228d4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5188>\r\n   0x000055555562265b <+4555>:\tmov    $0x430,%edi\r\n\r\n482\t    }\r\n   0x0000555555622638 <+4520>:\tjmp    0x55555562265b <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4555>\r\n\r\n483\t    CNode* pnode = new CNode(id, nLocalServices, sock->Release(), addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", conn_type);\r\n   0x0000555555622660 <+4560>:\tcall   0x555555581420 <_Znwm@plt>\r\n   0x0000555555622665 <+4565>:\tmov    %rax,-0x5a0(%rbp)\r\n   0x000055555562266c <+4572>:\tjmp    0x555555622671 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4577>\r\n   0x0000555555622671 <+4577>:\tmovb   $0x1,-0x419(%rbp)\r\n   0x0000555555622678 <+4584>:\tmov    -0x5a0(%rbp),%rax\r\n   0x000055555562267f <+4591>:\tmov    -0x408(%rbp),%rsi\r\n   0x0000555555622686 <+4598>:\tmov    -0x430(%rbp),%rcx\r\n   0x000055555562268d <+4605>:\tmov    0x503d8(%rcx),%rdx\r\n   0x0000555555622694 <+4612>:\tlea    -0x380(%rbp),%rdi\r\n   0x000055555562269b <+4619>:\tmov    %rax,-0x5a8(%rbp)\r\n   0x00005555556226a2 <+4626>:\tmov    %rsi,-0x5b0(%rbp)\r\n   0x00005555556226a9 <+4633>:\tmov    %rdx,-0x5b8(%rbp)\r\n   0x00005555556226b0 <+4640>:\tcall   0x55555563edf0 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEptEv>\r\n   0x00005555556226b5 <+4645>:\tmov    (%rax),%rcx\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n   0x00005555556226b8 <+4648>:\tmov    0x20(%rcx),%rcx\r\n   0x00005555556226bc <+4652>:\tmov    %rax,%rdi\r\n   0x00005555556226bf <+4655>:\tcall   *%rcx\r\n   0x00005555556226c1 <+4657>:\tmov    %eax,-0x5bc(%rbp)\r\n   0x00005555556226c7 <+4663>:\tjmp    0x5555556226cc <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4668>\r\n   0x00005555556226cc <+4668>:\tmov    -0x430(%rbp),%rdi\r\n   0x00005555556226d3 <+4675>:\tmov    -0x428(%rbp),%rsi\r\n   0x00005555556226da <+4682>:\tcall   0x555555623610 <_ZNK8CConnman22CalculateKeyedNetGroupERK8CAddress>\r\n   0x00005555556226df <+4687>:\tmov    %rax,-0x5c8(%rbp)\r\n   0x00005555556226e6 <+4694>:\tjmp    0x5555556226eb <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4699>\r\n   0x00005555556226eb <+4699>:\tmov    -0x410(%rbp),%rax\r\n   0x00005555556226f2 <+4706>:\tcmpq   $0x0,-0x340(%rbp)\r\n   0x00005555556226fa <+4714>:\tmov    %rax,-0x5d0(%rbp)\r\n   0x0000555555622701 <+4721>:\tje     0x55555562271a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4746>\r\n   0x0000555555622707 <+4727>:\tmov    -0x340(%rbp),%rax\r\n   0x000055555562270e <+4734>:\tmov    %rax,-0x5d8(%rbp)\r\n   0x0000555555622715 <+4741>:\tjmp    0x55555562272d <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4765>\r\n   0x000055555562271a <+4746>:\tlea    0xb5c546(%rip),%rax        # 0x55555617ec67\r\n   0x0000555555622721 <+4753>:\tmov    %rax,-0x5d8(%rbp)\r\n   0x0000555555622728 <+4760>:\tjmp    0x55555562272d <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4765>\r\n   0x000055555562272d <+4765>:\tmov    -0x5d8(%rbp),%rax\r\n   0x0000555555622734 <+4772>:\tlea    -0x3b8(%rbp),%rcx\r\n   0x000055555562273b <+4779>:\tmov    %rcx,%rdi\r\n   0x000055555562273e <+4782>:\tmov    %rax,-0x5e0(%rbp)\r\n   0x0000555555622745 <+4789>:\tmov    %rcx,-0x5e8(%rbp)\r\n   0x000055555562274c <+4796>:\tcall   0x555555582c40 <_ZNSaIcEC1Ev@plt>\r\n   0x0000555555622751 <+4801>:\tlea    -0x328(%rbp),%rdi\r\n   0x0000555555622758 <+4808>:\tmov    -0x5e0(%rbp),%rsi\r\n   0x000055555562275f <+4815>:\tmov    -0x5e8(%rbp),%rdx\r\n   0x0000555555622766 <+4822>:\tcall   0x55555559c0c0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC2IS3_EEPKcRKS3_>\r\n   0x000055555562276b <+4827>:\tjmp    0x555555622770 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4832>\r\n   0x0000555555622770 <+4832>:\tmov    -0x3d0(%rbp),%eax\r\n   0x0000555555622776 <+4838>:\tmov    %rsp,%rcx\r\n   0x0000555555622779 <+4841>:\tmov    %eax,0x18(%rcx)\r\n   0x000055555562277c <+4844>:\tlea    -0x328(%rbp),%rdx\r\n   0x0000555555622783 <+4851>:\tmov    %rdx,0x10(%rcx)\r\n   0x0000555555622787 <+4855>:\tlea    -0x190(%rbp),%rdx\r\n   0x000055555562278e <+4862>:\tmov    %rdx,0x8(%rcx)\r\n   0x0000555555622792 <+4866>:\tmov    -0x5d0(%rbp),%rdx\r\n   0x0000555555622799 <+4873>:\tmov    %rdx,(%rcx)\r\n   0x000055555562279c <+4876>:\tmovl   $0x0,0x20(%rcx)\r\n   0x00005555556227a3 <+4883>:\tmov    -0x5a8(%rbp),%rdi\r\n   0x00005555556227aa <+4890>:\tmov    -0x5b0(%rbp),%rsi\r\n   0x00005555556227b1 <+4897>:\tmov    -0x5b8(%rbp),%rdx\r\n   0x00005555556227b8 <+4904>:\tmov    -0x5bc(%rbp),%ecx\r\n   0x00005555556227be <+4910>:\tmov    -0x428(%rbp),%r8\r\n   0x00005555556227c5 <+4917>:\tmov    -0x5c8(%rbp),%r9\r\n   0x00005555556227cc <+4924>:\tcall   0x5555556388d0 <_ZN5CNodeC2El12ServiceFlagsjRK8CAddressmmS3_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE14ConnectionTypeb>\r\n   0x00005555556227d1 <+4929>:\tjmp    0x5555556227d6 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4934>\r\n   0x00005555556227d6 <+4934>:\tmovb   $0x0,-0x419(%rbp)\r\n   0x00005555556227dd <+4941>:\tlea    -0x328(%rbp),%rdi\r\n   0x00005555556227e4 <+4948>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x00005555556227e9 <+4953>:\tlea    -0x3b8(%rbp),%rdi\r\n   0x00005555556227f0 <+4960>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x00005555556227f5 <+4965>:\tmov    -0x5a8(%rbp),%rax\r\n   0x00005555556227fc <+4972>:\tmov    %rax,-0x418(%rbp)\r\n   0x0000555555622870 <+5088>:\tlea    -0x328(%rbp),%rdi\r\n   0x0000555555622877 <+5095>:\tcall   0x5555555833d0 <_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@plt>\r\n   0x000055555562287c <+5100>:\tlea    -0x3b8(%rbp),%rdi\r\n   0x0000555555622883 <+5107>:\tcall   0x5555555833a0 <_ZNSaIcED1Ev@plt>\r\n   0x0000555555622888 <+5112>:\ttestb  $0x1,-0x419(%rbp)\r\n   0x000055555562288f <+5119>:\tjne    0x55555562289a <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5130>\r\n   0x0000555555622895 <+5125>:\tjmp    0x5555556228a6 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5142>\r\n   0x000055555562289a <+5130>:\tmov    -0x5a0(%rbp),%rdi\r\n   0x00005555556228a1 <+5137>:\tcall   0x555555581f10 <_ZdlPv@plt>\r\n   0x00005555556228a6 <+5142>:\tjmp    0x5555556228d4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5188>\r\n\r\n484\t    pnode->AddRef();\r\n   0x0000555555622803 <+4979>:\tmov    -0x418(%rbp),%rdi\r\n   0x000055555562280a <+4986>:\tcall   0x55555563ef20 <_ZN5CNode6AddRefEv>\r\n   0x000055555562280f <+4991>:\tjmp    0x555555622814 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4996>\r\n\r\n485\t\r\n486\t    // We're making a new connection, harvest entropy from the time (and our peer count)\r\n487\t    RandAddEvent((uint32_t)id);\r\n   0x0000555555622814 <+4996>:\tmov    -0x408(%rbp),%rax\r\n   0x000055555562281b <+5003>:\tmov    %eax,%edi\r\n   0x000055555562281d <+5005>:\tcall   0x555555f58da0 <_Z12RandAddEventj>\r\n\r\n488\t\r\n489\t    return pnode;\r\n   0x0000555555622822 <+5010>:\tmov    -0x418(%rbp),%rcx\r\n   0x0000555555622829 <+5017>:\tmov    %rcx,-0x3c0(%rbp)\r\n   0x0000555555622830 <+5024>:\tmovl   $0x1,-0x3f0(%rbp)\r\n   0x000055555562283a <+5034>:\tjmp    0x5555556228ab <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5147>\r\n\r\n490\t}\r\n   0x00005555556215c4 <+308>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x00005555556215cb <+315>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621756 <+710>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x000055555562175d <+717>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621763 <+723>:\tjmp    0x55555562177e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+750>\r\n   0x0000555555621768 <+728>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x000055555562176f <+735>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621a18 <+1416>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621a1f <+1423>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621a25 <+1429>:\tjmp    0x555555621a40 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1456>\r\n   0x0000555555621a2a <+1434>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621a31 <+1441>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621a51 <+1473>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621a58 <+1480>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621a5e <+1486>:\tjmp    0x555555621d02 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2162>\r\n   0x0000555555621a63 <+1491>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621a6a <+1498>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621a70 <+1504>:\tjmp    0x555555621a8e <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+1534>\r\n   0x0000555555621a75 <+1509>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621a7c <+1516>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621a9f <+1551>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621aa6 <+1558>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621c24 <+1940>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621c2b <+1947>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621c31 <+1953>:\tjmp    0x555555621cbe <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2094>\r\n   0x0000555555621c36 <+1958>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621c3d <+1965>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621c54 <+1988>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621c5b <+1995>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621c61 <+2001>:\tjmp    0x555555621c7f <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2031>\r\n   0x0000555555621c66 <+2006>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621c6d <+2013>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621d98 <+2312>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621d9f <+2319>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621da5 <+2325>:\tjmp    0x5555556228ec <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5212>\r\n   0x0000555555621daa <+2330>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621db1 <+2337>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621db7 <+2343>:\tjmp    0x5555556228e0 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5200>\r\n   0x0000555555621dbc <+2348>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621dc3 <+2355>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621dc9 <+2361>:\tjmp    0x5555556228d4 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5188>\r\n   0x0000555555621dce <+2366>:\tmov    -0x428(%rbp),%rdi\r\n   0x0000555555621f5f <+2767>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621f66 <+2774>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621f6c <+2780>:\tjmp    0x555555621fbe <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2862>\r\n   0x0000555555621f71 <+2785>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621f78 <+2792>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x0000555555621f7e <+2798>:\tjmp    0x555555621f9c <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+2828>\r\n   0x0000555555621f83 <+2803>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555621f8a <+2810>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x000055555562213c <+3244>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555622143 <+3251>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x000055555562249d <+4109>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x00005555556224a4 <+4116>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x00005555556224aa <+4122>:\tjmp    0x5555556224c8 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+4152>\r\n   0x00005555556224af <+4127>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x00005555556224b6 <+4134>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x00005555556224d9 <+4169>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x00005555556224e0 <+4176>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x000055555562263d <+4525>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555622644 <+4532>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x000055555562283f <+5039>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555622846 <+5046>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x000055555562284c <+5052>:\tjmp    0x555555622888 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5112>\r\n   0x0000555555622851 <+5057>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x0000555555622858 <+5064>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x000055555562285e <+5070>:\tjmp    0x55555562287c <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5100>\r\n   0x0000555555622863 <+5075>:\tmov    %rax,-0x3e0(%rbp)\r\n   0x000055555562286a <+5082>:\tmov    %edx,-0x3e4(%rbp)\r\n   0x00005555556228ab <+5147>:\tlea    -0x190(%rbp),%rdi\r\n   0x00005555556228b2 <+5154>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x00005555556228b7 <+5159>:\tlea    -0x160(%rbp),%rdi\r\n   0x00005555556228be <+5166>:\tcall   0x5555555d3ad0 <_ZN9proxyTypeD2Ev>\r\n   0x00005555556228c3 <+5171>:\tlea    -0x380(%rbp),%rdi\r\n   0x00005555556228ca <+5178>:\tcall   0x55555563ece0 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EED2Ev>\r\n   0x00005555556228cf <+5183>:\tjmp    0x5555556228fd <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5229>\r\n   0x00005555556228d4 <+5188>:\tlea    -0x190(%rbp),%rdi\r\n--Type <RET> for more, q to quit, c to continue without paging--\r\n   0x00005555556228db <+5195>:\tcall   0x55555563de90 <_ZN8CAddressD2Ev>\r\n   0x00005555556228e0 <+5200>:\tlea    -0x160(%rbp),%rdi\r\n   0x00005555556228e7 <+5207>:\tcall   0x5555555d3ad0 <_ZN9proxyTypeD2Ev>\r\n   0x00005555556228ec <+5212>:\tlea    -0x380(%rbp),%rdi\r\n   0x00005555556228f3 <+5219>:\tcall   0x55555563ece0 <_ZNSt10unique_ptrI4SockSt14default_deleteIS0_EED2Ev>\r\n   0x00005555556228f8 <+5224>:\tjmp    0x555555622931 <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5281>\r\n   0x00005555556228fd <+5229>:\tmov    -0x3c0(%rbp),%rax\r\n   0x0000555555622904 <+5236>:\tmov    %fs:0x28,%rcx\r\n   0x000055555562290d <+5245>:\tmov    -0x8(%rbp),%rdx\r\n   0x0000555555622911 <+5249>:\tcmp    %rdx,%rcx\r\n   0x0000555555622914 <+5252>:\tmov    %rax,-0x5f0(%rbp)\r\n   0x000055555562291b <+5259>:\tjne    0x55555562293d <_ZN8CConnman11ConnectNodeE8CAddressPKcb14ConnectionType+5293>\r\n   0x0000555555622921 <+5265>:\tmov    -0x5f0(%rbp),%rax\r\n   0x0000555555622928 <+5272>:\tadd    $0x620,%rsp\r\n   0x000055555562292f <+5279>:\tpop    %rbp\r\n   0x0000555555622930 <+5280>:\tret    \r\n\r\nEnd of assembler dump.\r\n(gdb) \r\n```\r\n</p></details>\r\n",
      "created_at" : "2021-02-14T15:57:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-778797544",
      "id" : 778797544,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3ODc5NzU0NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-14T15:57:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/778797544",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r575828254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/575828254"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Both gdb and valgrind are hitting this line",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-14T15:59:55Z",
      "diff_hunk" : "@@ -432,10 +424,20 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     bool connected = false;\n     std::unique_ptr<Sock> sock;\n     proxyType proxy;\n+    CAddress addr_bind;\n+    assert(!addr_bind.IsValid());\n+\n     if (addrConnect.IsValid()) {\n         bool proxyConnectionFailed = false;\n \n-        if (GetProxy(addrConnect.GetNetwork(), proxy)) {\n+        if (addrConnect.GetNetwork() == NET_I2P && m_i2p_sam_session.get() != nullptr) {\n+            i2p::Connection conn;\n+            if (m_i2p_sam_session->Connect(addrConnect, conn, proxyConnectionFailed)) {\n+                connected = true;\n+                *sock = std::move(conn.sock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r575828254",
      "id" : 575828254,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTgyODI1NA==",
      "original_commit_id" : "a456bd3f296f18e463e36048c866c404b69363b6",
      "original_line" : 437,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 590061151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/575828254",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "So it hits an illegal instruction on this line:\r\n```\r\n   0x0000555555621ede <+2638>:\tmov    (%rax),%rcx\r\n```\r\nThis is really strange. That looks like a perfectly basic x86 instruction. I could understand a segmentation fault here, but illegal instruction is strange. At least it is in code that is affected by this PR.",
      "created_at" : "2021-02-14T19:24:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-778827585",
      "id" : 778827585,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3ODgyNzU4NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-14T19:24:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/778827585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The previous tests were with clang 9; seeing the same segfault with gcc 10.2.1:\r\n\r\n```\r\n$ gcc --version\r\ngcc (Debian 10.2.1-6) 10.2.1 20210110\r\n$ gdb bitcoind\r\nGNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git\r\n```\r\n\r\n```gdb\r\n2021-02-15T08:47:39Z I2P: SAM session created: session id=qqqq, my address=qqqq.b32.i2p:8333\r\n2021-02-15T08:47:39Z AddLocal(qqqq.b32.i2p:8333,2)\r\n2021-02-15T08:47:47Z UpdateTip: new best=000000000000000000099c233db18ba6797892a9d0e0a915207ceb635b39f21c height=670691 version=0x20600000 log2_work=92.669960 tx=616400432 date='2021-02-15T08:47:12Z' progress=1.000000 cache=9.3MiB(70444txo)\r\n2021-02-15T08:47:48Z New outbound peer connected: version: 70015, blocks=670691, peer=9, peeraddr=jvmq5xt2xcbe32ug.onion:8333 (outbound-full-relay)\r\n\r\nThread 18 \"b-addcon\" received signal SIGSEGV, Segmentation fault.\r\n[Switching to Thread 0x7fff4baf1700 (LWP 55615)]\r\nCConnman::ConnectNode (this=0x555556c59f50, addrConnect=..., pszDest=0x7fff28002e50 \"qqqq.b32.i2p\", \r\n    fCountFailure=false, conn_type=ConnectionType::MANUAL) at net.cpp:437\r\n437\t                *sock = std::move(conn.sock);\r\n\r\n(gdb) disass /m\r\n.../...\r\n437\t                *sock = std::move(conn.sock);\r\n   0x00005555555fb83a <+1692>:\tlea    -0x3e8(%rbp),%rax\r\n   0x00005555555fb841 <+1699>:\tmov    %rax,%rdi\r\n   0x00005555555fb844 <+1702>:\tcall   0x55555561c796 <_ZNKSt10unique_ptrI4SockSt14default_deleteIS0_EEdeEv>\r\n   0x00005555555fb849 <+1707>:\tmov    %rax,%rbx\r\n=> 0x00005555555fb84c <+1710>:\tmov    (%rbx),%rax\r\n   0x00005555555fb84f <+1713>:\tadd    $0x10,%rax\r\n   0x00005555555fb853 <+1717>:\tmov    (%rax),%r12\r\n   0x00005555555fb856 <+1720>:\tlea    -0x90(%rbp),%rax\r\n   0x00005555555fb85d <+1727>:\tmov    %rax,%rdi\r\n   0x00005555555fb860 <+1730>:\tcall   0x55555561c7d7 <_ZSt4moveIR4SockEONSt16remove_referenceIT_E4typeEOS3_>\r\n   0x00005555555fb865 <+1735>:\tmov    %rax,%rsi\r\n   0x00005555555fb868 <+1738>:\tmov    %rbx,%rdi\r\n   0x00005555555fb86b <+1741>:\tcall   *%r12\r\n```\r\n\r\n<details><summary>backtrace</summary><p>\r\n\r\n```gdb\r\n(gdb) bt\r\n#0  CConnman::ConnectNode (this=0x555556c59f50, addrConnect=..., pszDest=0x7fff28002e50 \"qqqq.b32.i2p\", \r\n    fCountFailure=false, conn_type=ConnectionType::MANUAL) at net.cpp:437\r\n#1  0x0000555555605be1 in CConnman::OpenNetworkConnection (this=0x555556c59f50, addrConnect=..., fCountFailure=false, grantOutbound=0x7fff4baf0810, \r\n    pszDest=0x7fff28002e50 \"qqqq.b32.i2p\", conn_type=ConnectionType::MANUAL) at net.cpp:2152\r\n#2  0x000055555560581c in CConnman::ThreadOpenAddedConnections (this=0x555556c59f50) at net.cpp:2119\r\n#3  0x00005555556605f2 in std::__invoke_impl<void, void (CConnman::*&)(), CConnman*&> (\r\n    __f=@0x5555639f9670: (void (CConnman::*)(CConnman * const)) 0x555555605692 <CConnman::ThreadOpenAddedConnections()>, __t=@0x5555639f9680: 0x555556c59f50)\r\n    at /usr/include/c++/10/bits/invoke.h:73\r\n#4  0x000055555565e4bf in std::__invoke<void (CConnman::*&)(), CConnman*&> (\r\n    __fn=@0x5555639f9670: (void (CConnman::*)(CConnman * const)) 0x555555605692 <CConnman::ThreadOpenAddedConnections()>) at /usr/include/c++/10/bits/invoke.h:95\r\n#5  0x000055555565b1b7 in std::_Bind<void (CConnman::*(CConnman*))()>::__call<void, , 0ul>(std::tuple<>&&, std::_Index_tuple<0ul>) (this=0x5555639f9670, \r\n    __args=...) at /usr/include/c++/10/functional:416\r\n#6  0x00005555556559df in std::_Bind<void (CConnman::*(CConnman*))()>::operator()<, void>() (this=0x5555639f9670) at /usr/include/c++/10/functional:499\r\n#7  0x000055555564dddb in std::__invoke_impl<void, std::_Bind<void (CConnman::*(CConnman*))()>&>(std::__invoke_other, std::_Bind<void (CConnman::*(CConnman*))()>&)\r\n    (__f=...) at /usr/include/c++/10/bits/invoke.h:60\r\n#8  0x00005555556423ae in std::__invoke_r<void, std::_Bind<void (CConnman::*(CConnman*))()>&>(std::_Bind<void (CConnman::*(CConnman*))()>&) (__fn=...)\r\n    at /usr/include/c++/10/bits/invoke.h:110\r\n#9  0x00005555556327d0 in std::_Function_handler<void (), std::_Bind<void (CConnman::*(CConnman*))()> >::_M_invoke(std::_Any_data const&) (__functor=...)\r\n    at /usr/include/c++/10/bits/std_function.h:291\r\n#10 0x00005555555cda5f in std::function<void ()>::operator()() const (this=0x7fff4baf0b20) at /usr/include/c++/10/bits/std_function.h:622\r\n#11 0x00005555555c2aa5 in TraceThread<std::function<void ()> >(char const*, std::function<void ()>) (name=0x555556000af8 \"addcon\", func=...) at ./util/system.h:470\r\n#12 0x0000555555662ea0 in std::__invoke_impl<void, void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> >(std::__invoke_other, void (*&&)(char const*, std::function<void ()>), char const*&&, std::function<void ()>&&) (\r\n    __f=@0x55555ff62670: 0x5555555c2a1b <TraceThread<std::function<void ()> >(char const*, std::function<void ()>)>) at /usr/include/c++/10/bits/invoke.h:60\r\n#13 0x0000555555662d16 in std::__invoke<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> >(void (*&&)(char const*, std::function<void ()>), char const*&&, std::function<void ()>&&) (\r\n    __fn=@0x55555ff62670: 0x5555555c2a1b <TraceThread<std::function<void ()> >(char const*, std::function<void ()>)>) at /usr/include/c++/10/bits/invoke.h:95\r\n#14 0x0000555555662b82 in std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > >::_M_invoke<0ul, 1ul, 2ul>(std::_Index_tuple<0ul, 1ul, 2ul>) (this=0x55555ff62648) at /usr/include/c++/10/thread:264\r\n#15 0x0000555555662af9 in std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > >::operator()() (\r\n    this=0x55555ff62648) at /usr/include/c++/10/thread:271\r\n#16 0x0000555555662ab7 in std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(char const*, std::function<void ()>), char const*, std::function<void ()> > > >::_M_run() (this=0x55555ff62640) at /usr/include/c++/10/thread:215\r\n#17 0x00007ffff7beced0 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6\r\n#18 0x00007ffff7f8aea7 in start_thread (arg=<optimized out>) at pthread_create.c:477\r\n#19 0x00007ffff78f8def in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95\r\n(gdb) \r\n```\r\n</p></details>\r\n",
      "created_at" : "2021-02-15T09:01:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-779070785",
      "id" : 779070785,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3OTA3MDc4NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-15T09:03:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/779070785",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "[a456bd3f2..da2ba3e87](https://github.com/bitcoin/bitcoin/compare/a456bd3f296f18e463e36048c866c404b69363b6..da2ba3e87105a82d573c8873a99d0b11af219c87): don't dereference an unset unique_ptr, thanks @jonatack, @laanwj!",
      "created_at" : "2021-02-15T09:30:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-779089078",
      "id" : 779089078,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3OTA4OTA3OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-15T09:35:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/779089078",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576052607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576052607"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, that is an invalid way to assign a new value to unique_ptr that is not set. :bomb:  Fixed!",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-15T09:32:36Z",
      "diff_hunk" : "@@ -432,10 +424,20 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     bool connected = false;\n     std::unique_ptr<Sock> sock;\n     proxyType proxy;\n+    CAddress addr_bind;\n+    assert(!addr_bind.IsValid());\n+\n     if (addrConnect.IsValid()) {\n         bool proxyConnectionFailed = false;\n \n-        if (GetProxy(addrConnect.GetNetwork(), proxy)) {\n+        if (addrConnect.GetNetwork() == NET_I2P && m_i2p_sam_session.get() != nullptr) {\n+            i2p::Connection conn;\n+            if (m_i2p_sam_session->Connect(addrConnect, conn, proxyConnectionFailed)) {\n+                connected = true;\n+                *sock = std::move(conn.sock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576052607",
      "id" : 576052607,
      "in_reply_to_id" : 575828254,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjA1MjYwNw==",
      "original_commit_id" : "a456bd3f296f18e463e36048c866c404b69363b6",
      "original_line" : 437,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 590299436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576052607",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576056054"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576056054"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Makes sense. Building the new push.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-15T09:37:56Z",
      "diff_hunk" : "@@ -432,10 +424,20 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     bool connected = false;\n     std::unique_ptr<Sock> sock;\n     proxyType proxy;\n+    CAddress addr_bind;\n+    assert(!addr_bind.IsValid());\n+\n     if (addrConnect.IsValid()) {\n         bool proxyConnectionFailed = false;\n \n-        if (GetProxy(addrConnect.GetNetwork(), proxy)) {\n+        if (addrConnect.GetNetwork() == NET_I2P && m_i2p_sam_session.get() != nullptr) {\n+            i2p::Connection conn;\n+            if (m_i2p_sam_session->Connect(addrConnect, conn, proxyConnectionFailed)) {\n+                connected = true;\n+                *sock = std::move(conn.sock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576056054",
      "id" : 576056054,
      "in_reply_to_id" : 575828254,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjA1NjA1NA==",
      "original_commit_id" : "a456bd3f296f18e463e36048c866c404b69363b6",
      "original_line" : 437,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 590303767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576056054",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks -- da2ba3e following the fix is working now. ",
      "created_at" : "2021-02-15T10:14:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-779115834",
      "id" : 779115834,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3OTExNTgzNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-15T10:14:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/779115834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-02-15T15:06:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-779280201",
      "id" : 779280201,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3OTI4MDIwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-15T15:06:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/779280201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "`da2ba3e87...e19bc9938`: rebase due to conflicts",
      "created_at" : "2021-02-15T15:47:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-779305997",
      "id" : 779305997,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3OTMwNTk5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-15T15:47:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/779305997",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576301546"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576301546"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This will need the following change (if not already made but I didn't see it)\r\n```diff\r\n/test/functional/rpc_net.py\r\n@@ -105,7 +105,7 @@ class NetTest(BitcoinTestFramework):\r\n         assert_equal(peer_info[1][1]['connection_type'], 'inbound')\r\n \r\n         # Check dynamically generated networks list in getpeerinfo help output.\r\n-        assert \"(ipv4, ipv6, onion, not_publicly_routable)\" in self.nodes[0].help(\"getpeerinfo\")\r\n+        assert \"(ipv4, ipv6, onion, i2p, not_publicly_routable)\" in self.nodes[0].help(\"getpeerinfo\")\r\n \r\n     def test_getnettotals(self):\r\n         self.log.info(\"Test getnettotals\")\r\n@@ -156,7 +156,7 @@ class NetTest(BitcoinTestFramework):\r\n             assert_net_servicesnames(int(info[\"localservices\"], 0x10), info[\"localservicesnames\"])\r\n \r\n         # Check dynamically generated networks list in getnetworkinfo help output.\r\n-        assert \"(ipv4, ipv6, onion)\" in self.nodes[0].help(\"getnetworkinfo\")\r\n+        assert \"(ipv4, ipv6, onion, i2p)\" in self.nodes[0].help(\"getnetworkinfo\")\r\n \r\n     def test_getaddednodeinfo(self):\r\n```\r\n",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-15T16:17:58Z",
      "diff_hunk" : "@@ -78,7 +78,7 @@ std::vector<std::string> GetNetworkNames(bool append_unroutable)\n     std::vector<std::string> names;\n     for (int n = 0; n < NET_MAX; ++n) {\n         const enum Network network{static_cast<Network>(n)};\n-        if (network == NET_UNROUTABLE || network == NET_I2P || network == NET_CJDNS || network == NET_INTERNAL) continue;\n+        if (network == NET_UNROUTABLE || network == NET_CJDNS || network == NET_INTERNAL) continue;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576301546",
      "id" : 576301546,
      "line" : 81,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjMwMTU0Ng==",
      "original_commit_id" : "433d9a9f1e416c5518f832b4ca9402c8807877bc",
      "original_line" : 81,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 42,
      "pull_request_review_id" : 590613911,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576301546",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576902941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576902941"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed, thanks!",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-16T15:18:04Z",
      "diff_hunk" : "@@ -78,7 +78,7 @@ std::vector<std::string> GetNetworkNames(bool append_unroutable)\n     std::vector<std::string> names;\n     for (int n = 0; n < NET_MAX; ++n) {\n         const enum Network network{static_cast<Network>(n)};\n-        if (network == NET_UNROUTABLE || network == NET_I2P || network == NET_CJDNS || network == NET_INTERNAL) continue;\n+        if (network == NET_UNROUTABLE || network == NET_CJDNS || network == NET_INTERNAL) continue;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r576902941",
      "id" : 576902941,
      "in_reply_to_id" : 576301546,
      "line" : 81,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkwMjk0MQ==",
      "original_commit_id" : "433d9a9f1e416c5518f832b4ca9402c8807877bc",
      "original_line" : 81,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 42,
      "pull_request_review_id" : 591328483,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/576902941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "`433d9a9f1...2a7bb343a`: fix failing `rpc_net.py`",
      "created_at" : "2021-02-16T15:18:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-779904970",
      "id" : 779904970,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc3OTkwNDk3MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-16T15:18:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/779904970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm trying with `i2pd` now on FreeBSD. Not having much luck. I could install it and start it quite easily (much more easily than the Java one):\r\n```\r\n$ pkg install i2pd\r\n# add i2pd_enable=\"YES\"  and optionally i2pd_flags=\"--bandwidth X\"\r\n$ vi /etc/rc.conf\r\n$ service i2pd start\r\n$ i2pd --version\r\ni2pd version 2.33.0 (0.9.47)\r\n```\r\nThat's it. SAM is enabled on port `7656`.\r\n\r\n**Edit:** below issue is fixed\r\n\r\n---------------------\r\n\r\nHowever, it doesn't seem to succesfully start the I2P listener. It looks like it hangs after sending the session create, doesn't get a reply.\r\n```\r\n2021-02-17T07:52:35Z I2P: Creating SAM session with 127.0.0.1:7656\r\nâ®\r\n2021-02-17T07:55:35Z I2P: Error listening: Receive timeout (received 0 bytes without terminator before that)\r\n2021-02-17T07:55:35Z I2P: Control socket error: not connected\r\n```\r\n\r\nOn the `i2pd` side:\r\n```\r\n08:55:36@682/error - NetDb: runtime exception: No known routers, reseed seems to be totally failed\r\n08:55:36@270/debug - SAM: new connection from 127.0.0.1:14315\r\n08:55:36@270/debug - SAM: handshake HELLO VERSION MIN=3.1 MAX=3.1\r\n08:55:36@270/debug - SAM: session create: STYLE=STREAM ID=b66590c3b4 DESTINATION=[snip]\r\n08:55:36@270/warn - Clients: Local destination [snip].b32.i2p exists\r\n08:55:37@7/warn - Tunnel: can't find any router, skip creating tunnel\r\n08:55:37@7/debug - Tunnels: Creating destination outbound tunnel...\r\nâ®\r\n09:00:07@7/error - Tunnels: Can't create inbound tunnel, no peers available\r\n09:00:07@7/debug - Tunnels: Creating destination inbound tunnel...\r\n09:00:07@7/error - Tunnels: Can't select next hop for G[snip]=\r\n09:00:07@7/error - Tunnels: Can't create inbound tunnel, no peers available\r\n```\r\n\r\nThe latter part keeps repeating and repeating. It looks like a problem on the `i2pd` side not the `bitcoind` one. I have no networking issues, IPv4 and IPv6 and Tor works on the host. Anyone with ideas?\r\n",
      "created_at" : "2021-02-17T08:02:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-780378548",
      "id" : 780378548,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MDM3ODU0OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-17T09:55:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/780378548",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "If this is the issue Suhas encountered, upgrade to i2pd v2.35ï¿¼ï¿¼ (latest release, build from source or on Debian it's in the testing sources).",
      "created_at" : "2021-02-17T09:03:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-780409790",
      "id" : 780409790,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MDQwOTc5MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-17T09:03:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/780409790",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I don't think it's the same issue. He had a much older version (2.23 instead of 2.33), which had problems handling the commands from `bitcoind`. My i2pd seems completely broken, it doesn't get any peer connections.\r\n\r\nThe whole \"runtime exception: No known routers, reseed seems to be totally failed\" message gives only one result on Google, some Russian github thread. Argh.\r\n\r\n**Edit:** oh, it could have been something with clock skew. After running `ntpdate europe.pool.ntp.org`  and restarting the service it seems to be doing more!\r\n```\r\n10:14:29@122/error - SSU: clock skew detected 4294967197. Check your clock\r\n```\r\n**Edit.2** yes, that fixed it!:\r\n```\r\n2021-02-17T09:21:44Z I2P: SAM session created: session id=be83961cec, my address=[snip].b32.i2p:8333\r\n2021-02-17T09:21:44Z AddLocal([snip].b32.i2p:8333,2)\r\n```",
      "created_at" : "2021-02-17T09:07:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-780412089",
      "id" : 780412089,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MDQxMjA4OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-17T09:22:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/780412089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code review and extensively manually tested ACK 2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6\r\n\r\nI think it would be nice to have unit tests for the `Reply` parsing in `i2p.cpp` and maybe the alt-Base64 parsing, however this can be done in a later PR (and doesn't need to hold up progress here). Maybe someone will even look into fuzzing.",
      "created_at" : "2021-02-22T08:45:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-783202637",
      "id" : 783202637,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MzIwMjYzNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-22T08:45:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/783202637",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Update, about halfway through reviewing the commits. Each builds cleanly and no comments so far.\r\n\r\nI've been testing this these past weeks using i2pd 2.35. Apparently, i2pd 2.36 was released last week and I plan to test with it.\r\n\r\nThe only oddity I've been seeing from the first day of testing until now is inbound I2P peers can regularly have two connections, present for a few minutes. I haven't looked further into it yet. Here are two screenshots taken on February 14 and 20:\r\n\r\n![Screenshot from 2021-02-14 01-33-45](https://user-images.githubusercontent.com/2415484/109143667-31b98000-7758-11eb-8fb7-e9eea1a727a2.png)\r\n\r\n\r\n![Screenshot from 2021-02-20 11-37-26](https://user-images.githubusercontent.com/2415484/109143660-3120e980-7758-11eb-8f73-0936a2483b32.png)\r\n",
      "created_at" : "2021-02-25T11:02:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-785811984",
      "id" : 785811984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NTgxMTk4NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-25T11:02:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/785811984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "1. Unable to build for Windows using instructions mentioned in this doc: https://github.com/bitcoin/bitcoin/blob/master/doc/build-windows.md (It worked for other pull request recently)\r\n\r\n<pre>\r\n  CXXLD    bitcoind.exe\r\n  CXXLD    bitcoin-wallet.exe\r\n  CXXLD    test/test_bitcoin.exe\r\n  CXXLD    bench/bench_bitcoin.exe\r\n  CXXLD    test/fuzz/fuzz.exe\r\n  AR       qt/libbitcoinqt.a\r\n/usr/bin/x86_64-w64-mingw32-ld: /usr/lib/gcc/x86_64-w64-mingw32/9.3-posix/../../../../x86_64-w64-mingw32/lib/libmingw32.a(lib64_libmingw32_a-crt0_c.o): in function `main':\r\n./build/x86_64-w64-mingw32-x86_64-w64-mingw32-crt/./mingw-w64-crt/crt/crt0_c.c:18: undefined reference to `WinMain'\r\ncollect2: error: ld returned 1 exit status\r\nmake[2]: *** [Makefile:5863: test/fuzz/fuzz.exe] Error 1\r\nmake[2]: *** Waiting for unfinished jobs....\r\nmake[2]: Leaving directory '/home/rebel/bitcoin/src'\r\nmake[1]: *** [Makefile:15177: all-recursive] Error 1\r\nmake[1]: Leaving directory '/home/rebel/bitcoin/src'\r\nmake: *** [Makefile:809: all-recursive] Error 1\r\n</pre>\r\n\r\n2. Compiled successfully on Ubuntu 20.04.2 LTS. Tests passed. \r\n\r\nInstalled i2p with the instructions mentioned here: https://geti2p.net/en/download/debian followed by `i2prouter start`\r\n\r\n`bitcoin.conf` file:\r\n\r\n<pre>\r\ntestnet=1\r\nprune=555\r\ni2psam=127.0.0.1:7658\r\ni2pacceptincoming=1\r\n</pre>\r\n\r\nDon't see any `i2p_private_key` file created in _.bitcoin/testnet3_\r\n\r\nLogs:\r\n\r\n<pre>\r\n2021-02-25T20:12:16Z i2paccept thread start\r\n2021-02-25T20:12:16Z msghand thread start\r\n2021-02-25T20:12:16Z opencon thread start\r\n2021-02-25T20:12:16Z dnsseed thread start\r\n2021-02-25T20:12:16Z Waiting 300 seconds before querying DNS seeds.\r\n2021-02-25T20:12:16Z addcon thread start\r\n2021-02-25T20:12:16Z GUI: Platform customization: \"other\"\r\n2021-02-25T20:12:16Z tor: Got service ID omy7kj7zwvfg5luayideh73uqb2latkoyyy5h65y4atv3fymnlxlzwqd, advertising service omy7kj7zwvfg5luayideh73uqb2latkoyyy5h65y4atv3fymnlxlzwqd.onion:18333\r\n2021-02-25T20:12:16Z AddLocal(omy7kj7zwvfg5luayideh73uqb2latkoyyy5h65y4atv3fymnlxlzwqd.onion:18333,4)\r\n2021-02-25T20:12:17Z New outbound peer connected: version: 70015, blocks=1937809, peer=0 (block-relay-only)\r\n2021-02-25T20:12:18Z New outbound peer connected: version: 70015, blocks=1937809, peer=1 (block-relay-only)\r\n2021-02-25T20:12:18Z Synchronizing blockheaders, height: 1937809 (~100.00%)\r\n</pre>\r\n\r\n",
      "created_at" : "2021-02-25T20:15:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-786172893",
      "id" : 786172893,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NjE3Mjg5Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-25T20:15:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/786172893",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/13405205?v=4",
         "events_url" : "https://api.github.com/users/prayank23/events{/privacy}",
         "followers_url" : "https://api.github.com/users/prayank23/followers",
         "following_url" : "https://api.github.com/users/prayank23/following{/other_user}",
         "gists_url" : "https://api.github.com/users/prayank23/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/prayank23",
         "id" : 13405205,
         "login" : "prayank23",
         "node_id" : "MDQ6VXNlcjEzNDA1MjA1",
         "organizations_url" : "https://api.github.com/users/prayank23/orgs",
         "received_events_url" : "https://api.github.com/users/prayank23/received_events",
         "repos_url" : "https://api.github.com/users/prayank23/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/prayank23/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/prayank23"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@prayank23  Strange. Adding `debug=i2p` to your config might give some more information in the log as to why it's not working.\r\n\r\nThe windows linker issue seems unrelated (you could create a new issue for it if you want).",
      "created_at" : "2021-02-25T20:26:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-786181506",
      "id" : 786181506,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NjE4MTUwNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-25T20:26:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/786181506",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<pre>\r\n2021-02-25T21:25:14Z i2paccept thread start\r\n2021-02-25T21:25:14Z I2P: Creating SAM session with 127.0.0.1:7658\r\n2021-02-25T21:25:14Z net thread start\r\n2021-02-25T21:25:14Z GUI: Platform customization: \"other\"\r\n2021-02-25T21:25:15Z I2P: Error listening: Missing RESULT= in the reply to 'HELLO VERSION MIN=3.1 MAX=3.1': 'HTTP/1.1 400 Illegal character SPACE=' '\\x0d'\r\n2021-02-25T21:25:15Z I2P: Control socket error: not connected\r\n</pre>",
      "created_at" : "2021-02-25T21:29:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-786240512",
      "id" : 786240512,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NjI0MDUxMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-25T21:29:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/786240512",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/13405205?v=4",
         "events_url" : "https://api.github.com/users/prayank23/events{/privacy}",
         "followers_url" : "https://api.github.com/users/prayank23/followers",
         "following_url" : "https://api.github.com/users/prayank23/following{/other_user}",
         "gists_url" : "https://api.github.com/users/prayank23/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/prayank23",
         "id" : 13405205,
         "login" : "prayank23",
         "node_id" : "MDQ6VXNlcjEzNDA1MjA1",
         "organizations_url" : "https://api.github.com/users/prayank23/orgs",
         "received_events_url" : "https://api.github.com/users/prayank23/received_events",
         "repos_url" : "https://api.github.com/users/prayank23/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/prayank23/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/prayank23"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It doesn't look like it's a SAM proxy you're connecting to, but a HTTP proxy (it's clearly speaking HTTP). From what I remember the Java I2P router doesn't start a SAM service by default and you need to add it.",
      "created_at" : "2021-02-25T21:39:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-786245631",
      "id" : 786245631,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NjI0NTYzMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-25T21:39:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/786245631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Unable to build for Windows\r\n\r\nThe Windows linking issue has been fixed in master in #21226. This PR just needs rebasing.",
      "created_at" : "2021-02-26T02:00:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-786356515",
      "id" : 786356515,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NjM1NjUxNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-26T02:00:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/786356515",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jonatack, next time you observe two incoming connections from the same peer, try to capture the output of `bitcoin-cli getpeerinfo |jq 'map(select(.network == \"i2p\")) |map({inbound: .inbound, addr: .addr, addrbind: .addrbind})'`. I suspect it has something to do with the ports.\r\n\r\n@prayank23, the SAM proxy is usually listening on port `7656`. Surely it can be changed to anything, but I guess you did not change it and your config `i2psam=127.0.0.1:7658` is pointing to the HTTP proxy, as @laanwj mentioned.",
      "created_at" : "2021-02-26T16:32:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-786753429",
      "id" : 786753429,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4Njc1MzQyOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-26T16:32:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/786753429",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@prayank23 yes, fwiw I'm building and reviewing the PR after rebasing to current master (let it run last night building and testing each commit and they are all clean/green), as mentioned above, if you do that it should(:tm:) build on Windows.\r\n\r\n@vasild sure np. Should finish reviewing the current branch today.",
      "created_at" : "2021-02-26T17:06:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-786773001",
      "id" : 786773001,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4Njc3MzAwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-26T17:06:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/786773001",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583817273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583817273"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2ee63a5 For the six `SetSpecial`, `SetTor` and `SetI2P` declarations and definitions, I think it would be clearer to use the same param name. It's currently sometimes `name` and sometimes `str` and different between the declarations and the definitions for `SetTor` and `SetI2P`.  (I'd propose `const std::string& addr` for all six.) ",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T17:56:31Z",
      "diff_hunk" : "@@ -151,7 +151,16 @@ class CNetAddr\n \n         bool SetInternal(const std::string& name);\n \n-        bool SetSpecial(const std::string &strName); // for Tor addresses\n+        /**\n+         * Parse a Tor or I2P address and set this object to it.\n+         * @param[in] name Address to parse, for example",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583817273",
      "id" : 583817273,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzgxNzI3Mw==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 156,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/netaddress.h",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583817273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583883970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583883970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "45cfaf0d296b6b6f9d4c86d4ec1b4c4392947b36 here and also line 248, maybe use a different name for the  `timeout` local variable (maybe `wait_time` or `wait_timeout`) than the `timeout` input param",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T19:57:36Z",
      "diff_hunk" : "@@ -93,10 +114,167 @@ bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n \n     timeval timeout_struct = MillisToTimeval(timeout);\n \n-    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+    if (select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) == SOCKET_ERROR) {\n+        return false;\n+    }\n+\n+    if (occurred != nullptr) {\n+        *occurred = 0;\n+        if (FD_ISSET(m_socket, &fdset_recv)) {\n+            *occurred |= RECV;\n+        }\n+        if (FD_ISSET(m_socket, &fdset_send)) {\n+            *occurred |= SEND;\n+        }\n+    }\n+\n+    return true;\n #endif /* USE_POLL */\n }\n \n+void Sock::SendComplete(const std::string& data,\n+                        std::chrono::milliseconds timeout,\n+                        CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = Send(data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        const auto timeout = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583883970",
      "id" : 583883970,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzg4Mzk3MA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 171,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/util/sock.cpp",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583883970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583885090"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583885090"
         }
      },
      "author_association" : "MEMBER",
      "body" : "45cfaf0\r\n```suggestion\r\n    // as many bytes as possible without crossing the terminator.\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T19:59:45Z",
      "diff_hunk" : "@@ -93,10 +114,167 @@ bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n \n     timeval timeout_struct = MillisToTimeval(timeout);\n \n-    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+    if (select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) == SOCKET_ERROR) {\n+        return false;\n+    }\n+\n+    if (occurred != nullptr) {\n+        *occurred = 0;\n+        if (FD_ISSET(m_socket, &fdset_recv)) {\n+            *occurred |= RECV;\n+        }\n+        if (FD_ISSET(m_socket, &fdset_send)) {\n+            *occurred |= SEND;\n+        }\n+    }\n+\n+    return true;\n #endif /* USE_POLL */\n }\n \n+void Sock::SendComplete(const std::string& data,\n+                        std::chrono::milliseconds timeout,\n+                        CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = Send(data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        const auto timeout = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});\n+        Wait(timeout, SEND);\n+    }\n+}\n+\n+std::string Sock::RecvUntilTerminator(uint8_t terminator,\n+                                      std::chrono::milliseconds timeout,\n+                                      CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583885090",
      "id" : 583885090,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzg4NTA5MA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 187,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/util/sock.cpp",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583885090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583893589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583893589"
         }
      },
      "author_association" : "MEMBER",
      "body" : "45cfaf0d296b6b6f9d4c86d4ec1b4c4392947b36 maybe make explicit that this is narrowing from long to unsigned long (size_t)\r\n```suggestion\r\n            const size_t append_len{static_cast<size_t>(terminator_found ? read_ret - 1 : read_ret)};\r\n```\r\n\r\n(In general, in these two added functions `Sock::SendComplete()` and `Sock::RecvUntilTerminator()`, I would personally find it more clear and reassuring if uniform initialization with explicit typing was used.)",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T20:17:01Z",
      "diff_hunk" : "@@ -93,10 +114,167 @@ bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n \n     timeval timeout_struct = MillisToTimeval(timeout);\n \n-    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+    if (select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) == SOCKET_ERROR) {\n+        return false;\n+    }\n+\n+    if (occurred != nullptr) {\n+        *occurred = 0;\n+        if (FD_ISSET(m_socket, &fdset_recv)) {\n+            *occurred |= RECV;\n+        }\n+        if (FD_ISSET(m_socket, &fdset_send)) {\n+            *occurred |= SEND;\n+        }\n+    }\n+\n+    return true;\n #endif /* USE_POLL */\n }\n \n+void Sock::SendComplete(const std::string& data,\n+                        std::chrono::milliseconds timeout,\n+                        CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = Send(data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        const auto timeout = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});\n+        Wait(timeout, SEND);\n+    }\n+}\n+\n+std::string Sock::RecvUntilTerminator(uint8_t terminator,\n+                                      std::chrono::milliseconds timeout,\n+                                      CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = Recv(buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = Recv(buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583893589",
      "id" : 583893589,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzg5MzU4OQ==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 225,
      "original_position" : 172,
      "original_start_line" : null,
      "path" : "src/util/sock.cpp",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583893589",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583917118"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583917118"
         }
      },
      "author_association" : "MEMBER",
      "body" : "6da5c7eb32b51ab89f27a84e6c5e33db0e8e3e6e\r\n```suggestion\r\n     * Open a new connection to the SAM proxy and issue \"STREAM ACCEPT\" request using the existing\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T21:05:16Z",
      "diff_hunk" : "@@ -0,0 +1,260 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_I2P_H\n+#define BITCOIN_I2P_H\n+\n+#include <compat.h>\n+#include <fs.h>\n+#include <netaddress.h>\n+#include <sync.h>\n+#include <threadinterrupt.h>\n+#include <util/sock.h>\n+\n+#include <optional>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+namespace i2p {\n+\n+/**\n+ * Binary data.\n+ */\n+using Binary = std::vector<uint8_t>;\n+\n+/**\n+ * An established connection with another peer.\n+ */\n+struct Connection {\n+    /** Connected socket. */\n+    Sock sock;\n+\n+    /** Our I2P address. */\n+    CService me;\n+\n+    /** The peer's I2P address. */\n+    CService peer;\n+};\n+\n+namespace sam {\n+\n+/**\n+ * I2P SAM session.\n+ */\n+class Session\n+{\n+public:\n+    /**\n+     * Construct a session. This will not initiate any IO, the session will be lazily created\n+     * later when first used.\n+     * @param[in] private_key_file Path to a private key file. If the file does not exist then the\n+     * private key will be generated and saved into the file.\n+     * @param[in] control_host Location of the SAM proxy.\n+     * @param[in,out] interrupt If this is signaled then all operations are canceled as soon as\n+     * possible and executing methods throw an exception. Notice: only a pointer to the\n+     * `CThreadInterrupt` object is saved, so it must not be destroyed earlier than this\n+     * `Session` object.\n+     */\n+    Session(const fs::path& private_key_file,\n+            const CService& control_host,\n+            CThreadInterrupt* interrupt);\n+\n+    /**\n+     * Destroy the session, closing the internally used sockets. The sockets that have been\n+     * returned by `Accept()` or `Connect()` will not be closed, but they will be closed by\n+     * the SAM proxy because the session is destroyed. So they will return an error next time\n+     * we try to read or write to them.\n+     */\n+    ~Session();\n+\n+    /**\n+     * Start listening for an incoming connection.\n+     * @param[out] conn Upon successful completion the `sock` and `me` members will be set\n+     * to the listening socket and address.\n+     * @return true on success\n+     */\n+    bool Listen(Connection& conn);\n+\n+    /**\n+     * Wait for and accept a new incoming connection.\n+     * @param[in,out] conn The `sock` member is used for waiting and accepting. Upon successful\n+     * completion the `peer` member will be set to the address of the incoming peer.\n+     * @return true on success\n+     */\n+    bool Accept(Connection& conn);\n+\n+    /**\n+     * Connect to an I2P peer.\n+     * @param[in] to Peer to connect to.\n+     * @param[out] conn Established connection. Only set if `true` is returned.\n+     * @param[out] proxy_error If an error occurs due to proxy or general network failure, then\n+     * this is set to `true`. If an error occurs due to unreachable peer (likely peer is down), then\n+     * it is set to `false`. Only set if `false` is returned.\n+     * @return true on success\n+     */\n+    bool Connect(const CService& to, Connection& conn, bool& proxy_error);\n+\n+private:\n+    /**\n+     * A reply from the SAM proxy.\n+     */\n+    struct Reply {\n+        /**\n+         * Full, unparsed reply.\n+         */\n+        std::string full;\n+\n+        /**\n+         * Request, used for detailed error reporting.\n+         */\n+        std::string request;\n+\n+        /**\n+         * A map of keywords from the parsed reply.\n+         * For example, if the reply is \"A=X B C=YZ\", then the map will be\n+         * keys[\"A\"] == \"X\"\n+         * keys[\"B\"] == (empty std::optional)\n+         * keys[\"C\"] == \"YZ\"\n+         */\n+        std::unordered_map<std::string, std::optional<std::string>> keys;\n+\n+        /**\n+         * Get the value of a given key.\n+         * For example if the reply is \"A=X B\" then:\n+         * Value(\"A\") -> \"X\"\n+         * Value(\"B\") -> throws\n+         * Value(\"C\") -> throws\n+         * @param[in] key Key whose value to retrieve\n+         * @returns the key's value\n+         * @throws std::runtime_error if the key is not present or if it has no value\n+         */\n+        std::string Get(const std::string& key) const;\n+    };\n+\n+    /**\n+     * Log a message in the `BCLog::I2P` category.\n+     * @param[in] fmt printf(3)-like format string.\n+     * @param[in] args printf(3)-like arguments that correspond to `fmt`.\n+     */\n+    template <typename... Args>\n+    void Log(const std::string& fmt, const Args&... args) const;\n+\n+    /**\n+     * Send request and get a reply from the SAM proxy.\n+     * @param[in] sock A socket that is connected to the SAM proxy.\n+     * @param[in] request Raw request to send, a newline terminator is appended to it.\n+     * @param[in] check_result_ok If true then after receiving the reply a check is made\n+     * whether it contains \"RESULT=OK\" and an exception is thrown if it does not.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Reply SendRequestAndGetReply(const Sock& sock,\n+                                 const std::string& request,\n+                                 bool check_result_ok = true) const;\n+\n+    /**\n+     * Open a new connection to the SAM proxy.\n+     * @return a connected socket\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Sock Hello() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Check the control socket for errors and possibly disconnect.\n+     */\n+    void CheckControlSock();\n+\n+    /**\n+     * Generate a new destination with the SAM proxy and set `m_private_key` to it.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void DestGenerate(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Generate a new destination with the SAM proxy, set `m_private_key` to it and save\n+     * it on disk to `m_private_key_file`.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void GenerateAndSavePrivateKey(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Derive own destination from `m_private_key`.\n+     * @see https://geti2p.net/spec/common-structures#destination\n+     * @return an I2P destination\n+     */\n+    Binary MyDestination() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Create the session if not already created. Reads the private key file and connects to the\n+     * SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void CreateIfNotCreatedAlready() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Open a new connection to the SAM proxy and issue \"STREAM ACCEPT\" request using the existent",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583917118",
      "id" : 583917118,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzkxNzExOA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/i2p.h",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583917118",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583919626"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583919626"
         }
      },
      "author_association" : "MEMBER",
      "body" : "6da5c7e A peer = a node that is not us. If `m_my_addr` is for our own address only, maybe `s/this peer/our node/` or `* Our .b32.i2p address.`",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T21:10:26Z",
      "diff_hunk" : "@@ -0,0 +1,260 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_I2P_H\n+#define BITCOIN_I2P_H\n+\n+#include <compat.h>\n+#include <fs.h>\n+#include <netaddress.h>\n+#include <sync.h>\n+#include <threadinterrupt.h>\n+#include <util/sock.h>\n+\n+#include <optional>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+namespace i2p {\n+\n+/**\n+ * Binary data.\n+ */\n+using Binary = std::vector<uint8_t>;\n+\n+/**\n+ * An established connection with another peer.\n+ */\n+struct Connection {\n+    /** Connected socket. */\n+    Sock sock;\n+\n+    /** Our I2P address. */\n+    CService me;\n+\n+    /** The peer's I2P address. */\n+    CService peer;\n+};\n+\n+namespace sam {\n+\n+/**\n+ * I2P SAM session.\n+ */\n+class Session\n+{\n+public:\n+    /**\n+     * Construct a session. This will not initiate any IO, the session will be lazily created\n+     * later when first used.\n+     * @param[in] private_key_file Path to a private key file. If the file does not exist then the\n+     * private key will be generated and saved into the file.\n+     * @param[in] control_host Location of the SAM proxy.\n+     * @param[in,out] interrupt If this is signaled then all operations are canceled as soon as\n+     * possible and executing methods throw an exception. Notice: only a pointer to the\n+     * `CThreadInterrupt` object is saved, so it must not be destroyed earlier than this\n+     * `Session` object.\n+     */\n+    Session(const fs::path& private_key_file,\n+            const CService& control_host,\n+            CThreadInterrupt* interrupt);\n+\n+    /**\n+     * Destroy the session, closing the internally used sockets. The sockets that have been\n+     * returned by `Accept()` or `Connect()` will not be closed, but they will be closed by\n+     * the SAM proxy because the session is destroyed. So they will return an error next time\n+     * we try to read or write to them.\n+     */\n+    ~Session();\n+\n+    /**\n+     * Start listening for an incoming connection.\n+     * @param[out] conn Upon successful completion the `sock` and `me` members will be set\n+     * to the listening socket and address.\n+     * @return true on success\n+     */\n+    bool Listen(Connection& conn);\n+\n+    /**\n+     * Wait for and accept a new incoming connection.\n+     * @param[in,out] conn The `sock` member is used for waiting and accepting. Upon successful\n+     * completion the `peer` member will be set to the address of the incoming peer.\n+     * @return true on success\n+     */\n+    bool Accept(Connection& conn);\n+\n+    /**\n+     * Connect to an I2P peer.\n+     * @param[in] to Peer to connect to.\n+     * @param[out] conn Established connection. Only set if `true` is returned.\n+     * @param[out] proxy_error If an error occurs due to proxy or general network failure, then\n+     * this is set to `true`. If an error occurs due to unreachable peer (likely peer is down), then\n+     * it is set to `false`. Only set if `false` is returned.\n+     * @return true on success\n+     */\n+    bool Connect(const CService& to, Connection& conn, bool& proxy_error);\n+\n+private:\n+    /**\n+     * A reply from the SAM proxy.\n+     */\n+    struct Reply {\n+        /**\n+         * Full, unparsed reply.\n+         */\n+        std::string full;\n+\n+        /**\n+         * Request, used for detailed error reporting.\n+         */\n+        std::string request;\n+\n+        /**\n+         * A map of keywords from the parsed reply.\n+         * For example, if the reply is \"A=X B C=YZ\", then the map will be\n+         * keys[\"A\"] == \"X\"\n+         * keys[\"B\"] == (empty std::optional)\n+         * keys[\"C\"] == \"YZ\"\n+         */\n+        std::unordered_map<std::string, std::optional<std::string>> keys;\n+\n+        /**\n+         * Get the value of a given key.\n+         * For example if the reply is \"A=X B\" then:\n+         * Value(\"A\") -> \"X\"\n+         * Value(\"B\") -> throws\n+         * Value(\"C\") -> throws\n+         * @param[in] key Key whose value to retrieve\n+         * @returns the key's value\n+         * @throws std::runtime_error if the key is not present or if it has no value\n+         */\n+        std::string Get(const std::string& key) const;\n+    };\n+\n+    /**\n+     * Log a message in the `BCLog::I2P` category.\n+     * @param[in] fmt printf(3)-like format string.\n+     * @param[in] args printf(3)-like arguments that correspond to `fmt`.\n+     */\n+    template <typename... Args>\n+    void Log(const std::string& fmt, const Args&... args) const;\n+\n+    /**\n+     * Send request and get a reply from the SAM proxy.\n+     * @param[in] sock A socket that is connected to the SAM proxy.\n+     * @param[in] request Raw request to send, a newline terminator is appended to it.\n+     * @param[in] check_result_ok If true then after receiving the reply a check is made\n+     * whether it contains \"RESULT=OK\" and an exception is thrown if it does not.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Reply SendRequestAndGetReply(const Sock& sock,\n+                                 const std::string& request,\n+                                 bool check_result_ok = true) const;\n+\n+    /**\n+     * Open a new connection to the SAM proxy.\n+     * @return a connected socket\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Sock Hello() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Check the control socket for errors and possibly disconnect.\n+     */\n+    void CheckControlSock();\n+\n+    /**\n+     * Generate a new destination with the SAM proxy and set `m_private_key` to it.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void DestGenerate(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Generate a new destination with the SAM proxy, set `m_private_key` to it and save\n+     * it on disk to `m_private_key_file`.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void GenerateAndSavePrivateKey(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Derive own destination from `m_private_key`.\n+     * @see https://geti2p.net/spec/common-structures#destination\n+     * @return an I2P destination\n+     */\n+    Binary MyDestination() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Create the session if not already created. Reads the private key file and connects to the\n+     * SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void CreateIfNotCreatedAlready() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Open a new connection to the SAM proxy and issue \"STREAM ACCEPT\" request using the existent\n+     * session id. Return the idle socket that is waiting for a peer to connect to us.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Sock StreamAccept() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Destroy the session, closing the internally used sockets.\n+     */\n+    void Disconnect() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * The name of the file where this peer's private key is stored (in binary).\n+     */\n+    const fs::path m_private_key_file;\n+\n+    /**\n+     * The host and port of the SAM control service.\n+     */\n+    const CService m_control_host;\n+\n+    /**\n+     * Cease network activity when this is signaled.\n+     */\n+    CThreadInterrupt* const m_interrupt;\n+\n+    /**\n+     * Mutex protecting the members that can be concurrently accessed.\n+     */\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * The private key of this peer.\n+     * @see The reply to the \"DEST GENERATE\" command in https://geti2p.net/en/docs/api/samv3\n+     */\n+    Binary m_private_key GUARDED_BY(m_mutex);\n+\n+    /**\n+     * SAM control socket.\n+     * Used to connect to the I2P SAM service and create a session\n+     * (\"SESSION CREATE\"). With the established session id we later open\n+     * other connections to the SAM service to accept incoming I2P\n+     * connections and make outgoing ones.\n+     * See https://geti2p.net/en/docs/api/samv3\n+     */\n+    Sock m_control_sock GUARDED_BY(m_mutex);\n+\n+    /**\n+     * The .b32.i2p address of this peer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583919626",
      "id" : 583919626,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzkxOTYyNg==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 246,
      "original_position" : 246,
      "original_start_line" : null,
      "path" : "src/i2p.h",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583919626",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583953158"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583953158"
         }
      },
      "author_association" : "MEMBER",
      "body" : "300a654feb8cc68fc12bc8baff0f69ef031bd51f s/Notice/Note/ (or just omit \"Notice that\")\r\n\r\n```suggestion\r\n    argsman.AddArg(\"-i2pacceptincoming\", \"If set and -i2psam is also set then incoming I2P connections are accepted via the SAM proxy. If this is not set but -i2psam is set then only outgoing connections will be made to the I2P network. Ignored if -i2psam is not set. Listening for incoming I2P connections is done through the SAM proxy, not by binding to a local address and port (default: 1)\", ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T22:19:12Z",
      "diff_hunk" : "@@ -446,7 +446,9 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-maxtimeadjustment\", strprintf(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\", DEFAULT_MAX_TIME_ADJUSTMENT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-maxuploadtarget=<n>\", strprintf(\"Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: %d)\", DEFAULT_MAX_UPLOAD_TARGET), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-onion=<ip:port>\", \"Use separate SOCKS5 proxy to reach peers via Tor onion services, set -noonion to disable (default: -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-    argsman.AddArg(\"-onlynet=<net>\", \"Make outgoing connections only through network <net> (\" + Join(GetNetworkNames(), \", \") + \"). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks. Warning: if it is used with ipv4 or ipv6 but not onion and the -onion or -proxy option is set, then outbound onion connections will still be made; use -noonion or -onion=0 to disable outbound onion connections in this case.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2psam=<ip:port>\", \"I2P SAM proxy to reach I2P peers and accept I2P connections (default: none)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2pacceptincoming\", \"If set and -i2psam is also set then incoming I2P connections are accepted via the SAM proxy. If this is not set but -i2psam is set then only outgoing connections will be made to the I2P network. Ignored if -i2psam is not set. Notice that listening for incoming I2P connections is done through the SAM proxy, not by binding to a local address and port (default: 1)\", ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583953158",
      "id" : 583953158,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk1MzE1OA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 451,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583953158",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583955143"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583955143"
         }
      },
      "author_association" : "MEMBER",
      "body" : "300a654feb8cc68fc12bc8baff0f69ef031bd51f\r\n```suggestion\r\n    if (!i2psam_arg.empty()) {\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-26T22:21:19Z",
      "diff_hunk" : "@@ -1986,6 +1991,21 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n             connOptions.m_specified_outgoing = connect;\n         }\n     }\n+\n+    const std::string& i2psam_arg = args.GetArg(\"-i2psam\", \"\");\n+    if (i2psam_arg != \"\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583955143",
      "id" : 583955143,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk1NTE0Mw==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 2000,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/583955143",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584177133"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584177133"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    m_my_addr = CService{DestBinToAddr(MyDestination()), static_cast<uint16_t>(Params().GetDefaultPort())};\r\n```",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-27T19:16:11Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584177133",
      "id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDE3NzEzMw==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 599729825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584177133",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@laanwj \r\n\r\n> I think it would be nice to have unit tests for the `Reply` parsing in `i2p.cpp` and maybe the alt-Base64 parsing, however this can be done in a later PR (and doesn't need to hold up progress here). Maybe someone will even look into fuzzing.\r\n\r\nAgreed! I plan to add a fuzzing harness for the I2P `Reply` parsing code (unless @vasild plans to do it as part of this PR of course :)).\r\n\r\nShameless plug: a fuzzing harness for the Tor controller reply parsing code was submitted in June last year in the still open PR #19288. Review welcome! :)\r\n",
      "created_at" : "2021-02-28T19:53:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-787511568",
      "id" : 787511568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NzUxMTU2OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-28T19:53:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/787511568",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584369558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584369558"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why?",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-28T22:13:40Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584369558",
      "id" : 584369558,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDM2OTU1OA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600311645,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584369558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Finally `i2p_private_key` created :)\r\n\r\n![image](https://user-images.githubusercontent.com/13405205/109435256-99fdaf80-7a3f-11eb-8757-d613372dab12.png)\r\n\r\nIt was port: 7656 and I had to use `i2pd` instead of `i2prouter`. Thanks for the help @laanwj @vasild \r\n\r\n@jonatack @fanquake Thanks. Will try to build for Windows. I think we will also need a `i2p.md` file in docs for everyone to setup i2p service for Bitcoin Core.\r\n",
      "created_at" : "2021-02-28T22:14:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-787533008",
      "id" : 787533008,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NzUzMzAwOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-28T22:14:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/787533008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/13405205?v=4",
         "events_url" : "https://api.github.com/users/prayank23/events{/privacy}",
         "followers_url" : "https://api.github.com/users/prayank23/followers",
         "following_url" : "https://api.github.com/users/prayank23/following{/other_user}",
         "gists_url" : "https://api.github.com/users/prayank23/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/prayank23",
         "id" : 13405205,
         "login" : "prayank23",
         "node_id" : "MDQ6VXNlcjEzNDA1MjA1",
         "organizations_url" : "https://api.github.com/users/prayank23/orgs",
         "received_events_url" : "https://api.github.com/users/prayank23/received_events",
         "repos_url" : "https://api.github.com/users/prayank23/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/prayank23/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/prayank23"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I think we will also need a `i2p.md` file in docs for everyone to setup i2p service for Bitcoin Core.\n\n@prayank23 yes, discussed above at https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-777455470\n",
      "created_at" : "2021-02-28T22:27:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-787535879",
      "id" : 787535879,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NzUzNTg3OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-28T22:27:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/787535879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584371944"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584371944"
         }
      },
      "author_association" : "MEMBER",
      "body" : "To be explicit about the narrowing conversion, same as https://github.com/bitcoin/bitcoin/pull/20685#discussion_r583893589 above",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-28T22:31:36Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584371944",
      "id" : 584371944,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDM3MTk0NA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600313446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584371944",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584372575"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584372575"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Being explicit with a static_cast has no benefits I'm aware of, just would silence warnings in cases where the warning is warranted...?",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-02-28T22:36:48Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584372575",
      "id" : 584372575,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDM3MjU3NQ==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600314007,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584372575",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I would recommend against extending the scope of this PR.\r\nLet's make sure that this change is correct, address remaining comments, and then merge it. It's useful to have this on the branch so that other people can work on it.\r\nDocumentation and additional testing can be added in a later PR.",
      "created_at" : "2021-03-01T10:59:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-787858109",
      "id" : 787858109,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4Nzg1ODEwOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-01T10:59:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/787858109",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584631345"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584631345"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@luke-jr I think it's the opposite, brace (uniform) initialization raises compile time warnings, e.g. for narrowing and conversions, and named casts provide compile time checks as well.\r\n\r\n- https://google.github.io/styleguide/cppguide.html#Casting\r\n- https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-named\r\n\r\n\"Use brace initialization to convert arithmetic types (e.g., int64{x}). This is the safest approach because code will not compile if conversion can result in information loss. The syntax is also concise. Use static_cast as the equivalent of a C-style cast that does value conversion.\"\r\n\r\n\"Brace initialization makes it clear that the type conversion was intended and also prevents conversions between types that might result in loss of precision. (It is a compilation error to try to initialize a float from a double in this fashion, for example.)\"\r\n",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T11:18:07Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584631345",
      "id" : 584631345,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDYzMTM0NQ==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600626998,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584631345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584633270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584633270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For example, without the named cast here, brace initialization raises a compile time error for the narrowing conversion.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T11:21:21Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584633270",
      "id" : 584633270,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDYzMzI3MA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600629443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584633270",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> It's useful to have this on the branch so that other people can work on it.\r\n\r\nAgree! Though per @vasild's IRC comments last week (http://www.erisian.com.au/bitcoin-core-dev/log-2021-02-25.html#l-242) he may have planned one more update.\r\n",
      "created_at" : "2021-03-01T11:27:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-787875632",
      "id" : 787875632,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4Nzg3NTYzMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-01T11:28:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/787875632",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "`2a7bb343a...e41cb7dbd`: rebase to fix the windows fuzz build issue",
      "created_at" : "2021-03-01T12:14:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-787904082",
      "id" : 787904082,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4NzkwNDA4Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-01T12:14:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/787904082",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584873708"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584873708"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The thing is that here `GetDefaultPort()` returns `int` and `CService` constructor takes `uint16_t` argument. So we would get a justified warning that we want to silence. The proper fix would be to change `GetDefaultPort()` to return `uint16_t` which is out of the scope of this PR.\r\n\r\nI don't see a point in using a brace initialization for the warning and then to silence the warning with a `static_cast`.\r\n\r\n```cpp\r\nint x = 300;\r\n\r\n// no warning\r\nuint16_t c1 = x;\r\n\r\n// non-constant-expression cannot be narrowed from type 'int' to 'uint16_t'\r\nuint16_t c2{x};\r\n\r\n// no warning\r\nuint16_t c3{static_cast<uint16_t>(x)};\r\n```\r\n\r\nLeft it as is.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T16:42:55Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584873708",
      "id" : 584873708,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg3MzcwOA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600940851,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584873708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584879187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584879187"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree it can be considered out of scope to change `GetDefaultPort()`, but the suggested (ugly!) change would make explicit the type mismatch and maybe encourage improving it. As mentioned in the parent comment, none of these are blockers, just items I noted while reviewing.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T16:50:00Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584879187",
      "id" : 584879187,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg3OTE4Nw==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600948238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T22:26:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584879187",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584886956"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584886956"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Anyway, no worries. I'll look into improving it.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T16:59:42Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584886956",
      "id" : 584886956,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg4Njk1Ng==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 600958643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584886956",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "`e41cb7dbd...f181f24ca`: address suggestions\r\n(no tests yet)",
      "created_at" : "2021-03-01T17:08:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-788114200",
      "id" : 788114200,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4ODExNDIwMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-01T17:08:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/788114200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584893905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584893905"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:08:48Z",
      "diff_hunk" : "@@ -151,7 +151,16 @@ class CNetAddr\n \n         bool SetInternal(const std::string& name);\n \n-        bool SetSpecial(const std::string &strName); // for Tor addresses\n+        /**\n+         * Parse a Tor or I2P address and set this object to it.\n+         * @param[in] name Address to parse, for example",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584893905",
      "id" : 584893905,
      "in_reply_to_id" : 583817273,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5MzkwNQ==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 156,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/netaddress.h",
      "position" : null,
      "pull_request_review_id" : 600967935,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584893905",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584894116"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584894116"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:08:59Z",
      "diff_hunk" : "@@ -93,10 +114,167 @@ bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n \n     timeval timeout_struct = MillisToTimeval(timeout);\n \n-    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+    if (select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) == SOCKET_ERROR) {\n+        return false;\n+    }\n+\n+    if (occurred != nullptr) {\n+        *occurred = 0;\n+        if (FD_ISSET(m_socket, &fdset_recv)) {\n+            *occurred |= RECV;\n+        }\n+        if (FD_ISSET(m_socket, &fdset_send)) {\n+            *occurred |= SEND;\n+        }\n+    }\n+\n+    return true;\n #endif /* USE_POLL */\n }\n \n+void Sock::SendComplete(const std::string& data,\n+                        std::chrono::milliseconds timeout,\n+                        CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = Send(data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        const auto timeout = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584894116",
      "id" : 584894116,
      "in_reply_to_id" : 583883970,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5NDExNg==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 171,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/util/sock.cpp",
      "position" : null,
      "pull_request_review_id" : 600968137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584894116",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584894270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584894270"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:09:07Z",
      "diff_hunk" : "@@ -93,10 +114,167 @@ bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n \n     timeval timeout_struct = MillisToTimeval(timeout);\n \n-    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+    if (select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) == SOCKET_ERROR) {\n+        return false;\n+    }\n+\n+    if (occurred != nullptr) {\n+        *occurred = 0;\n+        if (FD_ISSET(m_socket, &fdset_recv)) {\n+            *occurred |= RECV;\n+        }\n+        if (FD_ISSET(m_socket, &fdset_send)) {\n+            *occurred |= SEND;\n+        }\n+    }\n+\n+    return true;\n #endif /* USE_POLL */\n }\n \n+void Sock::SendComplete(const std::string& data,\n+                        std::chrono::milliseconds timeout,\n+                        CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = Send(data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        const auto timeout = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});\n+        Wait(timeout, SEND);\n+    }\n+}\n+\n+std::string Sock::RecvUntilTerminator(uint8_t terminator,\n+                                      std::chrono::milliseconds timeout,\n+                                      CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584894270",
      "id" : 584894270,
      "in_reply_to_id" : 583885090,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5NDI3MA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 187,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/util/sock.cpp",
      "position" : null,
      "pull_request_review_id" : 600968293,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584894270",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895326"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895326"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In this case we can use `try_len` which is `size_t` and we already checked that it equals to `read_ret` just above this snippet.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:10:22Z",
      "diff_hunk" : "@@ -93,10 +114,167 @@ bool Sock::Wait(std::chrono::milliseconds timeout, Event requested) const\n \n     timeval timeout_struct = MillisToTimeval(timeout);\n \n-    return select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) != SOCKET_ERROR;\n+    if (select(m_socket + 1, &fdset_recv, &fdset_send, nullptr, &timeout_struct) == SOCKET_ERROR) {\n+        return false;\n+    }\n+\n+    if (occurred != nullptr) {\n+        *occurred = 0;\n+        if (FD_ISSET(m_socket, &fdset_recv)) {\n+            *occurred |= RECV;\n+        }\n+        if (FD_ISSET(m_socket, &fdset_send)) {\n+            *occurred |= SEND;\n+        }\n+    }\n+\n+    return true;\n #endif /* USE_POLL */\n }\n \n+void Sock::SendComplete(const std::string& data,\n+                        std::chrono::milliseconds timeout,\n+                        CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = Send(data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        const auto timeout = std::min(deadline - now, std::chrono::milliseconds{MAX_WAIT_FOR_IO});\n+        Wait(timeout, SEND);\n+    }\n+}\n+\n+std::string Sock::RecvUntilTerminator(uint8_t terminator,\n+                                      std::chrono::milliseconds timeout,\n+                                      CThreadInterrupt& interrupt) const\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = Recv(buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = Recv(buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895326",
      "id" : 584895326,
      "in_reply_to_id" : 583893589,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5NTMyNg==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 225,
      "original_position" : 172,
      "original_start_line" : null,
      "path" : "src/util/sock.cpp",
      "position" : null,
      "pull_request_review_id" : 600969626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895326",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895629"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:10:40Z",
      "diff_hunk" : "@@ -0,0 +1,260 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_I2P_H\n+#define BITCOIN_I2P_H\n+\n+#include <compat.h>\n+#include <fs.h>\n+#include <netaddress.h>\n+#include <sync.h>\n+#include <threadinterrupt.h>\n+#include <util/sock.h>\n+\n+#include <optional>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+namespace i2p {\n+\n+/**\n+ * Binary data.\n+ */\n+using Binary = std::vector<uint8_t>;\n+\n+/**\n+ * An established connection with another peer.\n+ */\n+struct Connection {\n+    /** Connected socket. */\n+    Sock sock;\n+\n+    /** Our I2P address. */\n+    CService me;\n+\n+    /** The peer's I2P address. */\n+    CService peer;\n+};\n+\n+namespace sam {\n+\n+/**\n+ * I2P SAM session.\n+ */\n+class Session\n+{\n+public:\n+    /**\n+     * Construct a session. This will not initiate any IO, the session will be lazily created\n+     * later when first used.\n+     * @param[in] private_key_file Path to a private key file. If the file does not exist then the\n+     * private key will be generated and saved into the file.\n+     * @param[in] control_host Location of the SAM proxy.\n+     * @param[in,out] interrupt If this is signaled then all operations are canceled as soon as\n+     * possible and executing methods throw an exception. Notice: only a pointer to the\n+     * `CThreadInterrupt` object is saved, so it must not be destroyed earlier than this\n+     * `Session` object.\n+     */\n+    Session(const fs::path& private_key_file,\n+            const CService& control_host,\n+            CThreadInterrupt* interrupt);\n+\n+    /**\n+     * Destroy the session, closing the internally used sockets. The sockets that have been\n+     * returned by `Accept()` or `Connect()` will not be closed, but they will be closed by\n+     * the SAM proxy because the session is destroyed. So they will return an error next time\n+     * we try to read or write to them.\n+     */\n+    ~Session();\n+\n+    /**\n+     * Start listening for an incoming connection.\n+     * @param[out] conn Upon successful completion the `sock` and `me` members will be set\n+     * to the listening socket and address.\n+     * @return true on success\n+     */\n+    bool Listen(Connection& conn);\n+\n+    /**\n+     * Wait for and accept a new incoming connection.\n+     * @param[in,out] conn The `sock` member is used for waiting and accepting. Upon successful\n+     * completion the `peer` member will be set to the address of the incoming peer.\n+     * @return true on success\n+     */\n+    bool Accept(Connection& conn);\n+\n+    /**\n+     * Connect to an I2P peer.\n+     * @param[in] to Peer to connect to.\n+     * @param[out] conn Established connection. Only set if `true` is returned.\n+     * @param[out] proxy_error If an error occurs due to proxy or general network failure, then\n+     * this is set to `true`. If an error occurs due to unreachable peer (likely peer is down), then\n+     * it is set to `false`. Only set if `false` is returned.\n+     * @return true on success\n+     */\n+    bool Connect(const CService& to, Connection& conn, bool& proxy_error);\n+\n+private:\n+    /**\n+     * A reply from the SAM proxy.\n+     */\n+    struct Reply {\n+        /**\n+         * Full, unparsed reply.\n+         */\n+        std::string full;\n+\n+        /**\n+         * Request, used for detailed error reporting.\n+         */\n+        std::string request;\n+\n+        /**\n+         * A map of keywords from the parsed reply.\n+         * For example, if the reply is \"A=X B C=YZ\", then the map will be\n+         * keys[\"A\"] == \"X\"\n+         * keys[\"B\"] == (empty std::optional)\n+         * keys[\"C\"] == \"YZ\"\n+         */\n+        std::unordered_map<std::string, std::optional<std::string>> keys;\n+\n+        /**\n+         * Get the value of a given key.\n+         * For example if the reply is \"A=X B\" then:\n+         * Value(\"A\") -> \"X\"\n+         * Value(\"B\") -> throws\n+         * Value(\"C\") -> throws\n+         * @param[in] key Key whose value to retrieve\n+         * @returns the key's value\n+         * @throws std::runtime_error if the key is not present or if it has no value\n+         */\n+        std::string Get(const std::string& key) const;\n+    };\n+\n+    /**\n+     * Log a message in the `BCLog::I2P` category.\n+     * @param[in] fmt printf(3)-like format string.\n+     * @param[in] args printf(3)-like arguments that correspond to `fmt`.\n+     */\n+    template <typename... Args>\n+    void Log(const std::string& fmt, const Args&... args) const;\n+\n+    /**\n+     * Send request and get a reply from the SAM proxy.\n+     * @param[in] sock A socket that is connected to the SAM proxy.\n+     * @param[in] request Raw request to send, a newline terminator is appended to it.\n+     * @param[in] check_result_ok If true then after receiving the reply a check is made\n+     * whether it contains \"RESULT=OK\" and an exception is thrown if it does not.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Reply SendRequestAndGetReply(const Sock& sock,\n+                                 const std::string& request,\n+                                 bool check_result_ok = true) const;\n+\n+    /**\n+     * Open a new connection to the SAM proxy.\n+     * @return a connected socket\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Sock Hello() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Check the control socket for errors and possibly disconnect.\n+     */\n+    void CheckControlSock();\n+\n+    /**\n+     * Generate a new destination with the SAM proxy and set `m_private_key` to it.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void DestGenerate(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Generate a new destination with the SAM proxy, set `m_private_key` to it and save\n+     * it on disk to `m_private_key_file`.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void GenerateAndSavePrivateKey(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Derive own destination from `m_private_key`.\n+     * @see https://geti2p.net/spec/common-structures#destination\n+     * @return an I2P destination\n+     */\n+    Binary MyDestination() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Create the session if not already created. Reads the private key file and connects to the\n+     * SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void CreateIfNotCreatedAlready() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Open a new connection to the SAM proxy and issue \"STREAM ACCEPT\" request using the existent",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895629",
      "id" : 584895629,
      "in_reply_to_id" : 583917118,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5NTYyOQ==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/i2p.h",
      "position" : null,
      "pull_request_review_id" : 600969934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895629",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895797"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:10:52Z",
      "diff_hunk" : "@@ -446,7 +446,9 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-maxtimeadjustment\", strprintf(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\", DEFAULT_MAX_TIME_ADJUSTMENT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-maxuploadtarget=<n>\", strprintf(\"Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: %d)\", DEFAULT_MAX_UPLOAD_TARGET), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-onion=<ip:port>\", \"Use separate SOCKS5 proxy to reach peers via Tor onion services, set -noonion to disable (default: -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-    argsman.AddArg(\"-onlynet=<net>\", \"Make outgoing connections only through network <net> (\" + Join(GetNetworkNames(), \", \") + \"). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks. Warning: if it is used with ipv4 or ipv6 but not onion and the -onion or -proxy option is set, then outbound onion connections will still be made; use -noonion or -onion=0 to disable outbound onion connections in this case.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2psam=<ip:port>\", \"I2P SAM proxy to reach I2P peers and accept I2P connections (default: none)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2pacceptincoming\", \"If set and -i2psam is also set then incoming I2P connections are accepted via the SAM proxy. If this is not set but -i2psam is set then only outgoing connections will be made to the I2P network. Ignored if -i2psam is not set. Notice that listening for incoming I2P connections is done through the SAM proxy, not by binding to a local address and port (default: 1)\", ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895797",
      "id" : 584895797,
      "in_reply_to_id" : 583953158,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5NTc5Nw==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 451,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 600970146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895797",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895915"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895915"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:11:02Z",
      "diff_hunk" : "@@ -1986,6 +1991,21 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n             connOptions.m_specified_outgoing = connect;\n         }\n     }\n+\n+    const std::string& i2psam_arg = args.GetArg(\"-i2psam\", \"\");\n+    if (i2psam_arg != \"\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584895915",
      "id" : 584895915,
      "in_reply_to_id" : 583955143,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5NTkxNQ==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 2000,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 600970318,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584895915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584896106"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584896106"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T17:11:15Z",
      "diff_hunk" : "@@ -0,0 +1,260 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_I2P_H\n+#define BITCOIN_I2P_H\n+\n+#include <compat.h>\n+#include <fs.h>\n+#include <netaddress.h>\n+#include <sync.h>\n+#include <threadinterrupt.h>\n+#include <util/sock.h>\n+\n+#include <optional>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+namespace i2p {\n+\n+/**\n+ * Binary data.\n+ */\n+using Binary = std::vector<uint8_t>;\n+\n+/**\n+ * An established connection with another peer.\n+ */\n+struct Connection {\n+    /** Connected socket. */\n+    Sock sock;\n+\n+    /** Our I2P address. */\n+    CService me;\n+\n+    /** The peer's I2P address. */\n+    CService peer;\n+};\n+\n+namespace sam {\n+\n+/**\n+ * I2P SAM session.\n+ */\n+class Session\n+{\n+public:\n+    /**\n+     * Construct a session. This will not initiate any IO, the session will be lazily created\n+     * later when first used.\n+     * @param[in] private_key_file Path to a private key file. If the file does not exist then the\n+     * private key will be generated and saved into the file.\n+     * @param[in] control_host Location of the SAM proxy.\n+     * @param[in,out] interrupt If this is signaled then all operations are canceled as soon as\n+     * possible and executing methods throw an exception. Notice: only a pointer to the\n+     * `CThreadInterrupt` object is saved, so it must not be destroyed earlier than this\n+     * `Session` object.\n+     */\n+    Session(const fs::path& private_key_file,\n+            const CService& control_host,\n+            CThreadInterrupt* interrupt);\n+\n+    /**\n+     * Destroy the session, closing the internally used sockets. The sockets that have been\n+     * returned by `Accept()` or `Connect()` will not be closed, but they will be closed by\n+     * the SAM proxy because the session is destroyed. So they will return an error next time\n+     * we try to read or write to them.\n+     */\n+    ~Session();\n+\n+    /**\n+     * Start listening for an incoming connection.\n+     * @param[out] conn Upon successful completion the `sock` and `me` members will be set\n+     * to the listening socket and address.\n+     * @return true on success\n+     */\n+    bool Listen(Connection& conn);\n+\n+    /**\n+     * Wait for and accept a new incoming connection.\n+     * @param[in,out] conn The `sock` member is used for waiting and accepting. Upon successful\n+     * completion the `peer` member will be set to the address of the incoming peer.\n+     * @return true on success\n+     */\n+    bool Accept(Connection& conn);\n+\n+    /**\n+     * Connect to an I2P peer.\n+     * @param[in] to Peer to connect to.\n+     * @param[out] conn Established connection. Only set if `true` is returned.\n+     * @param[out] proxy_error If an error occurs due to proxy or general network failure, then\n+     * this is set to `true`. If an error occurs due to unreachable peer (likely peer is down), then\n+     * it is set to `false`. Only set if `false` is returned.\n+     * @return true on success\n+     */\n+    bool Connect(const CService& to, Connection& conn, bool& proxy_error);\n+\n+private:\n+    /**\n+     * A reply from the SAM proxy.\n+     */\n+    struct Reply {\n+        /**\n+         * Full, unparsed reply.\n+         */\n+        std::string full;\n+\n+        /**\n+         * Request, used for detailed error reporting.\n+         */\n+        std::string request;\n+\n+        /**\n+         * A map of keywords from the parsed reply.\n+         * For example, if the reply is \"A=X B C=YZ\", then the map will be\n+         * keys[\"A\"] == \"X\"\n+         * keys[\"B\"] == (empty std::optional)\n+         * keys[\"C\"] == \"YZ\"\n+         */\n+        std::unordered_map<std::string, std::optional<std::string>> keys;\n+\n+        /**\n+         * Get the value of a given key.\n+         * For example if the reply is \"A=X B\" then:\n+         * Value(\"A\") -> \"X\"\n+         * Value(\"B\") -> throws\n+         * Value(\"C\") -> throws\n+         * @param[in] key Key whose value to retrieve\n+         * @returns the key's value\n+         * @throws std::runtime_error if the key is not present or if it has no value\n+         */\n+        std::string Get(const std::string& key) const;\n+    };\n+\n+    /**\n+     * Log a message in the `BCLog::I2P` category.\n+     * @param[in] fmt printf(3)-like format string.\n+     * @param[in] args printf(3)-like arguments that correspond to `fmt`.\n+     */\n+    template <typename... Args>\n+    void Log(const std::string& fmt, const Args&... args) const;\n+\n+    /**\n+     * Send request and get a reply from the SAM proxy.\n+     * @param[in] sock A socket that is connected to the SAM proxy.\n+     * @param[in] request Raw request to send, a newline terminator is appended to it.\n+     * @param[in] check_result_ok If true then after receiving the reply a check is made\n+     * whether it contains \"RESULT=OK\" and an exception is thrown if it does not.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Reply SendRequestAndGetReply(const Sock& sock,\n+                                 const std::string& request,\n+                                 bool check_result_ok = true) const;\n+\n+    /**\n+     * Open a new connection to the SAM proxy.\n+     * @return a connected socket\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Sock Hello() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Check the control socket for errors and possibly disconnect.\n+     */\n+    void CheckControlSock();\n+\n+    /**\n+     * Generate a new destination with the SAM proxy and set `m_private_key` to it.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void DestGenerate(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Generate a new destination with the SAM proxy, set `m_private_key` to it and save\n+     * it on disk to `m_private_key_file`.\n+     * @param[in] sock Socket to use for talking to the SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void GenerateAndSavePrivateKey(const Sock& sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Derive own destination from `m_private_key`.\n+     * @see https://geti2p.net/spec/common-structures#destination\n+     * @return an I2P destination\n+     */\n+    Binary MyDestination() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Create the session if not already created. Reads the private key file and connects to the\n+     * SAM proxy.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    void CreateIfNotCreatedAlready() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Open a new connection to the SAM proxy and issue \"STREAM ACCEPT\" request using the existent\n+     * session id. Return the idle socket that is waiting for a peer to connect to us.\n+     * @throws std::runtime_error if an error occurs\n+     */\n+    Sock StreamAccept() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * Destroy the session, closing the internally used sockets.\n+     */\n+    void Disconnect() EXCLUSIVE_LOCKS_REQUIRED(m_mutex);\n+\n+    /**\n+     * The name of the file where this peer's private key is stored (in binary).\n+     */\n+    const fs::path m_private_key_file;\n+\n+    /**\n+     * The host and port of the SAM control service.\n+     */\n+    const CService m_control_host;\n+\n+    /**\n+     * Cease network activity when this is signaled.\n+     */\n+    CThreadInterrupt* const m_interrupt;\n+\n+    /**\n+     * Mutex protecting the members that can be concurrently accessed.\n+     */\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * The private key of this peer.\n+     * @see The reply to the \"DEST GENERATE\" command in https://geti2p.net/en/docs/api/samv3\n+     */\n+    Binary m_private_key GUARDED_BY(m_mutex);\n+\n+    /**\n+     * SAM control socket.\n+     * Used to connect to the I2P SAM service and create a session\n+     * (\"SESSION CREATE\"). With the established session id we later open\n+     * other connections to the SAM service to accept incoming I2P\n+     * connections and make outgoing ones.\n+     * See https://geti2p.net/en/docs/api/samv3\n+     */\n+    Sock m_control_sock GUARDED_BY(m_mutex);\n+\n+    /**\n+     * The .b32.i2p address of this peer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r584896106",
      "id" : 584896106,
      "in_reply_to_id" : 583919626,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDg5NjEwNg==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 246,
      "original_position" : 246,
      "original_start_line" : null,
      "path" : "src/i2p.h",
      "position" : null,
      "pull_request_review_id" : 600970572,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T17:29:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/584896106",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "`f181f24ca...a701fcf01`: pet the linter which seems to be upset by `R\"(foo \"%s\" bar\")`",
      "created_at" : "2021-03-01T17:30:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-788130339",
      "id" : 788130339,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4ODEzMDMzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-01T17:30:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/788130339",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r585094710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/585094710"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Proposed #21328 to address it without requiring any changes here.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-01T22:26:18Z",
      "diff_hunk" : "@@ -0,0 +1,406 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    LOCK(m_mutex);\n+    Disconnect();\n+}\n+\n+bool Session::Listen(Connection& conn)\n+{\n+    try {\n+        LOCK(m_mutex);\n+        CreateIfNotCreatedAlready();\n+        conn.me = m_my_addr;\n+        conn.sock = StreamAccept();\n+        return true;\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error listening: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Accept(Connection& conn)\n+{\n+    try {\n+        while (!*m_interrupt) {\n+            Sock::Event occurred;\n+            conn.sock.Wait(MAX_WAIT_FOR_IO, Sock::RECV, &occurred);\n+\n+            if ((occurred & Sock::RECV) == 0) {\n+                // Timeout, no incoming connections within MAX_WAIT_FOR_IO.\n+                continue;\n+            }\n+\n+            const std::string& peer_dest =\n+                conn.sock.RecvUntilTerminator('\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+            conn.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+\n+            return true;\n+        }\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error accepting: %s\", e.what());\n+        CheckControlSock();\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.sock = std::move(sock);\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        CheckControlSock();\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    sock.SendComplete(request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = sock.RecvUntilTerminator('\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {\n+        throw std::runtime_error(strprintf(\"Unexpected reply to '%s': '%s'\", request, reply.full));\n+    }\n+\n+    return reply;\n+}\n+\n+Sock Session::Hello() const\n+{\n+    auto sock = CreateSock(m_control_host);\n+\n+    if (!sock) {\n+        throw std::runtime_error(\"Cannot create socket\");\n+    }\n+\n+    if (!ConnectSocketDirectly(m_control_host, sock->Get(), nConnectTimeout, true)) {\n+        throw std::runtime_error(strprintf(\"Cannot connect to %s\", m_control_host.ToString()));\n+    }\n+\n+    SendRequestAndGetReply(*sock, \"HELLO VERSION MIN=3.1 MAX=3.1\");\n+\n+    return std::move(*sock);\n+}\n+\n+void Session::CheckControlSock()\n+{\n+    LOCK(m_mutex);\n+\n+    std::string errmsg;\n+    if (!m_control_sock.IsConnected(errmsg)) {\n+        Log(\"Control socket error: %s\", errmsg);\n+        Disconnect();\n+    }\n+}\n+\n+void Session::DestGenerate(const Sock& sock)\n+{\n+    // https://geti2p.net/spec/common-structures#key-certificates\n+    // \"7\" or \"EdDSA_SHA512_Ed25519\" - \"Recent Router Identities and Destinations\".\n+    // Use \"7\" because i2pd <2.24.0 does not recognize the textual form.\n+    const Reply& reply = SendRequestAndGetReply(sock, \"DEST GENERATE SIGNATURE_TYPE=7\", false);\n+\n+    m_private_key = DecodeI2PBase64(reply.Get(\"PRIV\"));\n+}\n+\n+void Session::GenerateAndSavePrivateKey(const Sock& sock)\n+{\n+    DestGenerate(sock);\n+\n+    // umask is set to 077 in init.cpp, which is ok (unless -sysperms is given)\n+    if (!WriteBinaryFile(m_private_key_file,\n+                         std::string(m_private_key.begin(), m_private_key.end()))) {\n+        throw std::runtime_error(\n+            strprintf(\"Cannot save I2P private key to %s\", m_private_key_file));\n+    }\n+}\n+\n+Binary Session::MyDestination() const\n+{\n+    // From https://geti2p.net/spec/common-structures#destination:\n+    // \"They are 387 bytes plus the certificate length specified at bytes 385-386, which may be\n+    // non-zero\"\n+    static constexpr size_t DEST_LEN_BASE = 387;\n+    static constexpr size_t CERT_LEN_POS = 385;\n+\n+    uint16_t cert_len;\n+    memcpy(&cert_len, &m_private_key.at(CERT_LEN_POS), sizeof(cert_len));\n+    cert_len = be16toh(cert_len);\n+\n+    const size_t dest_len = DEST_LEN_BASE + cert_len;\n+\n+    return Binary{m_private_key.begin(), m_private_key.begin() + dest_len};\n+}\n+\n+void Session::CreateIfNotCreatedAlready()\n+{\n+    std::string errmsg;\n+    if (m_control_sock.IsConnected(errmsg)) {\n+        return;\n+    }\n+\n+    Log(\"Creating SAM session with %s\", m_control_host.ToString());\n+\n+    Sock sock = Hello();\n+\n+    const auto& [read_ok, data] = ReadBinaryFile(m_private_key_file);\n+    if (read_ok) {\n+        m_private_key.assign(data.begin(), data.end());\n+    } else {\n+        GenerateAndSavePrivateKey(sock);\n+    }\n+\n+    const std::string& session_id = GetRandHash().GetHex().substr(0, 10); // full is an overkill, too verbose in the logs\n+    const std::string& private_key_b64 = SwapBase64(EncodeBase64(m_private_key));\n+\n+    SendRequestAndGetReply(sock, strprintf(\"SESSION CREATE STYLE=STREAM ID=%s DESTINATION=%s\",\n+                                           session_id, private_key_b64));\n+\n+    m_my_addr = CService(DestBinToAddr(MyDestination()), Params().GetDefaultPort());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r585094710",
      "id" : 585094710,
      "in_reply_to_id" : 584177133,
      "line" : 365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA5NDcxMA==",
      "original_commit_id" : "2a7bb343ac77f2bf52ea1a8959a22ef266d49aa6",
      "original_line" : 365,
      "original_position" : 364,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 365,
      "pull_request_review_id" : 601224030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-01T22:26:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/585094710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-03-02T10:38:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-788809219",
      "id" : 788809219,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4ODgwOTIxOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-02T10:38:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/788809219",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@practicalswift \r\n> I plan to add a fuzzing harness for the I2P Reply parsing code (unless @vasild plans to do it as part of this PR of course :)).\r\n\r\nI am adding some basic fuzzing of the `i2p::sam::Session` public interface using `FuzzedSock` (not to `Reply()`). Will open a PR soonish...",
      "created_at" : "2021-03-04T16:40:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-790754217",
      "id" : 790754217,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MDc1NDIxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-04T16:40:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/790754217",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@vasild \r\n\r\n> > I plan to add a fuzzing harness for the I2P Reply parsing code (unless @vasild plans to do it as part of this PR of course :)).\r\n> \r\n> I am adding some basic fuzzing of the `i2p::sam::Session` public interface using `FuzzedSock` (not to `Reply()`). Will open a PR soonish...\r\n\r\nThat's great news! Looking forward to reviewing it: don't hesitate to ping me when ready :)",
      "created_at" : "2021-03-04T20:15:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-790910380",
      "id" : 790910380,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MDkxMDM4MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-04T20:15:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/790910380",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@vasild here are a couple more screenshots of being connected twice to the same I2P peer (one example of inbound+outbound, which can be persistent (and not unique to I2P peers IIRC, here we are each manually addnode-ing each other I believe), and one example of double inbound, which doesn't usually last more than ~5 minutes AFAICT but happens the most often, I see it a few times a day).\r\n\r\nThe `addrbind` in every case is my local I2P address.\r\n\r\n![Screenshot from 2021-03-05 10-58-35](https://user-images.githubusercontent.com/2415484/110099684-7e750a80-7d99-11eb-9e80-e8bfedd55930.png)\r\n\r\n![Screenshot from 2021-03-05 01-59-28](https://user-images.githubusercontent.com/2415484/110099744-90ef4400-7d99-11eb-973f-3d03e6db0054.png)\r\n",
      "created_at" : "2021-03-05T10:04:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-791315141",
      "id" : 791315141,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MTMxNTE0MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-05T10:06:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/791315141",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@practicalswift: fuzzing tests in https://github.com/bitcoin/bitcoin/pull/21387.",
      "created_at" : "2021-03-08T12:54:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-792736217",
      "id" : 792736217,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjczNjIxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-08T12:54:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792736217",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jonatack \r\n> one example of inbound+outbound, which can be persistent (and not unique to I2P peers\r\n\r\nRight. A->B and A<-B is not forbidden and can be done even with IPv4 addresses.\r\n\r\n> and one example of double inbound\r\n\r\nI opened https://github.com/bitcoin/bitcoin/issues/21389 to track this.",
      "created_at" : "2021-03-08T17:21:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-792919651",
      "id" : 792919651,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjkxOTY1MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-08T17:21:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792919651",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> (did not test `onlynet=i2p`)\r\n\r\nSince writing that, I've been running `onlynet=i2p` with `onlynet=onion` and it seems to be working well.",
      "created_at" : "2021-03-08T19:25:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-793011126",
      "id" : 793011126,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MzAxMTEyNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-08T19:25:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/793011126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jonatack those i2p pings look much higher than the tor pings. Is that normal? Does i2p offer any advantage over tor?",
      "created_at" : "2021-05-03T13:48:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-831271303",
      "id" : 831271303,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMTI3MTMwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-03T13:48:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/831271303",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@rebroad indeed (see #21261). An advantage is potentially better decentralization, network robustness and censorship resistance, e.g. I2P may be operational when Tor isn't or has degraded operation, like in January and February. ",
      "created_at" : "2021-05-03T14:05:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-831282139",
      "id" : 831282139,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMTI4MjEzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-03T14:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/831282139",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "In addition, I2P connections have a \"source address\" - it is certain that the peer who connects from a given I2P address to us possesses the private key that corresponds to that I2P address. This can be used for white-listing \"friends\". It is a stronger guarantee than IP addresses (which can be spoofed by e.g. your ISP).",
      "created_at" : "2021-05-03T14:38:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-831303188",
      "id" : 831303188,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMTMwMzE4OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-03T14:38:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/831303188",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r625787084"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625787084"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't entirely understand how these enums (`LOCAL_BIND`, `LOCAL_MANUAL`, etc) are meant to be used, but I wonder if this should be `LOCAL_MANUAL` instead?  That seems to be what we use for listening on an onion address: https://github.com/bitcoin/bitcoin/blob/0ca8b7e7ecd5bc537fbc1e372f6755a34a136f7f/src/torcontrol.cpp#L354\r\n\r\nI noticed that when I'm running with `-externalip`, I don't get my i2p address listed as a local address (presumably because `fDiscover` gets defaulted to false and then anything less than `LOCAL_MANUAL` is ignored in `AddLocal()`), even though my onion address is unaffected by the setting.  Changing this to `LOCAL_MANUAL` seems to fix this issue.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-05-04T13:35:57Z",
      "diff_hunk" : "@@ -2187,6 +2188,45 @@ void CConnman::ThreadMessageHandler()\n     }\n }\n \n+void CConnman::ThreadI2PAcceptIncoming()\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    bool advertising_listen_addr = false;\n+    i2p::Connection conn;\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            if (advertising_listen_addr && conn.me.IsValid()) {\n+                RemoveLocal(conn.me);\n+                advertising_listen_addr = false;\n+            }\n+\n+            interruptNet.sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (!advertising_listen_addr) {\n+            AddLocal(conn.me, LOCAL_BIND);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r625787084",
      "id" : 625787084,
      "line" : 2217,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTc4NzA4NA==",
      "original_commit_id" : "b905363fa8b0bb03fe34b53b5410880f42e0af39",
      "original_line" : 2217,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 155,
      "pull_request_review_id" : 651243957,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-04T13:35:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625787084",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r625856311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625856311"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I played with the `LOCAL_*` enums, but I don't remember why I chose `LOCAL_BIND` :-( I wonder why `AddLocal()` induced by `-externalip` did not work:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/0ca8b7e7ecd5bc537fbc1e372f6755a34a136f7f/src/init.cpp#L1304-L1307",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-05-04T14:57:00Z",
      "diff_hunk" : "@@ -2187,6 +2188,45 @@ void CConnman::ThreadMessageHandler()\n     }\n }\n \n+void CConnman::ThreadI2PAcceptIncoming()\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    bool advertising_listen_addr = false;\n+    i2p::Connection conn;\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            if (advertising_listen_addr && conn.me.IsValid()) {\n+                RemoveLocal(conn.me);\n+                advertising_listen_addr = false;\n+            }\n+\n+            interruptNet.sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (!advertising_listen_addr) {\n+            AddLocal(conn.me, LOCAL_BIND);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r625856311",
      "id" : 625856311,
      "in_reply_to_id" : 625787084,
      "line" : 2217,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTg1NjMxMQ==",
      "original_commit_id" : "b905363fa8b0bb03fe34b53b5410880f42e0af39",
      "original_line" : 2217,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 155,
      "pull_request_review_id" : 651339507,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-04T14:57:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625856311",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r625858553"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625858553"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry I should have been more clear -- I was using `-externalip` with an ipv4 address (this node is listening on an ipv4 address, onion address, and i2p address).  However I noticed that with `-externalip` enabled, the `AddLocal` for the i2p address didn't work. \r\n\r\nPresumably if I set `-discover=1` explicitly then it would have worked?  But I was just surprised that there's a difference between what we do for onion vs i2p.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-05-04T14:59:35Z",
      "diff_hunk" : "@@ -2187,6 +2188,45 @@ void CConnman::ThreadMessageHandler()\n     }\n }\n \n+void CConnman::ThreadI2PAcceptIncoming()\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    bool advertising_listen_addr = false;\n+    i2p::Connection conn;\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            if (advertising_listen_addr && conn.me.IsValid()) {\n+                RemoveLocal(conn.me);\n+                advertising_listen_addr = false;\n+            }\n+\n+            interruptNet.sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (!advertising_listen_addr) {\n+            AddLocal(conn.me, LOCAL_BIND);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r625858553",
      "id" : 625858553,
      "in_reply_to_id" : 625787084,
      "line" : 2217,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTg1ODU1Mw==",
      "original_commit_id" : "b905363fa8b0bb03fe34b53b5410880f42e0af39",
      "original_line" : 2217,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 155,
      "pull_request_review_id" : 651342599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-04T15:00:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625858553",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r630063641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/630063641"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Presumably if I set `-discover=1` explicitly then it would have worked?\r\n\r\nYes.\r\n\r\nFixed in https://github.com/bitcoin/bitcoin/pull/21914.",
      "commit_id" : "a701fcf01f3ea9a12e869bfa52321302cf68351c",
      "created_at" : "2021-05-11T10:58:51Z",
      "diff_hunk" : "@@ -2187,6 +2188,45 @@ void CConnman::ThreadMessageHandler()\n     }\n }\n \n+void CConnman::ThreadI2PAcceptIncoming()\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    bool advertising_listen_addr = false;\n+    i2p::Connection conn;\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            if (advertising_listen_addr && conn.me.IsValid()) {\n+                RemoveLocal(conn.me);\n+                advertising_listen_addr = false;\n+            }\n+\n+            interruptNet.sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (!advertising_listen_addr) {\n+            AddLocal(conn.me, LOCAL_BIND);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r630063641",
      "id" : 630063641,
      "in_reply_to_id" : 625787084,
      "line" : 2217,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMDA2MzY0MQ==",
      "original_commit_id" : "b905363fa8b0bb03fe34b53b5410880f42e0af39",
      "original_line" : 2217,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 155,
      "pull_request_review_id" : 656566709,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-11T10:58:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/630063641",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   }
]
