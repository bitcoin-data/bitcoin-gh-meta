[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : ">That prevent a node to send addr to outbound nodes to prevent a fingerprint attack\r\nIs this still a valid point?\r\n\r\nYes. Well, it prevents from responding to ADDR requests. A node would still actively announce itself through those connections every day, as well as forward other's ADDR packages.\r\n\r\n>With feeler connections that test address validity, wouldn't be fair to send to outbound connections some addresses we have validated?\r\n\r\nThis does not help to prevent fingerprinting by any means (well, maybe an attacker would have to keep their sybil fingerprinting nodes running for a bit, but that's a very small improvement). You might get a better idea of this code by looking at the [corresponding PR](https://github.com/bitcoin/bitcoin/pull/5442).\r\n\r\n>I think this would help having a better distributed address propagation, or did I miss some points?\r\n\r\nWell, first of all, just removing this check would not change this at all âÂ honest Bitcoin nodes would not send GETADDR requests through inbound.\r\nIf you want to enable that as well âÂ I'd want to see some more reasoning about \"better address propagation\". I don't have an intuition that this should help. We use GETADDR only during node bootstrap, and all the further addr propagation is done via unsolicited periodic ADDR forwarding (every day every node announces itself to its peers, those announcements are then aggregated with self-announcements from other nodes and forwarded).\r\n",
      "created_at" : "2020-01-08T22:16:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17871#issuecomment-572284029",
      "id" : 572284029,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17871",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3MjI4NDAyOQ==",
      "updated_at" : "2020-01-08T22:17:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/572284029",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Now that I think, the change you are suggestion might make some sense, but it has nothing to do with the line you're pointing out. This line is mostly about responding to the requests which are done when a peer is bootstrapping.\r\n\r\nWill respond later, my laptop is dying right now.",
      "created_at" : "2020-01-08T22:20:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17871#issuecomment-572285500",
      "id" : 572285500,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17871",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3MjI4NTUwMA==",
      "updated_at" : "2020-01-08T22:20:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/572285500",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Alright, so it seems you are suggesting to do unsolicited forwarding of those addresses which were recently checked as feelers. (which has nothing to do with the code you link).\r\nUnfortunately, this feeler test would allow an attacker to collect information about the topology graph. \r\nBecause an attacker can:\r\na) after every feeler check from node X, an attacker reads all nodes AddrMans (this is doable) and sees which ones have attacker's node. Those will be X's connections. No good!\r\nb) An attacker selectively responds to feeler checks and make their address propagate in the network in a specific way, which can make malicious collecting information even more effective.\r\n\r\nMore importantly, I don't see much value in doing this. Frankly speaking, we don't have a clear framework for measuring AddrMan performance. But maybe you can show why this would help \"would help having a better distributed address propagation\"?\r\nAlso, take into account those self-announcements I mentioned in the previous message.",
      "created_at" : "2020-01-09T15:30:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17871#issuecomment-572613031",
      "id" : 572613031,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17871",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3MjYxMzAzMQ==",
      "updated_at" : "2020-01-09T15:31:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/572613031",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I think I got your points and probably I did a bad reasoning mixing connection sides but I think this could still be a valid issue in other terms, let's try to think about it:\r\n\r\nsuppose you start a a fresh node, you get some addresses by DNS seed then you attach to a malicious peer and that peer gives you (unsolecited?) addresses he's in control of, now you sync with it (and maybe connect to other peers he send you eventually) without problems and at this point you accept incoming connections and you start giving other peers the malicius address that have been passed to you (they arent' fake, are working node but malicious)\r\n\r\nAt this point you are spreading the plague because you reply to inbound peers your addrman containing mostly malicious peers, and you can't ask to these peers their address because they nagete it giving the code above (for them you are an outbound connection)\r\n\r\nAt this point such a client contains a lot of malicious peer addresses and can't get better ones because its inbound refuse it, isn't this a risk?\r\n\r\nWhat's the biggest risk, being under control of malicious peers or being fingerprinted? Which would be easier to achieve? Wouldn't replaying to gedaddr in both directions mitigate this risk?\r\n\r\nAnyway my question arised because I'm implementing a client in another language and I was trying to talk with a bitcoin core test node that wasn't replaying to my gedaddr messages and I found this code that represents a problem for my simple setup (but not that big) so I wanted to know if this code was still valid after all the time that passed since it was introduced",
      "created_at" : "2020-01-09T18:32:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17871#issuecomment-572692509",
      "id" : 572692509,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17871",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3MjY5MjUwOQ==",
      "updated_at" : "2020-01-09T18:32:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/572692509",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/5107375?v=4",
         "events_url" : "https://api.github.com/users/MithrilMan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MithrilMan/followers",
         "following_url" : "https://api.github.com/users/MithrilMan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MithrilMan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MithrilMan",
         "id" : 5107375,
         "login" : "MithrilMan",
         "node_id" : "MDQ6VXNlcjUxMDczNzU=",
         "organizations_url" : "https://api.github.com/users/MithrilMan/orgs",
         "received_events_url" : "https://api.github.com/users/MithrilMan/received_events",
         "repos_url" : "https://api.github.com/users/MithrilMan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MithrilMan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MithrilMan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MithrilMan"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I wanted to know if this code was still valid after all the time that passed since it was introduced\r\n\r\nIt is still valid.\r\n\r\n>I was trying to talk with a bitcoin core test node that wasn't replaying to my gedaddr messages\r\n\r\nIt would reply, if it's an inbound connection asking getaddr.\r\n\r\n>What's the biggest risk, being under control of malicious peers or being fingerprinted? Which would be easier to achieve? Wouldn't replaying to gedaddr in both directions mitigate this risk?\r\n\r\nFilling addrman with garbage peers is currently possible, but fairly impractical, due to bucketing, new/tried table, honest self-announcements. (Although I'd love to see measurements on this! I hope to find time to do this sometime)\r\nI'm not persuaded that the change you are suggesting would make anything *reasonably* more secure. While the new privacy leak it would cause is pretty straightforward.\r\n\r\nAlso, if you want to have more good records in AddrMan âÂ better ask your outbound peers. Outbound peers are more trusted in a way. Intuition: it's very easy for an attacker to create 100 inbound connections to a victim, but making the victim to connect to an attacker via victim's outbounds is significantly harder.\r\n\r\n>then you attach to a malicious peer and that peer gives you (unsolecited?) addresses he's in control of\r\n\r\nWe put addresses learned from 1 peer in only a subset of buckets (64 out of 1024 I believe). So 1 peer can't screw you very fast. If you connect to 4 bad peers out of 8 âÂ year, probably that might escalate quickly.  But even here I'm not sure your solution is effective.",
      "created_at" : "2020-01-09T22:29:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17871#issuecomment-572786796",
      "id" : 572786796,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17871",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3Mjc4Njc5Ng==",
      "updated_at" : "2020-01-09T22:30:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/572786796",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "thanks for the insights, I think I'll close the issue as it is now.",
      "created_at" : "2020-01-10T10:36:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17871#issuecomment-572981539",
      "id" : 572981539,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17871",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3Mjk4MTUzOQ==",
      "updated_at" : "2020-01-10T10:39:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/572981539",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/5107375?v=4",
         "events_url" : "https://api.github.com/users/MithrilMan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MithrilMan/followers",
         "following_url" : "https://api.github.com/users/MithrilMan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MithrilMan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MithrilMan",
         "id" : 5107375,
         "login" : "MithrilMan",
         "node_id" : "MDQ6VXNlcjUxMDczNzU=",
         "organizations_url" : "https://api.github.com/users/MithrilMan/orgs",
         "received_events_url" : "https://api.github.com/users/MithrilMan/received_events",
         "repos_url" : "https://api.github.com/users/MithrilMan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MithrilMan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MithrilMan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MithrilMan"
      }
   }
]
