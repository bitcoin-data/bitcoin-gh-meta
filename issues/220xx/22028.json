{
   "active_lock_reason" : null,
   "assignee" : null,
   "assignees" : [],
   "author_association" : "NONE",
   "body" : "I'm 98% certain that whomever submitted this CVE (Core devs?) erroneously reported that the protocol was not properly ejecting transactions from the mempool based on certain pre-coded conditions dictated by BIP125. \r\n\r\nI went through the protocol documentation (referencing 'Mastering Bitcoin' and relevant accompanying code), and will confirm in this post that the protocol is actually behaving the way that it should in the example scenario outlined in the CVE. \r\n\r\n### Quick Look at CVE-2021-31876\r\n\r\nYou can find the URL to that CVE here: <<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31876>>\r\n\r\nBelow is the full text of the CVE: \r\n\r\n> *\"Bitcoin Core 0.12.0 through 0.21.1 does not properly implement the replacement policy specified in BIP125, which makes it easier for attackers to trigger a loss of funds, or a denial of service attack against downstream projects such as Lightning network nodes. An unconfirmed child transaction with nSequence = 0xff_ff_ff_ff, spending an unconfirmed parent with nSequence <= 0xff_ff_ff_fd, should be replaceable because there is inherited signaling by the child transaction. However, the actual PreChecks implementation does not enforce this. Instead, mempool rejects the replacement attempt of the unconfirmed child transaction.\"* \r\n\r\nThat paragraph is a bit dense, so let's \"humanize\" the situation a bit by creating a mock situation involving you and your friends (Johnny and Amy):\r\n\r\n1. When you send a normal Bitcoin transaction, the \"parent\" is the transaction you received that gave you the balance necessary to be able to send that TX. \r\n\r\n2. Let's say Johnny sends you 1 Bitcoin because he's a great friend. You now have 1 BTC (you had absolutely nothing before - so Johnny blesed you)\r\n\r\n3. But you owe Amy money - specifically, 1 Bitcoin (life sucks). So you send 1 BTC to Amy. \r\n\r\n**At this point, two transactions have occurred**: \r\n\r\na) Johnny sent you 1 BTC (**parent**)\r\n\r\n**then**\r\n\r\nb) You sent Amy 1 (**child**) \r\n\r\nNow to understand the concept being outlined in the CVE, let's revise our scenario slightly. \r\n\r\n1. Let's say Johnny is lazy but he trusts you with his life because you're an honest, upstanding person. So Johnny hits you up and says, \"Dude here's my private key, just send yourself 1 BTC\". You say, 'Okay Johnny!' \r\n\r\n2. Using Johnny's wallet, you sign a transaction to yourself. \r\n\r\n3. But you **decide not to broadcast that signed transaction immediately**. You save it in a document on your desktop or something. \r\n\r\n4. You still owe Amy in this scenario (sorry!) and she still wants her money...or else. So you create your 1 BTC transaction to Amy. \r\n\r\n5. You use that signed transaction from Johnny as the input for your transaction to Amy. Even though you haven't broadcasted it yet, you still have all of the necessary information to craft such a transaction. \r\n\r\nThis transaction is actually considered **valid** and **standard**. \r\n\r\n> *Why?* \r\n\r\nBecause the process of creating transactions is not interactive. In other words, you can craft a transaction entirely offline (assuming you have the knowledge of the necessary inputs for the transaction etc.). \r\n\r\nThere are no checks in Bitcoin that determines whether a transaction is valid or not on the basis of whether it has been included in the chain or not. Instead, Bitcoin assesses whether you have met the necessary conditions to spend a transaction (i.e. ,SHA256+ripemd160(pubkey) & match that with the byte push, run the rest of the stack and validate the signature correlates with the raw Bitcoin pubkey you submitted as an input to the stack). \r\n\r\nIn this example, the transaction you're broadcasting is technically valid because you used Johnny's wallet to sign the 1 BTC over to you. And when you crafted  your TX to Amy, you used that same signed transaction as the input to your transaction to her. \r\n\r\nOnly issue here though is that Johnny's TX was never broadcasted, so even though the transaction is validly constructed - its referring to a transaction that does not yet currently exist. \r\n\r\nFrom here, I'm going to refer back to the CVE and isolate how it claims that Bitcoin behaves. Then I'm going to point out the protocol specification that states otherwise and explain a bit more how things work in that type of situation. \r\n\r\n### CVE Erroneously Claims That the Child Transaction Should be Replaceable\r\n\r\nSpecifically it states that the unconfirmed child transaction spending an \"unconfirmed parent\" should be replaceable \"because there is inherited signaling by the child transaction.\" \r\n\r\nFrom here, we get the supposed identified CVE, which is the claim that, \"The actual [PreChecks](<file:///home/libre/.ephemeral/Bitcoin/Technical/PreChecks.txt>) implementation does not enforce this. Instead, mempool rejects the replacement attempt of the unconfirmed child transaction.\" \r\n\r\nThis is how the mempool **should** act in this situation. \r\n\r\nSo essentially, they're stating that there can be multiple \"duplicate\" transactions (double spends) in the mempool - which the CVE identifies as incorrect behavior. This oversight is understandable since this is how it would **usually work**. \r\n\r\nBut as we'll see in the next section from 'Mastering Bitcoin', that this specific situation actually triggers an exception in the protocol that dictates special handling. \r\n\r\n### Bitcoin is Supposed to Behave This Way\r\n\r\nDon't ask me how I know this, but this exact situation is actually outlined in, 'Mastering Bitcoin' (really), where it is confirmed that this is how Bitcoin is supposed to behave. \r\n\r\nHere's the link: <<https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch05.html>>\r\n\r\n**Specifically, it says**:\r\n\r\n> \"When a chain of transactions is transmitted across the network, they don't always arrive in the same order. Sometimes, the child might arrive before the parent. In that case, the nodes that see a child first can see that it references a parent transaction that is not yet known.\"\r\n\r\nIn other words, that child transaction is referencing an unconfirmed parent...same situation as described in the CVE. \r\n\r\n**The chapter goes on to state**: \r\n\r\n> \"Rather than reject the child, they put it in a temporary pool (not the mempool) to await the arrival of its parent and propagate it to every other node. The pool of transactions without parents is known as the orphan transaction pool.\" \r\n\r\nMany people have never heard of the 'orphan transaction pool', but it does indeed exist (for transactions that fit the attributes we described above). \r\n\r\n'Mastering Bitcoin' wraps this section up making it clear that the transaction **does evenutally resolve**: \r\n\r\n> \"Once the parent arrives, any orphans that reference the UTXO created by the parent are released from the pool, revalidated recursively, and then the entire chain of transactions can be included in the transaction pool, ready to be mined in a block.\"\r\n\r\n### Unpacking What We Read Above\r\n\r\nThe most important takeaway from what we read above is that the parent must be spent before the unconfirmed child - but if we're in a situation where the child refers to an unconfirmed parent that is referenced as an otherwise valid input, then any 'double spend attempts' that also reference the same (unconfirmed) parent transaction will **not be ousted from the mempool** in the same way that a double spend referencing a **confirmed** parent transaction would.\r\n\r\nBeyond this, its also worth remembering that **this does not mean that the parent must already be confirmed before the child** (confusing, I know - stick with me). \r\n\r\n#### Explaining a Bit Further\r\n\r\nWhenever a new block is submitted by miners, they typically contain a ton of transactions, right? While the order of the TXs doesn't matter, **there is an order to those TXs**. So a miner **can** mine a valid block that contains a previously unspent parent transaction **and** its unspent child. \r\n\r\nThe only caveat is that the parent must be included **before** the child transaction, canonically, within that block.\r\n\r\n### When Parent is Spent, All Duplicates are Immediately Purged\r\n\r\nOnce nodes receive a block that validly spends the parent TX, the normal rules for handling attempted double-spend unconfirmed transactions kick in. So all transactions in the \"orphan transaction pool\" that attempted to spend that same unspent child transaction (whose parent and/or itself just got confirmed) will be expelled by nodes since this is now an unequivocal flagrant double spend attempt. \r\n\r\n### Conclusion - CVE Should Be Rescinded\r\n\r\nTo be honest, I'm not sure if this has happened with a CVE (where it was issued, then later retracted). \r\n\r\nI understand why Core came to the conclusion that this was a CVE (never heard of an 'orphan transaction pool' before I read that passage in 'Mastering Bitcoin', but lo and behold it does).\r\n\r\n**Perhaps This is Bullish**\r\n\r\nThis will undoubtedly be great for at least some folks to hear since it will alleviate the stress that some may feel knowing that there was an active CVE for Bitcoin. \r\n\r\n**Flipside** \r\n\r\nWhile the behavior is not incorrect, the conclusions that the developers came to about it being adverse for LN implementation does stand. \r\n\r\nSo this is more of a pyrrhic victory - depends on how one looks at it. \r\n\r\nAt the end of the day nothing about this situation is catastrophic for Bitcoin. I do think that this behavior should be investigated first and studied before unilaterally changing it since we now know that this is not incorrect behavior.\r\n\r\n",
   "closed_at" : "2021-05-24T10:10:37Z",
   "closed_by" : {
      "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
      "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
      "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/MarcoFalke",
      "id" : 6399679,
      "login" : "MarcoFalke",
      "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
      "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
      "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
      "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/MarcoFalke"
   },
   "comments" : 4,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22028/comments",
   "created_at" : "2021-05-23T22:42:57Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22028/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/22028",
   "id" : 899125286,
   "labels" : [],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22028/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDU6SXNzdWU4OTkxMjUyODY=",
   "number" : 22028,
   "performed_via_github_app" : null,
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "closed",
   "title" : "CVE-2021-31876 is Not a Vulnerability ",
   "updated_at" : "2021-05-24T10:10:37Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22028",
   "user" : {
      "avatar_url" : "https://avatars.githubusercontent.com/u/59129716?v=4",
      "events_url" : "https://api.github.com/users/Librechain/events{/privacy}",
      "followers_url" : "https://api.github.com/users/Librechain/followers",
      "following_url" : "https://api.github.com/users/Librechain/following{/other_user}",
      "gists_url" : "https://api.github.com/users/Librechain/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/Librechain",
      "id" : 59129716,
      "login" : "Librechain",
      "node_id" : "MDQ6VXNlcjU5MTI5NzE2",
      "organizations_url" : "https://api.github.com/users/Librechain/orgs",
      "received_events_url" : "https://api.github.com/users/Librechain/received_events",
      "repos_url" : "https://api.github.com/users/Librechain/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/Librechain/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/Librechain/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/Librechain"
   }
}
