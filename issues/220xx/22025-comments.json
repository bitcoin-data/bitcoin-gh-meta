[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #21940 (refactor: Mark CAddrMan::Select const by MarcoFalke)\n* #21129 (fuzz: check that ser+unser produces the same AddrMan by vasild)\n* #20233 (addrman: Make consistency checks a runtime option by jnewbery)\n* #19238 (refactor: Make CAddrMan::cs non-recursive by hebasto)\n* #18722 (addrman: improve performance by using more suitable containers by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2021-05-23T22:33:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#issuecomment-846634442",
      "id" : 846634442,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22025",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0NjYzNDQ0Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-24T22:12:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/846634442",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637790202"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637790202"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: this empty line can be removed",
      "commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "created_at" : "2021-05-24T08:49:40Z",
      "diff_hunk" : "@@ -759,6 +626,141 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManCorrupted;\n+    friend class CAddrManDeterministic;\n+    friend class CAddrManSerializationMock;\n+    friend class CAddrManTest;\n+\n };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637790202",
      "id" : 637790202,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzc5MDIwMg==",
      "original_commit_id" : "6627b0bab44a6e8392611182fdec4c4a85ba10a0",
      "original_line" : 763,
      "original_position" : 279,
      "original_start_line" : 762,
      "path" : "src/addrman.h",
      "position" : null,
      "pull_request_review_id" : 666529522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-05-24T08:49:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637790202",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637792669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637792669"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks! Done.",
      "commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "created_at" : "2021-05-24T08:53:59Z",
      "diff_hunk" : "@@ -759,6 +626,141 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManCorrupted;\n+    friend class CAddrManDeterministic;\n+    friend class CAddrManSerializationMock;\n+    friend class CAddrManTest;\n+\n };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637792669",
      "id" : 637792669,
      "in_reply_to_id" : 637790202,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzc5MjY2OQ==",
      "original_commit_id" : "6627b0bab44a6e8392611182fdec4c4a85ba10a0",
      "original_line" : 763,
      "original_position" : 279,
      "original_start_line" : 762,
      "path" : "src/addrman.h",
      "position" : null,
      "pull_request_review_id" : 666532857,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-05-24T08:53:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637792669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 1b177a442a2e3749073cc189ddd404e74a902923",
      "created_at" : "2021-05-24T11:29:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#issuecomment-846980247",
      "id" : 846980247,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22025",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0Njk4MDI0Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-24T11:29:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/846980247",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637959390"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637959390"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry but I'm not 100% sure that having this class know about all descendents in the tests is better than using `protected`.",
      "commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "created_at" : "2021-05-24T13:50:09Z",
      "diff_hunk" : "@@ -759,6 +626,140 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManCorrupted;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637959390",
      "id" : 637959390,
      "line" : 759,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzk1OTM5MA==",
      "original_commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "original_line" : 759,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : 274,
      "pull_request_review_id" : 666755647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-24T13:50:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637959390",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637974546"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637974546"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Currently, one derived testing class has the `friend` specifier, others have access to `protected` members.\r\nIs combining both approaches better?",
      "commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "created_at" : "2021-05-24T14:11:40Z",
      "diff_hunk" : "@@ -759,6 +626,140 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManCorrupted;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637974546",
      "id" : 637974546,
      "in_reply_to_id" : 637959390,
      "line" : 759,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzk3NDU0Ng==",
      "original_commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "original_line" : 759,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : 274,
      "pull_request_review_id" : 666780703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-24T14:11:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637974546",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637977808"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637977808"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd say that if there is a choice, using `protected` is better than explicitly naming every descendant. Ideally you'd be able to add tests without having to mention them in the code to be tested. `friend` is like a last resort option for otherwise unrelated classes.",
      "commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "created_at" : "2021-05-24T14:16:20Z",
      "diff_hunk" : "@@ -759,6 +626,140 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManCorrupted;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637977808",
      "id" : 637977808,
      "in_reply_to_id" : 637959390,
      "line" : 759,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzk3NzgwOA==",
      "original_commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "original_line" : 759,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : 274,
      "pull_request_review_id" : 666794266,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-24T14:16:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637977808",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637978686"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637978686"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see.",
      "commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "created_at" : "2021-05-24T14:17:43Z",
      "diff_hunk" : "@@ -759,6 +626,140 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManCorrupted;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637978686",
      "id" : 637978686,
      "in_reply_to_id" : 637959390,
      "line" : 759,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzk3ODY4Ng==",
      "original_commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "original_line" : 759,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : 274,
      "pull_request_review_id" : 666798365,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-24T14:17:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/637978686",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated 1b177a442a2e3749073cc189ddd404e74a902923 -> 8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab ([pr22025.02](https://github.com/hebasto/bitcoin/commits/pr22025.02) -> [pr22025.03](https://github.com/hebasto/bitcoin/commits/pr22025.03), [diff](https://github.com/hebasto/bitcoin/compare/pr22025.02..pr22025.03)):\r\n\r\n- addressed @laanwj's [comment](https://github.com/bitcoin/bitcoin/pull/22025#discussion_r637977808)",
      "created_at" : "2021-05-24T16:36:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#issuecomment-847180767",
      "id" : 847180767,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22025",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0NzE4MDc2Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-24T16:36:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/847180767",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r638110202"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/638110202"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks! [Updated](https://github.com/bitcoin/bitcoin/pull/22025#issuecomment-847180767).",
      "commit_id" : "8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
      "created_at" : "2021-05-24T16:36:31Z",
      "diff_hunk" : "@@ -759,6 +626,140 @@ friend class CAddrManTest;\n         Check();\n     }\n \n+private:\n+    //! critical section to protect the inner data structures\n+    mutable RecursiveMutex cs;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs);\n+\n+    //! table with information about all nIds\n+    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs);\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs);\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only)\n+    int64_t nLastGood GUARDED_BY(cs);\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    FastRandomContext insecure_rand;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! find an entry, creating it if necessary.\n+    //! nTime and nServices of the found node are updated, if necessary.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+#ifdef DEBUG_ADDRMAN\n+    //! Perform consistency check. Returns an error code or zero.\n+    int Check_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+#endif\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    friend class CAddrManCorrupted;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#discussion_r638110202",
      "id" : 638110202,
      "in_reply_to_id" : 637959390,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODExMDIwMg==",
      "original_commit_id" : "1b177a442a2e3749073cc189ddd404e74a902923",
      "original_line" : 759,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : null,
      "pull_request_review_id" : 666957322,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22025",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-24T16:36:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/638110202",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
      "created_at" : "2021-05-24T16:52:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#issuecomment-847190617",
      "id" : 847190617,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22025",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0NzE5MDYxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-24T16:52:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/847190617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2021-05-24T19:58:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#issuecomment-847296993",
      "id" : 847296993,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22025",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0NzI5Njk5Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-24T19:58:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/847296993",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code review ACK 8caf60dbbe16afa3c52574a7f6710d74c0bfd4ab",
      "created_at" : "2021-05-27T13:52:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22025#issuecomment-849653238",
      "id" : 849653238,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22025",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0OTY1MzIzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-27T13:52:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/849653238",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   }
]
