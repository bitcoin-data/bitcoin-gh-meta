{
   "active_lock_reason" : null,
   "assignee" : null,
   "assignees" : [],
   "author_association" : "MEMBER",
   "body" : "Background\r\n---\r\nIf two or more threads acquire mutexes in different order, that could cause a deadlock. Currently we have two mechanisms for detecting that - our [DEBUG_LOCKORDER](https://github.com/bitcoin/bitcoin/blob/bdedfcf/src/sync.cpp#L134) and the [thread sanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html).\r\n\r\nProblem\r\n---\r\nBoth methods may fail to detect some deadlocks:\r\n\r\ndeadlock type | detected by `DEBUG_LOCKORDER` | detected by TSan | detected by the proposed solution\r\n---|---|---|---\r\nA => B => C => A | :x: | :heavy_check_mark: | :heavy_check_mark:\r\ntest case `deadlock_unlock_not_last` | :x: | :heavy_check_mark: | :heavy_check_mark:\r\ntest case `deadlock_3` | :x: | :x: <sup>[1]</sup> | :heavy_check_mark:\r\nA => B, restart the program, B => A <sup>[2]</sup> | :x: | :x: | :heavy_check_mark: <sup>[3]</sup>\r\n\r\n<sup>[1]</sup> submitted as a bug report at https://github.com/google/sanitizers/issues/1258\r\n<sup>[2]</sup> I guess this is how the bug which https://github.com/bitcoin/bitcoin/pull/19132 fixes sneaked in\r\n<sup>[3]</sup> as long as just B => A is executed\r\n\r\n\r\n<details>\r\n<summary>test cases</summary>\r\n\r\n```cpp\r\nclass Event\r\n{\r\npublic:\r\n    void signal()\r\n    {\r\n        std::unique_lock<std::mutex> lk(m_mutex);\r\n        m_occurred = true;\r\n        m_cond.notify_all();\r\n    }\r\n\r\n    void wait()\r\n    {\r\n        std::unique_lock<std::mutex> lk(m_mutex);\r\n        m_cond.wait(lk, [&]() { return m_occurred; });\r\n    }\r\n\r\nprivate:\r\n    bool m_occurred{false};\r\n    std::condition_variable m_cond;\r\n    std::mutex m_mutex;\r\n};\r\n\r\nstatic std::mutex printf_mutex;\r\nvoid printf_sync(const char* format, ...)\r\n{\r\n    va_list ap;\r\n    va_start(ap, format);\r\n\r\n    {\r\n        std::unique_lock<std::mutex> lk(printf_mutex);\r\n        vprintf(format, ap);\r\n    }\r\n\r\n    va_end(ap);\r\n}\r\n\r\nBOOST_AUTO_TEST_CASE(deadlock_3)\r\n{\r\n#if 0\r\n    // detected by DEBUG_LOCKORDER\r\n    // not detected by the thread sanitizer (when DEBUG_LOCKORDER is disabled)\r\n    constexpr size_t n_threads = 2;\r\n#else\r\n    // deadlock is not detected by either one\r\n    constexpr size_t n_threads = 3;\r\n#endif\r\n\r\n    // t0: lock m0\r\n    // t1: lock m1\r\n    // t2: lock m2\r\n    // t0: try to lock m1, waits for t1\r\n    // t1: try to lock m2, waits for t2\r\n    // t2: try to lock m0, waits for t0 => deadlock\r\n\r\n    std::array<Mutex, n_threads> mutexes;\r\n    std::array<std::thread, n_threads> threads;\r\n    std::array<Event, n_threads> locked_own;\r\n    std::array<Event, n_threads> try_to_lock_next;\r\n\r\n    auto thread = [&](size_t i) {\r\n        LOCK(mutexes[i]);\r\n        printf_sync(\"thread%zu locked mutex%zu\\n\", i, i);\r\n        locked_own[i].signal();\r\n\r\n        try_to_lock_next[i].wait();\r\n\r\n        const size_t next = (i + 1) % n_threads;\r\n        printf_sync(\"thread%zu trying to lock mutex%zu\\n\", i, next);\r\n        LOCK(mutexes[next]);\r\n    };\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        threads[i] = std::thread{thread, i};\r\n    }\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        locked_own[i].wait();\r\n    }\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        try_to_lock_next[i].signal();\r\n    }\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        threads[i].join();\r\n    }\r\n}\r\n\r\nBOOST_AUTO_TEST_CASE(deadlock_unlock_not_last)\r\n{\r\n    // t0: lock m0\r\n    // t0: lock m1\r\n    // t0: unlock m0\r\n    // t1: lock m0\r\n    // t1: try to lock m1, waits for t0\r\n    // t0: try to lock m0, waits for t1 => deadlock\r\n\r\n    Mutex m0;\r\n    Mutex m1;\r\n    Event t1_locked_m0;\r\n\r\n    std::thread t0{[&]() {\r\n        ENTER_CRITICAL_SECTION(m0);\r\n        LOCK(m1);\r\n        LEAVE_CRITICAL_SECTION(m0);\r\n        t1_locked_m0.wait();\r\n        LOCK(m0);\r\n    }};\r\n\r\n    std::thread t1{[&]() {\r\n        LOCK(m0);\r\n        t1_locked_m0.signal();\r\n        LOCK(m1);\r\n    }};\r\n\r\n    t0.join();\r\n    t1.join();\r\n}\r\n```\r\n</details>\r\n\r\nSolution\r\n---\r\nAttach a predefined integer to each mutex that denotes the locking order in relation to other mutexes. So, whenever attempting to lock a mutex a thread would check if the previous mutex it acquired has a lower number.\r\n\r\nThis would require some thorough considerations when adding a new mutex - when is it going to be used, what other mutexes are going to be held at the time the new one is acquired and what other mutexes may be acquired while holding the new one. That is a good practice and should be done anyway. Such a mechanism will enforce it.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 15,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/comments",
   "created_at" : "2020-06-03T13:22:03Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/19157",
   "id" : 629990142,
   "labels" : [
      {
         "color" : "7cf575",
         "default" : false,
         "description" : null,
         "id" : 64583,
         "name" : "Feature",
         "node_id" : "MDU6TGFiZWw2NDU4Mw==",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDU6SXNzdWU2Mjk5OTAxNDI=",
   "number" : 19157,
   "performed_via_github_app" : null,
   "reactions" : {
      "+1" : 1,
      "-1" : 0,
      "confused" : 0,
      "eyes" : 0,
      "heart" : 0,
      "hooray" : 0,
      "laugh" : 0,
      "rocket" : 0,
      "total_count" : 1,
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/reactions"
   },
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "state_reason" : null,
   "timeline_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/timeline",
   "title" : "Improve deadlock detection",
   "updated_at" : "2022-08-12T13:24:00Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157",
   "user" : {
      "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
      "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
      "followers_url" : "https://api.github.com/users/vasild/followers",
      "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/vasild",
      "id" : 266751,
      "login" : "vasild",
      "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
      "organizations_url" : "https://api.github.com/users/vasild/orgs",
      "received_events_url" : "https://api.github.com/users/vasild/received_events",
      "repos_url" : "https://api.github.com/users/vasild/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/vasild"
   }
}
