{
   "assignee" : null,
   "assignees" : [],
   "author_association" : "CONTRIBUTOR",
   "body" : "Background\r\n---\r\nIf two or more threads acquire mutexes in different order, that could cause a deadlock. Currently we have two mechanisms for detecting that - our [DEBUG_LOCKORDER](https://github.com/bitcoin/bitcoin/blob/bdedfcf/src/sync.cpp#L134) and the [thread sanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html).\r\n\r\nProblem\r\n---\r\nBoth methods may fail to detect some deadlocks:\r\n* `DEBUG_LOCKORDER` only detects deadlocks that involve two mutexes: `A => B, B => A`. It will not detect `A => B, B => C, C => A`.\r\n* Both methods require all relevant code paths to execute in the same invocation of the program. `A => B, restart the program, B => A` will not be detected. I guess this is how the bug which https://github.com/bitcoin/bitcoin/pull/19132 fixes sneaked in.\r\n* The thread sanitizer fails to detect a deadlock from this test:\r\n<details>\r\n<summary>[1] test case causing undetected deadlock by the thread sanitizer</summary>\r\n\r\n```cpp\r\nBOOST_AUTO_TEST_CASE(deadlock_3)\r\n{\r\n#if 0\r\n    // detected by DEBUG_LOCKORDER\r\n    // not detected by the thread sanitizer (when DEBUG_LOCKORDER is disabled)\r\n    constexpr size_t n_threads = 2;\r\n#else\r\n    // deadlock is not detected by either one\r\n    constexpr size_t n_threads = 3;\r\n#endif\r\n\r\n    // thread0 locked mutex0\r\n    // thread1 locked mutex1\r\n    // thread2 locked mutex2\r\n    // thread0 trying to lock mutex1\r\n    // thread1 trying to lock mutex2\r\n    // thread2 trying to lock mutex0 <-- deadlocks\r\n\r\n    class Event\r\n    {\r\n    public:\r\n        void signal()\r\n        {\r\n            std::unique_lock<std::mutex> lk(m_mutex);\r\n            m_occurred = true;\r\n            m_cond.notify_all();\r\n        }\r\n        void wait()\r\n        {\r\n            std::unique_lock<std::mutex> lk(m_mutex);\r\n            m_cond.wait(lk, [&]() { return m_occurred; });\r\n        }\r\n\r\n    private:\r\n        bool m_occurred{false};\r\n        std::condition_variable m_cond;\r\n        std::mutex m_mutex;\r\n    };\r\n\r\n    std::mutex printf_mutex;\r\n    auto printf_sync = [&](const char* format, ...) {\r\n        va_list ap;\r\n        va_start(ap, format);\r\n\r\n        {\r\n            std::unique_lock<std::mutex> lk(printf_mutex);\r\n            vprintf(format, ap);\r\n        }\r\n\r\n        va_end(ap);\r\n    };\r\n\r\n    std::array<Mutex, n_threads> mutexes;\r\n    std::array<std::thread, n_threads> threads;\r\n    std::array<Event, n_threads> locked_own;\r\n    std::array<Event, n_threads> try_to_lock_next;\r\n\r\n    auto f = [&](size_t i) {\r\n        LOCK(mutexes[i]);\r\n        printf_sync(\"thread%zu locked mutex%zu\\n\", i, i);\r\n        locked_own[i].signal();\r\n\r\n        try_to_lock_next[i].wait();\r\n\r\n        const size_t next = (i + 1) % n_threads;\r\n        printf_sync(\"thread%zu trying to lock mutex%zu\\n\", i, next);\r\n        LOCK(mutexes[next]);\r\n    };\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        threads[i] = std::thread{f, i};\r\n    }\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        locked_own[i].wait();\r\n    }\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        try_to_lock_next[i].signal();\r\n    }\r\n\r\n    for (size_t i = 0; i < n_threads; ++i) {\r\n        threads[i].join();\r\n    }\r\n}\r\n```\r\n</details>\r\n\r\nSolution\r\n---\r\nAttach a predefined integer to each mutex that denotes the locking order in relation to other mutexes. So, whenever attempting to lock a mutex a thread would check if the previous mutex it acquired has a lower number.\r\n\r\nThis would require some thorough considerations when adding a new mutex - when is it going to be used, what other mutexes are going to be held at the time the new one is acquired and what other mutexes may be acquired while holding the new one. That is a good practice and should be done anyway. Such a mechanism will enforce it.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 1,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/comments",
   "created_at" : "2020-06-03T13:22:03Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/19157",
   "id" : 629990142,
   "labels" : [
      {
         "color" : "7cf575",
         "default" : false,
         "description" : null,
         "id" : 64583,
         "name" : "Feature",
         "node_id" : "MDU6TGFiZWw2NDU4Mw==",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDU6SXNzdWU2Mjk5OTAxNDI=",
   "number" : 19157,
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "title" : "Improve deadlock detection",
   "updated_at" : "2020-06-03T13:29:26Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19157",
   "user" : {
      "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
      "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
      "followers_url" : "https://api.github.com/users/vasild/followers",
      "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/vasild",
      "id" : 266751,
      "login" : "vasild",
      "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
      "organizations_url" : "https://api.github.com/users/vasild/orgs",
      "received_events_url" : "https://api.github.com/users/vasild/received_events",
      "repos_url" : "https://api.github.com/users/vasild/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/vasild"
   }
}
