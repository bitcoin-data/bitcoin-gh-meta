[
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2018-11-03T02:37:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#issuecomment-435554106",
      "id" : 435554106,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14646",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTU1NDEwNg==",
      "updated_at" : "2018-11-03T02:37:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435554106",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230548862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230548862"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Add a test for this?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T08:39:04Z",
      "diff_hunk" : "@@ -262,20 +264,33 @@ class DescriptorImpl : public Descriptor\n \n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkeys.size());\n \n         // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n         for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230548862",
      "id" : 230548862,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU0ODg2Mg==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 96,
      "path" : "src/script/descriptor.cpp",
      "position" : 276,
      "pull_request_review_id" : 171320860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230548862",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230548877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230548877"
         }
      },
      "author_association" : "MEMBER",
      "body" : "n00b C++ question: what happens if `cache_read` is too short?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T08:39:51Z",
      "diff_hunk" : "@@ -262,20 +264,33 @@ class DescriptorImpl : public Descriptor\n \n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkeys.size());\n \n         // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n         for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230548877",
      "id" : 230548877,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU0ODg3Nw==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 100,
      "path" : "src/script/descriptor.cpp",
      "position" : 280,
      "pull_request_review_id" : 171320860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230548877",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549061"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549061"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you add comments (to the existing code) what these two loops are about? E.g.\r\n```\r\n// Is ranged descriptor, expand up to 3 results\r\nsize_t max ...\r\nfor (size_t i = 0; i < max; ++i)\r\n...\r\n// ???\r\nfor (int t = 0; t < 2; ++t) \r\n```",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T08:51:35Z",
      "diff_hunk" : "@@ -88,9 +88,18 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n         for (int t = 0; t < 2; ++t) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549061",
      "id" : 230549061,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU0OTA2MQ==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 2,
      "path" : "src/test/descriptor_tests.cpp",
      "position" : 22,
      "pull_request_review_id" : 171320860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549061",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549171"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Since `ExpandHelper` doesn't care, should `ExpandFromCache` explicitly check that it wasn't unintentionally called with `cache=nullptr`? Or should `ExpandFromCache` be agnostic to whether or not there's actually a (useful) cache?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T08:56:44Z",
      "diff_hunk" : "@@ -299,6 +314,17 @@ class DescriptorImpl : public Descriptor\n         }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549171",
      "id" : 230549171,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU0OTE3MQ==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 127,
      "path" : "src/script/descriptor.cpp",
      "position" : 323,
      "pull_request_review_id" : 171320860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549171",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549882"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That would be undefined behavior.\n\nThankfully the line above checks that this isn't the case :)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T09:30:12Z",
      "diff_hunk" : "@@ -262,20 +264,33 @@ class DescriptorImpl : public Descriptor\n \n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkeys.size());\n \n         // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n         for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549882",
      "id" : 230549882,
      "in_reply_to_id" : 230548877,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU0OTg4Mg==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 100,
      "path" : "src/script/descriptor.cpp",
      "position" : 280,
      "pull_request_review_id" : 171321984,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549882",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549894"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549894"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The argument is a reference, not a pointer. Dereferencing a nullptr is UB.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T09:30:56Z",
      "diff_hunk" : "@@ -299,6 +314,17 @@ class DescriptorImpl : public Descriptor\n         }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230549894",
      "id" : 230549894,
      "in_reply_to_id" : 230549171,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU0OTg5NA==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 127,
      "path" : "src/script/descriptor.cpp",
      "position" : 323,
      "pull_request_review_id" : 171321996,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230549894",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors My idea is that the wallet will contain a number of records, each of which has a descriptor, a bool to indicate whether it's for change or not, a birthday, perhaps information about what HW device to prompt for, a gap limit, ...; those are all static configuration that generally doesn't change unless you import something. In addition there will be a wallet entry per expanded element of a record with the cached information, which also helps in identifying what the next unused address is etc.",
      "created_at" : "2018-11-03T09:35:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#issuecomment-435574146",
      "id" : 435574146,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14646",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTU3NDE0Ng==",
      "updated_at" : "2018-11-03T09:35:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435574146",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230551654"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230551654"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah yes, `cache` is a pointer for `Expand` and a reference for `ExpandFromCache`. ",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T10:54:37Z",
      "diff_hunk" : "@@ -299,6 +314,17 @@ class DescriptorImpl : public Descriptor\n         }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230551654",
      "id" : 230551654,
      "in_reply_to_id" : 230549171,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU1MTY1NA==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 127,
      "path" : "src/script/descriptor.cpp",
      "position" : 323,
      "pull_request_review_id" : 171323874,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230551654",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14826](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14826.html) (Avoid expanding descriptor scriptPubKeys by promag)\n* [#14505](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14505.html) (Make single parameter constructors explicit (C++11). Add explicit constructor linter. by practicalswift)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-11-03T15:12:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#issuecomment-435595274",
      "id" : 435595274,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14646",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTU5NTI3NA==",
      "updated_at" : "2018-11-29T03:13:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435595274",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230571330"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230571330"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T23:52:32Z",
      "diff_hunk" : "@@ -262,20 +264,33 @@ class DescriptorImpl : public Descriptor\n \n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkeys.size());\n \n         // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n         for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230571330",
      "id" : 230571330,
      "in_reply_to_id" : 230548862,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU3MTMzMA==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 96,
      "path" : "src/script/descriptor.cpp",
      "position" : 276,
      "pull_request_review_id" : 171345195,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230571330",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230571333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230571333"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added some comments to the test.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-03T23:52:55Z",
      "diff_hunk" : "@@ -88,9 +88,18 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n         for (int t = 0; t < 2; ++t) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230571333",
      "id" : 230571333,
      "in_reply_to_id" : 230549061,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU3MTMzMw==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 2,
      "path" : "src/test/descriptor_tests.cpp",
      "position" : 22,
      "pull_request_review_id" : 171345202,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230571333",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230605976"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605976"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Redundant trailing `;` :-)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:25:03Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230605976",
      "id" : 230605976,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNTk3Ng==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 112,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171380085,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605976",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230605984"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605984"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here :-)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:25:13Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230605984",
      "id" : 230605984,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNTk4NA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 113,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171380094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605984",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606091"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606091"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Better doing it explicitly using ternary operator?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:27:55Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606091",
      "id" : 230606091,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjA5MQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 194,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171380196,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606091",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606233"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606233"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This move is redundant?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:32:16Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606233",
      "id" : 230606233,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjIzMw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 204,
      "path" : "src/script/descriptor.cpp",
      "position" : 229,
      "pull_request_review_id" : 171380352,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606233",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here? The result is passed as a const reference argument and the move is hence a noop?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:32:50Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606259",
      "id" : 230606259,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjI1OQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 220,
      "path" : "src/script/descriptor.cpp",
      "position" : 245,
      "pull_request_review_id" : 171380382,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606259",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606297"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Override redundant here?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:33:39Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606297",
      "id" : 230606297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjI5Nw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 227,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171380420,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606297",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606304"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:33:53Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606304",
      "id" : 230606304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjMwNA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 234,
      "path" : "src/script/descriptor.cpp",
      "position" : 259,
      "pull_request_review_id" : 171380429,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606304",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606313"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606313"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:34:06Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606313",
      "id" : 230606313,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjMxMw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 292,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171380441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606313",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606321"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606321"
         }
      },
      "author_association" : "MEMBER",
      "body" : "And here?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:34:18Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606321",
      "id" : 230606321,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjMyMQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 297,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171380453,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606321",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606339"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606339"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be explicit?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:35:00Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606339",
      "id" : 230606339,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjMzOQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 370,
      "path" : "src/script/descriptor.cpp",
      "position" : 398,
      "pull_request_review_id" : 171380474,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606339",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606357"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606357"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Explicit?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:35:31Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606357",
      "id" : 230606357,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjM1Nw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 382,
      "path" : "src/script/descriptor.cpp",
      "position" : 410,
      "pull_request_review_id" : 171380492,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606357",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606363"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606363"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Explicit?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:35:38Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606363",
      "id" : 230606363,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjM2Mw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 392,
      "path" : "src/script/descriptor.cpp",
      "position" : 420,
      "pull_request_review_id" : 171380497,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606363",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606368"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606368"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Explicit?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:35:47Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}\n+};\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return \"combo(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = \"combo(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+/** A parsed combo(P) descriptor. */\n+class ComboDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider& out) const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        CKeyID keyid = key.GetID();\n-        {\n-            CScript p2pk = GetScriptForRawPubKey(key);\n-            CScript p2pkh = GetScriptForDestination(keyid);\n-            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n-            out.pubkeys.emplace(keyid, key);\n-            out.origins.emplace(keyid, std::move(info));\n-        }\n-        if (key.IsCompressed()) {\n-            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n-            CScriptID p2wpkh_id(p2wpkh);\n-            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n-            out.scripts.emplace(p2wpkh_id, p2wpkh);\n-            output_scripts.push_back(std::move(p2wpkh));\n-            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        std::vector<CScript> ret;\n+        CKeyID id = keys[0].GetID();\n+        ret.emplace_back(GetScriptForRawPubKey(keys[0])); // P2PK\n+        ret.emplace_back(GetScriptForDestination(id)); // P2PKH\n+        if (keys[0].IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(id));\n+            out.scripts.emplace(CScriptID(p2wpkh), p2wpkh);\n+            ret.emplace_back(p2wpkh);\n+            ret.emplace_back(GetScriptForDestination(CScriptID(p2wpkh))); // P2SH-P2WPKH\n         }\n-        return true;\n+        return ret;\n     }\n+public:\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"combo\") {}\n+};\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor final : public DescriptorImpl\n+{\n+    const int m_threshold;\n+protected:\n+    std::string ToStringExtra() const override { return strprintf(\"%i\", m_threshold); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForMultisig(m_threshold, keys)); }\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : DescriptorImpl(std::move(providers), {}, \"multi\"), m_threshold(threshold) {}\n+};\n+\n+/** A parsed sh(...) descriptor. */\n+class SHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>&) const override { return Singleton(GetScriptForDestination(CScriptID(script))); }\n+public:\n+    SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606368",
      "id" : 230606368,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjM2OA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 463,
      "path" : "src/script/descriptor.cpp",
      "position" : 492,
      "pull_request_review_id" : 171380503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606368",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Explicit?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:35:54Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}\n+};\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return \"combo(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = \"combo(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+/** A parsed combo(P) descriptor. */\n+class ComboDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider& out) const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        CKeyID keyid = key.GetID();\n-        {\n-            CScript p2pk = GetScriptForRawPubKey(key);\n-            CScript p2pkh = GetScriptForDestination(keyid);\n-            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n-            out.pubkeys.emplace(keyid, key);\n-            out.origins.emplace(keyid, std::move(info));\n-        }\n-        if (key.IsCompressed()) {\n-            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n-            CScriptID p2wpkh_id(p2wpkh);\n-            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n-            out.scripts.emplace(p2wpkh_id, p2wpkh);\n-            output_scripts.push_back(std::move(p2wpkh));\n-            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        std::vector<CScript> ret;\n+        CKeyID id = keys[0].GetID();\n+        ret.emplace_back(GetScriptForRawPubKey(keys[0])); // P2PK\n+        ret.emplace_back(GetScriptForDestination(id)); // P2PKH\n+        if (keys[0].IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(id));\n+            out.scripts.emplace(CScriptID(p2wpkh), p2wpkh);\n+            ret.emplace_back(p2wpkh);\n+            ret.emplace_back(GetScriptForDestination(CScriptID(p2wpkh))); // P2SH-P2WPKH\n         }\n-        return true;\n+        return ret;\n     }\n+public:\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"combo\") {}\n+};\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor final : public DescriptorImpl\n+{\n+    const int m_threshold;\n+protected:\n+    std::string ToStringExtra() const override { return strprintf(\"%i\", m_threshold); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForMultisig(m_threshold, keys)); }\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : DescriptorImpl(std::move(providers), {}, \"multi\"), m_threshold(threshold) {}\n+};\n+\n+/** A parsed sh(...) descriptor. */\n+class SHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>&) const override { return Singleton(GetScriptForDestination(CScriptID(script))); }\n+public:\n+    SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n+};\n+\n+/** A parsed wsh(...) descriptor. */\n+class WSHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>&) const override { return Singleton(GetScriptForDestination(WitnessV0ScriptHash(script))); }\n+public:\n+    WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606373",
      "id" : 230606373,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjM3Mw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 472,
      "path" : "src/script/descriptor.cpp",
      "position" : 501,
      "pull_request_review_id" : 171380510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606373",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606426"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`pos++` is a dead store?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-04T21:37:13Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230606426",
      "id" : 230606426,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNjQyNg==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 217,
      "path" : "src/script/descriptor.cpp",
      "position" : 242,
      "pull_request_review_id" : 171380559,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230606426",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620443"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620443"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't know what you mean.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:21:37Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620443",
      "id" : 230620443,
      "in_reply_to_id" : 230606091,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMDQ0Mw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 194,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171397153,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620443",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620525"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620525"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How so?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:22:32Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620525",
      "id" : 230620525,
      "in_reply_to_id" : 230606233,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMDUyNQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 204,
      "path" : "src/script/descriptor.cpp",
      "position" : 229,
      "pull_request_review_id" : 171397253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620525",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620549"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620549"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't understand.\r\n\r\nEDIT: Ah, I see; there is no `operator+=` for `std::string` that takes advantage of the rvalue, so this indeed has no function. That's strange, as it seems that there is an `operator+` that does.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:22:51Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620549",
      "id" : 230620549,
      "in_reply_to_id" : 230606259,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMDU0OQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 220,
      "path" : "src/script/descriptor.cpp",
      "position" : 245,
      "pull_request_review_id" : 171397285,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620549",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620860"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`override` is always redundant. Its function is making sure the code does what is intended, by preventing an accidental rename/change of the base class's definition from unintentionally changing the override into a new non-virtual method.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:26:33Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230620860",
      "id" : 230620860,
      "in_reply_to_id" : 230606297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMDg2MA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 227,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171397722,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230620860",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:43:13Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622438",
      "id" : 230622438,
      "in_reply_to_id" : 230605976,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjQzOA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 112,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171399649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622438",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622452"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622452"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:43:22Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622452",
      "id" : 230622452,
      "in_reply_to_id" : 230605984,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjQ1Mg==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 113,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171399661,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622452",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622467"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622467"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:43:33Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622467",
      "id" : 230622467,
      "in_reply_to_id" : 230606233,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjQ2Nw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 204,
      "path" : "src/script/descriptor.cpp",
      "position" : 229,
      "pull_request_review_id" : 171399679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622467",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622478"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622478"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:43:39Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622478",
      "id" : 230622478,
      "in_reply_to_id" : 230606259,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjQ3OA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 220,
      "path" : "src/script/descriptor.cpp",
      "position" : 245,
      "pull_request_review_id" : 171399691,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622478",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622500"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622500"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:43:52Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622500",
      "id" : 230622500,
      "in_reply_to_id" : 230606339,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjUwMA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 370,
      "path" : "src/script/descriptor.cpp",
      "position" : 398,
      "pull_request_review_id" : 171399716,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622500",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622508"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622508"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:43:58Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622508",
      "id" : 230622508,
      "in_reply_to_id" : 230606357,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjUwOA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 382,
      "path" : "src/script/descriptor.cpp",
      "position" : 410,
      "pull_request_review_id" : 171399726,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622508",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622520"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622520"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:44:05Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622520",
      "id" : 230622520,
      "in_reply_to_id" : 230606363,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjUyMA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 392,
      "path" : "src/script/descriptor.cpp",
      "position" : 420,
      "pull_request_review_id" : 171399739,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622520",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622538"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:44:12Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}\n+};\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return \"combo(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = \"combo(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+/** A parsed combo(P) descriptor. */\n+class ComboDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider& out) const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        CKeyID keyid = key.GetID();\n-        {\n-            CScript p2pk = GetScriptForRawPubKey(key);\n-            CScript p2pkh = GetScriptForDestination(keyid);\n-            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n-            out.pubkeys.emplace(keyid, key);\n-            out.origins.emplace(keyid, std::move(info));\n-        }\n-        if (key.IsCompressed()) {\n-            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n-            CScriptID p2wpkh_id(p2wpkh);\n-            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n-            out.scripts.emplace(p2wpkh_id, p2wpkh);\n-            output_scripts.push_back(std::move(p2wpkh));\n-            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        std::vector<CScript> ret;\n+        CKeyID id = keys[0].GetID();\n+        ret.emplace_back(GetScriptForRawPubKey(keys[0])); // P2PK\n+        ret.emplace_back(GetScriptForDestination(id)); // P2PKH\n+        if (keys[0].IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(id));\n+            out.scripts.emplace(CScriptID(p2wpkh), p2wpkh);\n+            ret.emplace_back(p2wpkh);\n+            ret.emplace_back(GetScriptForDestination(CScriptID(p2wpkh))); // P2SH-P2WPKH\n         }\n-        return true;\n+        return ret;\n     }\n+public:\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"combo\") {}\n+};\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor final : public DescriptorImpl\n+{\n+    const int m_threshold;\n+protected:\n+    std::string ToStringExtra() const override { return strprintf(\"%i\", m_threshold); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForMultisig(m_threshold, keys)); }\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : DescriptorImpl(std::move(providers), {}, \"multi\"), m_threshold(threshold) {}\n+};\n+\n+/** A parsed sh(...) descriptor. */\n+class SHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>&) const override { return Singleton(GetScriptForDestination(CScriptID(script))); }\n+public:\n+    SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622538",
      "id" : 230622538,
      "in_reply_to_id" : 230606368,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjUzOA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 463,
      "path" : "src/script/descriptor.cpp",
      "position" : 492,
      "pull_request_review_id" : 171399758,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622538",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622550"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:44:19Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+};\n \n-/** A parsed combo(P) descriptor. */\n-class ComboDescriptor final : public Descriptor\n+/** A parsed pkh(P) descriptor. */\n+class PKHDescriptor final : public DescriptorImpl\n {\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(keys[0].GetID())); }\n+public:\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+};\n \n+/** A parsed wpkh(P) descriptor. */\n+class WPKHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0KeyHash(keys[0].GetID()))); }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}\n+};\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return \"combo(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = \"combo(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+/** A parsed combo(P) descriptor. */\n+class ComboDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider& out) const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        CKeyID keyid = key.GetID();\n-        {\n-            CScript p2pk = GetScriptForRawPubKey(key);\n-            CScript p2pkh = GetScriptForDestination(keyid);\n-            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n-            out.pubkeys.emplace(keyid, key);\n-            out.origins.emplace(keyid, std::move(info));\n-        }\n-        if (key.IsCompressed()) {\n-            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n-            CScriptID p2wpkh_id(p2wpkh);\n-            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n-            out.scripts.emplace(p2wpkh_id, p2wpkh);\n-            output_scripts.push_back(std::move(p2wpkh));\n-            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        std::vector<CScript> ret;\n+        CKeyID id = keys[0].GetID();\n+        ret.emplace_back(GetScriptForRawPubKey(keys[0])); // P2PK\n+        ret.emplace_back(GetScriptForDestination(id)); // P2PKH\n+        if (keys[0].IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(id));\n+            out.scripts.emplace(CScriptID(p2wpkh), p2wpkh);\n+            ret.emplace_back(p2wpkh);\n+            ret.emplace_back(GetScriptForDestination(CScriptID(p2wpkh))); // P2SH-P2WPKH\n         }\n-        return true;\n+        return ret;\n     }\n+public:\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"combo\") {}\n+};\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor final : public DescriptorImpl\n+{\n+    const int m_threshold;\n+protected:\n+    std::string ToStringExtra() const override { return strprintf(\"%i\", m_threshold); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForMultisig(m_threshold, keys)); }\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : DescriptorImpl(std::move(providers), {}, \"multi\"), m_threshold(threshold) {}\n+};\n+\n+/** A parsed sh(...) descriptor. */\n+class SHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>&) const override { return Singleton(GetScriptForDestination(CScriptID(script))); }\n+public:\n+    SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n+};\n+\n+/** A parsed wsh(...) descriptor. */\n+class WSHDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>&) const override { return Singleton(GetScriptForDestination(WitnessV0ScriptHash(script))); }\n+public:\n+    WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622550",
      "id" : 230622550,
      "in_reply_to_id" : 230606373,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjU1MA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 472,
      "path" : "src/script/descriptor.cpp",
      "position" : 501,
      "pull_request_review_id" : 171399777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622550",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622557"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622557"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T02:44:25Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230622557",
      "id" : 230622557,
      "in_reply_to_id" : 230606426,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYyMjU1Nw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 217,
      "path" : "src/script/descriptor.cpp",
      "position" : 242,
      "pull_request_review_id" : 171399784,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230622557",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230659536"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230659536"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I mean:\r\n\r\n```\r\nsize_t pos = extra.size() > 0 ? 1 : 0;\r\n```",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T08:10:21Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230659536",
      "id" : 230659536,
      "in_reply_to_id" : 230606091,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDY1OTUzNg==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 194,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171444361,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230659536",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230663283"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230663283"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, obviously :-)  But I was thinking \"redundancy\" in the sense that the function also was declared as `final`. \r\n\r\nRationale: [Virtual functions should specify exactly one of virtual, override, or final](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T08:27:12Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230663283",
      "id" : 230663283,
      "in_reply_to_id" : 230606297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDY2MzI4Mw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 227,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171448776,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230663283",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230665444"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230665444"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Currently if `extra.size()` is 0 `pos` is `0` because `0 > 0` is `false` and `false` is `0`? I also like dumbing it down a bit with the ternary operator :-)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T08:36:39Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230665444",
      "id" : 230665444,
      "in_reply_to_id" : 230606091,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDY2NTQ0NA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 194,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171451487,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230665444",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230670527"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230670527"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's already used by the test `BOOST_CHECK(spks == spks_cached)`, but probably deserves its own test.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T08:57:07Z",
      "diff_hunk" : "@@ -24,6 +24,11 @@ struct KeyOriginInfo\n {\n     unsigned char fingerprint[4];\n     std::vector<uint32_t> path;\n+\n+    friend bool operator==(const KeyOriginInfo& a, const KeyOriginInfo& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230670527",
      "id" : 230670527,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDY3MDUyNw==",
      "original_commit_id" : "94677cc393a4663603f2a1e2cd5b6f2cafc6dd22",
      "original_position" : 5,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 171457854,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230670527",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230678480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230678480"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fun fact: this is only place in the entire codebase where a function is declared `final` (search `\\).* final[$\\ ]`). I like the suggestion in this guideline, though no strong opinion.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T09:23:52Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230678480",
      "id" : 230678480,
      "in_reply_to_id" : 230606297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDY3ODQ4MA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 227,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171457854,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230678480",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230680064"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230680064"
         }
      },
      "author_association" : "MEMBER",
      "body" : "One comment is probably enough for something that can be changed with find & replace :-)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T09:28:36Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230680064",
      "id" : 230680064,
      "in_reply_to_id" : 230606321,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDY4MDA2NA==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 297,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171457854,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230680064",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230847308"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230847308"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can you add description of this method: Return string containing initial arguments to descriptor function (prior to any key or script arguments)?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T17:48:25Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;\n \n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230847308",
      "id" : 230847308,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg0NzMwOA==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 41,
      "path" : "src/script/descriptor.cpp",
      "position" : 138,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230847308",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230852092"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230852092"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can you add a description of this member: List of descriptor public key arguments. Length > 1 for multisig descriptors, 1 for key or key hash descriptors, 0 for raw or address descriptors?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T18:02:47Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230852092",
      "id" : 230852092,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg1MjA5Mg==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 19,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230852092",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230853173"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230853173"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can you add a description of this member: Single descriptor script argument. Set for sh/wsh descriptors, unset for other types of descriptors?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T18:06:22Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230853173",
      "id" : 230853173,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg1MzE3Mw==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 20,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230853173",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230853421"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230853421"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can you add a description of this member: name of descriptor function?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T18:07:11Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230853421",
      "id" : 230853421,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg1MzQyMQ==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 21,
      "path" : "src/script/descriptor.cpp",
      "position" : 134,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230853421",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230854836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230854836"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I would maybe call these members `m_pubkey_args` and `m_script_arg` to give names more meaning. This would also avoid `RawDescriptor::m_script` shadowing `DescriptorImpl::m_script`, which is kind of confusing.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T18:11:24Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230854836",
      "id" : 230854836,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg1NDgzNg==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 20,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230854836",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230858743"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230858743"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can you add a more complete description of this method: Expand descriptor into corresponding scriptPubKey(s) using keys indicated by `m_pubkey` arguments?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T18:23:08Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;\n \n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; } //!< Invoked when no m_script is set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230858743",
      "id" : 230858743,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg1ODc0Mw==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 42,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230858743",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230863886"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230863886"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe call this method Expand. It seem inconsistent to talk about \"expanding descriptors\" externally and \"making scripts\" internally when they seem refer to same thing.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T18:38:39Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;\n \n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; } //!< Invoked when no m_script is set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230863886",
      "id" : 230863886,
      "in_reply_to_id" : 230858743,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg2Mzg4Ng==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 42,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230863886",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230867992"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230867992"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Having these two overloaded methods and deciding to call one or other other at runtime, then asserting the right one is called and overloaded seems awkward. I think it'd be better to replace both of these with a single pure virtual method:\r\n\r\n```c++\r\nvirtual void ExpandImpl(\r\n    const std::vector<CPubKey>& pubkeys,\r\n    const CScript* script,\r\n    std::vector<CScript>& output_scripts,\r\n    FlatSigningProvider& out) = 0;\r\n```\r\n\r\nThis would also make the new method more consistent with the existing `Descriptor::Expand`.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T18:50:34Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;\n \n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; } //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; } //!< Invoked for each CScript produced by m_script.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230867992",
      "id" : 230867992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg2Nzk5Mg==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 43,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171678271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230867992",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230881249"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230881249"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@practicalswift Oh, good point - I never realized that `override` would be redundant with `final`. Fixing.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:29:18Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230881249",
      "id" : 230881249,
      "in_reply_to_id" : 230606297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg4MTI0OQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 227,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171720653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230881249",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230881563"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230881563"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this function is too trivial. It's just a dumb datastructure and a comparison operator. What would the test do? Replicate the implementation and verify it does the same? Such tests are not useful.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:30:14Z",
      "diff_hunk" : "@@ -24,6 +24,11 @@ struct KeyOriginInfo\n {\n     unsigned char fingerprint[4];\n     std::vector<uint32_t> path;\n+\n+    friend bool operator==(const KeyOriginInfo& a, const KeyOriginInfo& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230881563",
      "id" : 230881563,
      "in_reply_to_id" : 230670527,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg4MTU2Mw==",
      "original_commit_id" : "94677cc393a4663603f2a1e2cd5b6f2cafc6dd22",
      "original_position" : 5,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 171721074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230881563",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890669"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:56:51Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890669",
      "id" : 230890669,
      "in_reply_to_id" : 230606091,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MDY2OQ==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 194,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171732343,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890669",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890746"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:57:03Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;\n \n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890746",
      "id" : 230890746,
      "in_reply_to_id" : 230847308,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MDc0Ng==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 41,
      "path" : "src/script/descriptor.cpp",
      "position" : 138,
      "pull_request_review_id" : 171732437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890746",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:57:10Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890794",
      "id" : 230890794,
      "in_reply_to_id" : 230853173,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MDc5NA==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 20,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171732494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890794",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890839"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890839"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:57:19Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890839",
      "id" : 230890839,
      "in_reply_to_id" : 230853421,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MDgzOQ==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 21,
      "path" : "src/script/descriptor.cpp",
      "position" : 134,
      "pull_request_review_id" : 171732556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890839",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890957"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point, I didn't even realize it was shadowing.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:57:48Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230890957",
      "id" : 230890957,
      "in_reply_to_id" : 230854836,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MDk1Nw==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 20,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171732712,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230890957",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230891213"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230891213"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Rewritten (see next suggestion) and added more comments.\r\n\r\nI don't think it should be called `Expand`, as it's only one piece of the expansion process.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:58:34Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;\n \n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; } //!< Invoked when no m_script is set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230891213",
      "id" : 230891213,
      "in_reply_to_id" : 230858743,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MTIxMw==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 42,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171733039,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230891213",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230891580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230891580"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's much better indeed, as it allows static checking that all implementations provide it.\r\n\r\nI don't think Expand is a good name.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-05T19:59:44Z",
      "diff_hunk" : "@@ -202,212 +202,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<Descriptor> m_script;\n+    const std::string m_name;\n \n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; } //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; } //!< Invoked for each CScript produced by m_script.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r230891580",
      "id" : 230891580,
      "in_reply_to_id" : 230867992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDg5MTU4MA==",
      "original_commit_id" : "c957f5bd34c8ee53430c54c40454256c62778f33",
      "original_position" : 43,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 171733501,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230891580",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r231043088"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231043088"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `output_script` -> `output_scripts` (was already wrong in the original)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-06T09:06:05Z",
      "diff_hunk" : "@@ -44,8 +44,18 @@ struct Descriptor {\n      * provider: the provider to query for private keys in case of hardened derivation.\n      * output_script: the expanded scriptPubKeys will be put here.\n      * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     * cache: vector which will be overwritten with cache data necessary to-evaluate the descriptor at this point without access to private keys.\n      */\n-    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n+    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const = 0;\n+\n+    /** Expand a descriptor at a specified position using cached expansion data.\n+     *\n+     * pos: the position at which to expand the descriptor. If IsRange() is false, this is ignored.\n+     * cache: vector from which cached expansion data will be read.\n+     * output_script: the expanded scriptPubKeys will be put here.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r231043088",
      "id" : 231043088,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTA0MzA4OA==",
      "original_commit_id" : "ab67eb24bb039a8bb8ff3c7363e6667bf7a5ea6e",
      "original_position" : 13,
      "path" : "src/script/descriptor.h",
      "position" : 13,
      "pull_request_review_id" : 171917106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231043088",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r231043596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231043596"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think the comments were lost in a recent refactor :-(",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-06T09:07:52Z",
      "diff_hunk" : "@@ -88,9 +88,18 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n         for (int t = 0; t < 2; ++t) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r231043596",
      "id" : 231043596,
      "in_reply_to_id" : 230549061,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTA0MzU5Ng==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 2,
      "path" : "src/test/descriptor_tests.cpp",
      "position" : 22,
      "pull_request_review_id" : 171917106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231043596",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Nice. Concept ACK.",
      "created_at" : "2018-11-07T02:13:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#issuecomment-436479167",
      "id" : 436479167,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14646",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjQ3OTE2Nw==",
      "updated_at" : "2018-11-07T02:13:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436479167",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r231636363"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231636363"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I added a new commit with more comments.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-07T19:02:45Z",
      "diff_hunk" : "@@ -88,9 +88,18 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n         for (int t = 0; t < 2; ++t) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r231636363",
      "id" : 231636363,
      "in_reply_to_id" : 230549061,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTYzNjM2Mw==",
      "original_commit_id" : "0bfff69c3372fb927dbbc4a2b2343e026f5fb5d8",
      "original_position" : 2,
      "path" : "src/test/descriptor_tests.cpp",
      "position" : 22,
      "pull_request_review_id" : 172648779,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231636363",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232168071"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232168071"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `poisition` -> `position`",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-09T08:07:05Z",
      "diff_hunk" : "@@ -79,28 +79,42 @@ void Check(const std::string& prv, const std::string& pub, int flags, const std:\n     BOOST_CHECK_EQUAL(parse_pub->IsRange(), (flags & RANGE) != 0);\n     BOOST_CHECK_EQUAL(parse_priv->IsRange(), (flags & RANGE) != 0);\n \n-\n-    // Is not ranged descriptor, only a single result is expected.\n+    // * For ranged descriptors,  the `scripts` parameter is a list of expected result outputs, for subsequent\n+    //   positions to evaluate the descriptors on (so the first element of `scripts` is for evaluating the\n+    //   descriptor at 0; the second at 1; and so on). To verify this, we evaluate the descriptors once for\n+    //   each element in `scripts`.\n+    // * For non-ranged descriptors, we evaluate the descriptors at positions 0, 1, and 2, but expect the\n+    //   same result in each case, namely the first element of `scripts`. Because of that, the size of\n+    //   `scripts` must be one in that case.\n     if (!(flags & RANGE)) assert(scripts.size() == 1);\n-\n     size_t max = (flags & RANGE) ? scripts.size() : 3;\n+\n+    // Iterate over the position we'll evaluate the descriptors in.\n     for (size_t i = 0; i < max; ++i) {\n+        // Call the expected result scripts `ref`.\n         const auto& ref = scripts[(flags & RANGE) ? i : 0];\n+        // When t=0, evaluate the `prv` descriptor; when t=1, evaluate the `pub` descriptor.\n         for (int t = 0; t < 2; ++t) {\n+            // When the descriptor is hardened, evaluate with access to the private keys inside.\n             const FlatSigningProvider& key_provider = (flags & HARDENED) ? keys_priv : keys_pub;\n+\n+            // Evaluate the descriptor selected by `t` in poisition `i`.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232168071",
      "id" : 232168071,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjE2ODA3MQ==",
      "original_commit_id" : "729b8187dd795e31a87cad9ce0ba3638cf01f502",
      "original_position" : 26,
      "path" : "src/test/descriptor_tests.cpp",
      "position" : 29,
      "pull_request_review_id" : 173305703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232168071",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232168283"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232168283"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Still missing `explicit`? :-)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-09T08:08:15Z",
      "diff_hunk" : "@@ -202,212 +204,236 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkeys;\n+    const std::unique_ptr<DescriptorImpl> m_script;\n+    const std::string m_name;\n \n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n+protected:\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, FlatSigningProvider&) const { assert(false); return {}; }; //!< Invoked when no m_script is set.\n+    virtual std::vector<CScript> MakeScripts(const CScript& script, const std::vector<CPubKey>& pubkeys) const { assert(false); return {}; }; //!< Invoked for each CScript produced by m_script.\n \n public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkeys(std::move(pubkeys)), m_script(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const override final\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n-\n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n-    }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n-    {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script) {\n+            if (m_script->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkeys) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const override final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkeys.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkeys) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n+        std::vector<CScript> subscripts;\n+        if (m_script) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n+        }\n+\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(subscript, pubkeys);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));\n+                }\n+            }\n+        } else {\n+            output_scripts = MakeScripts(pubkeys, out);\n+        }\n         return true;\n     }\n+\n+    bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache = nullptr) const override final\n+    {\n+        return ExpandHelper(pos, provider, nullptr, output_scripts, out, cache);\n+    }\n+\n+    bool ExpandFromCache(int pos, const std::vector<unsigned char>& cache, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override final\n+    {\n+        Span<const unsigned char> span = MakeSpan(cache);\n+        return ExpandHelper(pos, DUMMY_SIGNING_PROVIDER, &span, output_scripts, out, nullptr) && span.size() == 0;\n+    }\n };\n \n-/** A parsed sh(S) or wsh(S) descriptor. */\n-class ConvertorDescriptor : public Descriptor\n+/** Construct a vector with one element, which is moved into it. */\n+template<typename T>\n+std::vector<T> Singleton(T elem)\n {\n-    const std::function<CScript(const CScript&)> m_convert_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<Descriptor> m_descriptor;\n+    std::vector<T> ret;\n+    ret.emplace_back(std::move(elem));\n+    return ret;\n+}\n \n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public DescriptorImpl\n+{\n+    const CTxDestination m_destination;\n+protected:\n+    std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n public:\n-    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+    AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n+};\n \n-    bool IsRange() const override { return m_descriptor->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<CScript> sub;\n-        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n-        output_scripts.clear();\n-        for (const auto& script : sub) {\n-            CScriptID id(script);\n-            out.scripts.emplace(CScriptID(script), script);\n-            output_scripts.push_back(m_convert_fn(script));\n-        }\n-        return true;\n-    }\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public DescriptorImpl\n+{\n+    const CScript m_script;\n+protected:\n+    std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, FlatSigningProvider&) const override { return Singleton(m_script); }\n+public:\n+    RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n };\n \n-CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n-CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+/** A parsed pk(P) descriptor. */\n+class PKDescriptor final : public DescriptorImpl\n+{\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+public:\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232168283",
      "id" : 232168283,
      "in_reply_to_id" : 230606339,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjE2ODI4Mw==",
      "original_commit_id" : "582685e75bcc3bd0abe9736c65ae07cf18f8a2bf",
      "original_position" : 370,
      "path" : "src/script/descriptor.cpp",
      "position" : 398,
      "pull_request_review_id" : 173305963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232168283",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232170947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232170947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure what policy we have with regards to using the standard algorithms, but I guess this could use `std::transform`?\r\n\r\nOne argument for using the standard algorithms would be that it prepares us for C++17 parallel algorithms for the STL.",
      "commit_id" : "729b8187dd795e31a87cad9ce0ba3638cf01f502",
      "created_at" : "2018-11-09T08:21:22Z",
      "diff_hunk" : "@@ -202,212 +204,251 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n+    //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n+    const std::unique_ptr<DescriptorImpl> m_script_arg;\n+    //! The string name of the descriptor function.\n+    const std::string m_name;\n+\n+protected:\n+    //! Return a serialization of anything except pubkey and script arguments, to be prepended to those.\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+\n+    /** A helper function to construct the scripts for this descriptor.\n+     *\n+     *  This function is invoked once for every CScript produced by evaluating\n+     *  m_script_arg, or just once in case m_script_arg is nullptr.\n+\n+     *  @param pubkeys The evaluations of the m_pubkey_args field.\n+     *  @param script The evaluation of m_script_arg (or nullptr when m_script_arg is nullptr).\n+     *  @param out A FlatSigningProvider to put scripts or public keys in that are necessary to the solver.\n+     *             The script and pubkeys argument to this function are automatically added.\n+     *  @return A vector with scriptPubKeys for this descriptor.\n+     */\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n \n public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_script_arg(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const final\n     {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script_arg) {\n+            if (m_script_arg->IsRange()) return true;\n+        }\n+        return false;\n     }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n \n-public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0 ? 1 : 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n+        }\n+        if (m_script_arg) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script_arg->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n+        }\n+        out = std::move(ret) + \")\";\n         return true;\n     }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n \n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    std::string ToString() const final\n     {\n         std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n     }\n-};\n \n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n-        }\n-        return false;\n-    }\n+        std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n+        entries.reserve(m_pubkey_args.size());\n \n-    std::string ToString() const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkey_args) {\n+            entries.emplace_back();\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;\n+                if (!(compressed || uncompressed)) return false;\n+                CPubKey pubkey(cache_read->begin(), cache_read->begin() + (compressed ? 33 : 65));\n+                entries.back().first = pubkey;\n+                *cache_read = cache_read->subspan(compressed ? 33 : 65);\n+            }\n+            if (cache_write) {\n+                cache_write->insert(cache_write->end(), entries.back().first.begin(), entries.back().first.end());\n+            }\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        std::vector<CScript> subscripts;\n+        if (m_script_arg) {\n+            FlatSigningProvider subprovider;\n+            if (!m_script_arg->ExpandHelper(pos, arg, cache_read, subscripts, subprovider, cache_write)) return false;\n+            out = Merge(out, subprovider);\n         }\n-        out = std::move(ret) + \")\";\n-        return true;\n-    }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n-            entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n-        }\n         std::vector<CPubKey> pubkeys;\n         pubkeys.reserve(entries.size());\n         for (auto& entry : entries) {\n             pubkeys.push_back(entry.first);\n             out.origins.emplace(entry.first.GetID(), std::move(entry.second));\n             out.pubkeys.emplace(entry.first.GetID(), entry.first);\n         }\n-        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        if (m_script_arg) {\n+            for (const auto& subscript : subscripts) {\n+                out.scripts.emplace(CScriptID(subscript), subscript);\n+                std::vector<CScript> addscripts = MakeScripts(pubkeys, &subscript, out);\n+                for (auto& addscript : addscripts) {\n+                    output_scripts.push_back(std::move(addscript));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232170947",
      "id" : 232170947,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjE3MDk0Nw==",
      "original_commit_id" : "729b8187dd795e31a87cad9ce0ba3638cf01f502",
      "original_position" : 298,
      "path" : "src/script/descriptor.cpp",
      "position" : 298,
      "pull_request_review_id" : 173309299,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-09T08:21:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232170947",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232171125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232171125"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why `>=` instead of just equality? In what case would it be longer?",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-09T08:22:08Z",
      "diff_hunk" : "@@ -277,20 +279,33 @@ class DescriptorImpl : public Descriptor\n \n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const final\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkey_args.size());\n \n         // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n         for (const auto& p : m_pubkey_args) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r232171125",
      "id" : 232171125,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjE3MTEyNQ==",
      "original_commit_id" : "ab67eb24bb039a8bb8ff3c7363e6667bf7a5ea6e",
      "original_position" : 98,
      "path" : "src/script/descriptor.cpp",
      "position" : 278,
      "pull_request_review_id" : 173305703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232171125",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r234260295"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234260295"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There can be multiple public keys in one descriptor, and the cache contains all of them concatenated.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-16T16:11:06Z",
      "diff_hunk" : "@@ -277,20 +279,33 @@ class DescriptorImpl : public Descriptor\n \n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const final\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n         entries.reserve(m_pubkey_args.size());\n \n         // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n         for (const auto& p : m_pubkey_args) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;\n+            if (cache_read) {\n+                // Cached expanded public key exists, use it.\n+                if (cache_read->size() == 0) return false;\n+                bool compressed = ((*cache_read)[0] == 0x02 || (*cache_read)[0] == 0x03) && cache_read->size() >= 33;\n+                bool uncompressed = ((*cache_read)[0] == 0x04) && cache_read->size() >= 65;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r234260295",
      "id" : 234260295,
      "in_reply_to_id" : 232171125,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDI2MDI5NQ==",
      "original_commit_id" : "ab67eb24bb039a8bb8ff3c7363e6667bf7a5ea6e",
      "original_position" : 98,
      "path" : "src/script/descriptor.cpp",
      "position" : 278,
      "pull_request_review_id" : 175871254,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/234260295",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r235785867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235785867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Doesn't seem like there is a case where both `cache_read` and `cache_write` should be supplied, right? If you make that explicit / an error condition we can rely on it elsewhere.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-22T16:51:52Z",
      "diff_hunk" : "@@ -202,212 +204,251 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CTxDestination m_destination;\n+    //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n+    //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n+    const std::unique_ptr<DescriptorImpl> m_script_arg;\n+    //! The string name of the descriptor function.\n+    const std::string m_name;\n+\n+protected:\n+    //! Return a serialization of anything except pubkey and script arguments, to be prepended to those.\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+\n+    /** A helper function to construct the scripts for this descriptor.\n+     *\n+     *  This function is invoked once for every CScript produced by evaluating\n+     *  m_script_arg, or just once in case m_script_arg is nullptr.\n+\n+     *  @param pubkeys The evaluations of the m_pubkey_args field.\n+     *  @param script The evaluation of m_script_arg (or nullptr when m_script_arg is nullptr).\n+     *  @param out A FlatSigningProvider to put scripts or public keys in that are necessary to the solver.\n+     *             The script and pubkeys argument to this function are automatically added.\n+     *  @return A vector with scriptPubKeys for this descriptor.\n+     */\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n \n public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_script_arg(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsRange() const final\n     {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script_arg) {\n+            if (m_script_arg->IsRange()) return true;\n+        }\n+        return false;\n     }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n \n-public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n-\n-    bool IsRange() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        output_scripts = std::vector<CScript>{m_script};\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0 ? 1 : 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n+        }\n+        if (m_script_arg) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script_arg->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n+        }\n+        out = std::move(ret) + \")\";\n         return true;\n     }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n-{\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n \n-public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n-\n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    std::string ToString() const final\n     {\n         std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n-        return true;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n     }\n-};\n \n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n \n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n-\n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r235785867",
      "id" : 235785867,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNTc4NTg2Nw==",
      "original_commit_id" : "729b8187dd795e31a87cad9ce0ba3638cf01f502",
      "original_position" : 223,
      "path" : "src/script/descriptor.cpp",
      "position" : 261,
      "pull_request_review_id" : 177733379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235785867",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r235786983"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235786983"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How about instead extracting `GetPubKeyInfo` and changing up the caller in `ExpandHelper` to only request the desired information? This looks doable if `cache_read` and `cache_write` are mutually exclusive.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-22T16:57:03Z",
      "diff_hunk" : "@@ -94,9 +94,9 @@ class ConstPubkeyProvider final : public PubkeyProvider\n \n public:\n     ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n-        key = m_pubkey;\n+        if (key) *key = m_pubkey;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r235786983",
      "id" : 235786983,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNTc4Njk4Mw==",
      "original_commit_id" : "729b8187dd795e31a87cad9ce0ba3638cf01f502",
      "original_position" : 28,
      "path" : "src/script/descriptor.cpp",
      "position" : 28,
      "pull_request_review_id" : 177734920,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/235786983",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-11-27T20:29:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#issuecomment-442205565",
      "id" : 442205565,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14646",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0MjIwNTU2NQ==",
      "updated_at" : "2018-11-27T20:29:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442205565",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r236834645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236834645"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/14646#discussion_r235786983\r\n\r\n> How about instead extracting GetPubKeyInfo and changing up the caller in ExpandHelper to only request the desired information? This looks doable if cache_read and cache_write are mutually exclusive.\r\n\r\nIt does seem like it would be a minor simplification to have separate methods for retrieving CPubKey and KeyOriginInfo, since KeyOriginInfo isn't needed by ExpandHelper. But that would make this PR bigger, and I also don't see what it has to do with cache read/write becoming exclusive options.",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-11-27T20:31:14Z",
      "diff_hunk" : "@@ -94,9 +94,9 @@ class ConstPubkeyProvider final : public PubkeyProvider\n \n public:\n     ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n-    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& key, KeyOriginInfo& info) const override\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey* key, KeyOriginInfo& info) const override\n     {\n-        key = m_pubkey;\n+        if (key) *key = m_pubkey;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r236834645",
      "id" : 236834645,
      "in_reply_to_id" : 235786983,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNjgzNDY0NQ==",
      "original_commit_id" : "729b8187dd795e31a87cad9ce0ba3638cf01f502",
      "original_position" : 28,
      "path" : "src/script/descriptor.cpp",
      "position" : 28,
      "pull_request_review_id" : 178994387,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-11-28T23:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/236834645",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2018-11-28T23:26:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#issuecomment-442645467",
      "id" : 442645467,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14646",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0MjY0NTQ2Nw==",
      "updated_at" : "2018-11-28T23:26:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442645467",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240082037"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240082037"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `of` -> `for` ",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-12-10T04:30:30Z",
      "diff_hunk" : "@@ -202,219 +202,240 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n-{\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    CScript m_script;\n+    //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240082037",
      "id" : 240082037,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDA4MjAzNw==",
      "original_commit_id" : "6be0fb4b3f865e80e0465c2266b0560bd6bbb406",
      "original_position" : 29,
      "path" : "src/script/descriptor.cpp",
      "position" : 129,
      "pull_request_review_id" : 183028560,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-12-11T10:36:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240082037",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240190425"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240190425"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: remove `-`",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-12-10T12:25:04Z",
      "diff_hunk" : "@@ -48,8 +48,18 @@ struct Descriptor {\n      * provider: the provider to query for private keys in case of hardened derivation.\n      * output_script: the expanded scriptPubKeys will be put here.\n      * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     * cache: vector which will be overwritten with cache data necessary to-evaluate the descriptor at this point without access to private keys.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240190425",
      "id" : 240190425,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDE5MDQyNQ==",
      "original_commit_id" : "82df4c64ffa2f0dd45e7ae694903615358f121a6",
      "original_position" : 4,
      "path" : "src/script/descriptor.h",
      "position" : 4,
      "pull_request_review_id" : 183028560,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-12-11T10:36:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240190425",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240662924"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240662924"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: explain that if we already have a cache, we don't want `GetPubKey` to return public keys, since we're getting them from the cache ourselves. This is counter intuitive given the name of the function, but the point is to only make `GetPubKey` do work if our cache is empty.\r\n\r\nAlternatively, maybe the stuff below under `if (cache_read)` belongs in `GetPubKey`?\r\n\r\nMaybe add an assert to `GetPubKey` if `KeyOriginInfo& info` is non empty and doesn't match `m_extkey.pubkey.GetID()`? ",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-12-11T15:39:47Z",
      "diff_hunk" : "@@ -202,219 +204,261 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n-{\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n-\n-public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+    //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n+    //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n+    const std::unique_ptr<DescriptorImpl> m_script_arg;\n+    //! The string name of the descriptor function.\n+    const std::string m_name;\n+\n+protected:\n+    //! Return a serialization of anything except pubkey and script arguments, to be prepended to those.\n+    virtual std::string ToStringExtra() const { return \"\"; }\n+\n+    /** A helper function to construct the scripts for this descriptor.\n+     *\n+     *  This function is invoked once for every CScript produced by evaluating\n+     *  m_script_arg, or just once in case m_script_arg is nullptr.\n+\n+     *  @param pubkeys The evaluations of the m_pubkey_args field.\n+     *  @param script The evaluation of m_script_arg (or nullptr when m_script_arg is nullptr).\n+     *  @param out A FlatSigningProvider to put scripts or public keys in that are necessary to the solver.\n+     *             The script and pubkeys argument to this function are automatically added.\n+     *  @return A vector with scriptPubKeys for this descriptor.\n+     */\n+    virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n \n public:\n-    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+    DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_script_arg(std::move(script)), m_name(name) {}\n \n-    bool IsRange() const override { return m_provider->IsRange(); }\n-    bool IsSolvable() const override { return true; }\n-    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret;\n-        if (!m_provider->ToPrivateString(arg, ret)) return false;\n-        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n-        return true;\n-    }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    bool IsSolvable() const override\n     {\n-        CPubKey key;\n-        KeyOriginInfo info;\n-        if (!m_provider->GetPubKey(pos, arg, key, info)) return false;\n-        output_scripts = std::vector<CScript>{m_script_fn(key)};\n-        out.origins.emplace(key.GetID(), std::move(info));\n-        out.pubkeys.emplace(key.GetID(), key);\n+        if (m_script_arg) {\n+            if (!m_script_arg->IsSolvable()) return false;\n+        }\n         return true;\n     }\n-};\n-\n-CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n-CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n-CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n-\n-/** A parsed multi(...) descriptor. */\n-class MultisigDescriptor : public Descriptor\n-{\n-    int m_threshold;\n-    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n \n-public:\n-    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n-\n-    bool IsRange() const override\n+    bool IsRange() const final\n     {\n-        for (const auto& p : m_providers) {\n-            if (p->IsRange()) return true;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        if (m_script_arg) {\n+            if (m_script_arg->IsRange()) return true;\n         }\n         return false;\n     }\n \n-    bool IsSolvable() const override { return true; }\n-\n-    std::string ToString() const override\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n     {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            ret += \",\" + p->ToString();\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0 ? 1 : 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (priv) {\n+                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n+            } else {\n+                tmp = pubkey->ToString();\n+            }\n+            ret += std::move(tmp);\n         }\n-        return std::move(ret) + \")\";\n-    }\n-\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n-    {\n-        std::string ret = strprintf(\"multi(%i\", m_threshold);\n-        for (const auto& p : m_providers) {\n-            std::string sub;\n-            if (!p->ToPrivateString(arg, sub)) return false;\n-            ret += \",\" + std::move(sub);\n+        if (m_script_arg) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_script_arg->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n         }\n         out = std::move(ret) + \")\";\n         return true;\n     }\n \n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    std::string ToString() const final\n+    {\n+        std::string ret;\n+        ToStringHelper(nullptr, ret, false);\n+        return ret;\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override final { return ToStringHelper(&arg, out, true); }\n+\n+    bool ExpandHelper(int pos, const SigningProvider& arg, Span<const unsigned char>* cache_read, std::vector<CScript>& output_scripts, FlatSigningProvider& out, std::vector<unsigned char>* cache_write) const\n     {\n         std::vector<std::pair<CPubKey, KeyOriginInfo>> entries;\n-        entries.reserve(m_providers.size());\n-        // Construct temporary data in `entries`, to avoid producing output in case of failure.\n-        for (const auto& p : m_providers) {\n+        entries.reserve(m_pubkey_args.size());\n+\n+        // Construct temporary data in `entries` and `subscripts`, to avoid producing output in case of failure.\n+        for (const auto& p : m_pubkey_args) {\n             entries.emplace_back();\n-            if (!p->GetPubKey(pos, arg, entries.back().first, entries.back().second)) return false;\n+            if (!p->GetPubKey(pos, arg, cache_read ? nullptr : &entries.back().first, entries.back().second)) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240662924",
      "id" : 240662924,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDY2MjkyNA==",
      "original_commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "original_position" : 273,
      "path" : "src/script/descriptor.cpp",
      "position" : 273,
      "pull_request_review_id" : 183744065,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-12-11T16:21:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240662924",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240677238"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240677238"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can we rename this to `m_sub_descriptor_arg`? (I found that a replace-all reduced my headache)",
      "commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "created_at" : "2018-12-11T16:10:48Z",
      "diff_hunk" : "@@ -202,219 +204,261 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n-/** A parsed addr(A) descriptor. */\n-class AddressDescriptor final : public Descriptor\n-{\n-    CTxDestination m_destination;\n-\n-public:\n-    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n-        return true;\n-    }\n-};\n-\n-/** A parsed raw(H) descriptor. */\n-class RawDescriptor final : public Descriptor\n-{\n-    CScript m_script;\n-\n-public:\n-    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n-\n-    bool IsRange() const override { return false; }\n-    bool IsSolvable() const override { return false; }\n-    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n-    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n-    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n-    {\n-        output_scripts = std::vector<CScript>{m_script};\n-        return true;\n-    }\n-};\n-\n-/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n-class SingleKeyDescriptor final : public Descriptor\n+/** Base class for all Descriptor implementations. */\n+class DescriptorImpl : public Descriptor\n {\n-    const std::function<CScript(const CPubKey&)> m_script_fn;\n-    const std::string m_fn_name;\n-    std::unique_ptr<PubkeyProvider> m_provider;\n+    //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size of Multisig).\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n+    //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n+    const std::unique_ptr<DescriptorImpl> m_script_arg;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#discussion_r240677238",
      "id" : 240677238,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDY3NzIzOA==",
      "original_commit_id" : "26879509f1a3b9fc0fa616164e5a88fdb344ac4d",
      "original_position" : 132,
      "path" : "src/script/descriptor.cpp",
      "position" : 132,
      "pull_request_review_id" : 183744065,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14646",
      "updated_at" : "2018-12-11T16:21:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240677238",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Because this is obviously intended to be followed-up by more work, I think we can leave the last couple nits to be addressed later",
      "created_at" : "2018-12-12T03:31:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14646#issuecomment-446449477",
      "id" : 446449477,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14646",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NjQ0OTQ3Nw==",
      "updated_at" : "2018-12-12T03:31:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446449477",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   }
]
