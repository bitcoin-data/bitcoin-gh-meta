[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK.\n\nWe have to implement crypto ourselves to keep the surface area small and avoid bringing in large dependencies. Differential fuzzing against a reference implementation is a great addition to testing the reference test vectors.\n\nThank you for your work, and welcome to Bitcoin Core!",
      "created_at" : "2021-08-14T19:38:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-898950491",
      "id" : 898950491,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841lOVb",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-14T19:38:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898950491",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@agroce / @guidovranken this may also interest you.",
      "created_at" : "2021-08-15T03:28:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-898989809",
      "id" : 898989809,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841lX7x",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T03:28:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898989809",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Essentially this is already done by Cryptofuzz which compares it against the Botan implementation, and is running on OSS-Fuzz in the bitcoin-core project\r\n\r\nhttps://github.com/guidovranken/cryptofuzz/blob/6dddb6bb97a2cd8d7bf915bca00d0411ccf5e1c0/modules/bitcoin/module.cpp#L417-L420",
      "created_at" : "2021-08-15T03:48:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-898991078",
      "id" : 898991078,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841lYPm",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T03:48:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/898991078",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6846644?v=4",
         "events_url" : "https://api.github.com/users/guidovranken/events{/privacy}",
         "followers_url" : "https://api.github.com/users/guidovranken/followers",
         "following_url" : "https://api.github.com/users/guidovranken/following{/other_user}",
         "gists_url" : "https://api.github.com/users/guidovranken/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/guidovranken",
         "id" : 6846644,
         "login" : "guidovranken",
         "node_id" : "MDQ6VXNlcjY4NDY2NDQ=",
         "organizations_url" : "https://api.github.com/users/guidovranken/orgs",
         "received_events_url" : "https://api.github.com/users/guidovranken/received_events",
         "repos_url" : "https://api.github.com/users/guidovranken/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/guidovranken/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/guidovranken/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/guidovranken"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Oh..I wasn't aware of the differential fuzzing for Bitcoin Core cryptographic libraries being done in Cryptofuzz. Crypofuzz is an incredible project! Could you please elaborate more on where the comparison with Botan implementation is happening?\r\n\r\nWould there be incremental value in fuzzing against D.J. Bernstein's reference implementation? And including the Keystream() function too in the Bitcoin Core/Cryptofuzz diferential fuzz tests?",
      "created_at" : "2021-08-19T18:48:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902156184",
      "id" : 902156184,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841xc-Y",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T18:48:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902156184",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692403396"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692403396"
         }
      },
      "author_association" : "MEMBER",
      "body" : "how is this different from\r\n\r\n```suggestion\r\n    while (fuzzed_data_provider.ConsumeBool()) {\r\n```\r\n\r\nAlso, could use `LIMITED_WHILE` to avoid unlimited runtime.",
      "commit_id" : "a63773439302f2cdef81e36c705bfd59046f6fa0",
      "created_at" : "2021-08-19T18:59:42Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692403396",
      "id" : 692403396,
      "line" : 292,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjQwMzM5Ng==",
      "original_commit_id" : "a63773439302f2cdef81e36c705bfd59046f6fa0",
      "original_line" : 292,
      "original_position" : 292,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 292,
      "pull_request_review_id" : 734359834,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-19T19:00:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692403396",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "btw, I don't mind adding the fuzz test here, even if it is redundant with oss-fuzz. Oss-fuzz is just one fuzzing providre, but I also run my own fuzzing servers to not put all eggs into one basket. I am sure others are running the Bitcoin Core fuzz target, too.",
      "created_at" : "2021-08-19T19:02:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902164938",
      "id" : 902164938,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841xfHK",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T19:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902164938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "+1 for what @MarcoFalke said. It'd be nice to be able to run this along with other fuzz targets on personal machines.",
      "created_at" : "2021-08-19T19:06:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902167984",
      "id" : 902167984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841xf2w",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T19:06:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902167984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK for the reasons @MarcoFalke mentioned",
      "created_at" : "2021-08-19T21:18:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902254545",
      "id" : 902254545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841x0_R",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T21:18:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902254545",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "There are fuzzers (e.g. https://github.com/bitcoin/bitcoin/pull/22585) not available via OSS-Fuzz, also.",
      "created_at" : "2021-08-19T22:34:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-902296051",
      "id" : 902296051,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5841x_Hz",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T22:34:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902296051",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/967816?v=4",
         "events_url" : "https://api.github.com/users/agroce/events{/privacy}",
         "followers_url" : "https://api.github.com/users/agroce/followers",
         "following_url" : "https://api.github.com/users/agroce/following{/other_user}",
         "gists_url" : "https://api.github.com/users/agroce/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/agroce",
         "id" : 967816,
         "login" : "agroce",
         "node_id" : "MDQ6VXNlcjk2NzgxNg==",
         "organizations_url" : "https://api.github.com/users/agroce/orgs",
         "received_events_url" : "https://api.github.com/users/agroce/received_events",
         "repos_url" : "https://api.github.com/users/agroce/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/agroce/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/agroce/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/agroce"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692702350"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692702350"
         }
      },
      "author_association" : "NONE",
      "body" : "> how is this different from\r\n\r\nIncreased the probability of entering the while loop as `ConsumeBool()` has only 50% chance of returning true while `ConsumeIntegralInRange<uint32_t>(0,100) >= 10` will have 90% chance of returning true.\r\nEssentially weâre trying to get the test running longer for each fuzz seed so multiple functions are exercised per seed, especially since `ChaCha20` maintains an internal state for each seed.",
      "commit_id" : "48b07c254795529ebeeef3c39083ee3ba90b3386",
      "created_at" : "2021-08-20T06:37:07Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692702350",
      "id" : 692702350,
      "in_reply_to_id" : 692403396,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjcwMjM1MA==",
      "original_commit_id" : "a63773439302f2cdef81e36c705bfd59046f6fa0",
      "original_line" : 292,
      "original_position" : 292,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : null,
      "pull_request_review_id" : 734714644,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T06:37:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692702350",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44579179?v=4",
         "events_url" : "https://api.github.com/users/prakash1512/events{/privacy}",
         "followers_url" : "https://api.github.com/users/prakash1512/followers",
         "following_url" : "https://api.github.com/users/prakash1512/following{/other_user}",
         "gists_url" : "https://api.github.com/users/prakash1512/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/prakash1512",
         "id" : 44579179,
         "login" : "prakash1512",
         "node_id" : "MDQ6VXNlcjQ0NTc5MTc5",
         "organizations_url" : "https://api.github.com/users/prakash1512/orgs",
         "received_events_url" : "https://api.github.com/users/prakash1512/received_events",
         "repos_url" : "https://api.github.com/users/prakash1512/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/prakash1512/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/prakash1512/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/prakash1512"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692712329"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692712329"
         }
      },
      "author_association" : "NONE",
      "body" : "> Also, could use `LIMITED_WHILE` to avoid unlimited runtime.\r\n\r\nGreat suggestion! Added `LIMITED_WHILE`.",
      "commit_id" : "48b07c254795529ebeeef3c39083ee3ba90b3386",
      "created_at" : "2021-08-20T06:57:02Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692712329",
      "id" : 692712329,
      "in_reply_to_id" : 692403396,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjcxMjMyOQ==",
      "original_commit_id" : "a63773439302f2cdef81e36c705bfd59046f6fa0",
      "original_line" : 292,
      "original_position" : 292,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : null,
      "pull_request_review_id" : 734726510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T06:57:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692712329",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692735180"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692735180"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Essentially weâre trying to get the test running longer\r\n\r\nDo you have data to support that claim? Fuzzing engines will store inputs that increase coverage data and once the data is stored, for replay it doesn't matter whether it was `ConsumeBool` or `ConsumeIntegralInRange` that evaluated to true.",
      "commit_id" : "48b07c254795529ebeeef3c39083ee3ba90b3386",
      "created_at" : "2021-08-20T07:38:43Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692735180",
      "id" : 692735180,
      "in_reply_to_id" : 692403396,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MjczNTE4MA==",
      "original_commit_id" : "a63773439302f2cdef81e36c705bfd59046f6fa0",
      "original_line" : 292,
      "original_position" : 292,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : null,
      "pull_request_review_id" : 734755634,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T07:38:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/692735180",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r693226653"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693226653"
         }
      },
      "author_association" : "NONE",
      "body" : "> Do you have data to support that claim?\r\n\r\nBacking the claim with data was indeed a great suggestion, so we generated the data and plots to verify it.\r\nNow we have results to dismiss that claim :)\r\nSharing our findings here:\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/863100385152335883/878387475096170607/unknown.png\"\r\n\ttitle=\"Plot\" width=\"500\" height=\"300\" />\r\n`x-axis denotes no of iterations`\r\n`y-axis denotes frequency of each iteration`",
      "commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "created_at" : "2021-08-20T21:25:22Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    while (fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(0, 100) >= 10) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r693226653",
      "id" : 693226653,
      "in_reply_to_id" : 692403396,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIyNjY1Mw==",
      "original_commit_id" : "a63773439302f2cdef81e36c705bfd59046f6fa0",
      "original_line" : 292,
      "original_position" : 292,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : null,
      "pull_request_review_id" : 735396200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:25:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693226653",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44579179?v=4",
         "events_url" : "https://api.github.com/users/prakash1512/events{/privacy}",
         "followers_url" : "https://api.github.com/users/prakash1512/followers",
         "following_url" : "https://api.github.com/users/prakash1512/following{/other_user}",
         "gists_url" : "https://api.github.com/users/prakash1512/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/prakash1512",
         "id" : 44579179,
         "login" : "prakash1512",
         "node_id" : "MDQ6VXNlcjQ0NTc5MTc5",
         "organizations_url" : "https://api.github.com/users/prakash1512/orgs",
         "received_events_url" : "https://api.github.com/users/prakash1512/received_events",
         "repos_url" : "https://api.github.com/users/prakash1512/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/prakash1512/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/prakash1512/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/prakash1512"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Added `LIMITED_WHILE` and updated `ConsumeIntegralInRange()` to `ConsumeBool()` as per discussion in [comments](https://github.com/bitcoin/bitcoin/pull/22704#discussion_r692403396).\r\nReady for further review.",
      "created_at" : "2021-10-14T04:52:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-942945385",
      "id" : 942945385,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5844NDRp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942945385/reactions"
      },
      "updated_at" : "2021-10-14T04:52:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942945385",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#23441](https://github.com/bitcoin/bitcoin/pull/23441) (fuzz: Differential fuzzing for ChaCha20Forward4064-Poly1305@bitcoin cipher suite by stratospher)\n* [#23322](https://github.com/bitcoin/bitcoin/pull/23322) ([Fuzz] Poly1305 differential fuzzing against Floodyberry's implementation by prakash1512)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2021-10-21T16:20:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-948773721",
      "id" : 948773721,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5844jSNZ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/948773721/reactions"
      },
      "updated_at" : "2021-11-06T00:58:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/948773721",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757817842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757817842"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: it might be useful to add the definition of `ENCRYPT_ctx` in the comments.\r\n```\r\n/* \r\n * ECRYPT_ctx is the structure containing the representation of the\r\n * internal state of your cipher. \r\n */\r\n```",
      "commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "created_at" : "2021-11-27T20:34:03Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757817842",
      "id" : 757817842,
      "line" : 45,
      "node_id" : "PRRC_kwDOABII584tK2Hy",
      "original_commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "original_line" : 45,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 45,
      "pull_request_review_id" : 817158428,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757817842/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-11-27T22:28:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757817842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/56887198?v=4",
         "events_url" : "https://api.github.com/users/siv2r/events{/privacy}",
         "followers_url" : "https://api.github.com/users/siv2r/followers",
         "following_url" : "https://api.github.com/users/siv2r/following{/other_user}",
         "gists_url" : "https://api.github.com/users/siv2r/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/siv2r",
         "id" : 56887198,
         "login" : "siv2r",
         "node_id" : "MDQ6VXNlcjU2ODg3MTk4",
         "organizations_url" : "https://api.github.com/users/siv2r/orgs",
         "received_events_url" : "https://api.github.com/users/siv2r/received_events",
         "repos_url" : "https://api.github.com/users/siv2r/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/siv2r/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/siv2r/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/siv2r"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818204"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818204"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\nstatic const char sigma[16] = \"expand 32-byte k\";\r\nstatic const char tau[16] = \"expand 16-byte k\";\r\n```",
      "commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "created_at" : "2021-11-27T20:50:53Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818204",
      "id" : 757818204,
      "line" : 97,
      "node_id" : "PRRC_kwDOABII584tK2Nc",
      "original_commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "original_line" : 97,
      "original_position" : 97,
      "original_start_line" : 96,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 97,
      "pull_request_review_id" : 817158428,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818204/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 96,
      "start_side" : "RIGHT",
      "updated_at" : "2021-11-27T22:28:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818204",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/56887198?v=4",
         "events_url" : "https://api.github.com/users/siv2r/events{/privacy}",
         "followers_url" : "https://api.github.com/users/siv2r/followers",
         "following_url" : "https://api.github.com/users/siv2r/following{/other_user}",
         "gists_url" : "https://api.github.com/users/siv2r/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/siv2r",
         "id" : 56887198,
         "login" : "siv2r",
         "node_id" : "MDQ6VXNlcjU2ODg3MTk4",
         "organizations_url" : "https://api.github.com/users/siv2r/orgs",
         "received_events_url" : "https://api.github.com/users/siv2r/received_events",
         "repos_url" : "https://api.github.com/users/siv2r/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/siv2r/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/siv2r/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/siv2r"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818918"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\r\n    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\r\n    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\r\n    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\r\n```\r\nnit: this pattern of defining the `QUATERROUND` macro is following in many places ([chacha20.cpp](https://github.com/bitcoin/bitcoin/blob/master/src/crypto/chacha20.cpp#L15)).",
      "commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "created_at" : "2021-11-27T22:20:17Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818918",
      "id" : 757818918,
      "line" : 94,
      "node_id" : "PRRC_kwDOABII584tK2Ym",
      "original_commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "original_line" : 94,
      "original_position" : 94,
      "original_start_line" : 87,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 94,
      "pull_request_review_id" : 817158428,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818918/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 87,
      "start_side" : "RIGHT",
      "updated_at" : "2021-11-27T22:28:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757818918",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/56887198?v=4",
         "events_url" : "https://api.github.com/users/siv2r/events{/privacy}",
         "followers_url" : "https://api.github.com/users/siv2r/followers",
         "following_url" : "https://api.github.com/users/siv2r/following{/other_user}",
         "gists_url" : "https://api.github.com/users/siv2r/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/siv2r",
         "id" : 56887198,
         "login" : "siv2r",
         "node_id" : "MDQ6VXNlcjU2ODg3MTk4",
         "organizations_url" : "https://api.github.com/users/siv2r/orgs",
         "received_events_url" : "https://api.github.com/users/siv2r/received_events",
         "repos_url" : "https://api.github.com/users/siv2r/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/siv2r/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/siv2r/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/siv2r"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762392225"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392225"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'd like to keep D. J. Bernstein's reference implementation of ChaCha20 as such.",
      "commit_id" : "c0554c7a516047cc7d98bfa02e96adc1e4dc8014",
      "created_at" : "2021-12-04T06:19:19Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762392225",
      "id" : 762392225,
      "in_reply_to_id" : 757817842,
      "line" : 45,
      "node_id" : "PRRC_kwDOABII584tcS6h",
      "original_commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "original_line" : 45,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 45,
      "pull_request_review_id" : 823242514,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392225/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-04T06:19:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392225",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762392237"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392237"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Since this is actually 16 characters + '\\0', we'd have to put a number â¥17. There's a discussion [here](https://groups.google.com/g/sci.crypt/c/mWjGx8HLVCE) which talks about the change needed in the reference implementation. This is the only place where such a change was made.",
      "commit_id" : "c0554c7a516047cc7d98bfa02e96adc1e4dc8014",
      "created_at" : "2021-12-04T06:19:30Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762392237",
      "id" : 762392237,
      "in_reply_to_id" : 757818204,
      "line" : 93,
      "node_id" : "PRRC_kwDOABII584tcS6t",
      "original_commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "original_line" : 93,
      "original_position" : 97,
      "original_start_line" : 96,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 93,
      "pull_request_review_id" : 823242527,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392237/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 92,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-04T06:19:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392237",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762392241"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392241"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks! I've made the changes.",
      "commit_id" : "c0554c7a516047cc7d98bfa02e96adc1e4dc8014",
      "created_at" : "2021-12-04T06:19:36Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762392241",
      "id" : 762392241,
      "in_reply_to_id" : 757818918,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584tcS6x",
      "original_commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "original_line" : 94,
      "original_position" : 94,
      "original_start_line" : 87,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : null,
      "pull_request_review_id" : 823242537,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392241/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-04T06:19:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762392241",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Addressed [#22704(comment)](https://github.com/bitcoin/bitcoin/pull/22704#discussion_r757818918). (Thanks @siv2r!) Ready for further review.",
      "created_at" : "2021-12-04T06:20:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-985977476",
      "id" : 985977476,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5846xNKE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/985977476/reactions"
      },
      "updated_at" : "2021-12-04T06:20:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/985977476",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762436249"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762436249"
         }
      },
      "author_association" : "NONE",
      "body" : "Ah, I see. Thanks!",
      "commit_id" : "c0554c7a516047cc7d98bfa02e96adc1e4dc8014",
      "created_at" : "2021-12-04T15:19:02Z",
      "diff_hunk" : "@@ -0,0 +1,334 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b);              \\\n+    d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d);              \\\n+    b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r762436249",
      "id" : 762436249,
      "in_reply_to_id" : 757818204,
      "line" : 93,
      "node_id" : "PRRC_kwDOABII584tcdqZ",
      "original_commit_id" : "258d751c1c0363a880889275b4c567118b779ba1",
      "original_line" : 93,
      "original_position" : 97,
      "original_start_line" : 96,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 93,
      "pull_request_review_id" : 823277086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762436249/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 92,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-04T15:19:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/762436249",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/56887198?v=4",
         "events_url" : "https://api.github.com/users/siv2r/events{/privacy}",
         "followers_url" : "https://api.github.com/users/siv2r/followers",
         "following_url" : "https://api.github.com/users/siv2r/following{/other_user}",
         "gists_url" : "https://api.github.com/users/siv2r/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/siv2r",
         "id" : 56887198,
         "login" : "siv2r",
         "node_id" : "MDQ6VXNlcjU2ODg3MTk4",
         "organizations_url" : "https://api.github.com/users/siv2r/orgs",
         "received_events_url" : "https://api.github.com/users/siv2r/received_events",
         "repos_url" : "https://api.github.com/users/siv2r/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/siv2r/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/siv2r/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/siv2r"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "You might want to set a different author name for your commits than \"root\" if you want to be credited properly in the release notes.",
      "created_at" : "2021-12-10T21:32:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-991308926",
      "id" : 991308926,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5847Fix-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/991308926/reactions"
      },
      "updated_at" : "2021-12-10T21:32:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/991308926",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> You might want to set a different author name for your commits than \"root\" if you want to be credited properly in the release notes.\r\n\r\nThank you for letting me know! I've updated the author name.",
      "created_at" : "2021-12-11T03:12:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-991426211",
      "id" : 991426211,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5847F_aj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/991426211/reactions"
      },
      "updated_at" : "2021-12-11T03:13:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/991426211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code review ACK 4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-17T15:53:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-996829640",
      "id" : 996829640,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5847amnI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/996829640/reactions"
      },
      "updated_at" : "2021-12-17T15:53:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/996829640",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771510067"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510067"
         }
      },
      "author_association" : "MEMBER",
      "body" : "any reason to use a low level function, when https://en.cppreference.com/w/cpp/container/vector/operator_cmp could be used?",
      "commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-17T16:02:53Z",
      "diff_hunk" : "@@ -0,0 +1,330 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    LIMITED_WHILE (fuzzed_data_provider.ConsumeBool(), 3000) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+                ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+                // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+                uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+                ECRYPT_ivsetup(&ctx, iv);\n+            },\n+            [&] {\n+                uint64_t iv = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.SetIV(iv);\n+                ctx.input[14] = iv;\n+                ctx.input[15] = iv >> 32;\n+            },\n+            [&] {\n+                uint64_t counter = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.Seek(counter);\n+                ctx.input[12] = counter;\n+                ctx.input[13] = counter >> 32;\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                chacha20.Keystream(output.data(), output.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_keystream_bytes(&ctx, djb_output.data(), djb_output.size());\n+                if (output.data() != NULL && djb_output.data() != NULL) {\n+                    assert(memcmp(output.data(), djb_output.data(), integralInRange) == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771510067",
      "id" : 771510067,
      "line" : 318,
      "node_id" : "PRRC_kwDOABII584t_E8z",
      "original_commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "original_line" : 318,
      "original_position" : 318,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 318,
      "pull_request_review_id" : 835398234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510067/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T16:04:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510067",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771510786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510786"
         }
      },
      "author_association" : "MEMBER",
      "body" : "when would this fail?",
      "commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-17T16:03:57Z",
      "diff_hunk" : "@@ -0,0 +1,330 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    LIMITED_WHILE (fuzzed_data_provider.ConsumeBool(), 3000) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+                ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+                // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+                uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+                ECRYPT_ivsetup(&ctx, iv);\n+            },\n+            [&] {\n+                uint64_t iv = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.SetIV(iv);\n+                ctx.input[14] = iv;\n+                ctx.input[15] = iv >> 32;\n+            },\n+            [&] {\n+                uint64_t counter = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.Seek(counter);\n+                ctx.input[12] = counter;\n+                ctx.input[13] = counter >> 32;\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                chacha20.Keystream(output.data(), output.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_keystream_bytes(&ctx, djb_output.data(), djb_output.size());\n+                if (output.data() != NULL && djb_output.data() != NULL) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771510786",
      "id" : 771510786,
      "line" : 317,
      "node_id" : "PRRC_kwDOABII584t_FIC",
      "original_commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "original_line" : 317,
      "original_position" : 317,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 317,
      "pull_request_review_id" : 835398234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510786/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T16:04:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510786",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771510963"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510963"
         }
      },
      "author_association" : "MEMBER",
      "body" : "missing https://en.cppreference.com/w/cpp/container/vector/operator_cmp ?",
      "commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-17T16:04:12Z",
      "diff_hunk" : "@@ -0,0 +1,330 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    LIMITED_WHILE (fuzzed_data_provider.ConsumeBool(), 3000) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+                ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+                // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+                uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+                ECRYPT_ivsetup(&ctx, iv);\n+            },\n+            [&] {\n+                uint64_t iv = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.SetIV(iv);\n+                ctx.input[14] = iv;\n+                ctx.input[15] = iv >> 32;\n+            },\n+            [&] {\n+                uint64_t counter = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.Seek(counter);\n+                ctx.input[12] = counter;\n+                ctx.input[13] = counter >> 32;\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                chacha20.Keystream(output.data(), output.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_keystream_bytes(&ctx, djb_output.data(), djb_output.size());\n+                if (output.data() != NULL && djb_output.data() != NULL) {\n+                    assert(memcmp(output.data(), djb_output.data(), integralInRange) == 0);\n+                }\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                const std::vector<uint8_t> input = ConsumeFixedLengthByteVector(fuzzed_data_provider, output.size());\n+                chacha20.Crypt(input.data(), output.data(), input.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_encrypt_bytes(&ctx, input.data(), djb_output.data(), input.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771510963",
      "id" : 771510963,
      "line" : 327,
      "node_id" : "PRRC_kwDOABII584t_FKz",
      "original_commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "original_line" : 327,
      "original_position" : 327,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 327,
      "pull_request_review_id" : 835398234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510963/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T16:04:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771510963",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771578243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578243"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I went with this because [some of the crypto unit tests](https://github.com/bitcoin/bitcoin/blob/4ad59042b359f473d5888ecee0c9288dcf98f1c9/src/test/crypto_tests.cpp#L636) used memcmp. I feel you're right though and memcmp doesn't really provide any added advantage.",
      "commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-17T17:47:32Z",
      "diff_hunk" : "@@ -0,0 +1,330 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    LIMITED_WHILE (fuzzed_data_provider.ConsumeBool(), 3000) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+                ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+                // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+                uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+                ECRYPT_ivsetup(&ctx, iv);\n+            },\n+            [&] {\n+                uint64_t iv = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.SetIV(iv);\n+                ctx.input[14] = iv;\n+                ctx.input[15] = iv >> 32;\n+            },\n+            [&] {\n+                uint64_t counter = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.Seek(counter);\n+                ctx.input[12] = counter;\n+                ctx.input[13] = counter >> 32;\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                chacha20.Keystream(output.data(), output.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_keystream_bytes(&ctx, djb_output.data(), djb_output.size());\n+                if (output.data() != NULL && djb_output.data() != NULL) {\n+                    assert(memcmp(output.data(), djb_output.data(), integralInRange) == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771578243",
      "id" : 771578243,
      "in_reply_to_id" : 771510067,
      "line" : 318,
      "node_id" : "PRRC_kwDOABII584t_VmD",
      "original_commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "original_line" : 318,
      "original_position" : 318,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 318,
      "pull_request_review_id" : 835494505,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578243/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T17:47:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578243",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771578344"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578344"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I meant this as a check to not pass a null pointer(In a situation where `integralInRange` is 0) to memcmp since it would exhibit undefined behaviour. This can be removed if memcmp is removed.",
      "commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-17T17:47:40Z",
      "diff_hunk" : "@@ -0,0 +1,330 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    LIMITED_WHILE (fuzzed_data_provider.ConsumeBool(), 3000) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+                ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+                // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+                uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+                ECRYPT_ivsetup(&ctx, iv);\n+            },\n+            [&] {\n+                uint64_t iv = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.SetIV(iv);\n+                ctx.input[14] = iv;\n+                ctx.input[15] = iv >> 32;\n+            },\n+            [&] {\n+                uint64_t counter = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.Seek(counter);\n+                ctx.input[12] = counter;\n+                ctx.input[13] = counter >> 32;\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                chacha20.Keystream(output.data(), output.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_keystream_bytes(&ctx, djb_output.data(), djb_output.size());\n+                if (output.data() != NULL && djb_output.data() != NULL) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771578344",
      "id" : 771578344,
      "in_reply_to_id" : 771510786,
      "line" : 317,
      "node_id" : "PRRC_kwDOABII584t_Vno",
      "original_commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "original_line" : 317,
      "original_position" : 317,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 317,
      "pull_request_review_id" : 835494640,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578344/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T17:47:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578344",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771578420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578420"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nice catch. Thanks!\r\nI can open a follow up PR to include these suggestions.",
      "commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-17T17:47:47Z",
      "diff_hunk" : "@@ -0,0 +1,330 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    LIMITED_WHILE (fuzzed_data_provider.ConsumeBool(), 3000) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+                ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+                // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+                uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+                ECRYPT_ivsetup(&ctx, iv);\n+            },\n+            [&] {\n+                uint64_t iv = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.SetIV(iv);\n+                ctx.input[14] = iv;\n+                ctx.input[15] = iv >> 32;\n+            },\n+            [&] {\n+                uint64_t counter = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.Seek(counter);\n+                ctx.input[12] = counter;\n+                ctx.input[13] = counter >> 32;\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                chacha20.Keystream(output.data(), output.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_keystream_bytes(&ctx, djb_output.data(), djb_output.size());\n+                if (output.data() != NULL && djb_output.data() != NULL) {\n+                    assert(memcmp(output.data(), djb_output.data(), integralInRange) == 0);\n+                }\n+            },\n+            [&] {\n+                uint32_t integralInRange = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n+                std::vector<uint8_t> output(integralInRange);\n+                const std::vector<uint8_t> input = ConsumeFixedLengthByteVector(fuzzed_data_provider, output.size());\n+                chacha20.Crypt(input.data(), output.data(), input.size());\n+                std::vector<uint8_t> djb_output(integralInRange);\n+                ECRYPT_encrypt_bytes(&ctx, input.data(), djb_output.data(), input.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r771578420",
      "id" : 771578420,
      "in_reply_to_id" : 771510963,
      "line" : 327,
      "node_id" : "PRRC_kwDOABII584t_Vo0",
      "original_commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "original_line" : 327,
      "original_position" : 327,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 327,
      "pull_request_review_id" : 835494739,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578420/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T17:47:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771578420",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the review @MarcoFalke. I've opened #23806 to address your comments.",
      "created_at" : "2021-12-17T17:56:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-996912422",
      "id" : 996912422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5847a60m",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/996912422/reactions"
      },
      "updated_at" : "2021-12-17T17:56:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/996912422",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "```\r\n# FUZZ=crypto_diff_fuzz_chacha20 /root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz ./scratch/fuzz_gen/code/crash-03f91945a7518033b0df73bf35c2caa452126610 \r\nINFO: Running with entropic power schedule (0xFF, 100).\r\nINFO: Seed: 3283247107\r\nINFO: Loaded 1 modules   (306045 inline 8-bit counters): 306045 [0x55c5b9987bc0, 0x55c5b99d273d), \r\nINFO: Loaded 1 PC tables (306045 PCs): 306045 [0x55c5b99d2740,0x55c5b9e7df10), \r\n/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz: Running 1 inputs 1 time(s) each.\r\nRunning: ./scratch/fuzz_gen/code/crash-03f91945a7518033b0df73bf35c2caa452126610\r\ntest/fuzz/crypto_diff_fuzz_chacha20.cpp:179:13: runtime error: left shift of 268500992 by 8 places cannot be represented in type 'unsigned int'\r\n    #0 0x55c5b722ff9b in ECRYPT_encrypt_bytes(ECRYPT_ctx*, unsigned char const*, unsigned char*, unsigned int) src/test/fuzz/crypto_diff_fuzz_chacha20.cpp:179:13\r\n    #1 0x55c5b723a342 in ECRYPT_keystream_bytes(ECRYPT_ctx*, unsigned char*, unsigned int) src/test/fuzz/crypto_diff_fuzz_chacha20.cpp:265:5\r\n    #2 0x55c5b723a342 in crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_3::operator()() const src/test/fuzz/crypto_diff_fuzz_chacha20.cpp:316:17\r\n    #3 0x55c5b723a342 in unsigned long CallOneOf<crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_0, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_1, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_2, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_3, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_4>(FuzzedDataProvider&, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_0, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_1, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_2, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_3, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_4) src/./test/fuzz/util.h:49:27\r\n    #4 0x55c5b72393d5 in crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>) src/test/fuzz/crypto_diff_fuzz_chacha20.cpp:289:9\r\n    #5 0x55c5b7167628 in std::_Function_handler<void (Span<unsigned char const>), void (*)(Span<unsigned char const>)>::_M_invoke(std::_Any_data const&, Span<unsigned char const>&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:300:2\r\n    #6 0x55c5b80f997d in std::function<void (Span<unsigned char const>)>::operator()(Span<unsigned char const>) const /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:688:14\r\n    #7 0x55c5b80f9628 in LLVMFuzzerTestOneInput src/test/fuzz/fuzz.cpp:91:5\r\n    #8 0x55c5b7076fb3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1461fb3)\r\n    #9 0x55c5b706037f in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x144b37f)\r\n    #10 0x55c5b706615c in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x145115c)\r\n    #11 0x55c5b7090d72 in main (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x147bd72)\r\n    #12 0x7f395fca90b2 in __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:308:16\r\n    #13 0x55c5b705ab0d in _start (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1445b0d)\r\n\r\nSUMMARY: UndefinedBehaviorSanitizer: invalid-shift-base test/fuzz/crypto_diff_fuzz_chacha20.cpp:179:13 in \r\n```\r\n\r\n```\r\n# base64 ./scratch/fuzz_gen/code/crash-03f91945a7518033b0df73bf35c2caa452126610 \r\n9tXRyA==\r\n",
      "created_at" : "2021-12-24T11:37:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#issuecomment-1000804547",
      "id" : 1000804547,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22704",
      "node_id" : "IC_kwDOABII5847pxDD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1000804547/reactions"
      },
      "updated_at" : "2021-12-24T11:37:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1000804547",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r774989422"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/774989422"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\ntest/fuzz/crypto_diff_fuzz_chacha20.cpp:302:33: runtime error: implicit conversion from type 'uint64_t' (aka 'unsigned long') of value 270751369970 (64-bit, unsigned) to type 'u32' (aka 'unsigned int') changed the value to 168430322 (32-bit, unsigned)\r\n    #0 0x55b2974ba838 in crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_1::operator()() const src/test/fuzz/crypto_diff_fuzz_chacha20.cpp:302:33\r\n    #1 0x55b2974ba838 in unsigned long CallOneOf<crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_0, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_1, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_2, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_3, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_4>(FuzzedDataProvider&, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_0, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_1, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_2, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_3, crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>)::$_4) src/./test/fuzz/util.h:49:27\r\n    #2 0x55b2974b93d5 in crypto_diff_fuzz_chacha20_fuzz_target(Span<unsigned char const>) src/test/fuzz/crypto_diff_fuzz_chacha20.cpp:289:9\r\n    #3 0x55b2973e7628 in std::_Function_handler<void (Span<unsigned char const>), void (*)(Span<unsigned char const>)>::_M_invoke(std::_Any_data const&, Span<unsigned char const>&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:300:2\r\n    #4 0x55b29837997d in std::function<void (Span<unsigned char const>)>::operator()(Span<unsigned char const>) const /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/std_function.h:688:14\r\n    #5 0x55b298379628 in LLVMFuzzerTestOneInput src/test/fuzz/fuzz.cpp:91:5\r\n    #6 0x55b2972f6fb3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1461fb3)\r\n    #7 0x55b2972f6709 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1461709)\r\n    #8 0x55b2972f7ef9 in fuzzer::Fuzzer::MutateAndTestOne() (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1462ef9)\r\n    #9 0x55b2972f8a75 in fuzzer::Fuzzer::Loop(std::vector<fuzzer::SizedFile, std::allocator<fuzzer::SizedFile> >&) (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1463a75)\r\n    #10 0x55b2972e6288 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1451288)\r\n    #11 0x55b297310d72 in main (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x147bd72)\r\n    #12 0x7fcb06fc90b2 in __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:308:16\r\n    #13 0x55b2972dab0d in _start (/root/fuzz_dir/scratch/fuzz_gen/code/src/test/fuzz/fuzz+0x1445b0d)\r\n\r\nSUMMARY: UndefinedBehaviorSanitizer: implicit-unsigned-integer-truncation test/fuzz/crypto_diff_fuzz_chacha20.cpp:302:33 in \r\nMS: 4 ShuffleBytes-CrossOver-ChangeBinInt-CopyPart-; base unit: 47966b9379790c601d5e098f1ba5ccae76f25861\r\n0xf2,0xa,0xa,0xa,0x3f,0x38,0x1b,0xf4,\r\n\\362\\012\\012\\012?8\\033\\364\r\nartifact_prefix='./'; Test unit written to ./crash-ce471b8e19b31491ff5f4a3669aefa84b1848f06\r\nBase64: 8goKCj84G/Q=\r\n",
      "commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "created_at" : "2021-12-24T11:43:01Z",
      "diff_hunk" : "@@ -0,0 +1,330 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha20.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+/*\n+From https://cr.yp.to/chacha.html\n+chacha-merged.c version 20080118\n+D. J. Bernstein\n+Public domain.\n+*/\n+\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#define U8C(v) (v##U)\n+#define U32C(v) (v##U)\n+\n+#define U8V(v) ((u8)(v)&U8C(0xFF))\n+#define U32V(v) ((u32)(v)&U32C(0xFFFFFFFF))\n+\n+#define ROTL32(v, n) (U32V((v) << (n)) | ((v) >> (32 - (n))))\n+\n+#define U8TO32_LITTLE(p)                                              \\\n+    (((u32)((p)[0])) | ((u32)((p)[1]) << 8) | ((u32)((p)[2]) << 16) | \\\n+     ((u32)((p)[3]) << 24))\n+\n+#define U32TO8_LITTLE(p, v)      \\\n+    do {                         \\\n+        (p)[0] = U8V((v));       \\\n+        (p)[1] = U8V((v) >> 8);  \\\n+        (p)[2] = U8V((v) >> 16); \\\n+        (p)[3] = U8V((v) >> 24); \\\n+    } while (0)\n+\n+/* ------------------------------------------------------------------------- */\n+/* Data structures */\n+\n+typedef struct\n+{\n+    u32 input[16];\n+} ECRYPT_ctx;\n+\n+/* ------------------------------------------------------------------------- */\n+/* Mandatory functions */\n+\n+void ECRYPT_keysetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* key,\n+    u32 keysize, /* Key size in bits. */\n+    u32 ivsize); /* IV size in bits. */\n+\n+void ECRYPT_ivsetup(\n+    ECRYPT_ctx* ctx,\n+    const u8* iv);\n+\n+void ECRYPT_encrypt_bytes(\n+    ECRYPT_ctx* ctx,\n+    const u8* plaintext,\n+    u8* ciphertext,\n+    u32 msglen); /* Message length in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+/* Optional features */\n+\n+void ECRYPT_keystream_bytes(\n+    ECRYPT_ctx* ctx,\n+    u8* keystream,\n+    u32 length); /* Length of keystream in bytes. */\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#define ROTATE(v, c) (ROTL32(v, c))\n+#define XOR(v, w) ((v) ^ (w))\n+#define PLUS(v, w) (U32V((v) + (w)))\n+#define PLUSONE(v) (PLUS((v), 1))\n+\n+#define QUARTERROUND(a, b, c, d) \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 16);   \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 12);   \\\n+    a = PLUS(a, b); d = ROTATE(XOR(d, a), 8);    \\\n+    c = PLUS(c, d); b = ROTATE(XOR(b, c), 7);\n+\n+static const char sigma[] = \"expand 32-byte k\";\n+static const char tau[] = \"expand 16-byte k\";\n+\n+void ECRYPT_keysetup(ECRYPT_ctx* x, const u8* k, u32 kbits, u32 ivbits)\n+{\n+    const char* constants;\n+\n+    x->input[4] = U8TO32_LITTLE(k + 0);\n+    x->input[5] = U8TO32_LITTLE(k + 4);\n+    x->input[6] = U8TO32_LITTLE(k + 8);\n+    x->input[7] = U8TO32_LITTLE(k + 12);\n+    if (kbits == 256) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* kbits == 128 */\n+        constants = tau;\n+    }\n+    x->input[8] = U8TO32_LITTLE(k + 0);\n+    x->input[9] = U8TO32_LITTLE(k + 4);\n+    x->input[10] = U8TO32_LITTLE(k + 8);\n+    x->input[11] = U8TO32_LITTLE(k + 12);\n+    x->input[0] = U8TO32_LITTLE(constants + 0);\n+    x->input[1] = U8TO32_LITTLE(constants + 4);\n+    x->input[2] = U8TO32_LITTLE(constants + 8);\n+    x->input[3] = U8TO32_LITTLE(constants + 12);\n+}\n+\n+void ECRYPT_ivsetup(ECRYPT_ctx* x, const u8* iv)\n+{\n+    x->input[12] = 0;\n+    x->input[13] = 0;\n+    x->input[14] = U8TO32_LITTLE(iv + 0);\n+    x->input[15] = U8TO32_LITTLE(iv + 4);\n+}\n+\n+void ECRYPT_encrypt_bytes(ECRYPT_ctx* x, const u8* m, u8* c, u32 bytes)\n+{\n+    u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    u8* ctarget = NULL;\n+    u8 tmp[64];\n+    uint32_t i;\n+\n+    if (!bytes) return;\n+\n+    j0 = x->input[0];\n+    j1 = x->input[1];\n+    j2 = x->input[2];\n+    j3 = x->input[3];\n+    j4 = x->input[4];\n+    j5 = x->input[5];\n+    j6 = x->input[6];\n+    j7 = x->input[7];\n+    j8 = x->input[8];\n+    j9 = x->input[9];\n+    j10 = x->input[10];\n+    j11 = x->input[11];\n+    j12 = x->input[12];\n+    j13 = x->input[13];\n+    j14 = x->input[14];\n+    j15 = x->input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            for (i = 0; i < bytes; ++i)\n+                tmp[i] = m[i];\n+            m = tmp;\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20; i > 0; i -= 2) {\n+            QUARTERROUND(x0, x4, x8, x12)\n+            QUARTERROUND(x1, x5, x9, x13)\n+            QUARTERROUND(x2, x6, x10, x14)\n+            QUARTERROUND(x3, x7, x11, x15)\n+            QUARTERROUND(x0, x5, x10, x15)\n+            QUARTERROUND(x1, x6, x11, x12)\n+            QUARTERROUND(x2, x7, x8, x13)\n+            QUARTERROUND(x3, x4, x9, x14)\n+        }\n+        x0 = PLUS(x0, j0);\n+        x1 = PLUS(x1, j1);\n+        x2 = PLUS(x2, j2);\n+        x3 = PLUS(x3, j3);\n+        x4 = PLUS(x4, j4);\n+        x5 = PLUS(x5, j5);\n+        x6 = PLUS(x6, j6);\n+        x7 = PLUS(x7, j7);\n+        x8 = PLUS(x8, j8);\n+        x9 = PLUS(x9, j9);\n+        x10 = PLUS(x10, j10);\n+        x11 = PLUS(x11, j11);\n+        x12 = PLUS(x12, j12);\n+        x13 = PLUS(x13, j13);\n+        x14 = PLUS(x14, j14);\n+        x15 = PLUS(x15, j15);\n+\n+        x0 = XOR(x0, U8TO32_LITTLE(m + 0));\n+        x1 = XOR(x1, U8TO32_LITTLE(m + 4));\n+        x2 = XOR(x2, U8TO32_LITTLE(m + 8));\n+        x3 = XOR(x3, U8TO32_LITTLE(m + 12));\n+        x4 = XOR(x4, U8TO32_LITTLE(m + 16));\n+        x5 = XOR(x5, U8TO32_LITTLE(m + 20));\n+        x6 = XOR(x6, U8TO32_LITTLE(m + 24));\n+        x7 = XOR(x7, U8TO32_LITTLE(m + 28));\n+        x8 = XOR(x8, U8TO32_LITTLE(m + 32));\n+        x9 = XOR(x9, U8TO32_LITTLE(m + 36));\n+        x10 = XOR(x10, U8TO32_LITTLE(m + 40));\n+        x11 = XOR(x11, U8TO32_LITTLE(m + 44));\n+        x12 = XOR(x12, U8TO32_LITTLE(m + 48));\n+        x13 = XOR(x13, U8TO32_LITTLE(m + 52));\n+        x14 = XOR(x14, U8TO32_LITTLE(m + 56));\n+        x15 = XOR(x15, U8TO32_LITTLE(m + 60));\n+\n+        j12 = PLUSONE(j12);\n+        if (!j12) {\n+            j13 = PLUSONE(j13);\n+            /* stopping at 2^70 bytes per nonce is user's responsibility */\n+        }\n+\n+        U32TO8_LITTLE(c + 0, x0);\n+        U32TO8_LITTLE(c + 4, x1);\n+        U32TO8_LITTLE(c + 8, x2);\n+        U32TO8_LITTLE(c + 12, x3);\n+        U32TO8_LITTLE(c + 16, x4);\n+        U32TO8_LITTLE(c + 20, x5);\n+        U32TO8_LITTLE(c + 24, x6);\n+        U32TO8_LITTLE(c + 28, x7);\n+        U32TO8_LITTLE(c + 32, x8);\n+        U32TO8_LITTLE(c + 36, x9);\n+        U32TO8_LITTLE(c + 40, x10);\n+        U32TO8_LITTLE(c + 44, x11);\n+        U32TO8_LITTLE(c + 48, x12);\n+        U32TO8_LITTLE(c + 52, x13);\n+        U32TO8_LITTLE(c + 56, x14);\n+        U32TO8_LITTLE(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0; i < bytes; ++i)\n+                    ctarget[i] = c[i];\n+            }\n+            x->input[12] = j12;\n+            x->input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+        m += 64;\n+    }\n+}\n+\n+void ECRYPT_keystream_bytes(ECRYPT_ctx* x, u8* stream, u32 bytes)\n+{\n+    u32 i;\n+    for (i = 0; i < bytes; ++i)\n+        stream[i] = 0;\n+    ECRYPT_encrypt_bytes(x, stream, stream, bytes);\n+}\n+\n+FUZZ_TARGET(crypto_diff_fuzz_chacha20)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+\n+    ChaCha20 chacha20;\n+    ECRYPT_ctx ctx;\n+    // D. J. Bernstein doesn't initialise ctx to 0 while Bitcoin Core initialises chacha20 to 0 in the constructor\n+    for (int i = 0; i < 16; i++) {\n+        ctx.input[i] = 0;\n+    }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+        chacha20 = ChaCha20{key.data(), key.size()};\n+        ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+        // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+        uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+        ECRYPT_ivsetup(&ctx, iv);\n+    }\n+\n+    LIMITED_WHILE (fuzzed_data_provider.ConsumeBool(), 3000) {\n+        CallOneOf(\n+            fuzzed_data_provider,\n+            [&] {\n+                const std::vector<unsigned char> key = ConsumeFixedLengthByteVector(fuzzed_data_provider, fuzzed_data_provider.ConsumeIntegralInRange<size_t>(16, 32));\n+                chacha20.SetKey(key.data(), key.size());\n+                ECRYPT_keysetup(&ctx, key.data(), key.size() * 8, 0);\n+                // ECRYPT_keysetup() doesn't set the counter and nonce to 0 while SetKey() does\n+                uint8_t iv[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n+                ECRYPT_ivsetup(&ctx, iv);\n+            },\n+            [&] {\n+                uint64_t iv = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                chacha20.SetIV(iv);\n+                ctx.input[14] = iv;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22704#discussion_r774989422",
      "id" : 774989422,
      "line" : 302,
      "node_id" : "PRRC_kwDOABII584uMWZu",
      "original_commit_id" : "4d0ac72f3ae78e3c6a0d5dc4f7e809583abd0546",
      "original_line" : 302,
      "original_position" : 302,
      "original_start_line" : null,
      "path" : "src/test/fuzz/crypto_diff_fuzz_chacha20.cpp",
      "position" : 302,
      "pull_request_review_id" : 839888777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22704",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/774989422/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-24T11:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/774989422",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   }
]
