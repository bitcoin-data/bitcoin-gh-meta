[
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK and code looks good on first read.\r\n\r\n```\r\ntest/rbf_tests.cpp:47:14: error: calling function 'addUnchecked' requires holding mutex 'pool.cs' exclusively [-Werror,-Wthread-safety-analysis]\r\n        pool.addUnchecked(entry.FromTx(next_tx));\r\n             ^\r\ntest/rbf_tests.cpp:47:14: error: calling function 'addUnchecked' requires holding mutex 'cs_main' exclusively [-Werror,-Wthread-safety-analysis]\r\n```\r\n ",
      "created_at" : "2022-07-22T11:40:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1192485046",
      "id" : 1192485046,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HE-C2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192485046/reactions"
      },
      "updated_at" : "2022-07-22T11:40:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192485046",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927846036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927846036"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should note what this is doing ahead of time, or do it JIT before usage",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T17:08:38Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927846036",
      "id" : 927846036,
      "line" : 88,
      "node_id" : "PRRC_kwDOABII5843Tc6U",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 88,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927846036/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927846036",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927887590"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927887590"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\r\n    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\r\n```\r\nrules out the case where tx2 has no witness data(same wtxid) but some other bug.,.",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:10:34Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927887590",
      "id" : 927887590,
      "line" : 135,
      "node_id" : "PRRC_kwDOABII5843TnDm",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 135,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 135,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927887590/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927887590",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927890596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927890596"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    const auto higher_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE * 2};\r\n```\r\nin case the incremental rate ever changes out from underneath the test",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:15:13Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927890596",
      "id" : 927890596,
      "line" : 144,
      "node_id" : "PRRC_kwDOABII5843Tnyk",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 144,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 144,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927890596/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927890596",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927895019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927895019"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not really a part of this test, but I find the name `relay_fee` and the header description very misleading.\r\n\r\n```\r\n* @param[in]   relay_fee           The node's minimum feerate for transaction relay.\r\n```\r\n\r\nThis is whatever ::incrementalRelayFee is during runtime, which is explicitly not that? i.e. mempool minfee could be much higher, yes?",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:22:26Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927895019",
      "id" : 927895019,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII5843To3r",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 149,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927895019/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927895019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927900263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927900263"
         }
      },
      "author_association" : "MEMBER",
      "body" : "QoL improvement for future readers/editors would be accumulating these constants",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:30:34Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927900263",
      "id" : 927900263,
      "line" : 175,
      "node_id" : "PRRC_kwDOABII5843TqJn",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 175,
      "original_position" : 175,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 175,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927900263/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927900263",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#25038](https://github.com/bitcoin/bitcoin/pull/25038) (policy: nVersion=3 and Package RBF by glozow)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-07-23T01:14:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1193029730",
      "id" : 1193029730,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HHDBi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1193029730/reactions"
      },
      "updated_at" : "2022-07-23T01:14:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1193029730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928564065"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928564065"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah looking back I should have named it `incremental_relay_feerate`, and that description is not helpful... oops\r\n\r\nThis should always be called with the incremental relay feerate. The reason it's parameterizable instead of having the function use `::incrementalRelayFee` is to avoid using globals within this module (see https://github.com/bitcoin/bitcoin/pull/22675#discussion_r702737511).",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-25T07:44:15Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928564065",
      "id" : 928564065,
      "in_reply_to_id" : 927895019,
      "line" : 154,
      "node_id" : "PRRC_kwDOABII5843WMNh",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 154,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 154,
      "pull_request_review_id" : 1048999401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928564065/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T16:28:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928564065",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568171"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T07:49:02Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568171",
      "id" : 928568171,
      "in_reply_to_id" : 927887590,
      "line" : 137,
      "node_id" : "PRRC_kwDOABII5843WNNr",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 137,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 137,
      "pull_request_review_id" : 1049005234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568171/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T07:49:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568171",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568272"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568272"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T07:49:09Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568272",
      "id" : 928568272,
      "in_reply_to_id" : 927900263,
      "line" : 179,
      "node_id" : "PRRC_kwDOABII5843WNPQ",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 179,
      "original_position" : 175,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 179,
      "pull_request_review_id" : 1049005234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568272/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T07:49:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568272",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568622"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568622"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added comment, hopefully clearer now",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T07:49:32Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568622",
      "id" : 928568622,
      "in_reply_to_id" : 927846036,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843WNUu",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1049005234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568622/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T07:49:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568622",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928865773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928865773"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you can test the boundary value just under `CFeeRate(entry1->GetModifiedFee() - 1, entry1->GetTxSize())`. In case of accidental refactoring of `PaysMoreThanConflitcts` and the `<=` is dropped to `=` it should catch it.  ",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T13:09:53Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928865773",
      "id" : 928865773,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII5843XV3t",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 124,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928865773/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928865773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928905282"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928905282"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm wondering what you're aiming to demonstrate with this test ? If you would like to show that a replacement candidate with a higher ancestor feerate won't replace conflicts with higher individual feerate, I believe the replacement topology should have a parent with a higher feerate, namely here with `entry8` ?",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T13:47:16Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928905282",
      "id" : 928905282,
      "line" : 131,
      "node_id" : "PRRC_kwDOABII5843XfhC",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 131,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 131,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928905282/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928905282",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/25674/commits/433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T14:19:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1194112240",
      "id" : 1194112240,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HLLTw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1194112240/reactions"
      },
      "updated_at" : "2022-07-25T14:19:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1194112240",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928954333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928954333"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think in practice `entry1` should be part of the replacement transaction's ancestors so this topology should fail in a normal evaluation in `PreChecks` ? I'm correct can be nice to document.",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T14:30:38Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928954333",
      "id" : 928954333,
      "line" : 143,
      "node_id" : "PRRC_kwDOABII5843Xrfd",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 143,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 143,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928954333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928954333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928973898"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928973898"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think here you can the variant where the `additional_fees` are so high, even with a big transaction that it can succeed `PaysForRBF`, to verify that huge size in itself isn't a source of error ?",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T14:47:57Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928973898",
      "id" : 928973898,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII5843XwRK",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 162,
      "original_position" : 162,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 162,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928973898/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928973898",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928995580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928995580"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Bikeshedding of the day. This function name could actually reflect the fact that BIP125 is enforced here for codebase clarity, something like `FetchConflictingEntriesAndCheckMaxReplacement` ? (can be in other commit/PR).",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T15:07:31Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928995580",
      "id" : 928995580,
      "line" : 206,
      "node_id" : "PRRC_kwDOABII5843X1j8",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 206,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 206,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928995580/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928995580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928996334"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928996334"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you're bored, I think there is `IsRBFOptIn` remaining in `rbf.cpp` deserving unit test coverage.",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T15:08:08Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed\n+    CTransactionRef spends_unconfirmed = make_tx({36 * CENT}, {tx1});\n+    for (const auto& input : spends_unconfirmed->vin) {\n+        // Spends unconfirmed inputs.\n+        BOOST_CHECK(pool.exists(GenTxid::Txid(input.prevout.hash)));\n+    }\n+    BOOST_CHECK(HasNoNewUnconfirmed(/*tx=*/ *spends_unconfirmed.get(),\n+                                    /*pool=*/ pool,\n+                                    /*iters_conflicting=*/ all_entries) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, {entry2}) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, empty_set).has_value());\n+\n+    CTransactionRef spends_new_unconfirmed = make_tx({36 * CENT}, {tx1, tx8});\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, {entry2}).has_value());\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, all_entries).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928996334",
      "id" : 928996334,
      "line" : 222,
      "node_id" : "PRRC_kwDOABII5843X1vu",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 222,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 222,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928996334/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928996334",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929750073"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929750073"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Tests pass even if the check for mempool existence in `HasNoNewUnconfirmed`Â removed:\r\n```diff\r\ndiff --git a/src/policy/rbf.cpp b/src/policy/rbf.cpp\r\nindex e25f5c7c5b..f1d8301ab6 100644\r\n--- a/src/policy/rbf.cpp\r\n+++ b/src/policy/rbf.cpp\r\n@@ -106,10 +106,10 @@ std::optional<std::string> HasNoNewUnconfirmed(const CTransaction& tx,\r\n         if (!parents_of_conflicts.count(tx.vin[j].prevout.hash)) {\r\n             // Rather than check the UTXO set - potentially expensive - it's cheaper to just check\r\n             // if the new input refers to a tx that's in the mempool.\r\n-            if (pool.exists(GenTxid::Txid(tx.vin[j].prevout.hash))) {\r\n+            //if (pool.exists(GenTxid::Txid(tx.vin[j].prevout.hash))) {\r\n                 return strprintf(\"replacement %s adds unconfirmed input, idx %d\",\r\n                                  tx.GetHash().ToString(), j);\r\n-            }\r\n+            //}\r\n         }\r\n     }\r\n     return std::nullopt;\r\n```",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T09:40:22Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929750073",
      "id" : 929750073,
      "line" : 211,
      "node_id" : "PRRC_kwDOABII5843atw5",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 211,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 211,
      "pull_request_review_id" : 1050677147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929750073/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:10:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929750073",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929770835"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929770835"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The opposite, actually. We're showing that, if individual feerate is the same, the original is preferred even though it has a lower ancestor feerate. I don't think a high-feerate parent is particularly interesting, since they'd be mined without the child (which is why we usually use min(ancestor, individual) feerate).\r\n\r\nAlso note that entry8 doesn't have any parents.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:01:24Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929770835",
      "id" : 929770835,
      "in_reply_to_id" : 928905282,
      "line" : 133,
      "node_id" : "PRRC_kwDOABII5843ay1T",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 133,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 133,
      "pull_request_review_id" : 1050705894,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929770835/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:01:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929770835",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929772631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929772631"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changing the check in `PaysMoreThanConflict` to anything else than `<=` (ie `<`, `>`, `>=`, `==`) would fail the test already.\r\n\r\nChanging to `=` would not compile.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:03:18Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929772631",
      "id" : 929772631,
      "in_reply_to_id" : 928865773,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII5843azRX",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 124,
      "pull_request_review_id" : 1050677147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929772631/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:10:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929772631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929776616"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929776616"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Antoine: It's precisely what's being tested the 2 lines just above?",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:07:41Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929776616",
      "id" : 929776616,
      "in_reply_to_id" : 928954333,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII5843a0Po",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 145,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 145,
      "pull_request_review_id" : 1050677147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929776616/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:10:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929776616",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929795471"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929795471"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, I think the off-by-one error is accounted for on these lines. i.e. same fee fails, same fee + 1 succeeds.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:27:02Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929795471",
      "id" : 929795471,
      "in_reply_to_id" : 928865773,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII5843a42P",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 124,
      "pull_request_review_id" : 1050739785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929795471/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:27:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929795471",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796137"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796137"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a comment to clarify. Hopefully resolves this, but feel free to unresolve if not!",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:27:45Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796137",
      "id" : 929796137,
      "in_reply_to_id" : 928905282,
      "line" : 133,
      "node_id" : "PRRC_kwDOABII5843a5Ap",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 133,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 133,
      "pull_request_review_id" : 1050740666,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796137/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:27:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796137",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796517"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, that's the idea for the comment \"EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\" I've edited the comment and moved it down 2 lines to make it more clear what's being tested.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:28:12Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796517",
      "id" : 929796517,
      "in_reply_to_id" : 928954333,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII5843a5Gl",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 145,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 145,
      "pull_request_review_id" : 1050741255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796517/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:28:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796517",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796635"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796635"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, done.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:28:20Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796635",
      "id" : 929796635,
      "in_reply_to_id" : 928973898,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII5843a5Ib",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 164,
      "original_position" : 162,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 164,
      "pull_request_review_id" : 1050741413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796635/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:28:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796635",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796910"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796910"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point! Added a test for conflicting confirmed inputs.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:28:40Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796910",
      "id" : 929796910,
      "in_reply_to_id" : 929750073,
      "line" : 211,
      "node_id" : "PRRC_kwDOABII5843a5Mu",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 211,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 211,
      "pull_request_review_id" : 1050741823,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796910/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:28:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796910",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929798212"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929798212"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree the naming could be changed to reflect that the function checks max replacements. But maybe for another PR :sweat_smile:",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:30:11Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929798212",
      "id" : 929798212,
      "in_reply_to_id" : 928995580,
      "line" : 209,
      "node_id" : "PRRC_kwDOABII5843a5hE",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 209,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 209,
      "pull_request_review_id" : 1050743710,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929798212/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:30:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929798212",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, will review soon",
      "created_at" : "2022-07-26T11:47:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1195378564",
      "id" : 1195378564,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HQAeE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1195378564/reactions"
      },
      "updated_at" : "2022-07-26T11:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1195378564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931116723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931116723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Optional, feel free to ignore, maybe add this file to the RUN_TIDY include-what-you-use list in `ci/test/06_script_b.sh` and update the headers with any relevant suggestions in the tidy CI output.  ",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-27T14:13:17Z",
      "diff_hunk" : "@@ -117,6 +117,7 @@ BITCOIN_TESTS =\\\n   test/prevector_tests.cpp \\\n   test/raii_event_tests.cpp \\\n   test/random_tests.cpp \\\n+  test/rbf_tests.cpp \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931116723",
      "id" : 931116723,
      "line" : 120,
      "node_id" : "PRRC_kwDOABII5843f7az",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 120,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : 4,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931116723/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T15:46:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931116723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931136911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931136911"
         }
      },
      "author_association" : "MEMBER",
      "body" : "- can be static\r\n```suggestion\r\nstatic void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\r\n```\r\n\r\n- params order; from our developer notes:\r\n\r\n    When ordering function parameters, place input parameters first, then any in-out parameters, followed by any output parameters.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-27T14:29:42Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931136911",
      "id" : 931136911,
      "line" : 40,
      "node_id" : "PRRC_kwDOABII5843gAWP",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 40,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 40,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931136911/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T15:47:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931136911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931138577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931138577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3 places `s/cs_main/::cs_main/` (the absolute reference to cs_main is preferred for new code)\r\n```suggestion\r\n    EXCLUSIVE_LOCKS_REQUIRED(::cs_main, pool.cs)\r\n```",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-27T14:31:04Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931138577",
      "id" : 931138577,
      "line" : 41,
      "node_id" : "PRRC_kwDOABII5843gAwR",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 41,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 41,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931138577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T15:46:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931138577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931144432"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931144432"
         }
      },
      "author_association" : "MEMBER",
      "body" : "- can be static\r\n```suggestion\r\nstatic inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\r\n```\r\n\r\n- maybe order the params as `inputs`, then `outputs` (e.g. also per the members order in `struct CMutableTransaction`)\r\n- perhaps rename `output_values` to `outputs` for simplicity",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-27T14:35:52Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931144432",
      "id" : 931144432,
      "line" : 19,
      "node_id" : "PRRC_kwDOABII5843gCLw",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 19,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931144432/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T15:46:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931144432",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931153844"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931153844"
         }
      },
      "author_association" : "MEMBER",
      "body" : "maybe remove unneeded spaces throughout this new code per our current usual named arg style\r\n```suggestion\r\n        auto next_tx = make_tx(/*output_values=*/{(50 - i) * CENT}, /*inputs=*/{tx_to_spend});\r\n```",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-27T14:43:27Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931153844",
      "id" : 931153844,
      "line" : 49,
      "node_id" : "PRRC_kwDOABII5843gEe0",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 49,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 49,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931153844/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T15:46:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931153844",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931206932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931206932"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    const CAmount high_fee{COIN};\r\n```",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-27T15:28:54Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931206932",
      "id" : 931206932,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII5843gRcU",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 63,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931206932/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T15:46:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931206932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931220724"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931220724"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use braced initialization for type safety where you can (some in these tests with num_bytes passed won't compile without a cast due to narrowing)\r\n```diff\r\n-    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\r\n-    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\r\n+    const auto incremental_relay_feerate{CFeeRate{DEFAULT_INCREMENTAL_RELAY_FEE}};\r\n+    const auto higher_relay_feerate{CFeeRate{2 * DEFAULT_INCREMENTAL_RELAY_FEE}};\r\n```\r\n",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-27T15:41:29Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // PaysMoreThanConflicts checks individual feerate, not ancestor feerate. This test compares\n+    // replacement_feerate and entry4's feerate, which are the same. The replacement_feerate is\n+    // considered too low even though entry4 has a low ancestor feerate.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    // EntriesAndTxidsDisjoint does not calculate descendants of iters_conflicting; it uses whatever\n+    // the caller passed in. As such, no error is returned even though entry2 is a descendant of tx1.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931220724",
      "id" : 931220724,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843gUz0",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931220724/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T16:31:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931220724",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931222497"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931222497"
         }
      },
      "author_association" : "MEMBER",
      "body" : "These CTransactionRefs can be const if you like.\r\n\r\n```diff\r\n@@ -167,9 +168,9 @@ BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\r\n     // Tests for GetEntriesForConflicts\r\n     CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\r\n     CTxMemPool::setEntries all_children{entry2, entry4, entry6};\r\n-    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\r\n+    const std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\r\n                                                 m_coinbase_txns[3], m_coinbase_txns[4]});\r\n-    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\r\n+    const CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\r\n@@ -209,7 +210,7 @@ BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\r\n     // Tests for HasNoNewUnconfirmed\r\n-    CTransactionRef spends_unconfirmed = make_tx({36 * CENT}, {tx1});\r\n+    const CTransactionRef spends_unconfirmed = make_tx({36 * CENT}, {tx1});\r\n@@ -220,11 +221,11 @@ BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\r\n-    CTransactionRef spends_new_unconfirmed = make_tx({36 * CENT}, {tx1, tx8});\r\n+    const CTransactionRef spends_new_unconfirmed = make_tx({36 * CENT}, {tx1, tx8});\r\n     BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, {entry2}).has_value());\r\n     BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, all_entries).has_value());\r\n \r\n-    CTransactionRef spends_conflicting_confirmed = make_tx({45 * CENT}, {m_coinbase_txns[0], m_coinbase_txns[1]});\r\n+    const CTransactionRef spends_conflicting_confirmed = make_tx({45 * CENT}, {m_coinbase_txns[0], m_coinbase_txns[1]});\r\n }\r\n```\r\n",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-27T15:43:02Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // PaysMoreThanConflicts checks individual feerate, not ancestor feerate. This test compares\n+    // replacement_feerate and entry4's feerate, which are the same. The replacement_feerate is\n+    // considered too low even though entry4 has a low ancestor feerate.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    // EntriesAndTxidsDisjoint does not calculate descendants of iters_conflicting; it uses whatever\n+    // the caller passed in. As such, no error is returned even though entry2 is a descendant of tx1.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee + 99999999, 99999999, incremental_relay_feerate, unused_txid) == std::nullopt);\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed\n+    CTransactionRef spends_unconfirmed = make_tx({36 * CENT}, {tx1});\n+    for (const auto& input : spends_unconfirmed->vin) {\n+        // Spends unconfirmed inputs.\n+        BOOST_CHECK(pool.exists(GenTxid::Txid(input.prevout.hash)));\n+    }\n+    BOOST_CHECK(HasNoNewUnconfirmed(/*tx=*/ *spends_unconfirmed.get(),\n+                                    /*pool=*/ pool,\n+                                    /*iters_conflicting=*/ all_entries) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, {entry2}) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, empty_set).has_value());\n+\n+    CTransactionRef spends_new_unconfirmed = make_tx({36 * CENT}, {tx1, tx8});\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, {entry2}).has_value());\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, all_entries).has_value());\n+\n+    CTransactionRef spends_conflicting_confirmed = make_tx({45 * CENT}, {m_coinbase_txns[0], m_coinbase_txns[1]});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r931222497",
      "id" : 931222497,
      "line" : 227,
      "node_id" : "PRRC_kwDOABII5843gVPh",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 227,
      "original_position" : 227,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 227,
      "pull_request_review_id" : 1052585121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931222497/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-27T15:46:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/931222497",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Still looking at this but seeing tests green with very different values for low_fee and normal_fee and high_fee. \r\n\r\nThe fees should now be 10x apart each, so hopefully less arbitrary.\r\n\r\nAlso, apologies for the confusion, I should have mentioned that I pulled this out of #25038 which includes a new check for ancestor feerate. The low-high fees are essentially CPFPs and make a significant difference there, but are largely ignored in the current rules (hence all the \"notice how ancestor feerate is not checked here\" test cases in this PR). There's probably still room to make the values tighter, but hopefully this background helps.",
      "created_at" : "2022-07-28T10:33:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1197965279",
      "id" : 1197965279,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HZ3_f",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1197965279/reactions"
      },
      "updated_at" : "2022-07-28T11:06:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1197965279",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932072247"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932072247"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> can be static\r\n\r\ndone\r\n\r\n> * maybe order the params as `inputs`, then `outputs` (e.g. also per the members order in `struct CMutableTransaction`)\r\n> \r\n> * perhaps rename `output_values` to `outputs` for simplicity\r\n\r\nnote `output_values` is a vector of `CAmount`s, not `CTxOut`s",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T10:51:50Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932072247",
      "id" : 932072247,
      "in_reply_to_id" : 931144432,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843jks3",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 19,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1053884570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932072247/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932072247",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932072375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932072375"
         }
      },
      "author_association" : "MEMBER",
      "body" : "both done",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T10:51:58Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932072375",
      "id" : 932072375,
      "in_reply_to_id" : 931136911,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843jku3",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 40,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1053884570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932072375/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932072375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932073544"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932073544"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, thanks",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T10:53:22Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932073544",
      "id" : 932073544,
      "in_reply_to_id" : 931138577,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843jlBI",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 41,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1053884570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932073544/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932073544",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932073628"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932073628"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T10:53:29Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932073628",
      "id" : 932073628,
      "in_reply_to_id" : 931153844,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843jlCc",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 49,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1053884570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932073628/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932073628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932074218"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932074218"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed these to be 1 order of magnitude apart each (hopefully less arbitrary than before) and removed the `1 *`",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T10:54:16Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932074218",
      "id" : 932074218,
      "in_reply_to_id" : 931206932,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843jlLq",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1053884570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932074218/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932074218",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932075057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932075057"
         }
      },
      "author_association" : "MEMBER",
      "body" : "changed to `const CFeeRate incremental_relay_feerate{DEFAULT_INCREMENTAL_RELAY_FEE};`, which I think incorporates your suggestion and is less verbose than before\r\n",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T10:55:21Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // PaysMoreThanConflicts checks individual feerate, not ancestor feerate. This test compares\n+    // replacement_feerate and entry4's feerate, which are the same. The replacement_feerate is\n+    // considered too low even though entry4 has a low ancestor feerate.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    // EntriesAndTxidsDisjoint does not calculate descendants of iters_conflicting; it uses whatever\n+    // the caller passed in. As such, no error is returned even though entry2 is a descendant of tx1.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932075057",
      "id" : 932075057,
      "in_reply_to_id" : 931220724,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843jlYx",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1053884570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932075057/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932075057",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932076126"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932076126"
         }
      },
      "author_association" : "MEMBER",
      "body" : "changed everything holding return values from `make_tx` to `const auto`\r\nadded `const std::vector<CTransactionRef> parent_inputs`",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T10:56:33Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // PaysMoreThanConflicts checks individual feerate, not ancestor feerate. This test compares\n+    // replacement_feerate and entry4's feerate, which are the same. The replacement_feerate is\n+    // considered too low even though entry4 has a low ancestor feerate.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    // EntriesAndTxidsDisjoint does not calculate descendants of iters_conflicting; it uses whatever\n+    // the caller passed in. As such, no error is returned even though entry2 is a descendant of tx1.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee + 99999999, 99999999, incremental_relay_feerate, unused_txid) == std::nullopt);\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed\n+    CTransactionRef spends_unconfirmed = make_tx({36 * CENT}, {tx1});\n+    for (const auto& input : spends_unconfirmed->vin) {\n+        // Spends unconfirmed inputs.\n+        BOOST_CHECK(pool.exists(GenTxid::Txid(input.prevout.hash)));\n+    }\n+    BOOST_CHECK(HasNoNewUnconfirmed(/*tx=*/ *spends_unconfirmed.get(),\n+                                    /*pool=*/ pool,\n+                                    /*iters_conflicting=*/ all_entries) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, {entry2}) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, empty_set).has_value());\n+\n+    CTransactionRef spends_new_unconfirmed = make_tx({36 * CENT}, {tx1, tx8});\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, {entry2}).has_value());\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, all_entries).has_value());\n+\n+    CTransactionRef spends_conflicting_confirmed = make_tx({45 * CENT}, {m_coinbase_txns[0], m_coinbase_txns[1]});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932076126",
      "id" : 932076126,
      "in_reply_to_id" : 931222497,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843jlpe",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 227,
      "original_position" : 227,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1053884570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932076126/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932076126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932086923"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932086923"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Will save for later PR. It's fuzzed in src/test/fuzz/rbf.cpp so I'm less worried atm.",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T11:09:57Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed\n+    CTransactionRef spends_unconfirmed = make_tx({36 * CENT}, {tx1});\n+    for (const auto& input : spends_unconfirmed->vin) {\n+        // Spends unconfirmed inputs.\n+        BOOST_CHECK(pool.exists(GenTxid::Txid(input.prevout.hash)));\n+    }\n+    BOOST_CHECK(HasNoNewUnconfirmed(/*tx=*/ *spends_unconfirmed.get(),\n+                                    /*pool=*/ pool,\n+                                    /*iters_conflicting=*/ all_entries) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, {entry2}) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, empty_set).has_value());\n+\n+    CTransactionRef spends_new_unconfirmed = make_tx({36 * CENT}, {tx1, tx8});\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, {entry2}).has_value());\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, all_entries).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932086923",
      "id" : 932086923,
      "in_reply_to_id" : 928996334,
      "line" : 224,
      "node_id" : "PRRC_kwDOABII5843joSL",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 224,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 224,
      "pull_request_review_id" : 1053905231,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932086923/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T11:09:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932086923",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932371834"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932371834"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Even better indeed :+1: ",
      "commit_id" : "c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T15:13:04Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // PaysMoreThanConflicts checks individual feerate, not ancestor feerate. This test compares\n+    // replacement_feerate and entry4's feerate, which are the same. The replacement_feerate is\n+    // considered too low even though entry4 has a low ancestor feerate.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    // EntriesAndTxidsDisjoint does not calculate descendants of iters_conflicting; it uses whatever\n+    // the caller passed in. As such, no error is returned even though entry2 is a descendant of tx1.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r932371834",
      "id" : 932371834,
      "in_reply_to_id" : 931220724,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843kt16",
      "original_commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1054312411,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932371834/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-28T15:13:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/932371834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/25674/commits/c320cddb1b57a9c9911054fc440f7a12aaea61b5",
      "created_at" : "2022-07-28T15:20:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1198301592",
      "id" : 1198301592,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HbKGY",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1198301592/reactions"
      },
      "updated_at" : "2022-07-28T15:20:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1198301592",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for the context.\r\n\r\nACK c320cddb1b57a9c9911054fc440f7a12aaea61b5\r\n\r\n(modulo I haven't yet looked at https://github.com/bitcoin/bitcoin/pull/25038)",
      "created_at" : "2022-07-28T15:25:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1198307166",
      "id" : 1198307166,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HbLde",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1198307166/reactions"
      },
      "updated_at" : "2022-07-28T15:25:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1198307166",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This has 3 ACKs (thanks @w0xlt, @instagibbs, @jonatack) and the previous state had 2 other ACKs (thanks @darosior, @t-bast). This PR is just adding test coverage and doesn't conflict with anything other than my draft PR it's pulled out from. As such, it seems there is sufficient review to merge even though I am the author.",
      "created_at" : "2022-07-28T16:22:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1198368215",
      "id" : 1198368215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HbaXX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1198368215/reactions"
      },
      "updated_at" : "2022-07-28T16:22:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1198368215",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> This PR is just adding test coverage and doesn't conflict with anything other than my draft PR it's pulled out from. As such, it seems there is sufficient review to merge even though I am the author.\r\n\r\nIt seems review was insufficient. Adding wrong or low quality test coverage could lead to things not being tested but assumed to be tested.",
      "created_at" : "2022-08-11T13:26:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1211987919",
      "id" : 1211987919,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585IPXfP",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1211987919/reactions"
      },
      "updated_at" : "2022-08-11T13:26:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1211987919",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/94559964?v=4",
         "events_url" : "https://api.github.com/users/1440000bytes/events{/privacy}",
         "followers_url" : "https://api.github.com/users/1440000bytes/followers",
         "following_url" : "https://api.github.com/users/1440000bytes/following{/other_user}",
         "gists_url" : "https://api.github.com/users/1440000bytes/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/1440000bytes",
         "id" : 94559964,
         "login" : "1440000bytes",
         "node_id" : "U_kgDOBaLe3A",
         "organizations_url" : "https://api.github.com/users/1440000bytes/orgs",
         "received_events_url" : "https://api.github.com/users/1440000bytes/received_events",
         "repos_url" : "https://api.github.com/users/1440000bytes/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/1440000bytes/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/1440000bytes/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/1440000bytes"
      }
   }
]
