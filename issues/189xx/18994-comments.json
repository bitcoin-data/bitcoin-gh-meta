[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.",
      "created_at" : "2020-05-17T11:05:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#issuecomment-629779615",
      "id" : 629779615,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18994",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYyOTc3OTYxNQ==",
      "updated_at" : "2020-05-17T21:15:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/629779615",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426250850"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426250850"
         }
      },
      "author_association" : "MEMBER",
      "body" : "unrelated nit: At compile time this can never be null. I'd prefer if the return value for strings was always `std::string`. Every caller of `ScriptErrorString` converts to `std::string` anyway.",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-17T11:37:05Z",
      "diff_hunk" : "@@ -119,4 +125,41 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n             wit.SetNull();\n         }\n     }\n+\n+    const char* op_name = GetOpName(ConsumeOpcodeType(fuzzed_data_provider));\n+    assert(op_name != nullptr);\n+\n+    const char* error_string = ScriptErrorString(static_cast<ScriptError>(fuzzed_data_provider.ConsumeIntegralInRange<int>(0, SCRIPT_ERR_ERROR_COUNT)));\n+    assert(error_string != nullptr);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426250850",
      "id" : 426250850,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MDg1MA==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 135,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script.cpp",
      "position" : null,
      "pull_request_review_id" : 413153538,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426250850",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426251317"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426251317"
         }
      },
      "author_association" : "MEMBER",
      "body" : "this looks like a unit test that does not depend on any fuzz input",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-17T11:42:17Z",
      "diff_hunk" : "@@ -119,4 +125,41 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n             wit.SetNull();\n         }\n     }\n+\n+    const char* op_name = GetOpName(ConsumeOpcodeType(fuzzed_data_provider));\n+    assert(op_name != nullptr);\n+\n+    const char* error_string = ScriptErrorString(static_cast<ScriptError>(fuzzed_data_provider.ConsumeIntegralInRange<int>(0, SCRIPT_ERR_ERROR_COUNT)));\n+    assert(error_string != nullptr);\n+\n+    {\n+        const std::vector<uint8_t> bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+        CScript append_script{bytes.begin(), bytes.end()};\n+        append_script << fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+        append_script << ConsumeOpcodeType(fuzzed_data_provider);\n+        append_script << CScriptNum{fuzzed_data_provider.ConsumeIntegral<int64_t>()};\n+        append_script << ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    }\n+\n+    {\n+        WitnessUnknown witness_unknown_1{};\n+        witness_unknown_1.version = fuzzed_data_provider.ConsumeIntegral<int>();\n+        const std::vector<uint8_t> witness_unknown_program_1 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n+        witness_unknown_1.length = witness_unknown_program_1.size();\n+        std::copy(witness_unknown_program_1.begin(), witness_unknown_program_1.end(), witness_unknown_1.program);\n+\n+        WitnessUnknown witness_unknown_2{};\n+        witness_unknown_2.version = fuzzed_data_provider.ConsumeIntegral<int>();\n+        const std::vector<uint8_t> witness_unknown_program_2 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n+        witness_unknown_2.length = witness_unknown_program_2.size();\n+        std::copy(witness_unknown_program_2.begin(), witness_unknown_program_2.end(), witness_unknown_2.program);\n+\n+        (void)(witness_unknown_1 == witness_unknown_2);\n+        (void)(witness_unknown_1 < witness_unknown_2);\n+\n+        const CNoDestination no_destination_1;\n+        const CNoDestination no_destination_2;\n+        (void)(no_destination_1 == no_destination_2);\n+        (void)(no_destination_1 < no_destination_2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426251317",
      "id" : 426251317,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MTMxNw==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 165,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script.cpp",
      "position" : null,
      "pull_request_review_id" : 413153538,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426251317",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426252814"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426252814"
         }
      },
      "author_association" : "MEMBER",
      "body" : "unrelated, but I was wondering if `ConsumeDeserializable<T>` could always return type `T` (if the stream was empty, it would return `T{}`). Not returning optional would bring this helper in line with all other helpers. For example `ConsumeRandomLengthString` always return `std::string`.",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-17T11:58:00Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426252814",
      "id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MjgxNA==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 413153538,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426252814",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426252948"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426252948"
         }
      },
      "author_association" : "MEMBER",
      "body" : "My suggestion would be to construct a random `CTxDestination`.",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-17T11:59:38Z",
      "diff_hunk" : "@@ -119,4 +125,41 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n             wit.SetNull();\n         }\n     }\n+\n+    const char* op_name = GetOpName(ConsumeOpcodeType(fuzzed_data_provider));\n+    assert(op_name != nullptr);\n+\n+    const char* error_string = ScriptErrorString(static_cast<ScriptError>(fuzzed_data_provider.ConsumeIntegralInRange<int>(0, SCRIPT_ERR_ERROR_COUNT)));\n+    assert(error_string != nullptr);\n+\n+    {\n+        const std::vector<uint8_t> bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+        CScript append_script{bytes.begin(), bytes.end()};\n+        append_script << fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+        append_script << ConsumeOpcodeType(fuzzed_data_provider);\n+        append_script << CScriptNum{fuzzed_data_provider.ConsumeIntegral<int64_t>()};\n+        append_script << ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    }\n+\n+    {\n+        WitnessUnknown witness_unknown_1{};\n+        witness_unknown_1.version = fuzzed_data_provider.ConsumeIntegral<int>();\n+        const std::vector<uint8_t> witness_unknown_program_1 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n+        witness_unknown_1.length = witness_unknown_program_1.size();\n+        std::copy(witness_unknown_program_1.begin(), witness_unknown_program_1.end(), witness_unknown_1.program);\n+\n+        WitnessUnknown witness_unknown_2{};\n+        witness_unknown_2.version = fuzzed_data_provider.ConsumeIntegral<int>();\n+        const std::vector<uint8_t> witness_unknown_program_2 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n+        witness_unknown_2.length = witness_unknown_program_2.size();\n+        std::copy(witness_unknown_program_2.begin(), witness_unknown_program_2.end(), witness_unknown_2.program);\n+\n+        (void)(witness_unknown_1 == witness_unknown_2);\n+        (void)(witness_unknown_1 < witness_unknown_2);\n+\n+        const CNoDestination no_destination_1;\n+        const CNoDestination no_destination_2;\n+        (void)(no_destination_1 == no_destination_2);\n+        (void)(no_destination_1 < no_destination_2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426252948",
      "id" : 426252948,
      "in_reply_to_id" : 426251317,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Mjk0OA==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 165,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script.cpp",
      "position" : null,
      "pull_request_review_id" : 413155155,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426252948",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-05-17T14:29:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#issuecomment-629807292",
      "id" : 629807292,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18994",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYyOTgwNzI5Mg==",
      "updated_at" : "2020-05-17T14:29:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/629807292",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426279217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426279217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree, we should always return `std::string`. Will do that in a follow-up PR since that will touch validation code and thus need more scrutiny than adding tests.",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-17T16:24:47Z",
      "diff_hunk" : "@@ -119,4 +125,41 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n             wit.SetNull();\n         }\n     }\n+\n+    const char* op_name = GetOpName(ConsumeOpcodeType(fuzzed_data_provider));\n+    assert(op_name != nullptr);\n+\n+    const char* error_string = ScriptErrorString(static_cast<ScriptError>(fuzzed_data_provider.ConsumeIntegralInRange<int>(0, SCRIPT_ERR_ERROR_COUNT)));\n+    assert(error_string != nullptr);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426279217",
      "id" : 426279217,
      "in_reply_to_id" : 426250850,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTIxNw==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 135,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script.cpp",
      "position" : null,
      "pull_request_review_id" : 413177727,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426279217",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426625962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426625962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done! :)",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-18T13:28:59Z",
      "diff_hunk" : "@@ -119,4 +125,41 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n             wit.SetNull();\n         }\n     }\n+\n+    const char* op_name = GetOpName(ConsumeOpcodeType(fuzzed_data_provider));\n+    assert(op_name != nullptr);\n+\n+    const char* error_string = ScriptErrorString(static_cast<ScriptError>(fuzzed_data_provider.ConsumeIntegralInRange<int>(0, SCRIPT_ERR_ERROR_COUNT)));\n+    assert(error_string != nullptr);\n+\n+    {\n+        const std::vector<uint8_t> bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+        CScript append_script{bytes.begin(), bytes.end()};\n+        append_script << fuzzed_data_provider.ConsumeIntegral<int64_t>();\n+        append_script << ConsumeOpcodeType(fuzzed_data_provider);\n+        append_script << CScriptNum{fuzzed_data_provider.ConsumeIntegral<int64_t>()};\n+        append_script << ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    }\n+\n+    {\n+        WitnessUnknown witness_unknown_1{};\n+        witness_unknown_1.version = fuzzed_data_provider.ConsumeIntegral<int>();\n+        const std::vector<uint8_t> witness_unknown_program_1 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n+        witness_unknown_1.length = witness_unknown_program_1.size();\n+        std::copy(witness_unknown_program_1.begin(), witness_unknown_program_1.end(), witness_unknown_1.program);\n+\n+        WitnessUnknown witness_unknown_2{};\n+        witness_unknown_2.version = fuzzed_data_provider.ConsumeIntegral<int>();\n+        const std::vector<uint8_t> witness_unknown_program_2 = fuzzed_data_provider.ConsumeBytes<uint8_t>(40);\n+        witness_unknown_2.length = witness_unknown_program_2.size();\n+        std::copy(witness_unknown_program_2.begin(), witness_unknown_program_2.end(), witness_unknown_2.program);\n+\n+        (void)(witness_unknown_1 == witness_unknown_2);\n+        (void)(witness_unknown_1 < witness_unknown_2);\n+\n+        const CNoDestination no_destination_1;\n+        const CNoDestination no_destination_2;\n+        (void)(no_destination_1 == no_destination_2);\n+        (void)(no_destination_1 < no_destination_2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426625962",
      "id" : 426625962,
      "in_reply_to_id" : 426251317,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYyNTk2Mg==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 165,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script.cpp",
      "position" : null,
      "pull_request_review_id" : 413593920,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426625962",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426638879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426638879"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You mean something along the lines of:\r\n\r\n```c++\r\ntemplate <typename T>\r\nNODISCARD inline T ConsumeDeserializable(FuzzedDataProvider& fuzzed_data_provider, const size_t max_length = 4096) noexcept\r\n{\r\n    const std::vector<uint8_t> buffer = ConsumeRandomLengthByteVector(fuzzed_data_provider, max_length);\r\n    CDataStream ds{buffer, SER_NETWORK, INIT_PROTO_VERSION};\r\n    T obj;\r\n    try {\r\n        ds >> obj;\r\n    } catch (const std::ios_base::failure&) {\r\n    }\r\n    return obj;\r\n}\r\n```\r\n\r\nI've thought about that and while it would be better from a developer ergonomics perspective I think it might come with some negative impact on overall fuzzing. One risk I see is that the fuzzer might try to work also on \"meaningless\" inputs (inputs which cause `std::ios_base::failure`) which would now become \"somewhat meaningful\" due to default construction.\r\n\r\nTake the extreme example of a huge input containing a few million bytes worth of 0x41 scream (`AAAAAAAAAAAâ¦`) being deserialized to an object of type `CFoo`. The current fuzzer would quickly reach `std::ios_base::failure`, return a `nullopt` and then give up without further processing (fail early thanks to `if (!opt_foo) { return; }` or similar). If we were to return a `CFoo{}` instead then the fuzzer would proceed with processing (fail late) which may slow down the fuzzing.\r\n\r\nDoes it make sense? :)\r\n\r\ntl;dr -- would be worth doing if no negative fuzzing speed impact can be measured :)\r\n\r\n_Edit: [Proof of concept here](https://github.com/bitcoin/bitcoin/compare/master...practicalswift:consume) if someone wants to experiment :)_",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-18T13:48:03Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426638879",
      "id" : 426638879,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYzODg3OQ==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 413610947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426638879",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426672035"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426672035"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think when it comes to trading off giving the fuzz test more freedom to explore more code branches vs micro-optimizing for performance, we should always pick the option that gives the fuzz engine more freedom. Fuzzing is great to complement traditional tests (e.g. our unit and functional tests). Those traditional tests offer a reasonable line coverage, but fuzz testing can offer great branch coverage. Giving the fuzz engine to explore as much branches as possible is vital. With modern coverage guided fuzz engines, the strength of fuzzing is that even with a large search space, the fuzz engine will always find useful inputs that increase coverage. Additional search space may (or may not!) come with a performance penalty, but I think we shouldn't use performance as a way to measure usefulness of a fuzz tests. The fastest fuzz test is the one that tests nothing. However, it is also the most useless one. Anything that can be solved by letting the fuzz engine run for another hour or by simply adding one more core should not be a reason to cripple the test into one that yields less coverage.\r\n\r\nIn fact, this has shown to be effective in the past. Take for example the process_message harness vs the process_message*s* harness. The latter is allowed to send an arbitrary number of messages and start an arbitrary number of peers. The latter (more flexible and broader) test that gives the engine more freedom is also the *only* test that has found bugs in pull requests that none of the other fuzz test or unit test or even functional tests have found. Specifically:\r\n\r\n* It found a nullptr dereference: https://github.com/bitcoin/bitcoin/pull/18808#discussion_r417307258\r\n* It found an unidentified problem: https://github.com/bitcoin/bitcoin/pull/15197#pullrequestreview-408731734\r\n* Some more that I am missing...?",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-18T14:34:34Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426672035",
      "id" : 426672035,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MjAzNQ==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 413654484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426672035",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426695025"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426695025"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree regarding the coverage vs performance trade-off: I'd choose \"explore more code branches\" over performance any day in the week :)\r\n\r\nDo you see a scenario where returning a default constructed object in case of serialisation failure is likely to give more freedom to explore more code branches (in a way that will have a positive impact of coverage) compared to not doing so?\r\n\r\nIf so we'd have _two_ reasons to do this: developer ergonomics (no more `std::optional`) _and_ increased coverage :)\r\n\r\nMy thinking is more along the lines of \"how do we guide the coverage-guided fuzzer in a meaningful way\" rather than \"micro-optimizing for performance\". I guess the question boils down to if and to what extent the guidance provided by failing early is meaningful for the fuzzer :)\r\n\r\nCode if anyone wants to experiment: https://github.com/bitcoin/bitcoin/compare/master...practicalswift:consume",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-18T15:06:21Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426695025",
      "id" : 426695025,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NTAyNQ==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 413684094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426695025",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426698810"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426698810"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Do you see a scenario where returning a default constructed object in case of serialisation failure is likely to give more freedom to explore more code branches compared to not doing so?\r\n\r\nUnclear. This question boils down to whether default initialization leaves members uninitialized or initializes them with values that can not be the result of deserialization.",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-18T15:11:30Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426698810",
      "id" : 426698810,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5ODgxMA==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 413689053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426698810",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426854421"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426854421"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agreed. Sounds like we agree on the need for experimentation and measuring before proceeding with this :)",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-18T19:43:47Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426854421",
      "id" : 426854421,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1NDQyMQ==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 413888902,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-30T10:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/426854421",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needs rebase",
      "created_at" : "2020-05-29T00:01:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#issuecomment-635679615",
      "id" : 635679615,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18994",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNTY3OTYxNQ==",
      "updated_at" : "2020-05-29T00:01:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/635679615",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK f898ef65c947776750e49d050633f830546bbdc6 ð\r\n\r\n<details><summary>Show signature and timestamp</summary>\r\n\r\nSignature:\r\n\r\n```\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA512\r\n\r\nACK f898ef65c947776750e49d050633f830546bbdc6 ð\r\n-----BEGIN PGP SIGNATURE-----\r\n\r\niQGzBAEBCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\r\npUgtcwwAk2++KR5/UnaZ6/Gls4rZq7sjVolrOPUw/ADuxRyFu/qM7nmAOuzhX645\r\n/tuQPOszycpK7MuS8INKbw2gV4TTP35W7N9z8GhtbyaSlRXzBGF5vLGk0P1diJrp\r\nGwSiwUle6VU4sRLX44DctSgP9NvNMBkl+zqFEJpjspXkGZuYvtDJrP4Ipm+oSNOw\r\nd5K0zg6VKwz/+23qt9OJErovRltC7QUxIecI+Y0KmJzfkpScf+jGoMTFgo9q0zC4\r\nJDLJ0ZAU8BeiN2J/IK0yyxG1LhZPOK1LikFWqebeD4JEOSA+FnWopXHCUAj+sL7H\r\nhRZmjH1CJ8my2d2nOdqCmOn1R3K+kEuVB0L2cMpPsISRcPjgI8GlF4RcY23PpTBJ\r\nFtjGQdg30fzpNeLW0aPvti4RV7e8eDsi87BOWOVpNKY6AqeKWWcgJwNejrQREfNY\r\n/xHzGR2zvhFYcO7x5V2lafPHaB9CT6lxaRBsNFYfQf7ajaNGeHKXhjHsnQnlW46a\r\nELWIGbLJ\r\n=55wg\r\n-----END PGP SIGNATURE-----\r\n```\r\n\r\n[Timestamp of file with hash `6d0233da06adba4dcb766f9a62ac736cf11c827239891f0b3af49ea1152fcac1  -`](https://opentimestamps.org/info/?004f70656e54696d657374616d7073000050726f6f6600bf89e2e884e8929401086d0233da06adba4dcb766f9a62ac736cf11c827239891f0b3af49ea1152fcac1f010f0fda69d7ba0a0b4e2eb58e9a1a21f0408fff01044eb7829b1342a68a5a8ef361c825fc608f1045ed43688f00839dd2b6f65c2ce4d0083dfe30d2ef90c8e2e2d68747470733a2f2f616c6963652e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267fff0104bca8fb0c87f5e1963452b262a763fd708f1045ed43688f008f5bb659d2c15fd610083dfe30d2ef90c8e2c2b68747470733a2f2f626f622e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267fff0105bdb4a960d998352589f7292f969e03408f1045ed43688f008094f91e8a5d473e50083dfe30d2ef90c8e292868747470733a2f2f66696e6e65792e63616c656e6461722e657465726e69747977616c6c2e636f6df0109589d836dc8a404491ab0260dc03b6ee08f1045ed43687f0084d695a07cc8c234f0083dfe30d2ef90c8e232268747470733a2f2f6274632e63616c656e6461722e636174616c6c6178792e636f6d)\r\n\r\n</details>\r\n",
      "created_at" : "2020-05-31T22:58:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#issuecomment-636543317",
      "id" : 636543317,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18994",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNjU0MzMxNw==",
      "updated_at" : "2020-05-31T22:58:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/636543317",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r432993158"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/432993158"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@practicalswift Are you going to create a pull with the branch or should I do it?",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-05-31T22:59:33Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r432993158",
      "id" : 432993158,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5MzE1OA==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 421535458,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-31T22:59:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/432993158",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r433129784"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/433129784"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@MarcoFalke I plan to do a FuzzBench style test between the two variations (`T ConsumeDeserializable(â¦)` and `std::optional<T> ConsumeDeserializable(â¦)`) to see which one that helps us reach the highest coverage after 24 hours of fuzzing using `libFuzzer` (with each harness given `1/N` slice of the runtime) with an empty input corpus. Does that sound like a fair experimental setup that could guide us regarding the trade-offs we're facing here? If so, I'll do it :)",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-06-01T09:21:40Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r433129784",
      "id" : 433129784,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyOTc4NA==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 421705801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-01T09:21:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/433129784",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r433156970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/433156970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sure, can't hurt to do a benchmark",
      "commit_id" : "f898ef65c947776750e49d050633f830546bbdc6",
      "created_at" : "2020-06-01T10:27:18Z",
      "diff_hunk" : "@@ -0,0 +1,149 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <chainparamsbase.h>\n+#include <key.h>\n+#include <optional.h>\n+#include <pubkey.h>\n+#include <script/keyorigin.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <streams.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cassert>\n+#include <cstdint>\n+#include <iostream>\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+void initialize()\n+{\n+    static const ECCVerifyHandle ecc_verify_handle;\n+    ECC_Start();\n+    SelectParams(CBaseChainParams::REGTEST);\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+    const std::vector<uint8_t> key = ConsumeRandomLengthByteVector(fuzzed_data_provider, 128);\n+\n+    {\n+        CDataStream random_data_stream = ConsumeDataStream(fuzzed_data_provider);\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(random_data_stream, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+    }\n+\n+    {\n+        std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+        while (fuzzed_data_provider.ConsumeBool()) {\n+            const Optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);\n+            if (!pub_key) {\n+                break;\n+            }\n+            const Optional<KeyOriginInfo> key_origin_info = ConsumeDeserializable<KeyOriginInfo>(fuzzed_data_provider);\n+            if (!key_origin_info) {\n+                break;\n+            }\n+            hd_keypaths[*pub_key] = *key_origin_info;\n+        }\n+        CDataStream serialized{SER_NETWORK, PROTOCOL_VERSION};\n+        try {\n+            SerializeHDKeypaths(serialized, hd_keypaths, fuzzed_data_provider.ConsumeIntegral<uint8_t>());\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        std::map<CPubKey, KeyOriginInfo> deserialized_hd_keypaths;\n+        try {\n+            DeserializeHDKeypaths(serialized, key, hd_keypaths);\n+        } catch (const std::ios_base::failure&) {\n+        }\n+        assert(hd_keypaths.size() >= deserialized_hd_keypaths.size());\n+    }\n+\n+    {\n+        SignatureData signature_data_1{ConsumeScript(fuzzed_data_provider)};\n+        SignatureData signature_data_2{ConsumeScript(fuzzed_data_provider)};\n+        signature_data_1.MergeSignatureData(signature_data_2);\n+    }\n+\n+    FillableSigningProvider provider;\n+    CKey k;\n+    const std::vector<uint8_t> key_data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n+    k.Set(key_data.begin(), key_data.end(), fuzzed_data_provider.ConsumeBool());\n+    if (k.IsValid()) {\n+        provider.AddKey(k);\n+    }\n+\n+    {\n+        const Optional<CMutableTransaction> mutable_transaction = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+        const Optional<CTxOut> tx_out = ConsumeDeserializable<CTxOut>(fuzzed_data_provider);\n+        const unsigned int n_in = fuzzed_data_provider.ConsumeIntegral<unsigned int>();\n+        if (mutable_transaction && tx_out && mutable_transaction->vin.size() > n_in) {\n+            SignatureData signature_data_1 = DataFromTransaction(*mutable_transaction, n_in, *tx_out);\n+            CTxIn input;\n+            UpdateInput(input, signature_data_1);\n+            const CScript script = ConsumeScript(fuzzed_data_provider);\n+            SignatureData signature_data_2{script};\n+            signature_data_1.MergeSignatureData(signature_data_2);\n+        }\n+        if (mutable_transaction) {\n+            CTransaction tx_from{*mutable_transaction};\n+            CMutableTransaction tx_to;\n+            const Optional<CMutableTransaction> opt_tx_to = ConsumeDeserializable<CMutableTransaction>(fuzzed_data_provider);\n+            if (opt_tx_to) {\n+                tx_to = *opt_tx_to;\n+            }\n+            CMutableTransaction script_tx_to = tx_to;\n+            CMutableTransaction sign_transaction_tx_to = tx_to;\n+            if (n_in < tx_to.vin.size() && tx_to.vin[n_in].prevout.n < tx_from.vout.size()) {\n+                (void)SignSignature(provider, tx_from, tx_to, n_in, fuzzed_data_provider.ConsumeIntegral<int>());\n+            }\n+            if (n_in < script_tx_to.vin.size()) {\n+                (void)SignSignature(provider, ConsumeScript(fuzzed_data_provider), script_tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>());\n+                MutableTransactionSignatureCreator signature_creator{&tx_to, n_in, ConsumeMoney(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int>()};\n+                std::vector<unsigned char> vch_sig;\n+                CKeyID address;\n+                if (fuzzed_data_provider.ConsumeBool()) {\n+                    if (k.IsValid()) {\n+                        address = k.GetPubKey().GetID();\n+                    }\n+                } else {\n+                    address = CKeyID{ConsumeUInt160(fuzzed_data_provider)};\n+                }\n+                (void)signature_creator.CreateSig(provider, vch_sig, address, ConsumeScript(fuzzed_data_provider), fuzzed_data_provider.PickValueInArray({SigVersion::BASE, SigVersion::WITNESS_V0}));\n+            }\n+            std::map<COutPoint, Coin> coins;\n+            while (fuzzed_data_provider.ConsumeBool()) {\n+                const Optional<COutPoint> outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+                if (!outpoint) {\n+                    break;\n+                }\n+                const Optional<Coin> coin = ConsumeDeserializable<Coin>(fuzzed_data_provider);\n+                if (!coin) {\n+                    break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18994#discussion_r433156970",
      "id" : 433156970,
      "in_reply_to_id" : 426252814,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1Njk3MA==",
      "original_commit_id" : "55778f1472a8f3b8164241794575c0f67fcefbf3",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/fuzz/script_sign.cpp",
      "position" : 134,
      "pull_request_review_id" : 421741746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18994",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-01T10:27:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/433156970",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   }
]
