[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Are there demos of scripts based on this/BIP117 anywhere? eg has someone sat down and rewritten the Lightning scripts or TumbleBit scripts to use this stuff to compare the cost/privacy tradeoffs? What about example usage for hiding multisig?",
      "created_at" : "2018-01-09T21:42:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356423600",
      "id" : 356423600,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T21:42:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356423600",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "There are some examples inside the BIPs:\r\n\r\nhttps://github.com/bitcoin/bips/blob/master/bip-0116.mediawiki\r\nhttps://github.com/bitcoin/bips/blob/master/bip-0117.mediawiki\r\n\r\nIt is specifically anticipated that ALL instances of MAST would be of the following:\r\n\r\n> redeemScript: `[TOALTSTACK]*N OVER HASH256 <root> 1 MERKLEBRANCHVERIFY 2DROP 2DROP`\r\n> witness: `<policyScript> <proof> <arg1> ... <argN>`",
      "created_at" : "2018-01-09T22:15:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356432048",
      "id" : 356432048,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T22:15:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356432048",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm, I was hoping for somewhat larger scripts. Specifically, do you have a list of scripts which are cheaper to do using a merkle-hidden tail call than normally outside of large-multisig examples?",
      "created_at" : "2018-01-09T22:49:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356440036",
      "id" : 356440036,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T22:49:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356440036",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Basically every script where you are eliding, at minimum, a hash or pubkey push. Sorry for the obtuseness, but it seems like that describes just about anything and it didn't seem appropriate to overload the BIP with examples of everything beyond what was necessary to illustrate the concept. I would certainly like a lightning developer to show how those scripts could be reformulated to use tail-call semantics, but I'm not up to speed on the latest lightning standards.",
      "created_at" : "2018-01-09T23:02:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356442915",
      "id" : 356442915,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:02:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356442915",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm, well my primary motivation for asking was to get a better sense of the cost of using MBV+tail-call in practice. Comparing the cost of LN + TumbleBit scripts seems like an obvious route to figure that out, as it seems to me the only obvious user of something like this would be small-n large-m multisig, which seems somewhat of a waste.",
      "created_at" : "2018-01-09T23:05:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356443498",
      "id" : 356443498,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:05:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356443498",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems rather to me that the obvious user of something like this is 'everybody' for the fungibility improvement.",
      "created_at" : "2018-01-09T23:06:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356443782",
      "id" : 356443782,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:06:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356443782",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hence my concern - ideally \"everyone\" would use something like this for fungibility reasons, but I'm highly skeptical anyone will pay a material difference in fees to do so. Obviously I'm not suggesting we go through all the fun of SegWit again to adjust the discount to make a MAST extra branch free, but getting a good idea of exactly what that cost is for common protocols would be useful.",
      "created_at" : "2018-01-09T23:08:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356444255",
      "id" : 356444255,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:08:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356444255",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I think your intuition for the cost savings is off. Right now even a 2-of-3 multisig ends up costing about the same as a MAST of 2-of-2 vs having an extra (unused) pubkey. Likewise the 2of2 -or- CSV 1of1. And when we switch to Schnorr signatures basically any multisig becomes cheaper in the MAST construct because they all reduce to a MAST of 1of1's.",
      "created_at" : "2018-01-09T23:13:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356445236",
      "id" : 356445236,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:13:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356445236",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Concept ACK",
      "created_at" : "2018-01-10T01:26:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356469403",
      "id" : 356469403,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-10T01:26:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356469403",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/35275673?v=4",
         "events_url" : "https://api.github.com/users/Beyonderx/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Beyonderx/followers",
         "following_url" : "https://api.github.com/users/Beyonderx/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Beyonderx/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Beyonderx",
         "id" : 35275673,
         "login" : "Beyonderx",
         "organizations_url" : "https://api.github.com/users/Beyonderx/orgs",
         "received_events_url" : "https://api.github.com/users/Beyonderx/received_events",
         "repos_url" : "https://api.github.com/users/Beyonderx/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Beyonderx/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Beyonderx/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Beyonderx"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Conceptual question here: am i reading the code right or is the branch size limited to 9997 branches? Imho, having arbitrarily long branching trees could allow for really interesting stuff",
      "created_at" : "2018-01-11T12:28:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356920088",
      "id" : 356920088,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T12:28:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356920088",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/453214?v=4",
         "events_url" : "https://api.github.com/users/chiguireitor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/chiguireitor/followers",
         "following_url" : "https://api.github.com/users/chiguireitor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/chiguireitor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/chiguireitor",
         "id" : 453214,
         "login" : "chiguireitor",
         "organizations_url" : "https://api.github.com/users/chiguireitor/orgs",
         "received_events_url" : "https://api.github.com/users/chiguireitor/received_events",
         "repos_url" : "https://api.github.com/users/chiguireitor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/chiguireitor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/chiguireitor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/chiguireitor"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@chiguireitor I believe the 9997 cap is basically representing the maximum depth in the tree. I think that shrinks if you want to pick multiple entries, though. I could be wrong. @maaku?",
      "created_at" : "2018-01-11T13:56:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356940840",
      "id" : 356940840,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T13:56:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356940840",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I had to grep the diff to figure out what @chiguireitor was referring to. I assume it is the comment about MAX_STACK_SIZE limiting the number of elements that can be proven from a Merkle tree at once. That number is actually an error, as it should be 997, not 9997 as MAX_STACK_SIZE is a constant limit of 1,000 elements and 3 of those elements are the count parameter, the root hash, and the proof. It's worth noting that a separate limit, the 520 byte push limitation, prevents pushing a proof for a fully expanded Merkle tree of more than about 1380 elements anyway, so even if the MAX_STACK_SIZE limit were avoided you'd hit another one soon enough.\r\n\r\nHowever I think there is some confusion on @chiguireitor's part. Why would you want to prove 1,000+ items from a tree at once? This is the maximum number of elements that you can prove at one time, NOT the maximum number of elements that can be in a tree, for which there is no practical limit. The 520 byte push limitation prevents you from proving a hash more than 16 levels deep in a tree, but MERKLEBRANCHVERIFY calls can be chained allowing for verification of extremely deep trees, much larger than could be practically constructed. A single chained validation allows for trees consisting of billions of elements, that would take hours to construct on a reasonably powerful CPU.",
      "created_at" : "2018-01-11T14:33:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356951184",
      "id" : 356951184,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T14:33:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356951184",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Yeah, my bad. Makes sense now, it's just limiting the \"next\" level of the tree, so in fact, it's not limiting the overall tree structure at all, excellent.",
      "created_at" : "2018-01-11T15:05:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356960972",
      "id" : 356960972,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T15:05:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356960972",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/453214?v=4",
         "events_url" : "https://api.github.com/users/chiguireitor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/chiguireitor/followers",
         "following_url" : "https://api.github.com/users/chiguireitor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/chiguireitor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/chiguireitor",
         "id" : 453214,
         "login" : "chiguireitor",
         "organizations_url" : "https://api.github.com/users/chiguireitor/orgs",
         "received_events_url" : "https://api.github.com/users/chiguireitor/received_events",
         "repos_url" : "https://api.github.com/users/chiguireitor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/chiguireitor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/chiguireitor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/chiguireitor"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Code will go to 0.16 and softfork signalling will start 0.16.1?",
      "created_at" : "2018-01-16T08:49:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-357891958",
      "id" : 357891958,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-16T08:49:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357891958",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11314444?v=4",
         "events_url" : "https://api.github.com/users/martin-lizner/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martin-lizner/followers",
         "following_url" : "https://api.github.com/users/martin-lizner/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martin-lizner/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martin-lizner",
         "id" : 11314444,
         "login" : "martin-lizner",
         "organizations_url" : "https://api.github.com/users/martin-lizner/orgs",
         "received_events_url" : "https://api.github.com/users/martin-lizner/received_events",
         "repos_url" : "https://api.github.com/users/martin-lizner/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martin-lizner/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martin-lizner/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martin-lizner"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@martin-lizner There is no consensus yet on whether this code will be merged or not. It's still being debated (e.g. on the mailing list and such).",
      "created_at" : "2018-01-16T09:01:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-357894817",
      "id" : 357894817,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-16T09:01:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357894817",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r164653795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/164653795"
         }
      },
      "author_association" : "NONE",
      "body" : "> `uint64_t* len`\r\n\r\nIt's `uint64_t* bytes` in the sha256.h\r\n\r\n~ thanks to @gubatron ",
      "commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "created_at" : "2018-01-30T06:52:54Z",
      "diff_hunk" : "@@ -231,6 +243,11 @@ void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteBE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n     Write(sizedesc, 8);\n+    Midstate(hash, NULL, NULL);\n+}\n+\n+void CSHA256::Midstate(unsigned char hash[OUTPUT_SIZE], uint64_t* len, unsigned char* buffer)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r164653795",
      "id" : 164653795,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 26,
      "path" : "src/crypto/sha256.cpp",
      "position" : 26,
      "pull_request_review_id" : 92456590,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-01-30T06:52:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/164653795",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/23437045?v=4",
         "events_url" : "https://api.github.com/users/DesWurstes/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DesWurstes/followers",
         "following_url" : "https://api.github.com/users/DesWurstes/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DesWurstes/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DesWurstes",
         "id" : 23437045,
         "login" : "DesWurstes",
         "organizations_url" : "https://api.github.com/users/DesWurstes/orgs",
         "received_events_url" : "https://api.github.com/users/DesWurstes/received_events",
         "repos_url" : "https://api.github.com/users/DesWurstes/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DesWurstes/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DesWurstes/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DesWurstes"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175299607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175299607"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should error be returned here for invalid MerkleTree structure?",
      "commit_id" : "8191d011f548bd7986c5fd7bccb5243369fd3cbd",
      "created_at" : "2018-03-18T18:56:44Z",
      "diff_hunk" : "@@ -1022,6 +1025,142 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_MERKLEBRANCHVERIFY:\n+                {\n+                    if (!(flags & SCRIPT_VERIFY_MERKLEBRANCHVERIFY)) {\n+                        // not enabled; treat as a NOP4\n+                        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n+                            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n+                        }\n+                        break;\n+                    }\n+\n+                    // ([...verify hashes...] proof root {2*count+prehash})\n+                    if (stack.size() < 3) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    valtype& vchCount = stacktop(-1);\n+                    valtype& vchRoot  = stacktop(-2);\n+                    valtype& vchProof = stacktop(-3);\n+\n+                    // vchCount is a minimally encoded CScriptNum\n+                    // encoding 2*N plus a Boolean value in the low\n+                    // order bit encoding whether the leaf elements\n+                    // are pre-hashed.\n+                    bool prehashed = false;\n+                    std::size_t count = 0;\n+                    try {\n+                        // MAX_STACK_SIZE prevents count from ever\n+                        // being more than 997, which also means the\n+                        // first parameter can never be more than two\n+                        // bytes, when minimally serialized.\n+                        auto param = CScriptNum(vchCount, true, 2).getint();\n+                        if (param < 0) {\n+                            return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                        }\n+                        prehashed = param & 1;\n+                        count = param >> 1;\n+                    } catch (scriptnum_error e) {\n+                        // param is more than 2 bytes or not minimally encoded\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                    } catch (...) {\n+                        // Belt and suspenders. It should not be\n+                        // possible for other exceptions to be thrown,\n+                        // but in case that assessment is wrong or\n+                        // ever changes, let's not mask other\n+                        // exceptions.\n+                        throw;\n+                    }\n+\n+                    // There are count=N many leaf objects passed on\n+                    // the stack after the first three parameters\n+                    // which are always present.\n+                    if (stack.size() < (3 + count)) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    // vchRoot is a standard 32-byte hash. Note that\n+                    // this hash is pushed as data and not minimally\n+                    // encoded.\n+                    if (vchRoot.size() != 32) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG2);\n+                    }\n+                    const uint256 root = uint256(vchRoot);\n+\n+                    // The third argument is a MerkleProof, which we\n+                    // deserialize as part of the MerkleTree structure\n+                    // we are building to validate the entire root.\n+                    MerkleTree branch;\n+                    CDataStream proofStream(vchProof, SER_NETWORK, PROTOCOL_VERSION);\n+                    try {\n+                        Unserialize(proofStream, branch.m_proof);\n+                    } catch (const std::bad_alloc e) {\n+                        throw; // Don't mask a transient out-of-memory exception\n+                    } catch (...) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (!proofStream.empty()) {\n+                        // Extra bytes remaining after the MerkleProof\n+                        // was deserialized, which could be a source\n+                        // of witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (branch.m_proof.m_path.dirty()) {\n+                        // Extra bits in the final byte of the packed\n+                        // serialization of the Merkle branch's path,\n+                        // which would otherwise be another source of\n+                        // witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if ((!branch.m_proof.m_path.empty() || count || !branch.m_proof.m_skip.empty()) &&\n+                        ((count + branch.m_proof.m_skip.size()) != (branch.m_proof.m_path.size() + 1)))\n+                    {\n+                        // It is a property of any binary tree that\n+                        // the number of leaf nodes is precisely one\n+                        // more than the number of internal nodes.\n+                        // This acts as an early-out check of whether\n+                        // this is a well-formed proof. Note that the\n+                        // special case of a 0-node, 0-verify, 0-skip\n+                        // tree is exempted from this requirement.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+\n+                    // The remaining _count_ items on the stack are\n+                    // the verify hashes, or the actual leaf values\n+                    // which are hashed with double-SHA256 to get the\n+                    // verify hashes if _prehashed_ is clear.\n+                    branch.m_verify.reserve(count);\n+                    for (int i = 0; i < (int)count; ++i) {\n+                        // -1 through -3 are the count+prehashed, root\n+                        // hash, and MerkleProof we already extracted.\n+                        valtype& vchLeaf = stacktop(-4 - i);\n+                        if (prehashed) {\n+                            // Require 32-byte hash values, no\n+                            // truncation of ending bytes.\n+                            if (vchLeaf.size() != 32) {\n+                                return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG);\n+                            }\n+                            branch.m_verify.emplace_back(uint256(vchLeaf));\n+                        } else {\n+                            branch.m_verify.emplace_back();\n+                            CHash256().Write(vchLeaf.data(), vchLeaf.size()).Finalize(branch.m_verify.back().begin());\n+                        }\n+                    }\n+\n+                    // Compute Merkle root hash\n+                    uint256 result = branch.GetHash();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175299607",
      "id" : 175299607,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 153,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 104807405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-23T05:19:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175299607",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/8403418?v=4",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175364673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175364673"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@maaku Is there a reason why you presumed `!invalid` on this one? If not I think we should check validity and return error on `invalid=true`.",
      "commit_id" : "8191d011f548bd7986c5fd7bccb5243369fd3cbd",
      "created_at" : "2018-03-19T09:03:46Z",
      "diff_hunk" : "@@ -1022,6 +1025,142 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_MERKLEBRANCHVERIFY:\n+                {\n+                    if (!(flags & SCRIPT_VERIFY_MERKLEBRANCHVERIFY)) {\n+                        // not enabled; treat as a NOP4\n+                        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n+                            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n+                        }\n+                        break;\n+                    }\n+\n+                    // ([...verify hashes...] proof root {2*count+prehash})\n+                    if (stack.size() < 3) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    valtype& vchCount = stacktop(-1);\n+                    valtype& vchRoot  = stacktop(-2);\n+                    valtype& vchProof = stacktop(-3);\n+\n+                    // vchCount is a minimally encoded CScriptNum\n+                    // encoding 2*N plus a Boolean value in the low\n+                    // order bit encoding whether the leaf elements\n+                    // are pre-hashed.\n+                    bool prehashed = false;\n+                    std::size_t count = 0;\n+                    try {\n+                        // MAX_STACK_SIZE prevents count from ever\n+                        // being more than 997, which also means the\n+                        // first parameter can never be more than two\n+                        // bytes, when minimally serialized.\n+                        auto param = CScriptNum(vchCount, true, 2).getint();\n+                        if (param < 0) {\n+                            return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                        }\n+                        prehashed = param & 1;\n+                        count = param >> 1;\n+                    } catch (scriptnum_error e) {\n+                        // param is more than 2 bytes or not minimally encoded\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                    } catch (...) {\n+                        // Belt and suspenders. It should not be\n+                        // possible for other exceptions to be thrown,\n+                        // but in case that assessment is wrong or\n+                        // ever changes, let's not mask other\n+                        // exceptions.\n+                        throw;\n+                    }\n+\n+                    // There are count=N many leaf objects passed on\n+                    // the stack after the first three parameters\n+                    // which are always present.\n+                    if (stack.size() < (3 + count)) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    // vchRoot is a standard 32-byte hash. Note that\n+                    // this hash is pushed as data and not minimally\n+                    // encoded.\n+                    if (vchRoot.size() != 32) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG2);\n+                    }\n+                    const uint256 root = uint256(vchRoot);\n+\n+                    // The third argument is a MerkleProof, which we\n+                    // deserialize as part of the MerkleTree structure\n+                    // we are building to validate the entire root.\n+                    MerkleTree branch;\n+                    CDataStream proofStream(vchProof, SER_NETWORK, PROTOCOL_VERSION);\n+                    try {\n+                        Unserialize(proofStream, branch.m_proof);\n+                    } catch (const std::bad_alloc e) {\n+                        throw; // Don't mask a transient out-of-memory exception\n+                    } catch (...) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (!proofStream.empty()) {\n+                        // Extra bytes remaining after the MerkleProof\n+                        // was deserialized, which could be a source\n+                        // of witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (branch.m_proof.m_path.dirty()) {\n+                        // Extra bits in the final byte of the packed\n+                        // serialization of the Merkle branch's path,\n+                        // which would otherwise be another source of\n+                        // witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if ((!branch.m_proof.m_path.empty() || count || !branch.m_proof.m_skip.empty()) &&\n+                        ((count + branch.m_proof.m_skip.size()) != (branch.m_proof.m_path.size() + 1)))\n+                    {\n+                        // It is a property of any binary tree that\n+                        // the number of leaf nodes is precisely one\n+                        // more than the number of internal nodes.\n+                        // This acts as an early-out check of whether\n+                        // this is a well-formed proof. Note that the\n+                        // special case of a 0-node, 0-verify, 0-skip\n+                        // tree is exempted from this requirement.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+\n+                    // The remaining _count_ items on the stack are\n+                    // the verify hashes, or the actual leaf values\n+                    // which are hashed with double-SHA256 to get the\n+                    // verify hashes if _prehashed_ is clear.\n+                    branch.m_verify.reserve(count);\n+                    for (int i = 0; i < (int)count; ++i) {\n+                        // -1 through -3 are the count+prehashed, root\n+                        // hash, and MerkleProof we already extracted.\n+                        valtype& vchLeaf = stacktop(-4 - i);\n+                        if (prehashed) {\n+                            // Require 32-byte hash values, no\n+                            // truncation of ending bytes.\n+                            if (vchLeaf.size() != 32) {\n+                                return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG);\n+                            }\n+                            branch.m_verify.emplace_back(uint256(vchLeaf));\n+                        } else {\n+                            branch.m_verify.emplace_back();\n+                            CHash256().Write(vchLeaf.data(), vchLeaf.size()).Finalize(branch.m_verify.back().begin());\n+                        }\n+                    }\n+\n+                    // Compute Merkle root hash\n+                    uint256 result = branch.GetHash();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175364673",
      "id" : 175364673,
      "in_reply_to_id" : 175299607,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 153,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 104879230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-23T05:19:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175364673",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175815214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175815214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "inline?",
      "commit_id" : "8191d011f548bd7986c5fd7bccb5243369fd3cbd",
      "created_at" : "2018-03-20T15:39:30Z",
      "diff_hunk" : "@@ -35,4 +93,1361 @@ uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n  */\n std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position);\n \n+/*\n+ * Each link of a Merkle tree can have one of three values in a proof\n+ * object:\n+ *\n+ *   DESCEND: This link connects to another sub-tree, which must be\n+ *     processed. The root of this sub-tree is the hash value of the\n+ *     link.\n+ *\n+ *   VERIFY: This hash value of this link must be provided at\n+ *     validation time. Computation of the Merkle root and comparison\n+ *     with a reference value provides a batch confirmation as to\n+ *     whether ALL the provided VERIFY hashes are correct.\n+ *\n+ *   SKIP: The hash value of this link is provided as part of the\n+ *     proof.\n+ */\n+enum class MerkleLink : unsigned char { DESCEND, VERIFY, SKIP };\n+\n+/*\n+ * An internal node can have up to eight different structures, the\n+ * product of the 3 possible MerkleLink states the left and right\n+ * branches can have, with the exception of the {SKIP, SKIP} state\n+ * which would be pruned as a SKIP hash in the parent node.\n+ *\n+ * This means nodes can be represented as a 3-bit integer, and packed\n+ * 8 nodes to each 3 byte sequence. The MerkleNode class uses an\n+ * unsigned char to represent the unpacked code, whereas the\n+ * MerkleNodeReference class is used to access a 3-bit code value\n+ * within a packed representation.\n+ */\n+struct MerkleNode\n+{\n+    typedef unsigned char code_type;\n+\n+protected:\n+    code_type m_code;\n+\n+    static const std::array<MerkleLink, 8> m_left_from_code;\n+    static const std::array<MerkleLink, 8> m_right_from_code;\n+\n+    static code_type _get_code(MerkleLink left, MerkleLink right);\n+\n+public:\n+    explicit MerkleNode(MerkleLink left, MerkleLink right) : m_code(_get_code(left, right)) { }\n+\n+    explicit MerkleNode(code_type code) : m_code(code) { }\n+\n+    /* Note that a code value of 0 is a {VERIFY, SKIP} node. */\n+    MerkleNode() : m_code(0) { }\n+\n+    /* The default behavior is adequate. */\n+    MerkleNode(const MerkleNode&) = default;\n+    MerkleNode(MerkleNode&&) = default;\n+    MerkleNode& operator=(const MerkleNode&) = default;\n+    MerkleNode& operator=(MerkleNode&&) = default;\n+\n+    /*\n+     * Ideally this would perhaps be operator int() and operator=(),\n+     * however C++ does not let us mark an assingment operator as\n+     * explicit. This unfortunately defeats many of the protections\n+     * against bugs that strong typing would give us as any integer or\n+     * Boolean value could be mistakenly assigned and interpreted as a\n+     * code, and therefore assignable to a MerkleNode, probably\n+     * generating a memory access exception if the value is not\n+     * between 0 and 7.\n+     */\n+    inline code_type GetCode() const\n+      { return m_code; }\n+\n+    inline MerkleNode& SetCode(code_type code)\n+    {\n+        m_code = code;\n+        return *this;\n+    }\n+\n+    /*\n+     * The getters and setters for the left and right MerkleLinks\n+     * simply recalculate the code value using tables. The code values\n+     * line up such that this could be done with arithmetic and\n+     * shifts, but it is probably of similar efficiency.\n+     */\n+    inline MerkleLink GetLeft() const\n+      { return m_left_from_code[m_code]; }\n+\n+    inline MerkleNode& SetLeft(MerkleLink left)\n+    {\n+        m_code = _get_code(left, m_right_from_code[m_code]);\n+        return *this;\n+    }\n+\n+    inline MerkleLink GetRight() const\n+      { return m_right_from_code[m_code]; }\n+\n+    inline MerkleNode& SetRight(MerkleLink right)\n+    {\n+        m_code = _get_code(m_left_from_code[m_code], right);\n+        return *this;\n+    }\n+\n+    /* Equality */\n+    inline bool operator==(MerkleNode other) const\n+      { return (m_code == other.m_code); }\n+    inline bool operator!=(MerkleNode other) const\n+      { return !(*this == other); }\n+\n+    /* Relational */\n+    inline bool operator<(MerkleNode other) const\n+      { return (m_code < other.m_code); }\n+    inline bool operator<=(MerkleNode other) const\n+      { return !(other < *this); }\n+    inline bool operator>=(MerkleNode other) const\n+      { return !(*this < other); }\n+    inline bool operator>(MerkleNode other) const\n+      { return (other < *this); }\n+\n+    /* Needs access to m_{left,right}_from_code and _get_code() */\n+    friend struct MerkleNodeReference;\n+};\n+\n+/*\n+ * Now we begin constructing the necessary infrastructure for\n+ * supporting an STL-like container for packed 3-bit code\n+ * representations of MerkleNode values. This is parallels the way\n+ * that std::vector<bool> is specialized, with the added complication\n+ * of a non-power-of-2 packed size.\n+ */\n+\n+/*\n+ * First we build a \"reference\" class which is able to address the\n+ * location of a packed 3-bit value, and to read and write that value\n+ * without affecting its neighbors.\n+ *\n+ * Then we will make use of this MerkleNode reference type to\n+ * construct an STL-compatible iterator class (technically two, since\n+ * the class const_iterator is not a const instance of the class\n+ * iterator, for reasons).\n+ */\n+struct MerkleNodeReference\n+{\n+    /*\n+     * Nodes are stored with a tightly packed 3-bit encoding, the\n+     * code. This allows up to 8 node specifications to fit within 3\n+     * bytes:\n+     *\n+     *    -- Node index\n+     *   /\n+     *   00011122 23334445 55666777\n+     *    byte 0   byte 1   byte 2\n+     *   76543210 76543210 76543210\n+     *                            /\n+     *                Bit Index --\n+     *\n+     * A reference to a particular node consists of a pointer to the\n+     * beginning of this 3 byte sequence, and the index (between 0 and\n+     * 7) of the node.\n+     */\n+    typedef unsigned char base_type;\n+    typedef unsigned char offset_type;\n+\n+protected:\n+    base_type* m_base;\n+    offset_type m_offset;\n+\n+    /*\n+     * The parameterized constructor is protected because MerkleNode\n+     * references should only ever be created by the friended iterator\n+     * and container code.\n+     */\n+    MerkleNodeReference(base_type* base, offset_type offset) : m_base(base), m_offset(offset) { }\n+\n+    /*\n+     * We're emulating a reference, not a pointer, and it doesn't make\n+     * sense to have a default-constructable reference.\n+     */\n+    MerkleNodeReference() = delete;\n+\n+public:\n+    /*\n+     * The default copy constructors are sufficient. Note that these\n+     * create a new reference object that points to the same packed\n+     * MerkleNode value.\n+     */\n+    MerkleNodeReference(const MerkleNodeReference& other) = default;\n+    MerkleNodeReference(MerkleNodeReference&& other) = default;\n+\n+    /*\n+     * Copy assignment operators are NOT the default behavior:\n+     * assigning one reference to another copies the underlying\n+     * values, to make the MerkleNodeReference objects behave like\n+     * references. It is NOT the same as the copy constructor, which\n+     * copies the reference itself.\n+     */\n+    inline MerkleNodeReference& operator=(const MerkleNodeReference& other)\n+      { return SetCode(other.GetCode()); }\n+    inline MerkleNodeReference& operator=(MerkleNodeReference&& other)\n+      { return SetCode(other.GetCode()); }\n+\n+public:\n+    /* Read a 3-bit code value */\n+    MerkleNode::code_type GetCode() const;\n+\n+    /* Write a 3-bit code value */\n+    MerkleNodeReference& SetCode(MerkleNode::code_type code);\n+\n+    /* Read and write the MerkleLink values individually. */\n+    inline MerkleLink GetLeft() const\n+      { return MerkleNode::m_left_from_code[GetCode()]; }\n+    inline MerkleNodeReference& SetLeft(MerkleLink left)\n+      { return SetCode(MerkleNode::_get_code(left, GetRight())); }\n+\n+    MerkleLink GetRight() const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175815214",
      "id" : 175815214,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 289,
      "path" : "src/consensus/merkle.h",
      "position" : null,
      "pull_request_review_id" : 105407279,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-23T05:19:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175815214",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/8403418?v=4",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jl2012 Thanks for feedback! I inlined `GetRight`/`SetRight` in d99522a and added check/error for invalid result in `GetHash` in 8191d01. Not sure if `SCRIPT_ERR_BAD_DECODE_ARG` is suitable but it looked close enough.",
      "created_at" : "2018-03-23T05:17:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-375547840",
      "id" : 375547840,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-03-23T05:20:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/375547840",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r176899120"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/176899120"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this is the reason for allowing invalid=true in MBV. Maybe it should be fixed by setting *invalid to the logical OR of the various sizes referenced.",
      "commit_id" : "8191d011f548bd7986c5fd7bccb5243369fd3cbd",
      "created_at" : "2018-03-24T03:58:35Z",
      "diff_hunk" : "@@ -185,3 +263,296 @@ std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position)\n     }\n     return ComputeMerkleBranch(leaves, position);\n }\n+\n+/*\n+ * The {SKIP, SKIP} entry is missing on purpose. Not only does this\n+ * make the number of possible states a nicely packable power of 2,\n+ * but excluding that fully prunable state means that any given fully\n+ * expanded tree and set of verify hashes has one and only one proof\n+ * encoding -- the serialized tree with all {SKIP, SKIP} nodes\n+ * recursively pruned.\n+ */\n+const std::array<MerkleLink, 8> MerkleNode::m_left_from_code {{\n+    MerkleLink::VERIFY,  MerkleLink::VERIFY,  MerkleLink::VERIFY,\n+    MerkleLink::DESCEND, MerkleLink::DESCEND, MerkleLink::DESCEND,\n+      /* No SKIP */      MerkleLink::SKIP,    MerkleLink::SKIP }};\n+\n+const std::array<MerkleLink, 8> MerkleNode::m_right_from_code {{\n+    MerkleLink::SKIP, MerkleLink::VERIFY, MerkleLink::DESCEND,\n+    MerkleLink::SKIP, MerkleLink::VERIFY, MerkleLink::DESCEND,\n+      /* No SKIP */   MerkleLink::VERIFY, MerkleLink::DESCEND }};\n+\n+MerkleNode::code_type MerkleNode::_get_code(MerkleLink left, MerkleLink right)\n+{\n+    /*\n+     * Returns the 3-bit code for a given combination of left and\n+     * right link values in an internal node.\n+     */\n+    code_type code = std::numeric_limits<code_type>::max();\n+    /* Write out a table of Code values to see why this works :) */\n+    switch (left)\n+    {\n+        case MerkleLink::DESCEND: code = 5; break;\n+        case MerkleLink::VERIFY:  code = 2; break;\n+        case MerkleLink::SKIP:    code = 7; break;\n+    }\n+    switch (right)\n+    {\n+        case MerkleLink::SKIP:    --code; // No break!\n+        case MerkleLink::VERIFY:  --code; break;\n+        case MerkleLink::DESCEND:         break;\n+    }\n+    return code;\n+}\n+\n+MerkleNode::code_type MerkleNodeReference::GetCode() const\n+{\n+    /*\n+     * Belts and suspenders: m_offset should never be anything outside\n+     * the range [0, 7], so the assignment to max should be undone by\n+     * the switch that follows. But just in case we'll favor failing\n+     * in a way that is maximally likely to be detectable when the\n+     * code is later used.\n+     */\n+    MerkleNode::code_type code = std::numeric_limits<MerkleNode::code_type>::max();\n+    assert((m_offset >= 0) && (m_offset <= 7));\n+    switch (m_offset)\n+    {\n+        /*\n+         * Use the diagram in the class definition to work out that\n+         * these magic constant values are correct.\n+         */\n+        case 0: code =   m_base[0] >> 5;  break;\n+        case 1: code =   m_base[0] >> 2;  break;\n+        case 2: code =  (m_base[0] << 1)\n+                     | ((m_base[1] >> 7) & 1); break;\n+        case 3: code =   m_base[1] >> 4;  break;\n+        case 4: code =   m_base[1] >> 1;  break;\n+        case 5: code =  (m_base[1] << 2)\n+                     | ((m_base[2] >> 6) & 3); break;\n+        case 6: code =   m_base[2] >> 3;       break;\n+        case 7: code =   m_base[2];            break;\n+    }\n+    return code & 7;\n+}\n+\n+MerkleNodeReference& MerkleNodeReference::SetCode(MerkleNode::code_type code)\n+{\n+    switch (m_offset)\n+    {\n+        /*\n+         * Again, check the diagram in the class definition to see\n+         * where these magic constant shift and mask values arise\n+         * from.\n+         */\n+        case 0: m_base[0] = (m_base[0] & 0x1f) |  (code      << 5); break;\n+        case 1: m_base[0] = (m_base[0] & 0xe3) |  (code      << 2); break;\n+        case 2: m_base[0] = (m_base[0] & 0xfc) |  (code      >> 1);\n+                m_base[1] = (m_base[1] & 0x7f) | ((code & 1) << 7); break;\n+        case 3: m_base[1] = (m_base[1] & 0x8f) |  (code      << 4); break;\n+        case 4: m_base[1] = (m_base[1] & 0xf1) |  (code      << 1); break;\n+        case 5: m_base[1] = (m_base[1] & 0xfe) |  (code      >> 2);\n+                m_base[2] = (m_base[2] & 0x3f) | ((code & 3) << 6); break;\n+        case 6: m_base[2] = (m_base[2] & 0xc7) |  (code      << 3); break;\n+        case 7: m_base[2] = (m_base[2] & 0xf8) |   code;            break;\n+    }\n+    return *this;\n+}\n+\n+void MerkleNodeIteratorBase::_incr()\n+{\n+    if (m_ref.m_offset++ == 7) {\n+        m_ref.m_offset = 0;\n+        m_ref.m_base += 3;\n+    }\n+}\n+\n+void MerkleNodeIteratorBase::_decr()\n+{\n+    if (m_ref.m_offset-- == 0) {\n+        m_ref.m_offset = 7;\n+        m_ref.m_base -= 3;\n+    }\n+}\n+\n+void MerkleNodeIteratorBase::_seek(MerkleNodeIteratorBase::difference_type distance)\n+{\n+    difference_type bits = distance + m_ref.m_offset;\n+    m_ref.m_base += 3 * (bits / 8);\n+    bits = bits % 8;\n+    if (bits < 0) {\n+        bits += 8;\n+        m_ref.m_base -= 3;\n+    }\n+    m_ref.m_offset = static_cast<MerkleNodeReference::offset_type>(bits);\n+}\n+\n+MerkleNodeIteratorBase::difference_type MerkleNodeIteratorBase::operator-(const MerkleNodeIteratorBase& other) const\n+{\n+    /*\n+     * Compare with the version of _seek implemented above. The\n+     * following property should hold true:\n+     *\n+     *   A._seek(B-A) == B\n+     *\n+     * That is to say, the difference between two iterators is the\n+     * value which needs to be passed to _seek() to move from one to\n+     * the other.\n+     */\n+    return 8 * (m_ref.m_base - other.m_ref.m_base) / 3 + m_ref.m_offset - other.m_ref.m_offset;\n+}\n+\n+void MerkleProof::clear() noexcept\n+{\n+    m_path.clear();\n+    m_skip.clear();\n+}\n+\n+void swap(MerkleProof& lhs, MerkleProof& rhs)\n+{\n+    using std::swap;\n+    swap(lhs.m_path, rhs.m_path);\n+    swap(lhs.m_skip, rhs.m_skip);\n+}\n+\n+MerkleTree::MerkleTree(const MerkleTree& left, const MerkleTree& right)\n+{\n+    /* Handle the special case of both left and right being fully\n+     * pruned, which also results in a fully pruned super-tree.. */\n+    if (left.m_proof.m_path.empty() && left.m_proof.m_skip.size()==1 && left.m_verify.empty() &&\n+        right.m_proof.m_path.empty() && right.m_proof.m_skip.size()==1 && right.m_verify.empty())\n+    {\n+        m_proof.m_skip.resize(1);\n+        MerkleHash_Sha256Midstate(m_proof.m_skip[0], left.m_proof.m_skip[0], right.m_proof.m_skip[0]);\n+        return;\n+    }\n+\n+    /* We assume a well-formed, non-empty MerkleTree for both passed\n+     * in subtrees, in which if there are no internal nodes than\n+     * either m_skip XOR m_verify must have a single hash. Otherwise\n+     * the result of what follows will be an invalid MerkleTree. */\n+    m_proof.m_path.emplace_back(MerkleLink::DESCEND, MerkleLink::DESCEND);\n+\n+    if (left.m_proof.m_path.empty())\n+        m_proof.m_path.front().SetLeft(left.m_proof.m_skip.empty()? MerkleLink::VERIFY: MerkleLink::SKIP);\n+    m_proof.m_path.insert(m_proof.m_path.end(), left.m_proof.m_path.begin(), left.m_proof.m_path.end());\n+    m_proof.m_skip.insert(m_proof.m_skip.end(), left.m_proof.m_skip.begin(), left.m_proof.m_skip.end());\n+    m_verify.insert(m_verify.end(), left.m_verify.begin(), left.m_verify.end());\n+\n+    if (right.m_proof.m_path.empty())\n+        m_proof.m_path.front().SetRight(right.m_proof.m_skip.empty()? MerkleLink::VERIFY: MerkleLink::SKIP);\n+    m_proof.m_path.insert(m_proof.m_path.end(), right.m_proof.m_path.begin(), right.m_proof.m_path.end());\n+    m_proof.m_skip.insert(m_proof.m_skip.end(), right.m_proof.m_skip.begin(), right.m_proof.m_skip.end());\n+    m_verify.insert(m_verify.end(), right.m_verify.begin(), right.m_verify.end());\n+}\n+\n+void MerkleTree::clear() noexcept\n+{\n+    m_proof.clear();\n+    m_verify.clear();\n+}\n+\n+void swap(MerkleTree& lhs, MerkleTree& rhs)\n+{\n+    using std::swap;\n+    swap(lhs.m_proof, rhs.m_proof);\n+    swap(lhs.m_verify, rhs.m_verify);\n+}\n+\n+uint256 MerkleTree::GetHash(bool* invalid) const\n+{\n+    std::vector<std::pair<bool, uint256> > stack(2);\n+    auto verify_pos = m_verify.begin();\n+    auto verify_last = m_verify.end();\n+    auto skip_pos = m_proof.m_skip.begin();\n+    auto skip_last = m_proof.m_skip.end();\n+\n+    auto visitor = [&stack, &verify_pos, &verify_last, &skip_pos, &skip_last](std::size_t depth, MerkleLink value, bool right) -> bool\n+    {\n+        const uint256* new_hash = nullptr;\n+        switch(value) {\n+            case MerkleLink::DESCEND:\n+                stack.emplace_back();\n+                return false;\n+\n+            case MerkleLink::VERIFY:\n+                if (verify_pos == verify_last) // read past end of verify hashes list\n+                    return true;\n+                new_hash = &(verify_pos++)[0];\n+                break;\n+\n+            case MerkleLink::SKIP:\n+                if (skip_pos == skip_last) // read past end of skip hashes list\n+                    return true;\n+                new_hash = &(skip_pos++)[0];\n+                break;\n+        }\n+\n+        uint256 tmp;\n+        while (stack.back().first) {\n+            MerkleHash_Sha256Midstate(tmp, stack.back().second, *new_hash);\n+            new_hash = &tmp;\n+            stack.pop_back();\n+        }\n+\n+        stack.back().first = true;\n+        stack.back().second = *new_hash;\n+        return false;\n+    };\n+\n+    // As a special case, an empty proof with no verify hashes results\n+    // in the unsalted hash of empty string. Although this requires\n+    // extra work in this implementation to support, it provides\n+    // continuous semantics to the meaning of the MERKLEBLOCKVERIFY\n+    // opcode, which might potentially reduce the number of code paths\n+    // in some scripts.\n+    if (m_proof.m_path.empty() && m_verify.empty() && m_proof.m_skip.empty()) {\n+        if (invalid) {\n+            *invalid = false;\n+        }\n+        return CHashWriter(SER_GETHASH, PROTOCOL_VERSION).GetHash();\n+    }\n+\n+    // Except for the special case of a 0-node, 0-verify, 0-skip tree,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r176899120",
      "id" : 176899120,
      "original_commit_id" : "8191d011f548bd7986c5fd7bccb5243369fd3cbd",
      "original_position" : 402,
      "path" : "src/consensus/merkle.cpp",
      "position" : 402,
      "pull_request_review_id" : 106688790,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-24T03:59:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/176899120",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r177318302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/177318302"
         }
      },
      "author_association" : "MEMBER",
      "body" : "All tests passed, though. I'm pretty sure you are testing for that case, no?",
      "commit_id" : "8191d011f548bd7986c5fd7bccb5243369fd3cbd",
      "created_at" : "2018-03-27T06:20:41Z",
      "diff_hunk" : "@@ -185,3 +263,296 @@ std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position)\n     }\n     return ComputeMerkleBranch(leaves, position);\n }\n+\n+/*\n+ * The {SKIP, SKIP} entry is missing on purpose. Not only does this\n+ * make the number of possible states a nicely packable power of 2,\n+ * but excluding that fully prunable state means that any given fully\n+ * expanded tree and set of verify hashes has one and only one proof\n+ * encoding -- the serialized tree with all {SKIP, SKIP} nodes\n+ * recursively pruned.\n+ */\n+const std::array<MerkleLink, 8> MerkleNode::m_left_from_code {{\n+    MerkleLink::VERIFY,  MerkleLink::VERIFY,  MerkleLink::VERIFY,\n+    MerkleLink::DESCEND, MerkleLink::DESCEND, MerkleLink::DESCEND,\n+      /* No SKIP */      MerkleLink::SKIP,    MerkleLink::SKIP }};\n+\n+const std::array<MerkleLink, 8> MerkleNode::m_right_from_code {{\n+    MerkleLink::SKIP, MerkleLink::VERIFY, MerkleLink::DESCEND,\n+    MerkleLink::SKIP, MerkleLink::VERIFY, MerkleLink::DESCEND,\n+      /* No SKIP */   MerkleLink::VERIFY, MerkleLink::DESCEND }};\n+\n+MerkleNode::code_type MerkleNode::_get_code(MerkleLink left, MerkleLink right)\n+{\n+    /*\n+     * Returns the 3-bit code for a given combination of left and\n+     * right link values in an internal node.\n+     */\n+    code_type code = std::numeric_limits<code_type>::max();\n+    /* Write out a table of Code values to see why this works :) */\n+    switch (left)\n+    {\n+        case MerkleLink::DESCEND: code = 5; break;\n+        case MerkleLink::VERIFY:  code = 2; break;\n+        case MerkleLink::SKIP:    code = 7; break;\n+    }\n+    switch (right)\n+    {\n+        case MerkleLink::SKIP:    --code; // No break!\n+        case MerkleLink::VERIFY:  --code; break;\n+        case MerkleLink::DESCEND:         break;\n+    }\n+    return code;\n+}\n+\n+MerkleNode::code_type MerkleNodeReference::GetCode() const\n+{\n+    /*\n+     * Belts and suspenders: m_offset should never be anything outside\n+     * the range [0, 7], so the assignment to max should be undone by\n+     * the switch that follows. But just in case we'll favor failing\n+     * in a way that is maximally likely to be detectable when the\n+     * code is later used.\n+     */\n+    MerkleNode::code_type code = std::numeric_limits<MerkleNode::code_type>::max();\n+    assert((m_offset >= 0) && (m_offset <= 7));\n+    switch (m_offset)\n+    {\n+        /*\n+         * Use the diagram in the class definition to work out that\n+         * these magic constant values are correct.\n+         */\n+        case 0: code =   m_base[0] >> 5;  break;\n+        case 1: code =   m_base[0] >> 2;  break;\n+        case 2: code =  (m_base[0] << 1)\n+                     | ((m_base[1] >> 7) & 1); break;\n+        case 3: code =   m_base[1] >> 4;  break;\n+        case 4: code =   m_base[1] >> 1;  break;\n+        case 5: code =  (m_base[1] << 2)\n+                     | ((m_base[2] >> 6) & 3); break;\n+        case 6: code =   m_base[2] >> 3;       break;\n+        case 7: code =   m_base[2];            break;\n+    }\n+    return code & 7;\n+}\n+\n+MerkleNodeReference& MerkleNodeReference::SetCode(MerkleNode::code_type code)\n+{\n+    switch (m_offset)\n+    {\n+        /*\n+         * Again, check the diagram in the class definition to see\n+         * where these magic constant shift and mask values arise\n+         * from.\n+         */\n+        case 0: m_base[0] = (m_base[0] & 0x1f) |  (code      << 5); break;\n+        case 1: m_base[0] = (m_base[0] & 0xe3) |  (code      << 2); break;\n+        case 2: m_base[0] = (m_base[0] & 0xfc) |  (code      >> 1);\n+                m_base[1] = (m_base[1] & 0x7f) | ((code & 1) << 7); break;\n+        case 3: m_base[1] = (m_base[1] & 0x8f) |  (code      << 4); break;\n+        case 4: m_base[1] = (m_base[1] & 0xf1) |  (code      << 1); break;\n+        case 5: m_base[1] = (m_base[1] & 0xfe) |  (code      >> 2);\n+                m_base[2] = (m_base[2] & 0x3f) | ((code & 3) << 6); break;\n+        case 6: m_base[2] = (m_base[2] & 0xc7) |  (code      << 3); break;\n+        case 7: m_base[2] = (m_base[2] & 0xf8) |   code;            break;\n+    }\n+    return *this;\n+}\n+\n+void MerkleNodeIteratorBase::_incr()\n+{\n+    if (m_ref.m_offset++ == 7) {\n+        m_ref.m_offset = 0;\n+        m_ref.m_base += 3;\n+    }\n+}\n+\n+void MerkleNodeIteratorBase::_decr()\n+{\n+    if (m_ref.m_offset-- == 0) {\n+        m_ref.m_offset = 7;\n+        m_ref.m_base -= 3;\n+    }\n+}\n+\n+void MerkleNodeIteratorBase::_seek(MerkleNodeIteratorBase::difference_type distance)\n+{\n+    difference_type bits = distance + m_ref.m_offset;\n+    m_ref.m_base += 3 * (bits / 8);\n+    bits = bits % 8;\n+    if (bits < 0) {\n+        bits += 8;\n+        m_ref.m_base -= 3;\n+    }\n+    m_ref.m_offset = static_cast<MerkleNodeReference::offset_type>(bits);\n+}\n+\n+MerkleNodeIteratorBase::difference_type MerkleNodeIteratorBase::operator-(const MerkleNodeIteratorBase& other) const\n+{\n+    /*\n+     * Compare with the version of _seek implemented above. The\n+     * following property should hold true:\n+     *\n+     *   A._seek(B-A) == B\n+     *\n+     * That is to say, the difference between two iterators is the\n+     * value which needs to be passed to _seek() to move from one to\n+     * the other.\n+     */\n+    return 8 * (m_ref.m_base - other.m_ref.m_base) / 3 + m_ref.m_offset - other.m_ref.m_offset;\n+}\n+\n+void MerkleProof::clear() noexcept\n+{\n+    m_path.clear();\n+    m_skip.clear();\n+}\n+\n+void swap(MerkleProof& lhs, MerkleProof& rhs)\n+{\n+    using std::swap;\n+    swap(lhs.m_path, rhs.m_path);\n+    swap(lhs.m_skip, rhs.m_skip);\n+}\n+\n+MerkleTree::MerkleTree(const MerkleTree& left, const MerkleTree& right)\n+{\n+    /* Handle the special case of both left and right being fully\n+     * pruned, which also results in a fully pruned super-tree.. */\n+    if (left.m_proof.m_path.empty() && left.m_proof.m_skip.size()==1 && left.m_verify.empty() &&\n+        right.m_proof.m_path.empty() && right.m_proof.m_skip.size()==1 && right.m_verify.empty())\n+    {\n+        m_proof.m_skip.resize(1);\n+        MerkleHash_Sha256Midstate(m_proof.m_skip[0], left.m_proof.m_skip[0], right.m_proof.m_skip[0]);\n+        return;\n+    }\n+\n+    /* We assume a well-formed, non-empty MerkleTree for both passed\n+     * in subtrees, in which if there are no internal nodes than\n+     * either m_skip XOR m_verify must have a single hash. Otherwise\n+     * the result of what follows will be an invalid MerkleTree. */\n+    m_proof.m_path.emplace_back(MerkleLink::DESCEND, MerkleLink::DESCEND);\n+\n+    if (left.m_proof.m_path.empty())\n+        m_proof.m_path.front().SetLeft(left.m_proof.m_skip.empty()? MerkleLink::VERIFY: MerkleLink::SKIP);\n+    m_proof.m_path.insert(m_proof.m_path.end(), left.m_proof.m_path.begin(), left.m_proof.m_path.end());\n+    m_proof.m_skip.insert(m_proof.m_skip.end(), left.m_proof.m_skip.begin(), left.m_proof.m_skip.end());\n+    m_verify.insert(m_verify.end(), left.m_verify.begin(), left.m_verify.end());\n+\n+    if (right.m_proof.m_path.empty())\n+        m_proof.m_path.front().SetRight(right.m_proof.m_skip.empty()? MerkleLink::VERIFY: MerkleLink::SKIP);\n+    m_proof.m_path.insert(m_proof.m_path.end(), right.m_proof.m_path.begin(), right.m_proof.m_path.end());\n+    m_proof.m_skip.insert(m_proof.m_skip.end(), right.m_proof.m_skip.begin(), right.m_proof.m_skip.end());\n+    m_verify.insert(m_verify.end(), right.m_verify.begin(), right.m_verify.end());\n+}\n+\n+void MerkleTree::clear() noexcept\n+{\n+    m_proof.clear();\n+    m_verify.clear();\n+}\n+\n+void swap(MerkleTree& lhs, MerkleTree& rhs)\n+{\n+    using std::swap;\n+    swap(lhs.m_proof, rhs.m_proof);\n+    swap(lhs.m_verify, rhs.m_verify);\n+}\n+\n+uint256 MerkleTree::GetHash(bool* invalid) const\n+{\n+    std::vector<std::pair<bool, uint256> > stack(2);\n+    auto verify_pos = m_verify.begin();\n+    auto verify_last = m_verify.end();\n+    auto skip_pos = m_proof.m_skip.begin();\n+    auto skip_last = m_proof.m_skip.end();\n+\n+    auto visitor = [&stack, &verify_pos, &verify_last, &skip_pos, &skip_last](std::size_t depth, MerkleLink value, bool right) -> bool\n+    {\n+        const uint256* new_hash = nullptr;\n+        switch(value) {\n+            case MerkleLink::DESCEND:\n+                stack.emplace_back();\n+                return false;\n+\n+            case MerkleLink::VERIFY:\n+                if (verify_pos == verify_last) // read past end of verify hashes list\n+                    return true;\n+                new_hash = &(verify_pos++)[0];\n+                break;\n+\n+            case MerkleLink::SKIP:\n+                if (skip_pos == skip_last) // read past end of skip hashes list\n+                    return true;\n+                new_hash = &(skip_pos++)[0];\n+                break;\n+        }\n+\n+        uint256 tmp;\n+        while (stack.back().first) {\n+            MerkleHash_Sha256Midstate(tmp, stack.back().second, *new_hash);\n+            new_hash = &tmp;\n+            stack.pop_back();\n+        }\n+\n+        stack.back().first = true;\n+        stack.back().second = *new_hash;\n+        return false;\n+    };\n+\n+    // As a special case, an empty proof with no verify hashes results\n+    // in the unsalted hash of empty string. Although this requires\n+    // extra work in this implementation to support, it provides\n+    // continuous semantics to the meaning of the MERKLEBLOCKVERIFY\n+    // opcode, which might potentially reduce the number of code paths\n+    // in some scripts.\n+    if (m_proof.m_path.empty() && m_verify.empty() && m_proof.m_skip.empty()) {\n+        if (invalid) {\n+            *invalid = false;\n+        }\n+        return CHashWriter(SER_GETHASH, PROTOCOL_VERSION).GetHash();\n+    }\n+\n+    // Except for the special case of a 0-node, 0-verify, 0-skip tree,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r177318302",
      "id" : 177318302,
      "in_reply_to_id" : 176899120,
      "original_commit_id" : "8191d011f548bd7986c5fd7bccb5243369fd3cbd",
      "original_position" : 402,
      "path" : "src/consensus/merkle.cpp",
      "position" : 402,
      "pull_request_review_id" : 107163773,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-27T06:20:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/177318302",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The failure is due to a recent rewrite causing `READWRITE(REF(CFlatData(m_skip)));` to fail in `merkle.h`. \r\n\r\nDiscussing right now whether it makes a difference to switch to varint over compactsize explicitly as is done right now (I argue it does not make a difference, as the size is only a small fraction of the content).",
      "created_at" : "2018-04-24T06:38:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-383820180",
      "id" : 383820180,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-04-24T06:38:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383820180",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm closing this for now. If a better suited champion appears I'll help out where I can. Ping @btcdrak @maaku.",
      "created_at" : "2018-09-19T03:30:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-422638527",
      "id" : 422638527,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMjYzODUyNw==",
      "updated_at" : "2018-09-19T03:30:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/422638527",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   }
]
