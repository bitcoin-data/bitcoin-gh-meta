[
   {
      "author_association" : "MEMBER",
      "body" : "Why is it pubkeys and not addresses for the pubkey part?  (obviously xpubs are xpubs and need to be)",
      "created_at" : "2018-01-16T07:14:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-357872742",
      "id" : 357872742,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-16T07:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357872742",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "After a short discussion on IRC (https://botbot.me/freenode/bitcoin-core-dev/2018-01-16/?msg=95804115&page=2) support for addresses and pubkeys makes most sense. Will add support for an array of addresses.",
      "created_at" : "2018-01-16T07:33:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-357876083",
      "id" : 357876083,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-16T07:33:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357876083",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719264"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IMO there is no need to throw, a `bool` in the response is enough? Otherwise, missing test.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:42:29Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    }\n+    else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719264",
      "id" : 161719264,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcxOTI2NA==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 97,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719264",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719526"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719526"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove `other options`? There are none.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:43:33Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719526",
      "id" : 161719526,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcxOTUyNg==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 54,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719526",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719731"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`request.params.size() != 2`?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:44:02Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719731",
      "id" : 161719731,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcxOTczMQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 52,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719731",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719989"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit, newline after `{`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:44:58Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161719989",
      "id" : 161719989,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcxOTk4OQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 65,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161719989",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720229"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720229"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test for error.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:45:50Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720229",
      "id" : 161720229,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyMDIyOQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 90,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720229",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720355"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720355"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit, `else {` here.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:46:20Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    }\n+    else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        g_should_abourt_scan = true;\n+    }\n+    else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore tempKeystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeysU = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeysU.isArray()) {\n+            for (const UniValue& pubkeyU : pubkeysU.get_array().getValues()) {\n+                if (!pubkeyU.isStr() || !IsHex(pubkeyU.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkeyU.get_str()));\n+                CPubKey pubKey(data.begin(), data.end());\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pubKey);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubsU = find_value(request.params[1], \"xpubs\");\n+        if (xpubsU.isArray()) {\n+            for (const UniValue& xpubObjectU : xpubsU.get_array().getValues()) {\n+                if (!xpubObjectU.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubU = find_value(xpubObjectU, \"xpub\");\n+                UniValue lookupWindowU = find_value(xpubObjectU, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int windowStart = 0;\n+                unsigned int windowEnd = 1000;\n+                if (!lookupWindowU.isNull()) {\n+                    if (lookupWindowU.isArray() && lookupWindowU.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        windowStart = (unsigned int)lookupWindowU.get_array().getValues()[0].get_int();\n+                        windowEnd = (unsigned int)lookupWindowU.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                CBitcoinExtPubKey xpubBase58(xpubU.get_str()); //will throw if xpubU does not contain a string\n+\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = xpubBase58.GetKey();\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = windowStart; i <= windowEnd; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+        if (!pubkeysU.isArray() && !xpubsU.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid or empty public or xpub key array\");\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                tempKeystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                tempKeystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                tempKeystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                tempKeystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                tempKeystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        {\n+            std::map<COutPoint, Coin> coins;\n+            {\n+                g_should_abourt_scan = false;\n+                g_scan_progress = 0;\n+                int64_t count = 0;\n+                FlushStateToDisk();\n+                bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abourt_scan, count, needles, coins);\n+                result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+                result.push_back(Pair(\"searched_items\", count));\n+            }\n+\n+            for (auto& it : coins) {\n+                const COutPoint& outpoint = it.first;\n+                const Coin& coin = it.second;\n+                const CTxOut& txo = coin.out;\n+                input_txos.push_back(txo);\n+                total_in += txo.nValue;\n+\n+                UniValue unspent(UniValue::VOBJ);\n+                unspent.push_back(Pair(\"txid\", outpoint.hash.GetHex()));\n+                unspent.push_back(Pair(\"vout\", (int32_t)outpoint.n));\n+                unspent.push_back(Pair(\"scriptPubKey\", HexStr(txo.scriptPubKey.begin(), txo.scriptPubKey.end())));\n+                unspent.push_back(Pair(\"amount\", ValueFromAmount(txo.nValue)));\n+                unspent.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n+\n+                unspents.push_back(unspent);\n+            }\n+        }\n+        result.push_back(Pair(\"unspents\", unspents));\n+        result.push_back(Pair(\"total_amount\", ValueFromAmount(total_in)));\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720355",
      "id" : 161720355,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyMDM1NQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 243,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720355",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720471"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720471"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit, `else if () {` here.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:46:42Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    }\n+    else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        g_should_abourt_scan = true;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720471",
      "id" : 161720471,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyMDQ3MQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 100,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720471",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720621"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720621"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo, abort.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:47:17Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161720621",
      "id" : 161720621,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyMDYyMQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 23,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161720621",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161722614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161722614"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Lock only when changing `g_scan_in_progress`?\r\n```cpp\r\nif (m_could_reserve) {\r\n    std::lock_guard<std::mutex> lock(g_utxosetscan);\r\n    g_scan_in_progress = false;\r\n}\r\n```",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:55:14Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161722614",
      "id" : 161722614,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyMjYxNA==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 43,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161722614",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161723685"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161723685"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove \"status\"? Otherwise add ` or ` between actions.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T10:59:50Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    }\n+    else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        g_should_abourt_scan = true;\n+    }\n+    else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" \\\"status\\\"\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161723685",
      "id" : 161723685,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyMzY4NQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 104,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161723685",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161723933"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161723933"
         }
      },
      "author_association" : "MEMBER",
      "body" : "const auto&",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T11:00:53Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    }\n+    else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        g_should_abourt_scan = true;\n+    }\n+    else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore tempKeystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeysU = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeysU.isArray()) {\n+            for (const UniValue& pubkeyU : pubkeysU.get_array().getValues()) {\n+                if (!pubkeyU.isStr() || !IsHex(pubkeyU.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkeyU.get_str()));\n+                CPubKey pubKey(data.begin(), data.end());\n+                if (!pubKey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pubKey);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubsU = find_value(request.params[1], \"xpubs\");\n+        if (xpubsU.isArray()) {\n+            for (const UniValue& xpubObjectU : xpubsU.get_array().getValues()) {\n+                if (!xpubObjectU.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubU = find_value(xpubObjectU, \"xpub\");\n+                UniValue lookupWindowU = find_value(xpubObjectU, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int windowStart = 0;\n+                unsigned int windowEnd = 1000;\n+                if (!lookupWindowU.isNull()) {\n+                    if (lookupWindowU.isArray() && lookupWindowU.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        windowStart = (unsigned int)lookupWindowU.get_array().getValues()[0].get_int();\n+                        windowEnd = (unsigned int)lookupWindowU.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                CBitcoinExtPubKey xpubBase58(xpubU.get_str()); //will throw if xpubU does not contain a string\n+\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = xpubBase58.GetKey();\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = windowStart; i <= windowEnd; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+        if (!pubkeysU.isArray() && !xpubsU.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid or empty public or xpub key array\");\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                tempKeystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                tempKeystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                tempKeystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                tempKeystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                tempKeystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        {\n+            std::map<COutPoint, Coin> coins;\n+            {\n+                g_should_abourt_scan = false;\n+                g_scan_progress = 0;\n+                int64_t count = 0;\n+                FlushStateToDisk();\n+                bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abourt_scan, count, needles, coins);\n+                result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+                result.push_back(Pair(\"searched_items\", count));\n+            }\n+\n+            for (auto& it : coins) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161723933",
      "id" : 161723933,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyMzkzMw==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 224,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161723933",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161724018"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161724018"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Assert not reserved?\r\n```cpp\r\nassert(!m_could_reserve);\r\nstd::lock_guard<std::mutex> lock(g_utxosetscan);\r\nif (g_scan_in_progress) return false;\r\ng_scan_in_progress = true;\r\nm_could_reserve = true;\r\nreturn true;\r\n```",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-16T11:01:18Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r161724018",
      "id" : 161724018,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MTcyNDAxOA==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 33,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 89051250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161724018",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "OWNER",
      "body" : "Concept ACK, nice! I've wished for UTXO scanning functionality many times, much faster than importing into a watchonly wallet if you only care about spendable UTXOs.",
      "created_at" : "2018-01-16T12:41:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-357947957",
      "id" : 357947957,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-16T12:42:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357947957",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r162549141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/162549141"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nah. You can also call `scantxoutset status`",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-19T07:03:12Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r162549141",
      "id" : 162549141,
      "in_reply_to_id" : 161719731,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjU0OTE0MQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 52,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 90025058,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/162549141",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r162549573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/162549573"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You mean missing a functional test for that case. Yes. I though about it, but would require a mockup-slowdown argument (`-testslowdown` or similar). Otherwise I guess it's hard to properly test this.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-19T07:07:03Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r162549573",
      "id" : 162549573,
      "in_reply_to_id" : 161720229,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjU0OTU3Mw==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 90,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 90025540,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/162549573",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "* Added support for addresses (can scan unspent outputs after given addresses)\r\n* Added support for an optional raw sweep transaction including optional feerate or optional confirmation target",
      "created_at" : "2018-01-20T00:16:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-359125255",
      "id" : 359125255,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-20T00:16:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/359125255",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "~~The raw sweep fee calculation is currently WIP (misses the dummy signer part)... will fix soon.~~",
      "created_at" : "2018-01-20T00:26:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-359126554",
      "id" : 359126554,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-21T06:35:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/359126554",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Overhauled the fee calculation logic (see the dummy sign keystore).",
      "created_at" : "2018-01-21T06:36:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-359227556",
      "id" : 359227556,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-21T06:36:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/359227556",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r162837161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/162837161"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What prevents the state from being mutated out from under this scan?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-22T02:07:31Z",
      "diff_hunk" : "@@ -1597,6 +1602,335 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                CBitcoinExtPubKey xpub_base58c(xpubkey_uni.get_str()); //will throw if xpubU does not contain a string\n+\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = xpub_base58c.GetKey();\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+        // look for posssible addresses\n+        UniValue addresses_uni = find_value(request.params[1], \"addresses\");\n+        if (addresses_uni.isArray()) {\n+            for (const UniValue& address_uni : addresses_uni.get_array().getValues()) {\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                if (!script.empty()) {\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+        if (!pubkeys_uni.isArray() && !xpubs_uni.isArray() && !addresses_uni.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid or empty publickey, addresses or xpub array\");\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r162837161",
      "id" : 162837161,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjgzNzE2MQ==",
      "original_commit_id" : "1490e13b09a7adf1224719ff9663a98f0b87f90f",
      "original_position" : 269,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 90357208,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/162837161",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r163036137"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/163036137"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think due to the time required to perform a scan, it's something that may be tolerated (although it should be mentioned in the docs). Not sure, but I guess it's the same with `gettxoutsetinfo`.\r\n\r\nNot sure if you can scan a `CCoinsView` of a snapshot state... I guess no.\r\nLocking cs_main would be \"meh\".",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-22T19:04:56Z",
      "diff_hunk" : "@@ -1597,6 +1602,335 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                CBitcoinExtPubKey xpub_base58c(xpubkey_uni.get_str()); //will throw if xpubU does not contain a string\n+\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = xpub_base58c.GetKey();\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+        // look for posssible addresses\n+        UniValue addresses_uni = find_value(request.params[1], \"addresses\");\n+        if (addresses_uni.isArray()) {\n+            for (const UniValue& address_uni : addresses_uni.get_array().getValues()) {\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                if (!script.empty()) {\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+        if (!pubkeys_uni.isArray() && !xpubs_uni.isArray() && !addresses_uni.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid or empty publickey, addresses or xpub array\");\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r163036137",
      "id" : 163036137,
      "in_reply_to_id" : 162837161,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MzAzNjEzNw==",
      "original_commit_id" : "1490e13b09a7adf1224719ff9663a98f0b87f90f",
      "original_position" : 269,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 90588493,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/163036137",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r163036409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/163036409"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also, the rawtx (sweep) is in the same way \"outdated\" the moment you have received it... maybe you could argue that this is the same for `fundrawtx`",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-01-22T19:05:57Z",
      "diff_hunk" : "@@ -1597,6 +1602,335 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                CBitcoinExtPubKey xpub_base58c(xpubkey_uni.get_str()); //will throw if xpubU does not contain a string\n+\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = xpub_base58c.GetKey();\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+        // look for posssible addresses\n+        UniValue addresses_uni = find_value(request.params[1], \"addresses\");\n+        if (addresses_uni.isArray()) {\n+            for (const UniValue& address_uni : addresses_uni.get_array().getValues()) {\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                if (!script.empty()) {\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+        if (!pubkeys_uni.isArray() && !xpubs_uni.isArray() && !addresses_uni.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid or empty publickey, addresses or xpub array\");\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r163036409",
      "id" : 163036409,
      "in_reply_to_id" : 162837161,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MzAzNjQwOQ==",
      "original_commit_id" : "1490e13b09a7adf1224719ff9663a98f0b87f90f",
      "original_position" : 269,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 90588792,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/163036409",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "NACK supporting addresses. Addresses have no relation to the UTXOs.",
      "created_at" : "2018-01-24T19:23:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-360244898",
      "id" : 360244898,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-24T19:23:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/360244898",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr: Why? Addresses are encoded output scripts (scriptPubKey). The rational behind supporting addresses is that a) it may be more efficient then forming every possible known common script from a pubkey and b) that pubkeys are somewhat more difficult to export then the pure \"used addresses\".",
      "created_at" : "2018-01-24T19:27:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-360246041",
      "id" : 360246041,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-24T19:27:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/360246041",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Addresses are *opaque* identifiers for a given invoice. That they are currently implemented by encoding a scriptPubKey is irrelevant.",
      "created_at" : "2018-01-24T19:41:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-360250183",
      "id" : 360250183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-01-24T19:41:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/360250183",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Does it support mempool/unconfirmed utxos? I had a quick look and didn't seem to, I think it would be useful to have mempool too.\r\n\r\nWould it make sense to avoid the background job? maybe by keeping the utxo set sorted by scriptPubKey and binary search on it or perhaps some utxo set limited indexing?",
      "created_at" : "2018-02-26T18:44:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-368605251",
      "id" : 368605251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-02-26T18:44:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/368605251",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/5269298?v=4",
         "events_url" : "https://api.github.com/users/greenaddress/events{/privacy}",
         "followers_url" : "https://api.github.com/users/greenaddress/followers",
         "following_url" : "https://api.github.com/users/greenaddress/following{/other_user}",
         "gists_url" : "https://api.github.com/users/greenaddress/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/greenaddress",
         "id" : 5269298,
         "login" : "greenaddress",
         "organizations_url" : "https://api.github.com/users/greenaddress/orgs",
         "received_events_url" : "https://api.github.com/users/greenaddress/received_events",
         "repos_url" : "https://api.github.com/users/greenaddress/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/greenaddress/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/greenaddress/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/greenaddress"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Does it support mempool/unconfirmed utxos? I had a quick look and didn't seem to, I think it would be useful to have mempool too.\r\n\r\nIt currently does not scan the mempool (hence the command name `scantxoutset`), but I agree, that would be useful. But, since scans take a while, timing may be a problem for scanning the mempool.\r\nMaybe an additional RPC call would make sense (`scanmempool`)?\r\n\r\n> Would it make sense to avoid the background job? maybe by keeping the utxo set sorted by scriptPubKey and binary search on it or perhaps some utxo set limited indexing?\r\n\r\nYou mean speeding up the scan? I don't think its worth to keep an extra index (changing the sort order would probably slow down verification a lot).\r\nMy local tests did show a mainnet scan takes about ~30seconds (SSD, fast CPU).\r\nI don't know what the space requirements for a by-scriptPubKey-index would be, .... maybe we can look into this once this PR did proceed.",
      "created_at" : "2018-02-27T01:47:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-368717494",
      "id" : 368717494,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-02-27T01:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/368717494",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-02-27T01:52:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-368718491",
      "id" : 368718491,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-02-27T01:52:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/368718491",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The commit separation here is ugly: CCoinsView::FindScriptPubKey initially checks ShutdownRequested directly, and then this is removed with the RPC changes.\r\n\r\n",
      "created_at" : "2018-02-28T02:15:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-369097379",
      "id" : 369097379,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-02-28T02:15:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/369097379",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed the ugly commit separation in `coins.cpp`",
      "created_at" : "2018-02-28T14:22:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-369254165",
      "id" : 369254165,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-02-28T14:22:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/369254165",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189189080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189189080"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-18T07:54:56Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189189080",
      "id" : 189189080,
      "in_reply_to_id" : 161724018,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTE4OTA4MA==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 33,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121320274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189189080",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-05-18T08:43:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-390138671",
      "id" : 390138671,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-05-18T08:43:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/390138671",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189391605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189391605"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can this be made a function instead of a method? It doesn't seem like it needs access to any of the class's internals.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-18T20:58:21Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scanProgress, std::atomic<bool>& shouldAbort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189391605",
      "id" : 189391605,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTM5MTYwNQ==",
      "original_commit_id" : "a6019cd910a685b1036924539af6f8ec77f07ed0",
      "original_position" : 15,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 121570579,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189391605",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189391737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189391737"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: style for variable names.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-18T20:58:58Z",
      "diff_hunk" : "@@ -157,6 +160,10 @@ class CCoinsView\n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n+    //! Search for a given set of pubkey scripts\n+    static bool FindScriptPubKey(std::atomic<int>& scanProgress, std::atomic<bool>& shouldAbort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189391737",
      "id" : 189391737,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTM5MTczNw==",
      "original_commit_id" : "a6019cd910a685b1036924539af6f8ec77f07ed0",
      "original_position" : 15,
      "path" : "src/coins.h",
      "position" : null,
      "pull_request_review_id" : 121570579,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189391737",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189393229"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189393229"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@gmaxwell @jonasschnelli The cursor iterates over the state of the CCoinsView at the time it was created; modifying it during iteration is fine. This only works because `GetCursor` is not implemented for `CCoinsViewCache`, and is invoked directly on the `CCoinsViewDB` LevelDB wrapper.\r\n\r\nThe downside is that this requires a full flush of the database, hurting performance for all of the process (including validation).",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-18T21:05:45Z",
      "diff_hunk" : "@@ -1597,6 +1602,335 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                CBitcoinExtPubKey xpub_base58c(xpubkey_uni.get_str()); //will throw if xpubU does not contain a string\n+\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = xpub_base58c.GetKey();\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+        // look for posssible addresses\n+        UniValue addresses_uni = find_value(request.params[1], \"addresses\");\n+        if (addresses_uni.isArray()) {\n+            for (const UniValue& address_uni : addresses_uni.get_array().getValues()) {\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                if (!script.empty()) {\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+        if (!pubkeys_uni.isArray() && !xpubs_uni.isArray() && !addresses_uni.isArray()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid or empty publickey, addresses or xpub array\");\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189393229",
      "id" : 189393229,
      "in_reply_to_id" : 162837161,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTM5MzIyOQ==",
      "original_commit_id" : "1490e13b09a7adf1224719ff9663a98f0b87f90f",
      "original_position" : 269,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121570579,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189393229",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189396442"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189396442"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's unfortunate that this introduces yet another \"default set of addresses derived from a given key\". Maintaining this will lead to incompatibilities between implementations as new types of scripts get added.\r\n\r\nIt would be better to have an explicit way to describe a set of scripts to watch for that could be reused in multiple places. I'm working towards that (see https://gist.github.com/sipa/125cfa1615946d0c3f3eec2ad7f250a2), but it may be a while before it's usable.\r\n\r\nHowever, would you consider changing the RPC interface to be more easily adaptable to such a design? I think an interface which just takes a list of descriptions, each of which is a JSON object with either an address, script, or xpub (where the xpub one also takes a window size in a separate field). That means we can later add extra fields to describe what derivations to use, for example.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-18T21:22:30Z",
      "diff_hunk" : "@@ -1637,6 +1640,249 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubkey_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"invalid xpub\");\n+                }\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189396442",
      "id" : 189396442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTM5NjQ0Mg==",
      "original_commit_id" : "31d4874978c9e5176b2ee89269722670d8548320",
      "original_position" : 173,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121570579,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189396442",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Overall, I'm unsure about this. This is functionality that is more easily provided by software that maintains a UTXO index by script, [...]\r\n\r\nI think the scantxoutset approach is a low hanging fruit (relatively simple to implement) and may be replaced later with an (optional) UXTO index approach.\r\n\r\nIt will immediately allow pruned peers to sweep seeds/wallets with a process that takes less then a minute. Also, pruned & non pruned peers could import a wallet without a rescan (if just interested in the unspent outputs rather then the whole transaction history).\r\n\r\nAdditionally, it would allow to safely create a raw-sweep-transaction that can be later used to sign via a cold-store instance/HWW.\r\n\r\nI think it worth to finish the implementation because it fulfils direct user needs, even if we replace it later with an index based approach or even if we have to drop it completely once we move to a non-UTXO-set-based validation approach (far in future probably).",
      "created_at" : "2018-05-19T09:24:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-390392268",
      "id" : 390392268,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-05-19T09:24:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/390392268",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189674015"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189674015"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Since this return value is subject to several races [1], I believe you could just `return NullUniValue;`\r\n\r\n[1]:\r\n* e.g. the scan finishes between the last call and this one\r\n* e.g. this call returns true, but the last start call was not (yet) actually aborted",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T18:27:53Z",
      "diff_hunk" : "@@ -1637,6 +1640,249 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189674015",
      "id" : 189674015,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY3NDAxNQ==",
      "original_commit_id" : "31d4874978c9e5176b2ee89269722670d8548320",
      "original_position" : 100,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189674015",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189674525"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189674525"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could add `return result` (early return) to clarify that nothing else happens in the hundred lines below for this case.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T18:29:48Z",
      "diff_hunk" : "@@ -1637,6 +1640,249 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189674525",
      "id" : 189674525,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY3NDUyNQ==",
      "original_commit_id" : "31d4874978c9e5176b2ee89269722670d8548320",
      "original_position" : 96,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189674525",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189675354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189675354"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why would this be an exception, considering that the scan could normally finish between the last call and this one? Generally I think we should avoid exceptions for control flow in our code (and especially in third party code that uses the rpc interface)",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T18:32:34Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189675354",
      "id" : 189675354,
      "in_reply_to_id" : 161720229,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY3NTM1NA==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 90,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189675354",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189677197"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189677197"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree that just checking for exact matches (scriptPubKey from address) is probably sufficient. If scripts really need to be translated between address types, it can be done in the client (wallet) software or a third party tool by the caller. Thus the implementation is simplified here by removing this whole code block.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T18:39:20Z",
      "diff_hunk" : "@@ -1637,6 +1640,249 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubkey_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"invalid xpub\");\n+                }\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189677197",
      "id" : 189677197,
      "in_reply_to_id" : 189396442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY3NzE5Nw==",
      "original_commit_id" : "31d4874978c9e5176b2ee89269722670d8548320",
      "original_position" : 173,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189677197",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189679876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189679876"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I am pretty sure this never happens when the destination is valid (which you checked two lines above.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T18:48:25Z",
      "diff_hunk" : "@@ -1637,6 +1640,249 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubkey_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"invalid xpub\");\n+                }\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+        // look for posssible addresses\n+        UniValue addresses_uni = find_value(request.params[1], \"addresses\");\n+        if (addresses_uni.isArray()) {\n+            for (const UniValue& address_uni : addresses_uni.get_array().getValues()) {\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                if (!script.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189679876",
      "id" : 189679876,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY3OTg3Ng==",
      "original_commit_id" : "31d4874978c9e5176b2ee89269722670d8548320",
      "original_position" : 218,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189679876",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189682610"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189682610"
         }
      },
      "author_association" : "MEMBER",
      "body" : "typo-nit: ScantxoutsetTest",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T18:58:51Z",
      "diff_hunk" : "@@ -0,0 +1,70 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScanrxoutsetTest(BitcoinTestFramework):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189682610",
      "id" : 189682610,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4MjYxMA==",
      "original_commit_id" : "9ea4835210032c02562eee7f8cf690b76f1f9f3b",
      "original_position" : 12,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189682610",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189682988"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189682988"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: specify `p2sh-segwit`, so the tests don't break when the defaults change.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:00:22Z",
      "diff_hunk" : "@@ -0,0 +1,70 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScanrxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189682988",
      "id" : 189682988,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4Mjk4OA==",
      "original_commit_id" : "9ea4835210032c02562eee7f8cf690b76f1f9f3b",
      "original_position" : 20,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189682988",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189683374"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189683374"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `os.path.join(self.nodes[0].datadir, \"regtest\", 'wallets')`",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:01:49Z",
      "diff_hunk" : "@@ -0,0 +1,70 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScanrxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress()\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.options.tmpdir, \"node0/regtest/wallets\"))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189683374",
      "id" : 189683374,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4MzM3NA==",
      "original_commit_id" : "9ea4835210032c02562eee7f8cf690b76f1f9f3b",
      "original_position" : 33,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189683374",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189683735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189683735"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `os.path.join(self.nodes[1].datadir, \"regtest\", 'wallet.dat'`",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:03:21Z",
      "diff_hunk" : "@@ -0,0 +1,70 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScanrxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress()\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.options.tmpdir, \"node0/regtest/wallets\"))\n+        self.start_node(0)\n+        self.nodes[0].generate(110)\n+\n+        self.log.info(\"Send some coins to HD deriven keys\")\n+        #bip32/bip44 tests (use xpriv = \"tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK\")\n+        xpub_account_key = \"tpubDCWjaJPr3DfCGCvZzKVxXhneVjuRsXkDtoF18BFvci1eeLR97zz8DYr56kgT4sXgYDXQvwQqbvGm6SKRdxd4VLHex3dWXewrgTDZL44UpF5\"\n+        k_bip44_child0_ard = \"n1e8DCf7ahpMjVtDvoEfpBwTDEptLxKLs5\" #m/44'/0'/0'/0/0\n+        k_bip44_child1_ard = \"n14jYqMLvqG2oJWAr8Fkx2xtxtp8xtqM4C\" #m/44'/0'/0'/0/1\n+        k_bip44_child2_ard = \"myRrZdQnkH5aD8hkGX5hXA3S5gL96uszB8\" #m/44'/0'/0'/0/2000\n+        k_bip44_child3_ard = \"mnesCcdjvFA5Ys5zQsrLf4B4wmgUwS3kur\" #m/44'/0'/0'/1/0\n+        k_bip44_child4_ard = \"mvp9t1iRxGUw8JL615gDsJoq6LzdX2WYRn\" #m/44'/0'/0'/1/2000\n+\n+        self.nodes[0].sendtoaddress(k_bip44_child0_ard, 0.1)\n+        self.nodes[0].sendtoaddress(k_bip44_child1_ard, 0.2)\n+        self.nodes[0].sendtoaddress(k_bip44_child2_ard, 0.3)\n+        self.nodes[0].sendtoaddress(k_bip44_child3_ard, 0.4)\n+        self.nodes[0].sendtoaddress(k_bip44_child4_ard, 0.5)\n+        self.nodes[0].generate(1)\n+\n+        self.stop_node(0)\n+        os.remove(os.path.join(self.options.tmpdir, \"node0/regtest/wallet.dat\"))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189683735",
      "id" : 189683735,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4MzczNQ==",
      "original_commit_id" : "9ea4835210032c02562eee7f8cf690b76f1f9f3b",
      "original_position" : 54,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189683735",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189684608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189684608"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: \"Estimated fee\" implies that the fee is unknown, which is not true given that the exact fee can be calculated.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:07:08Z",
      "diff_hunk" : "@@ -1704,6 +1729,9 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"   }\\n\"\n             \"   ,...], \\n\"\n             \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189684608",
      "id" : 189684608,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4NDYwOA==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 55,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189684608",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189685191"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189685191"
         }
      },
      "author_association" : "MEMBER",
      "body" : "can be marked override",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:09:55Z",
      "diff_hunk" : "@@ -1671,6 +1674,23 @@ class CoinsViewScanReserver\n     }\n };\n \n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189685191",
      "id" : 189685191,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4NTE5MQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 22,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189685191",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189685205"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189685205"
         }
      },
      "author_association" : "MEMBER",
      "body" : "can be marked override",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:10:00Z",
      "diff_hunk" : "@@ -1671,6 +1674,23 @@ class CoinsViewScanReserver\n     }\n };\n \n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189685205",
      "id" : 189685205,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4NTIwNQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 27,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189685205",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189687339"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189687339"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think the vsizes of the signatures are only estimated?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:19:34Z",
      "diff_hunk" : "@@ -1704,6 +1729,9 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"   }\\n\"\n             \"   ,...], \\n\"\n             \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189687339",
      "id" : 189687339,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4NzMzOQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 54,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189687339",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189687505"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189687505"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe this doesn't use the wallet, but the `conf_target` instead?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:20:20Z",
      "diff_hunk" : "@@ -1692,6 +1712,11 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n             \"                }\\n\"\n             \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189687505",
      "id" : 189687505,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4NzUwNQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 43,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189687505",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189687580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189687580"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe the default for conf_target is 6?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-21T19:20:34Z",
      "diff_hunk" : "@@ -1692,6 +1712,11 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n             \"                }\\n\"\n             \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189687580",
      "id" : 189687580,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTY4NzU4MA==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 44,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 121899280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189687580",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189995755"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189995755"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe change this to\r\n```\r\n    \"scantxoutset \\\"action\\\" ( option )\\n\"\r\n```",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T17:54:39Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189995755",
      "id" : 189995755,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5NTc1NQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 80,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189995755",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996239"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove `\\n`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T17:56:06Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996239",
      "id" : 189996239,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5NjIzOQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 97,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996239",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996553"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996553"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Needs 2 spaces between argument name and description.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T17:56:57Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996553",
      "id" : 189996553,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5NjU1Mw==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 94,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996553",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996836"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Replace `]` with `}`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T17:57:50Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996836",
      "id" : 189996836,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5NjgzNg==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 117,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996836",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996929"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Needs 2 spaces before description.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T17:58:06Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996929",
      "id" : 189996929,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5NjkyOQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 114,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996929",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996965"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996965"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Needs 1 space before description.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T17:58:14Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996965",
      "id" : 189996965,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5Njk2NQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 115,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996965",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996991"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Needs 1 space before description.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T17:58:19Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189996991",
      "id" : 189996991,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5Njk5MQ==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 116,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189996991",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189997377"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189997377"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove `,` as this is the last key.",
      "commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "created_at" : "2018-05-22T17:59:31Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189997377",
      "id" : 189997377,
      "in_reply_to_id" : 189996991,
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 116,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 116,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-05-22T18:04:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189997377",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189998059"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189998059"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, agree that `status` should not raise an error when no scan is in progress.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T18:01:42Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}], other options}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                      (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                     (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]   (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"xpubs\\\":                   (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\\"xpub\\\":\\\"<xpub>\\\", (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",    (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                   (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",   (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,            (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,         (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189998059",
      "id" : 189998059,
      "in_reply_to_id" : 161720229,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5ODA1OQ==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 90,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189998059",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189998593"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189998593"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How about `assert(!script.empty())`?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T18:03:26Z",
      "diff_hunk" : "@@ -1637,6 +1640,249 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubkey_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"invalid xpub\");\n+                }\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script\n+            CScript witscript = GetScriptForWitness(script);\n+            CTxDestination result;\n+            ExtractDestination(witscript, result);\n+            CScript p2wpkh_script = GetScriptForDestination(result);\n+            CScript p2sh_p2wpkh_script = GetScriptForDestination(CScriptID(p2wpkh_script));\n+            if (!p2wpkh_script.empty()) {\n+                needles.insert(p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2wpkh_script);\n+            }\n+            if (!p2sh_p2wpkh_script.empty()) {\n+                needles.insert(p2sh_p2wpkh_script);\n+                temp_keystore.AddWatchOnly(p2sh_p2wpkh_script);\n+            }\n+            // add 1of1 multisig (used by Bitpay for a while)\n+            script = GetScriptForMultisig(1, std::vector<CPubKey>(1, pubKey));\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add legacy P2PK\n+            script = GetScriptForRawPubKey(pubKey);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+        // look for posssible addresses\n+        UniValue addresses_uni = find_value(request.params[1], \"addresses\");\n+        if (addresses_uni.isArray()) {\n+            for (const UniValue& address_uni : addresses_uni.get_array().getValues()) {\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                if (!script.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r189998593",
      "id" : 189998593,
      "in_reply_to_id" : 189679876,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTk5ODU5Mw==",
      "original_commit_id" : "31d4874978c9e5176b2ee89269722670d8548320",
      "original_position" : 218,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122283081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189998593",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r190004892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190004892"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Put these in an object `\"rawsweep\": { }`?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-22T18:23:04Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r190004892",
      "id" : 190004892,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MDAwNDg5Mg==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 114,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 122294034,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190004892",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r190819366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190819366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Since we access the instance cursor (`CCoinsView()::Cursor()`), wouldn't it then require to access `pcoinsdbview` from within `coins.cpp` which seems not ideal?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-25T08:09:27Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scanProgress, std::atomic<bool>& shouldAbort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r190819366",
      "id" : 190819366,
      "in_reply_to_id" : 189391605,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MDgxOTM2Ng==",
      "original_commit_id" : "a6019cd910a685b1036924539af6f8ec77f07ed0",
      "original_position" : 15,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 123277894,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190819366",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r190822306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190822306"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Another way would be to wait at this point (with a conditional variable) until the scan has aborted. Objections?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-25T08:21:13Z",
      "diff_hunk" : "@@ -1637,6 +1640,249 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"No scan in progress\");\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r190822306",
      "id" : 190822306,
      "in_reply_to_id" : 189674015,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MDgyMjMwNg==",
      "original_commit_id" : "31d4874978c9e5176b2ee89269722670d8548320",
      "original_position" : 100,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 123281330,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190822306",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think we should avoid doing this step for uncompressed pubkeys as such outputs would be unspendable.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-27T02:57:50Z",
      "diff_hunk" : "@@ -1926,6 +1929,251 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\":   [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // look for posssible pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        UniValue pubkeys_uni = find_value(request.params[1], \"pubkeys\");\n+        if (pubkeys_uni.isArray()) {\n+            for (const UniValue& pubkey_uni : pubkeys_uni.get_array().getValues()) {\n+                if (!pubkey_uni.isStr() || !IsHex(pubkey_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHex(pubkey_uni.get_str()));\n+                CPubKey pub_key(data.begin(), data.end());\n+                if (!pub_key.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+                pubkeys.push_back(pub_key);\n+            }\n+        }\n+\n+        // check for xpubs and derive a lookup window\n+        UniValue xpubs_uni = find_value(request.params[1], \"xpubs\");\n+        if (xpubs_uni.isArray()) {\n+            for (const UniValue& xpub_uni : xpubs_uni.get_array().getValues()) {\n+                if (!xpub_uni.isObject()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid xpub object\");\n+                }\n+\n+                UniValue xpubkey_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue lookup_window_uni = find_value(xpub_uni, \"lookupwindow\");\n+                //default lookup window\n+                unsigned int window_start = 0;\n+                unsigned int window_end = 1000;\n+                if (!lookup_window_uni.isNull()) {\n+                    if (lookup_window_uni.isArray() && lookup_window_uni.get_array().size() != 2) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"xpub lookupwindow must be an array with two elements (range)\");\n+                    }\n+                    else {\n+                        window_start = (unsigned int)lookup_window_uni.get_array().getValues()[0].get_int();\n+                        window_end = (unsigned int)lookup_window_uni.get_array().getValues()[1].get_int();\n+                    }\n+                }\n+                // Derive internal- and external-chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubkey_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"invalid xpub\");\n+                }\n+                CExtPubKey c0;\n+                CExtPubKey c1;\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = window_start; i <= window_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k;\n+                    c0.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                    c1.Derive(k, i);\n+                    pubkeys.push_back(k.pubkey);\n+                }\n+            }\n+        }\n+\n+        // add all common scripts for the given and derived pubkeys\n+        for (const CPubKey& pubKey : pubkeys) {\n+            // add legacy P2PKH script\n+            CKeyID address = pubKey.GetID();\n+            CScript script = GetScriptForDestination(address);\n+            if (!script.empty()) {\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            // add P2SH-P2WPKH script",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063217",
      "id" : 191063217,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA2MzIxNw==",
      "original_commit_id" : "e6b1a46eb8f82c39f490e1e6c2592cfd12fece7f",
      "original_position" : 184,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 123571013,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063217",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `searchItems` should be `search_items` to match the `.h` file.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-27T03:01:25Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    while (cursor.Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (cursor.GetKey(key) && cursor.GetValue(coin)) {\n+            if (count++ % 8192 == 0) {\n+                boost::this_thread::interruption_point();\n+                if (should_abort) {\n+                    // allow to abort the scan via the abort reference\n+                    return false;\n+                }\n+            }\n+            if (count % 256 == 0) {\n+                // update progress reference every 256 item\n+                uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+                scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+            }\n+            if (needles.count(coin.out.scriptPubKey)) {\n+                out_results.emplace(key, coin);\n+            }\n+        } else {\n+            return false;\n+        }\n+        cursor.Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& searchItems, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063259",
      "id" : 191063259,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA2MzI1OQ==",
      "original_commit_id" : "468b034a64a33146fcc2a0faddb4484fa5899d87",
      "original_position" : 45,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 123571013,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063259",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063262"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063262"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: should have `,...` after this.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-27T03:01:59Z",
      "diff_hunk" : "@@ -1926,6 +1929,251 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\":   [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063262",
      "id" : 191063262,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA2MzI2Mg==",
      "original_commit_id" : "e6b1a46eb8f82c39f490e1e6c2592cfd12fece7f",
      "original_position" : 71,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 123571013,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063262",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063268"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: the spacing of this block looks a bit funny. I think the text should be indented more and the braces for the object should be aligned.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-27T03:02:59Z",
      "diff_hunk" : "@@ -1926,6 +1929,251 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\":   [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r191063268",
      "id" : 191063268,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTA2MzI2OA==",
      "original_commit_id" : "e6b1a46eb8f82c39f490e1e6c2592cfd12fece7f",
      "original_position" : 83,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 123571013,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191063268",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Just noting that GitHub decides to hide half of my review comments by default and they were not addressed (mostly feedback on the tests).",
      "created_at" : "2018-05-29T15:43:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-392826053",
      "id" : 392826053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-05-29T15:43:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/392826053",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> tx = scantxoutset(\"start\", { \"sweep_to\": address })[\"sweep_tx\"]\r\n> fundrawtransaction(tx, { \"subtractFeeFromOutputs\": [0] })\r\n\r\n@promag: would that also work without the wallet? My idea was to make `scantxoutset` work without a wallet.",
      "created_at" : "2018-05-30T07:25:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393057791",
      "id" : 393057791,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-05-30T07:25:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393057791",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Just noting that GitHub decides to hide half of my review comments by default and they were not addressed (mostly feedback on the tests).\r\n\r\n@MarcoFalke: Have not forgotten. Still working on it.",
      "created_at" : "2018-05-30T07:25:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393057931",
      "id" : 393057931,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "updated_at" : "2018-05-30T07:25:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393057931",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nI tested against a blockchain.info testnet wallet and was able to get the correct balance for an account including change (there's an xpub export feature buried in settings).\r\n\r\nI also tested against a Ledger wallet with p2sh segwit addresses.\r\n\r\nAlso tested `status` and `abort`.\r\n\r\nBackground question: what index could be added to make this much faster? I'm guessing `scriptPubKey -> unspents`?\r\n\r\nIssues:\r\n* ~when I launch `src/qt/bitcoin-qt` it says the RPC method doesn't exist~\r\n* mention in help that unconfirmed transactions are not included\r\n\r\nI can't figure out what's wrong with this syntax (and it only throws the error _after_ doing the scan bit):\r\n\r\n```sh\r\nsrc/bitcoin-cli scantxoutset start '{\"xpubs\": [ {\"xpub\": \"tpub...\" }  ]}, \"rawsweep\": {}}'\r\nerror: Error parsing JSON:{\"xpubs\": [ {\"xpub\": \"tpub...\" }  ]}, \"rawsweep\": {}}\r\n```\r\n\r\nWhen I do add an address I get `Min relay fee not met (code -26)`, even if I set `\"conf_target\": 6}`, setting `conf_target` to 1 did help.\r\n\r\nI'm assuming that calling `rawsweep` without the optional `address` field makes it use the wallet? (if so, that should be in the help)\r\n\r\nSuggestions:\r\n* add `scantxoutset` to the PR description\r\n\r\nSuggestions for followup PR:\r\n* `total_amount` doesn't include unconfirmed funds, maybe add a flag to show those?\r\n* a minimum block height / date for faster scans (if only to make RPC dev lives happier)\r\n* it would be really cool to sweep using an `xpriv` (with or without importing keys)\r\n* `rawsweep` should have an option to make 1 transaction per output",
      "created_at" : "2018-05-30T14:47:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393190971",
      "id" : 393190971,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5MzE5MDk3MQ==",
      "updated_at" : "2018-05-30T15:35:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393190971",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Followed @sipa advice and changed the API.\r\nThe script type derivation is now controllable via the API.\r\n\r\nThe command takes now <n> scan objects that are either an `address`, `script`, `pubkey` or `xpub`.\r\nXpub and pubkey have the option to pass in the script type (P2PKH, P2SH-P2WPKH, P2WPKH).\r\n\r\nThe commit history is also more clean now.\r\n\r\nThanks for reviewing again.\r\n\r\n@MarcoFalke: your review is lost in the nirvana.. can't find the comments on the test anymore. Can you try to review again?\r\n@Sjors: the `Min relay fee not met (code -26)` is due to non initialise fee estimation. Use a feerate if you test on regtest without fee estimation available.\r\n\r\n```\r\n\"scanobjects\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\r\n      [\r\n        { \"address\" : \"<address>\" },       (string, optional) Bitcoin address\r\n        { \"script\"  : \"<scriptPubKey>\" },  (string, optional) HEX encoded script (scriptPubKey)\r\n        { \"pubkey\"  :                      (object, optional) Public key\r\n          {\r\n            \"pubkey\" : \"<pubkey\">,         (string, required) HEX encoded public key\r\n            \"script_types\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \"P2PKH\", \"P2SH-P2WPKH\", \"P2WPKH\")\r\n          }\r\n        },\r\n        { \"xpub\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\r\n          { \r\n            \"xpub\" : \"<xpub\">,             (string, required) Base58check encoded extended public key (xpub)\r\n            \"range\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\r\n            \"script_types\" : [ ... ],      (array, optional) Array of derivation type (possible values: \"P2PKH\", \"P2SH-P2WPKH\", \"P2WPKH\")\r\n          }\r\n        },\r\n      ]\r\n```",
      "created_at" : "2018-05-31T14:04:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393541211",
      "id" : 393541211,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5MzU0MTIxMQ==",
      "updated_at" : "2018-05-31T14:04:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393541211",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors \r\n> total_amount doesn't include unconfirmed funds, maybe add a flag to show those?\r\n\r\nThis should be done in a separate command (`scanmempool` which would be a great follow up).\r\n\r\n> a minimum block height / date for faster scans (if only to make RPC dev lives happier)\r\n\r\nNot possible AFAIK. We scan the UXTO set, not blocks.\r\n\r\n> it would be really cool to sweep using an xpriv (with or without importing keys)\r\n\r\nIMO the command should not include any private keys. Ideally we add xpriv support similar to this command to signrawtransaction.\r\nBut I agree that this would be a great.\r\n\r\n> rawsweep should have an option to make 1 transaction per output\r\n\r\nMaybe, but could/should be added later.\r\n\r\n> I'm assuming that calling rawsweep without the optional address field makes it use the wallet? (if so, that should be in the help)\r\n\r\nNo. This command is totally de-coupled from the wallet (runs without wallet).",
      "created_at" : "2018-05-31T14:08:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393542212",
      "id" : 393542212,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5MzU0MjIxMg==",
      "updated_at" : "2018-05-31T14:08:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393542212",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r192261221"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192261221"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As @Sjors points out, this should be required if `rawsweep` is set?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-05-31T23:02:24Z",
      "diff_hunk" : "@@ -1926,6 +1932,428 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> (<options>)\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r192261221",
      "id" : 192261221,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjI2MTIyMQ==",
      "original_commit_id" : "2776a951a4cec9d8e10b29ca141cb3b025dc3526",
      "original_position" : 145,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 125004762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192261221",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> `rawsweep` should have an option to make 1 transaction per output\r\n\r\n@Sjors why?\r\n",
      "created_at" : "2018-05-31T23:02:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393709394",
      "id" : 393709394,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5MzcwOTM5NA==",
      "updated_at" : "2018-05-31T23:02:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393709394",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jonasschnelli the `Min relay fee not met` error was on testnet, not regtest. Maybe that doesn't happen on mainnet much. Maybe it should detect the lack of fee estimation and throw a specific error (if no fee is specified by the user)?\r\n\r\n> We scan the UXTO set, not blocks\r\n\r\nI wish there an easy way to \"translate\" Bitcoin Core's internal data structures to SQL table descriptions, so it's easier to understand what \"columns\" and \"indexes\" exist. I haven't had much luck using external tools to load the various db files.\r\n\r\n>> I'm assuming that calling rawsweep without the optional address field makes it use the wallet? (if so, that should be in the help)\r\n> No. This command is totally de-coupled from the wallet (runs without wallet).\r\n\r\nOk, then I don't understand why the address field is documented as optional.\r\n\r\n@promag 1 transaction per output (to a unique address) improves privacy when sweeping an existing wallet. Especially if you don't broadcast them all at the same time. ",
      "created_at" : "2018-06-01T07:12:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393786069",
      "id" : 393786069,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5Mzc4NjA2OQ==",
      "updated_at" : "2018-06-01T07:12:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393786069",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@Sjors you have an extra close curly-brace after the close square bracket in `src/bitcoin-cli scantxoutset start '{\"xpubs\": [ {\"xpub\": \"tpub...\" }  ]}, \"rawsweep\": {}}'` ",
      "created_at" : "2018-06-02T11:24:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-394079921",
      "id" : 394079921,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NDA3OTkyMQ==",
      "updated_at" : "2018-06-02T11:24:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/394079921",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I have an unspent txout (on testnet) like this:\r\n```json\r\n  {\r\n    \"txid\": \"473abbc4eb4768d1fdad21f05d3485bcd96cb33f883dce3dd8bccebced3f4efc\",\r\n    \"vout\": 0,\r\n    \"address\": \"n2PaqLena7QZtpKowZok8FMPqCY21Xrp4x\",\r\n    \"label\": \"null\",\r\n    \"scriptPubKey\": \"21029b861186b49793708a4e00ecf3cec62c027dccfc12509b7e6ac2538b4b19b3abac\",\r\n    \"amount\": 25.00317000,\r\n    \"confirmations\": 980258,\r\n    \"spendable\": true,\r\n    \"solvable\": true,\r\n    \"safe\": true\r\n  }\r\n```\r\n\r\nBy address gives me no output:\r\n```json\r\n$ src/bitcoin-cli -testnet scantxoutset start '[{\"address\":\"n2PaqLena7QZtpKowZok8FMPqCY21Xrp4x\"}]'\r\n{\r\n  \"success\": \"yes\",\r\n  \"searched_items\": 19143564,\r\n  \"unspents\": [\r\n  ],\r\n  \"total_amount\": 0.00000000\r\n}\r\n$ \r\n```\r\n\r\nBy script it works, however\r\n```json\r\n$ src/bitcoin-cli -testnet scantxoutset start '[{\"script\":\"21029b861186b49793708a4e00ecf3cec62c027dccfc12509b7e6ac2538b4b19b3abac\"}]'\r\n{\r\n  \"success\": \"yes\",\r\n  \"searched_items\": 19162149,\r\n  \"unspents\": [\r\n    {\r\n      \"txid\": \"473abbc4eb4768d1fdad21f05d3485bcd96cb33f883dce3dd8bccebced3f4efc\",\r\n      \"vout\": 0,\r\n      \"scriptPubKey\": \"21029b861186b49793708a4e00ecf3cec62c027dccfc12509b7e6ac2538b4b19b3abac\",\r\n      \"amount\": 25.00317000,\r\n      \"height\": 330282\r\n    }\r\n  ],\r\n  \"total_amount\": 25.00317000\r\n}\r\n```",
      "created_at" : "2018-06-04T13:33:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-394356035",
      "id" : 394356035,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NDM1NjAzNQ==",
      "updated_at" : "2018-06-04T13:33:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/394356035",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needs rebase",
      "created_at" : "2018-06-11T14:38:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-396266591",
      "id" : 396266591,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NjI2NjU5MQ==",
      "updated_at" : "2018-06-11T14:38:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/396266591",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@laanwj:\r\nIf I execute `getaddressinfo n2PaqLena7QZtpKowZok8FMPqCY21Xrp4x` I get \r\n```json\r\n{\r\n  \"address\": \"n2PaqLena7QZtpKowZok8FMPqCY21Xrp4x\",\r\n  \"scriptPubKey\": \"76a914e4f5d0b9353f7715e1bfed11358a5b84fd7c4e3488ac\",\r\n  \"ismine\": false,\r\n  \"iswatchonly\": false,\r\n  \"isscript\": false,\r\n  \"iswitness\": false,\r\n  \"labels\": [\r\n  ]\r\n}\r\n```\r\n\r\nAFAIK your script (P2PK) `21029b861186b49793708a4e00ecf3cec62c027dccfc12509b7e6ac2538b4b19b3abac` can only be derived if one has the according pubkey.",
      "created_at" : "2018-06-12T08:40:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-396512496",
      "id" : 396512496,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NjUxMjQ5Ng==",
      "updated_at" : "2018-06-12T08:40:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/396512496",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2018-06-12T08:41:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-396512960",
      "id" : 396512960,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NjUxMjk2MA==",
      "updated_at" : "2018-06-12T08:41:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/396512960",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Added two commits:\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/12196/commits/fdd09d34a14ca4f416b9101b37187098f9145301 \r\nadds support for P2PK in `script_types`\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/12196/commits/3c546fd38e2bdb6957fa134f8847e2a7c5c7e23\r\n\r\nP2PK and P2PKH share the same address (two scripts result in the same address). Deriving a P2PK script requires the pubkey which is not available when the user provides an address.\r\n\r\nSince we not want to miss funds, we have to derive the P2PKH equivalent of every P2PK unspent in the txoutset and compare it against the provided address (only required when providing addresses).",
      "created_at" : "2018-06-13T14:09:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-396950856",
      "id" : 396950856,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5Njk1MDg1Ng==",
      "updated_at" : "2018-06-13T14:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/396950856",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195171435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195171435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`std::function` is defined in header `<functional>`, which needs to be included.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T17:30:23Z",
      "diff_hunk" : "@@ -157,6 +160,10 @@ class CCoinsView\n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n+    //! Search for a given set of pubkey scripts\n+    static bool FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, std::function<bool(const CScript& script)> match_func, std::map<COutPoint, Coin>& out_results);\n+    bool FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& search_items, std::function<bool(const CScript& script)> match_func, std::map<COutPoint, Coin>& out_results);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195171435",
      "id" : 195171435,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTE3MTQzNQ==",
      "original_commit_id" : "3c546fd38e2bdb6957fa134f8847e2a7c5c7e23a",
      "original_position" : 16,
      "path" : "src/coins.h",
      "position" : null,
      "pull_request_review_id" : 128485188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195171435",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "After discussion with @sipa on IRC, I removed the auto-derivation for P2PK scripts when scanning with addresses. Instead, I have added a short info to the RPC help that should make users aware for that particular edge case.",
      "created_at" : "2018-06-13T20:42:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-397079427",
      "id" : 397079427,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NzA3OTQyNw==",
      "updated_at" : "2018-06-13T20:42:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/397079427",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195255759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195255759"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also initialize `count = 0;`?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T22:29:39Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195255759",
      "id" : 195255759,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI1NTc1OQ==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 16,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195255759",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195255983"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195255983"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit,\r\n```cpp\r\nif (!cursor.GetKey(key) || !cursor.GetValue(coin) return false;\r\n```\r\nand reindent below.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T22:30:52Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    while (cursor.Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (cursor.GetKey(key) && cursor.GetValue(coin)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195255983",
      "id" : 195255983,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI1NTk4Mw==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 20,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195255983",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195257011"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195257011"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be `const std::atomic<bool>& should_abort`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T22:36:43Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195257011",
      "id" : 195257011,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI1NzAxMQ==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 15,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195257011",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195260599"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195260599"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`|| ShutdownRequested()`?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T22:55:42Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    while (cursor.Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (cursor.GetKey(key) && cursor.GetValue(coin)) {\n+            if (count++ % 8192 == 0) {\n+                boost::this_thread::interruption_point();\n+                if (should_abort) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195260599",
      "id" : 195260599,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI2MDU5OQ==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 23,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195260599",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195261696"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195261696"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, spaces inside `(` `)`",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T23:01:55Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> (<options>)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195261696",
      "id" : 195261696,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI2MTY5Ng==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 119,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195261696",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195267082"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195267082"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```py\r\nself.restart_node(0, ['-nowallet'])\r\n```\r\nand remove next 2 lines.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T23:36:07Z",
      "diff_hunk" : "@@ -0,0 +1,78 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScantxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.nodes[0].datadir, \"regtest\", 'wallets'))\n+        self.start_node(0)\n+        self.nodes[0].generate(110)\n+\n+        self.log.info(\"Send some coins to HD deriven keys\")\n+        #bip32/bip44 tests (use xpriv = \"tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK\")\n+        xpub_account_key = \"tpubDCWjaJPr3DfCGCvZzKVxXhneVjuRsXkDtoF18BFvci1eeLR97zz8DYr56kgT4sXgYDXQvwQqbvGm6SKRdxd4VLHex3dWXewrgTDZL44UpF5\"\n+        k_bip44_child0_ard = \"n1e8DCf7ahpMjVtDvoEfpBwTDEptLxKLs5\" #m/44'/0'/0'/0/0\n+        k_bip44_child1_ard = \"n14jYqMLvqG2oJWAr8Fkx2xtxtp8xtqM4C\" #m/44'/0'/0'/0/1\n+        k_bip44_child2_ard = \"myRrZdQnkH5aD8hkGX5hXA3S5gL96uszB8\" #m/44'/0'/0'/0/2000\n+        k_bip44_child3_ard = \"mnesCcdjvFA5Ys5zQsrLf4B4wmgUwS3kur\" #m/44'/0'/0'/1/0\n+        k_bip44_child4_ard = \"mvp9t1iRxGUw8JL615gDsJoq6LzdX2WYRn\" #m/44'/0'/0'/1/2000\n+\n+        self.nodes[0].sendtoaddress(k_bip44_child0_ard, 0.1)\n+        self.nodes[0].sendtoaddress(k_bip44_child1_ard, 0.2)\n+        self.nodes[0].sendtoaddress(k_bip44_child2_ard, 0.3)\n+        self.nodes[0].sendtoaddress(k_bip44_child3_ard, 0.4)\n+        self.nodes[0].sendtoaddress(k_bip44_child4_ard, 0.5)\n+        self.nodes[0].generate(1)\n+\n+        self.stop_node(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195267082",
      "id" : 195267082,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI2NzA4Mg==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 53,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195267082",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195269100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195269100"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could improve coverage:\r\n```py\r\n        result = self.nodes[1].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}], {\"rawsweep\" : {\"address\": addr_BECH32, \"feerate\": 0.00025000}})\r\n        decodedsweeptx = self.nodes[1].decoderawtransaction(result['rawsweep_tx'])\r\n        assert_equal(len(decodedsweeptx['vout']), 1)\r\n        assert_equal(len(decodedsweeptx['vin']), 3)\r\n        assert_equal(decodedsweeptx['vout'][0]['scriptPubKey']['addresses'], [addr_BECH32])\r\n```",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-13T23:51:06Z",
      "diff_hunk" : "@@ -0,0 +1,78 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScantxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.nodes[0].datadir, \"regtest\", 'wallets'))\n+        self.start_node(0)\n+        self.nodes[0].generate(110)\n+\n+        self.log.info(\"Send some coins to HD deriven keys\")\n+        #bip32/bip44 tests (use xpriv = \"tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK\")\n+        xpub_account_key = \"tpubDCWjaJPr3DfCGCvZzKVxXhneVjuRsXkDtoF18BFvci1eeLR97zz8DYr56kgT4sXgYDXQvwQqbvGm6SKRdxd4VLHex3dWXewrgTDZL44UpF5\"\n+        k_bip44_child0_ard = \"n1e8DCf7ahpMjVtDvoEfpBwTDEptLxKLs5\" #m/44'/0'/0'/0/0\n+        k_bip44_child1_ard = \"n14jYqMLvqG2oJWAr8Fkx2xtxtp8xtqM4C\" #m/44'/0'/0'/0/1\n+        k_bip44_child2_ard = \"myRrZdQnkH5aD8hkGX5hXA3S5gL96uszB8\" #m/44'/0'/0'/0/2000\n+        k_bip44_child3_ard = \"mnesCcdjvFA5Ys5zQsrLf4B4wmgUwS3kur\" #m/44'/0'/0'/1/0\n+        k_bip44_child4_ard = \"mvp9t1iRxGUw8JL615gDsJoq6LzdX2WYRn\" #m/44'/0'/0'/1/2000\n+\n+        self.nodes[0].sendtoaddress(k_bip44_child0_ard, 0.1)\n+        self.nodes[0].sendtoaddress(k_bip44_child1_ard, 0.2)\n+        self.nodes[0].sendtoaddress(k_bip44_child2_ard, 0.3)\n+        self.nodes[0].sendtoaddress(k_bip44_child3_ard, 0.4)\n+        self.nodes[0].sendtoaddress(k_bip44_child4_ard, 0.5)\n+        self.nodes[0].generate(1)\n+\n+        self.stop_node(0)\n+        os.remove(os.path.join(self.nodes[0].datadir, \"regtest\", \"wallet.dat\"))\n+        self.start_node(0)\n+        self.log.info(\"Test if we have found the non HD unspent outputs.\")\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}])['total_amount'], 6)\n+        decodedsweeptx = self.nodes[0].decoderawtransaction(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}], {\"rawsweep\" : {\"address\": addr_BECH32, \"feerate\": 0.00025000}})['rawsweep_tx'])\n+        assert_equal(len(decodedsweeptx['vin']), 3)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195269100",
      "id" : 195269100,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI2OTEwMA==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 59,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195269100",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195272842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195272842"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You could test sign and send the sweep transaction",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-14T00:18:22Z",
      "diff_hunk" : "@@ -0,0 +1,78 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScantxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.nodes[0].datadir, \"regtest\", 'wallets'))\n+        self.start_node(0)\n+        self.nodes[0].generate(110)\n+\n+        self.log.info(\"Send some coins to HD deriven keys\")\n+        #bip32/bip44 tests (use xpriv = \"tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK\")\n+        xpub_account_key = \"tpubDCWjaJPr3DfCGCvZzKVxXhneVjuRsXkDtoF18BFvci1eeLR97zz8DYr56kgT4sXgYDXQvwQqbvGm6SKRdxd4VLHex3dWXewrgTDZL44UpF5\"\n+        k_bip44_child0_ard = \"n1e8DCf7ahpMjVtDvoEfpBwTDEptLxKLs5\" #m/44'/0'/0'/0/0\n+        k_bip44_child1_ard = \"n14jYqMLvqG2oJWAr8Fkx2xtxtp8xtqM4C\" #m/44'/0'/0'/0/1\n+        k_bip44_child2_ard = \"myRrZdQnkH5aD8hkGX5hXA3S5gL96uszB8\" #m/44'/0'/0'/0/2000\n+        k_bip44_child3_ard = \"mnesCcdjvFA5Ys5zQsrLf4B4wmgUwS3kur\" #m/44'/0'/0'/1/0\n+        k_bip44_child4_ard = \"mvp9t1iRxGUw8JL615gDsJoq6LzdX2WYRn\" #m/44'/0'/0'/1/2000\n+\n+        self.nodes[0].sendtoaddress(k_bip44_child0_ard, 0.1)\n+        self.nodes[0].sendtoaddress(k_bip44_child1_ard, 0.2)\n+        self.nodes[0].sendtoaddress(k_bip44_child2_ard, 0.3)\n+        self.nodes[0].sendtoaddress(k_bip44_child3_ard, 0.4)\n+        self.nodes[0].sendtoaddress(k_bip44_child4_ard, 0.5)\n+        self.nodes[0].generate(1)\n+\n+        self.stop_node(0)\n+        os.remove(os.path.join(self.nodes[0].datadir, \"regtest\", \"wallet.dat\"))\n+        self.start_node(0)\n+        self.log.info(\"Test if we have found the non HD unspent outputs.\")\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}])['total_amount'], 6)\n+        decodedsweeptx = self.nodes[0].decoderawtransaction(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}], {\"rawsweep\" : {\"address\": addr_BECH32, \"feerate\": 0.00025000}})['rawsweep_tx'])\n+        assert_equal(len(decodedsweeptx['vin']), 3)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195272842",
      "id" : 195272842,
      "in_reply_to_id" : 195269100,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI3Mjg0Mg==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 59,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195272842",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195273137"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195273137"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`RPC_INVALID_PARAMETER` instead?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-14T00:20:16Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> (<options>)\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!xpub_uni.isNull() && !xpub_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }\n+                    else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+            else if (xpub_uni.isObject()) {\n+                // type: extended public key\n+                // derive <n> keys after lookup window (range)\n+                // derive scripts of all keys according to the script_type parameter\n+                UniValue script_types_uni = find_value(xpub_uni, \"script_types\");\n+                UniValue xpubdata_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue range_uni = find_value(xpub_uni, \"range\");\n+\n+                // check the script types and use default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                //set default child key derivation range\n+                unsigned int ckd_range_start = 0;\n+                unsigned int ckd_range_end = 1000;\n+                if (!range_uni.isNull() && (!range_uni.isArray() || range_uni.get_array().size() != 2)) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"range must be an array with two values\");\n+                }\n+                else if (!range_uni.isNull()) {\n+                    // use user defined derive range\n+                    ckd_range_start = (unsigned int)range_uni.get_array().getValues()[0].get_int();\n+                    ckd_range_end = (unsigned int)range_uni.get_array().getValues()[1].get_int();\n+                    if (ckd_range_start > ckd_range_end) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range\");\n+                    }\n+                }\n+\n+                // Derive internal and external chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubdata_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid xpub\");\n+                }\n+                CExtPubKey c0; //external chain\n+                CExtPubKey c1; //internal chain\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = ckd_range_start; i <= ckd_range_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k_external, k_internal;\n+                    c0.Derive(k_external, i);\n+                    c1.Derive(k_internal, i);\n+\n+                    for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                        OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                        if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                        // get internal and external scripts and add it to the containers\n+                        CScript script = GetScriptForDestination(GetDestinationForKey(k_external.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+\n+                        script = GetScriptForDestination(GetDestinationForKey(k_internal.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+                    }\n+                }\n+            }\n+            else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array, temp keystore)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);\n+\n+        // report back\n+        result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+        result.push_back(Pair(\"searched_items\", count));\n+\n+        int nIn = 0;\n+        for (const auto& it : coins) {\n+            const COutPoint& outpoint = it.first;\n+            const Coin& coin = it.second;\n+            const CTxOut& txo = coin.out;\n+            tx.vin.emplace_back(outpoint.hash, outpoint.n);\n+            tx.vin.back().nSequence = MAX_BIP125_RBF_SEQUENCE; //enforce BIP125\n+\n+            // Fill in dummy signatures for fee calculation, ignore signature verification.\n+            const CScript& scriptPubKey = txo.scriptPubKey;\n+            SignatureData sigdata;\n+            ProduceSignature(temp_keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata);\n+            UpdateInput(tx.vin.at(nIn), sigdata);\n+\n+            input_txos.push_back(txo);\n+            total_in += txo.nValue;\n+\n+            UniValue unspent(UniValue::VOBJ);\n+            unspent.push_back(Pair(\"txid\", outpoint.hash.GetHex()));\n+            unspent.push_back(Pair(\"vout\", (int32_t)outpoint.n));\n+            unspent.push_back(Pair(\"scriptPubKey\", HexStr(txo.scriptPubKey.begin(), txo.scriptPubKey.end())));\n+            unspent.push_back(Pair(\"amount\", ValueFromAmount(txo.nValue)));\n+            unspent.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n+\n+            unspents.push_back(unspent);\n+\n+            nIn++;\n+        }\n+\n+        // check and eventually build a raw sweep transaction\n+        UniValue rawsweep_uni = find_value(request.params[2], \"rawsweep\");\n+        if (!coins.empty() && rawsweep_uni.isObject()) {\n+            CTxDestination dest = DecodeDestination(find_value(rawsweep_uni, \"address\").get_str());\n+            if (!IsValidDestination(dest)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or missing raw sweep address\");\n+            }\n+            tx.vout.emplace_back(total_in, GetScriptForDestination(dest));\n+            int64_t tx_vsize = GetVirtualTransactionSize(tx);\n+\n+            // Remove scriptSigs to eliminate the fee calculation dummy signatures\n+            for (auto& vin : tx.vin) {\n+                vin.scriptSig = CScript();\n+                vin.scriptWitness.SetNull();\n+            }\n+\n+            // look for user provided feerate\n+            UniValue feerate_uni = find_value(rawsweep_uni, \"feerate\");\n+            CFeeRate feerate;\n+            if(feerate_uni.isNum()) {\n+                feerate = CFeeRate(AmountFromValue(feerate_uni));\n+            } else {\n+                // estimate feerate, check for optional conf_target\n+                int conf_target = 6;\n+                UniValue conf_target_uni = find_value(rawsweep_uni, \"conf_target\");\n+                if (conf_target_uni.isNum()) conf_target = conf_target_uni.get_int();\n+                FeeCalculation fee_calc;\n+                feerate = ::feeEstimator.estimateSmartFee(conf_target, &fee_calc, false).GetFee(tx_vsize);\n+            }\n+            CAmount fee_needed = feerate.GetFee(tx_vsize);\n+            if (fee_needed < ::minRelayTxFee.GetFee(tx_vsize)) {\n+                throw JSONRPCError(RPC_VERIFY_REJECTED, \"Min relay fee not met\");\n+            }\n+            if (fee_needed >= total_in) {\n+                throw JSONRPCError(RPC_VERIFY_REJECTED, strprintf(\"Not enough funds available in found unspent outputs to pay for the fee (total inputs: %lld, fee: %lld)\", total_in, fee_needed));\n+            }\n+            tx.vout[0].nValue = total_in - fee_needed;\n+            if (IsDust(tx.vout[0], ::minRelayTxFee)) {\n+                throw JSONRPCError(RPC_VERIFY_REJECTED, \"Swept value would be dust\");\n+            }\n+            result.push_back(Pair(\"rawsweep_tx\", EncodeHexTx(tx)));\n+            result.push_back(Pair(\"rawsweep_fee\", ValueFromAmount(fee_needed)));\n+            result.push_back(Pair(\"rawsweep_vsize\", tx_vsize));\n+        }\n+\n+        result.push_back(Pair(\"unspents\", unspents));\n+        result.push_back(Pair(\"total_amount\", ValueFromAmount(total_in)));\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid command\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195273137",
      "id" : 195273137,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI3MzEzNw==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 453,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195273137",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195273186"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195273186"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, space after `if`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-14T00:20:44Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> (<options>)\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!xpub_uni.isNull() && !xpub_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }\n+                    else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+            else if (xpub_uni.isObject()) {\n+                // type: extended public key\n+                // derive <n> keys after lookup window (range)\n+                // derive scripts of all keys according to the script_type parameter\n+                UniValue script_types_uni = find_value(xpub_uni, \"script_types\");\n+                UniValue xpubdata_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue range_uni = find_value(xpub_uni, \"range\");\n+\n+                // check the script types and use default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                //set default child key derivation range\n+                unsigned int ckd_range_start = 0;\n+                unsigned int ckd_range_end = 1000;\n+                if (!range_uni.isNull() && (!range_uni.isArray() || range_uni.get_array().size() != 2)) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"range must be an array with two values\");\n+                }\n+                else if (!range_uni.isNull()) {\n+                    // use user defined derive range\n+                    ckd_range_start = (unsigned int)range_uni.get_array().getValues()[0].get_int();\n+                    ckd_range_end = (unsigned int)range_uni.get_array().getValues()[1].get_int();\n+                    if (ckd_range_start > ckd_range_end) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range\");\n+                    }\n+                }\n+\n+                // Derive internal and external chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubdata_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid xpub\");\n+                }\n+                CExtPubKey c0; //external chain\n+                CExtPubKey c1; //internal chain\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = ckd_range_start; i <= ckd_range_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k_external, k_internal;\n+                    c0.Derive(k_external, i);\n+                    c1.Derive(k_internal, i);\n+\n+                    for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                        OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                        if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                        // get internal and external scripts and add it to the containers\n+                        CScript script = GetScriptForDestination(GetDestinationForKey(k_external.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+\n+                        script = GetScriptForDestination(GetDestinationForKey(k_internal.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+                    }\n+                }\n+            }\n+            else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array, temp keystore)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);\n+\n+        // report back\n+        result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+        result.push_back(Pair(\"searched_items\", count));\n+\n+        int nIn = 0;\n+        for (const auto& it : coins) {\n+            const COutPoint& outpoint = it.first;\n+            const Coin& coin = it.second;\n+            const CTxOut& txo = coin.out;\n+            tx.vin.emplace_back(outpoint.hash, outpoint.n);\n+            tx.vin.back().nSequence = MAX_BIP125_RBF_SEQUENCE; //enforce BIP125\n+\n+            // Fill in dummy signatures for fee calculation, ignore signature verification.\n+            const CScript& scriptPubKey = txo.scriptPubKey;\n+            SignatureData sigdata;\n+            ProduceSignature(temp_keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata);\n+            UpdateInput(tx.vin.at(nIn), sigdata);\n+\n+            input_txos.push_back(txo);\n+            total_in += txo.nValue;\n+\n+            UniValue unspent(UniValue::VOBJ);\n+            unspent.push_back(Pair(\"txid\", outpoint.hash.GetHex()));\n+            unspent.push_back(Pair(\"vout\", (int32_t)outpoint.n));\n+            unspent.push_back(Pair(\"scriptPubKey\", HexStr(txo.scriptPubKey.begin(), txo.scriptPubKey.end())));\n+            unspent.push_back(Pair(\"amount\", ValueFromAmount(txo.nValue)));\n+            unspent.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n+\n+            unspents.push_back(unspent);\n+\n+            nIn++;\n+        }\n+\n+        // check and eventually build a raw sweep transaction\n+        UniValue rawsweep_uni = find_value(request.params[2], \"rawsweep\");\n+        if (!coins.empty() && rawsweep_uni.isObject()) {\n+            CTxDestination dest = DecodeDestination(find_value(rawsweep_uni, \"address\").get_str());\n+            if (!IsValidDestination(dest)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or missing raw sweep address\");\n+            }\n+            tx.vout.emplace_back(total_in, GetScriptForDestination(dest));\n+            int64_t tx_vsize = GetVirtualTransactionSize(tx);\n+\n+            // Remove scriptSigs to eliminate the fee calculation dummy signatures\n+            for (auto& vin : tx.vin) {\n+                vin.scriptSig = CScript();\n+                vin.scriptWitness.SetNull();\n+            }\n+\n+            // look for user provided feerate\n+            UniValue feerate_uni = find_value(rawsweep_uni, \"feerate\");\n+            CFeeRate feerate;\n+            if(feerate_uni.isNum()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195273186",
      "id" : 195273186,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTI3MzE4Ng==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 424,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 128588162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195273186",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195323375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195323375"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This would couple it to init.h,.. ideally we would finally extract the shutdown detection into its own space.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-14T07:21:39Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    while (cursor.Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (cursor.GetKey(key) && cursor.GetValue(coin)) {\n+            if (count++ % 8192 == 0) {\n+                boost::this_thread::interruption_point();\n+                if (should_abort) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195323375",
      "id" : 195323375,
      "in_reply_to_id" : 195260599,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTMyMzM3NQ==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 23,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 128666528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195323375",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195354911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195354911"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Lets extend the tests later....",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-14T09:22:48Z",
      "diff_hunk" : "@@ -0,0 +1,78 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScantxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.nodes[0].datadir, \"regtest\", 'wallets'))\n+        self.start_node(0)\n+        self.nodes[0].generate(110)\n+\n+        self.log.info(\"Send some coins to HD deriven keys\")\n+        #bip32/bip44 tests (use xpriv = \"tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK\")\n+        xpub_account_key = \"tpubDCWjaJPr3DfCGCvZzKVxXhneVjuRsXkDtoF18BFvci1eeLR97zz8DYr56kgT4sXgYDXQvwQqbvGm6SKRdxd4VLHex3dWXewrgTDZL44UpF5\"\n+        k_bip44_child0_ard = \"n1e8DCf7ahpMjVtDvoEfpBwTDEptLxKLs5\" #m/44'/0'/0'/0/0\n+        k_bip44_child1_ard = \"n14jYqMLvqG2oJWAr8Fkx2xtxtp8xtqM4C\" #m/44'/0'/0'/0/1\n+        k_bip44_child2_ard = \"myRrZdQnkH5aD8hkGX5hXA3S5gL96uszB8\" #m/44'/0'/0'/0/2000\n+        k_bip44_child3_ard = \"mnesCcdjvFA5Ys5zQsrLf4B4wmgUwS3kur\" #m/44'/0'/0'/1/0\n+        k_bip44_child4_ard = \"mvp9t1iRxGUw8JL615gDsJoq6LzdX2WYRn\" #m/44'/0'/0'/1/2000\n+\n+        self.nodes[0].sendtoaddress(k_bip44_child0_ard, 0.1)\n+        self.nodes[0].sendtoaddress(k_bip44_child1_ard, 0.2)\n+        self.nodes[0].sendtoaddress(k_bip44_child2_ard, 0.3)\n+        self.nodes[0].sendtoaddress(k_bip44_child3_ard, 0.4)\n+        self.nodes[0].sendtoaddress(k_bip44_child4_ard, 0.5)\n+        self.nodes[0].generate(1)\n+\n+        self.stop_node(0)\n+        os.remove(os.path.join(self.nodes[0].datadir, \"regtest\", \"wallet.dat\"))\n+        self.start_node(0)\n+        self.log.info(\"Test if we have found the non HD unspent outputs.\")\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}])['total_amount'], 6)\n+        decodedsweeptx = self.nodes[0].decoderawtransaction(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}], {\"rawsweep\" : {\"address\": addr_BECH32, \"feerate\": 0.00025000}})['rawsweep_tx'])\n+        assert_equal(len(decodedsweeptx['vin']), 3)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195354911",
      "id" : 195354911,
      "in_reply_to_id" : 195269100,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTM1NDkxMQ==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 59,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : null,
      "pull_request_review_id" : 128705555,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195354911",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed @promag's points",
      "created_at" : "2018-06-14T09:23:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-397230499",
      "id" : 397230499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NzIzMDQ5OQ==",
      "updated_at" : "2018-06-14T09:23:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/397230499",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195474501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195474501"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, fair enough.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-14T15:47:13Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195474501",
      "id" : 195474501,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTQ3NDUwMQ==",
      "original_commit_id" : "12cb70c0caec282fad5d7dc97a409d025c092481",
      "original_position" : 121,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 128851997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195474501",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Again, addresses are opaque and do not get tied to UTXOs. It makes no sense to find UTXOs \"by address\".",
      "created_at" : "2018-06-16T16:27:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-397823655",
      "id" : 397823655,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NzgyMzY1NQ==",
      "updated_at" : "2018-06-16T16:27:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/397823655",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195908302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195908302"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/received by the address/of the UTXO/",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-16T17:41:23Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r195908302",
      "id" : 195908302,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTkwODMwMg==",
      "original_commit_id" : "12cb70c0caec282fad5d7dc97a409d025c092481",
      "original_position" : 158,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 129368754,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195908302",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r196063804"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196063804"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-18T12:48:13Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r196063804",
      "id" : 196063804,
      "in_reply_to_id" : 195908302,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NjA2MzgwNA==",
      "original_commit_id" : "12cb70c0caec282fad5d7dc97a409d025c092481",
      "original_position" : 158,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 129545429,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196063804",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr \r\n> Again, addresses are opaque and do not get tied to UTXOs. It makes no sense to find UTXOs \"by address\".\r\n\r\nYou have already made that argument [here](https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-360244898).\r\nIt seems like that the scans based on addresses are useful. Other developers opinions would be welcome.",
      "created_at" : "2018-06-18T12:50:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-398043176",
      "id" : 398043176,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5ODA0MzE3Ng==",
      "updated_at" : "2018-06-18T12:50:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/398043176",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> It seems like that the scans based on addresses are useful. Other developers opinions would be welcome.\r\n\r\nYes, that is useful, and for better or worse, likely how most people will be using this in practice.\r\n\r\nutACK 4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "created_at" : "2018-06-18T15:52:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-398102545",
      "id" : 398102545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5ODEwMjU0NQ==",
      "updated_at" : "2018-06-18T16:29:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/398102545",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Addresses are opaque identifiers for a given invoice. That they are currently implemented by encoding a scriptPubKey is irrelevant.\r\n\r\nThis makes no sense to me: per the wiki \"A Bitcoin address [...] is an identifier [...] that represents a possible destination for a bitcoin payment\", but if you want to send a bitcoin payment somewhere you have to be able to deduce the scriptPubKey from the address, or you can't make a transaction. I don't think it makes sense to generalise \"bitcoin addresses\" to things that you can't generate a scriptPubKey from (eg, bech32 encoded lightning invoices, or some new address format you don't yet understand).\r\n\r\nFinding UTXOs by scriptPubKey seems like it makes sense, and per the above finding the scriptPubKeys from an address should also always be straightforward. So ConceptACK fwiw, unless I'm missing something major here...",
      "created_at" : "2018-06-19T05:29:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-398278708",
      "id" : 398278708,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5ODI3ODcwOA==",
      "updated_at" : "2018-06-19T05:29:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/398278708",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197649532"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197649532"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, could specify symbols instead.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-24T19:00:25Z",
      "diff_hunk" : "@@ -0,0 +1,76 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197649532",
      "id" : 197649532,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzY0OTUzMg==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 7,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : 7,
      "pull_request_review_id" : 131433092,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197649532",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197650303"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197650303"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `} else if (...) {`\r\n\r\nThere are a couple of more cases throughout. ",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-24T19:29:19Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197650303",
      "id" : 197650303,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzY1MDMwMw==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 209,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 131433092,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197650303",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197650602"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197650602"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should use `pushKV` instead, `push_back(Pair(...))` occurrences were replaced recently.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-24T19:39:33Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!xpub_uni.isNull() && !xpub_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }\n+                    else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+            else if (xpub_uni.isObject()) {\n+                // type: extended public key\n+                // derive <n> keys after lookup window (range)\n+                // derive scripts of all keys according to the script_type parameter\n+                UniValue script_types_uni = find_value(xpub_uni, \"script_types\");\n+                UniValue xpubdata_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue range_uni = find_value(xpub_uni, \"range\");\n+\n+                // check the script types and use default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                //set default child key derivation range\n+                unsigned int ckd_range_start = 0;\n+                unsigned int ckd_range_end = 1000;\n+                if (!range_uni.isNull() && (!range_uni.isArray() || range_uni.get_array().size() != 2)) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"range must be an array with two values\");\n+                }\n+                else if (!range_uni.isNull()) {\n+                    // use user defined derive range\n+                    ckd_range_start = (unsigned int)range_uni.get_array().getValues()[0].get_int();\n+                    ckd_range_end = (unsigned int)range_uni.get_array().getValues()[1].get_int();\n+                    if (ckd_range_start > ckd_range_end) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range\");\n+                    }\n+                }\n+\n+                // Derive internal and external chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubdata_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid xpub\");\n+                }\n+                CExtPubKey c0; //external chain\n+                CExtPubKey c1; //internal chain\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = ckd_range_start; i <= ckd_range_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k_external, k_internal;\n+                    c0.Derive(k_external, i);\n+                    c1.Derive(k_internal, i);\n+\n+                    for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                        OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                        if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                        // get internal and external scripts and add it to the containers\n+                        CScript script = GetScriptForDestination(GetDestinationForKey(k_external.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+\n+                        script = GetScriptForDestination(GetDestinationForKey(k_internal.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+                    }\n+                }\n+            }\n+            else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array, temp keystore)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);\n+\n+        // report back\n+        result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+        result.push_back(Pair(\"searched_items\", count));\n+\n+        int nIn = 0;\n+        for (const auto& it : coins) {\n+            const COutPoint& outpoint = it.first;\n+            const Coin& coin = it.second;\n+            const CTxOut& txo = coin.out;\n+            tx.vin.emplace_back(outpoint.hash, outpoint.n);\n+            tx.vin.back().nSequence = MAX_BIP125_RBF_SEQUENCE; //enforce BIP125\n+\n+            // Fill in dummy signatures for fee calculation, ignore signature verification.\n+            const CScript& scriptPubKey = txo.scriptPubKey;\n+            SignatureData sigdata;\n+            ProduceSignature(temp_keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata);\n+            UpdateInput(tx.vin.at(nIn), sigdata);\n+\n+            input_txos.push_back(txo);\n+            total_in += txo.nValue;\n+\n+            UniValue unspent(UniValue::VOBJ);\n+            unspent.push_back(Pair(\"txid\", outpoint.hash.GetHex()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197650602",
      "id" : 197650602,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzY1MDYwMg==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 394,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 131433092,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197650602",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197650676"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197650676"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could drop `nIn` and use `tx.vin.back()` instead (like above).",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-06-24T19:41:52Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!xpub_uni.isNull() && !xpub_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }\n+                    else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+            else if (xpub_uni.isObject()) {\n+                // type: extended public key\n+                // derive <n> keys after lookup window (range)\n+                // derive scripts of all keys according to the script_type parameter\n+                UniValue script_types_uni = find_value(xpub_uni, \"script_types\");\n+                UniValue xpubdata_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue range_uni = find_value(xpub_uni, \"range\");\n+\n+                // check the script types and use default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                //set default child key derivation range\n+                unsigned int ckd_range_start = 0;\n+                unsigned int ckd_range_end = 1000;\n+                if (!range_uni.isNull() && (!range_uni.isArray() || range_uni.get_array().size() != 2)) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"range must be an array with two values\");\n+                }\n+                else if (!range_uni.isNull()) {\n+                    // use user defined derive range\n+                    ckd_range_start = (unsigned int)range_uni.get_array().getValues()[0].get_int();\n+                    ckd_range_end = (unsigned int)range_uni.get_array().getValues()[1].get_int();\n+                    if (ckd_range_start > ckd_range_end) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range\");\n+                    }\n+                }\n+\n+                // Derive internal and external chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubdata_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid xpub\");\n+                }\n+                CExtPubKey c0; //external chain\n+                CExtPubKey c1; //internal chain\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = ckd_range_start; i <= ckd_range_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k_external, k_internal;\n+                    c0.Derive(k_external, i);\n+                    c1.Derive(k_internal, i);\n+\n+                    for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                        OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                        if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                        // get internal and external scripts and add it to the containers\n+                        CScript script = GetScriptForDestination(GetDestinationForKey(k_external.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+\n+                        script = GetScriptForDestination(GetDestinationForKey(k_internal.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+                    }\n+                }\n+            }\n+            else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array, temp keystore)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);\n+\n+        // report back\n+        result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+        result.push_back(Pair(\"searched_items\", count));\n+\n+        int nIn = 0;\n+        for (const auto& it : coins) {\n+            const COutPoint& outpoint = it.first;\n+            const Coin& coin = it.second;\n+            const CTxOut& txo = coin.out;\n+            tx.vin.emplace_back(outpoint.hash, outpoint.n);\n+            tx.vin.back().nSequence = MAX_BIP125_RBF_SEQUENCE; //enforce BIP125\n+\n+            // Fill in dummy signatures for fee calculation, ignore signature verification.\n+            const CScript& scriptPubKey = txo.scriptPubKey;\n+            SignatureData sigdata;\n+            ProduceSignature(temp_keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata);\n+            UpdateInput(tx.vin.at(nIn), sigdata);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r197650676",
      "id" : 197650676,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzY1MDY3Ng==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 388,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 131433092,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/197650676",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199562326"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199562326"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `++count`",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-02T17:04:05Z",
      "diff_hunk" : "@@ -19,6 +23,39 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor.Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor.GetKey(key) || !cursor.GetValue(coin)) return false;\n+        if (count++ % 8192 == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199562326",
      "id" : 199562326,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTU2MjMyNg==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 22,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 133705906,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199562326",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199562977"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199562977"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`include <assert.h>`\r\nnit: whitespace could benefit from clang-format",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-02T17:06:56Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199562977",
      "id" : 199562977,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTU2Mjk3Nw==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 42,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 71,
      "pull_request_review_id" : 133706721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199562977",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199563287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199563287"
         }
      },
      "author_association" : "MEMBER",
      "body" : "~~nit: this is basically an ideal case for a `case` statement. :P~~",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-02T17:08:21Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199563287",
      "id" : 199563287,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTU2MzI4Nw==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 76,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 105,
      "pull_request_review_id" : 133707136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199563287",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199564547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199564547"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You could consider using `RPCTypeCheckObj` for some of this here and elsewhere. E.g. https://github.com/bitcoin/bitcoin/blob/686e97a0c7358291d628213447cf33e99cde7ce8/src/rpc/rawtransaction.cpp#L786-L791",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-02T17:13:25Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!xpub_uni.isNull() && !xpub_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain a single string as value\");\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199564547",
      "id" : 199564547,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTU2NDU0Nw==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 221,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 133708684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199564547",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199584524"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199584524"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You can't switch on strings in C/C++",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-02T18:32:04Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199584524",
      "id" : 199584524,
      "in_reply_to_id" : 199563287,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTU4NDUyNA==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 76,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 105,
      "pull_request_review_id" : 133732877,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199584524",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "As discussed in the meeting (http://www.erisian.com.au/meetbot/bitcoin-core-dev/2018/bitcoin-core-dev.2018-06-28-19.00.log.html), my suggestion is to (for now) drop the xpub support from this PR. That way we have some more time for a generic notation for chains of scripts to develop (something I'm currently working on) and be compatible with other places such a notation may be adopted.",
      "created_at" : "2018-07-02T18:40:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-401896375",
      "id" : 401896375,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTg5NjM3NQ==",
      "updated_at" : "2018-07-02T18:40:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401896375",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199596214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199596214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, thanks.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-02T19:20:14Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r199596214",
      "id" : 199596214,
      "in_reply_to_id" : 199563287,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTU5NjIxNA==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 76,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 105,
      "pull_request_review_id" : 133746952,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199596214",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Agree with @sipa - that way, we can move this forward without full agreement on xpub representation.",
      "created_at" : "2018-07-04T09:20:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-402419407",
      "id" : 402419407,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjQxOTQwNw==",
      "updated_at" : "2018-07-04T09:20:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402419407",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Removed the xpub support. Thanks for reviewing again.",
      "created_at" : "2018-07-04T10:11:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-402433457",
      "id" : 402433457,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjQzMzQ1Nw==",
      "updated_at" : "2018-07-04T10:11:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402433457",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-utACK 3bf8dbe48a1f45b7aa0584bfb0cf19a7ddf492c9",
      "created_at" : "2018-07-04T12:34:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-402465993",
      "id" : 402465993,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjQ2NTk5Mw==",
      "updated_at" : "2018-07-04T12:34:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402465993",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200112895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200112895"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `} else {`\r\n(some other instances too)",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T12:36:09Z",
      "diff_hunk" : "@@ -1916,6 +1923,356 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200112895",
      "id" : 200112895,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDExMjg5NQ==",
      "original_commit_id" : "3bf8dbe48a1f45b7aa0584bfb0cf19a7ddf492c9",
      "original_position" : 260,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 134363187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200112895",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200129500"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200129500"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:38:29Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200129500",
      "id" : 200129500,
      "in_reply_to_id" : 195257011,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEyOTUwMA==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 15,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 134383918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200129500",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200129540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200129540"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:38:37Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200129540",
      "id" : 200129540,
      "in_reply_to_id" : 195255759,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEyOTU0MA==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 16,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 134383918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200129540",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200129614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200129614"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:38:54Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    while (cursor.Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (cursor.GetKey(key) && cursor.GetValue(coin)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200129614",
      "id" : 200129614,
      "in_reply_to_id" : 195255983,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEyOTYxNA==",
      "original_commit_id" : "219f7b1d22d1ebc6fd5d5efa8bbc9d4a02170f4a",
      "original_position" : 20,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 134383918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200129614",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200133746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200133746"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:52:43Z",
      "diff_hunk" : "@@ -1926,6 +1932,428 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> (<options>)\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200133746",
      "id" : 200133746,
      "in_reply_to_id" : 192261221,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEzMzc0Ng==",
      "original_commit_id" : "2776a951a4cec9d8e10b29ca141cb3b025dc3526",
      "original_position" : 145,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 134383918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200133746",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200133905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200133905"
         }
      },
      "author_association" : "MEMBER",
      "body" : "More readable like this IMO",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:53:11Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!xpub_uni.isNull() && !xpub_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }\n+                    else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+            else if (xpub_uni.isObject()) {\n+                // type: extended public key\n+                // derive <n> keys after lookup window (range)\n+                // derive scripts of all keys according to the script_type parameter\n+                UniValue script_types_uni = find_value(xpub_uni, \"script_types\");\n+                UniValue xpubdata_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue range_uni = find_value(xpub_uni, \"range\");\n+\n+                // check the script types and use default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                //set default child key derivation range\n+                unsigned int ckd_range_start = 0;\n+                unsigned int ckd_range_end = 1000;\n+                if (!range_uni.isNull() && (!range_uni.isArray() || range_uni.get_array().size() != 2)) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"range must be an array with two values\");\n+                }\n+                else if (!range_uni.isNull()) {\n+                    // use user defined derive range\n+                    ckd_range_start = (unsigned int)range_uni.get_array().getValues()[0].get_int();\n+                    ckd_range_end = (unsigned int)range_uni.get_array().getValues()[1].get_int();\n+                    if (ckd_range_start > ckd_range_end) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range\");\n+                    }\n+                }\n+\n+                // Derive internal and external chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubdata_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid xpub\");\n+                }\n+                CExtPubKey c0; //external chain\n+                CExtPubKey c1; //internal chain\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = ckd_range_start; i <= ckd_range_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k_external, k_internal;\n+                    c0.Derive(k_external, i);\n+                    c1.Derive(k_internal, i);\n+\n+                    for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                        OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                        if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                        // get internal and external scripts and add it to the containers\n+                        CScript script = GetScriptForDestination(GetDestinationForKey(k_external.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+\n+                        script = GetScriptForDestination(GetDestinationForKey(k_internal.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+                    }\n+                }\n+            }\n+            else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array, temp keystore)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);\n+\n+        // report back\n+        result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+        result.push_back(Pair(\"searched_items\", count));\n+\n+        int nIn = 0;\n+        for (const auto& it : coins) {\n+            const COutPoint& outpoint = it.first;\n+            const Coin& coin = it.second;\n+            const CTxOut& txo = coin.out;\n+            tx.vin.emplace_back(outpoint.hash, outpoint.n);\n+            tx.vin.back().nSequence = MAX_BIP125_RBF_SEQUENCE; //enforce BIP125\n+\n+            // Fill in dummy signatures for fee calculation, ignore signature verification.\n+            const CScript& scriptPubKey = txo.scriptPubKey;\n+            SignatureData sigdata;\n+            ProduceSignature(temp_keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata);\n+            UpdateInput(tx.vin.at(nIn), sigdata);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200133905",
      "id" : 200133905,
      "in_reply_to_id" : 197650676,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEzMzkwNQ==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 388,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 134383918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200133905",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200134294"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200134294"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:54:14Z",
      "diff_hunk" : "@@ -1916,6 +1923,356 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200134294",
      "id" : 200134294,
      "in_reply_to_id" : 200112895,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEzNDI5NA==",
      "original_commit_id" : "3bf8dbe48a1f45b7aa0584bfb0cf19a7ddf492c9",
      "original_position" : 260,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 134383918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200134294",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200134648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200134648"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:55:25Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200134648",
      "id" : 200134648,
      "in_reply_to_id" : 199562977,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEzNDY0OA==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 42,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 71,
      "pull_request_review_id" : 134390057,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200134648",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200134661"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200134661"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-04T13:55:28Z",
      "diff_hunk" : "@@ -19,6 +23,39 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor.Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor.GetKey(key) || !cursor.GetValue(coin)) return false;\n+        if (count++ % 8192 == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200134661",
      "id" : 200134661,
      "in_reply_to_id" : 199562326,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEzNDY2MQ==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 22,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 134390071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200134661",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "While testing I hit an edge case:\r\n```\r\n./src/bitcoin-cli -regtest  scantxoutset start '[]' & ;  ./src/bitcoin-cli -regtest  scantxoutset abort\r\n[1] 90388\r\ntrue\r\n{\r\n  \"success\": \"yes\",\r\n  \"searched_items\": 6,\r\n  \"unspents\": [\r\n  ],\r\n  \"total_amount\": 0.00000000\r\n}\r\n[1]  + 90388 done       ./src/bitcoin-cli -regtest scantxoutset start '[]'\r\n```\r\nSo `abort` returned `true` but the scan finished successfully.\r\n\r\nNot sure but if the use case is to call `abort` after `status` Ã¢ÂÂ because it's taking too long Ã¢ÂÂ so maybe `abort` could just return null:\r\n```cpp\r\nif (request.params[0].get_str() == \"abort\") {\r\n    g_should_abort_scan = true;\r\n    return NullUniValue;\r\n}\r\n```",
      "created_at" : "2018-07-04T20:46:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-402556978",
      "id" : 402556978,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjU1Njk3OA==",
      "updated_at" : "2018-07-04T20:46:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402556978",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm not sure that's a harmful edge case. If you abort after the last opportunity to abort, I'd say it makes sense that it will finish successfully.",
      "created_at" : "2018-07-05T11:44:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-402695749",
      "id" : 402695749,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjY5NTc0OQ==",
      "updated_at" : "2018-07-05T11:44:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402695749",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "That's why I ask if it makes sense to return a bool in abort.",
      "created_at" : "2018-07-05T11:51:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-402697305",
      "id" : 402697305,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjY5NzMwNQ==",
      "updated_at" : "2018-07-05T11:51:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402697305",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200543393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200543393"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Add CCoinsView::FindScriptPubKey to search the UTXO set\".\r\n\r\nThere is no need for this function to burden the CCoinsView interface I think, as it only uses publicly available data from that class. The implementation can just move to where scantxoutset is defined.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-06T03:48:58Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200543393",
      "id" : 200543393,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDU0MzM5Mw==",
      "original_commit_id" : "4c0bc9f11db1664b3a79fe6d70c1c7b4c609ee45",
      "original_position" : 15,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 134880350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200543393",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200543631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200543631"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Blockchain/RPC: Add scantxoutset method to scan UTXO set\".\r\n\r\nThe implementation of \"CCoinsView::FindScriptPubKey\" is being changed significantly in this commit. Can you move the changes to the previous commit that introduces the function?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-06T03:51:11Z",
      "diff_hunk" : "@@ -23,37 +23,35 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n-bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n     scan_progress = 0;\n+    count = 0;\n     while (cursor.Valid()) {\n         COutPoint key;\n         Coin coin;\n-        if (cursor.GetKey(key) && cursor.GetValue(coin)) {\n-            if (++count % 8192 == 0) {\n-                boost::this_thread::interruption_point();\n-                if (should_abort) {\n-                    // allow to abort the scan via the abort reference\n-                    return false;\n-                }\n-            }\n-            if (count % 256 == 0) {\n-                // update progress reference every 256 item\n-                uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n-                scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n-            }\n-            if (needles.count(coin.out.scriptPubKey)) {\n-                out_results.emplace(key, coin);\n+        if (!cursor.GetKey(key) || !cursor.GetValue(coin)) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200543631",
      "id" : 200543631,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDU0MzYzMQ==",
      "original_commit_id" : "e5520b0249d594142d03823498ad94462a171b6e",
      "original_position" : 26,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 134880350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200543631",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200543957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200543957"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I would leave this out as well, as it'll be handled equally by the descriptor based approach. It's a lot of complexity to maintain which will be handled more generically later.\r\n\r\nAlso, I don't think it's very useful and add - if you know the pubkey and derivation type you generally also know the address already.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-06T03:54:25Z",
      "diff_hunk" : "@@ -1916,6 +1921,242 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200543957",
      "id" : 200543957,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDU0Mzk1Nw==",
      "original_commit_id" : "e5520b0249d594142d03823498ad94462a171b6e",
      "original_position" : 113,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 134880350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200543957",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200544556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200544556"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"scantxoutset: Add optional raw sweep transaction\".\r\n\r\nIs this the best place to implement this? As a separate wallet RPC it could work much more correctly (as it would know the actual scripts involved and be able to give a vsize estimate that's more than a dumb guess), and be more useful too by being combinable with whatever way to find inputs.\r\n\r\nI feel this makes the RPC look like a kitchen sink.\r\n",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-06T04:01:23Z",
      "diff_hunk" : "@@ -2012,6 +2032,12 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"          }\\n\"\n             \"        },\\n\"\n             \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200544556",
      "id" : 200544556,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDU0NDU1Ng==",
      "original_commit_id" : "625ac1e034dd66acc520cfb7203b016c15af7d45",
      "original_position" : 46,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 134880350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200544556",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200548588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200548588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Another option is to have a local for the current input, given it's referenced on 2193 above.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-06T04:49:07Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"        { \\\"xpub\\\"  :                        (object, optional) Use an extended public key child key range (m/0/k & m/1/k) to derive scripts from\\n\"\n+            \"          { \\n\"\n+            \"            \\\"xpub\\\" : \\\"<xpub\\\">,             (string, required) Base58check encoded extended public key (xpub)\\n\"\n+            \"            \\\"range\\\" : [ <s>, <e> ],        (array, optional) Range of keys that will be deriven from the given xpubs (default is 0 to 1000)\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of derivation type (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",            (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,                    (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,                (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+            \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",         (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",      (numeric) Estimated virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",        (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"}\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CCoinsViewScanDummySignKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+            UniValue xpub_uni    = find_value(scanobject, \"xpub\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull() + !xpub_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            }\n+            else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            }\n+            else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            }\n+            else if (!xpub_uni.isNull() && !xpub_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain an object as value\");\n+            }\n+            else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"xpub\\\" must contain a single string as value\");\n+            }\n+            else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+            else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    }\n+                    else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+            else if (xpub_uni.isObject()) {\n+                // type: extended public key\n+                // derive <n> keys after lookup window (range)\n+                // derive scripts of all keys according to the script_type parameter\n+                UniValue script_types_uni = find_value(xpub_uni, \"script_types\");\n+                UniValue xpubdata_uni = find_value(xpub_uni, \"xpub\");\n+                UniValue range_uni = find_value(xpub_uni, \"range\");\n+\n+                // check the script types and use default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                //set default child key derivation range\n+                unsigned int ckd_range_start = 0;\n+                unsigned int ckd_range_end = 1000;\n+                if (!range_uni.isNull() && (!range_uni.isArray() || range_uni.get_array().size() != 2)) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"range must be an array with two values\");\n+                }\n+                else if (!range_uni.isNull()) {\n+                    // use user defined derive range\n+                    ckd_range_start = (unsigned int)range_uni.get_array().getValues()[0].get_int();\n+                    ckd_range_end = (unsigned int)range_uni.get_array().getValues()[1].get_int();\n+                    if (ckd_range_start > ckd_range_end) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range\");\n+                    }\n+                }\n+\n+                // Derive internal and external chain keys\n+                CExtPubKey xpub = DecodeExtPubKey(xpubdata_uni.get_str());\n+                if (!xpub.pubkey.IsValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid xpub\");\n+                }\n+                CExtPubKey c0; //external chain\n+                CExtPubKey c1; //internal chain\n+                xpub.Derive(c0, 0);\n+                xpub.Derive(c1, 1);\n+\n+                for (unsigned int i = ckd_range_start; i <= ckd_range_end; i++) {\n+                    // derive both (internal and external chain) child keys\n+                    CExtPubKey k_external, k_internal;\n+                    c0.Derive(k_external, i);\n+                    c1.Derive(k_internal, i);\n+\n+                    for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                        OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                        if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                        // get internal and external scripts and add it to the containers\n+                        CScript script = GetScriptForDestination(GetDestinationForKey(k_external.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+\n+                        script = GetScriptForDestination(GetDestinationForKey(k_internal.pubkey, script_type));\n+                        assert(!script.empty());\n+                        needles.insert(script);\n+                        temp_keystore.AddWatchOnly(script);\n+                    }\n+                }\n+            }\n+            else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array, temp keystore)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        CMutableTransaction tx;\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+\n+        // flush utxo state and start the scan\n+        FlushStateToDisk();\n+        bool res = pcoinsdbview->FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, needles, coins);\n+\n+        // report back\n+        result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));\n+        result.push_back(Pair(\"searched_items\", count));\n+\n+        int nIn = 0;\n+        for (const auto& it : coins) {\n+            const COutPoint& outpoint = it.first;\n+            const Coin& coin = it.second;\n+            const CTxOut& txo = coin.out;\n+            tx.vin.emplace_back(outpoint.hash, outpoint.n);\n+            tx.vin.back().nSequence = MAX_BIP125_RBF_SEQUENCE; //enforce BIP125\n+\n+            // Fill in dummy signatures for fee calculation, ignore signature verification.\n+            const CScript& scriptPubKey = txo.scriptPubKey;\n+            SignatureData sigdata;\n+            ProduceSignature(temp_keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigdata);\n+            UpdateInput(tx.vin.at(nIn), sigdata);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200548588",
      "id" : 200548588,
      "in_reply_to_id" : 197650676,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDU0ODU4OA==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 388,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 134886262,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200548588",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200850998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200850998"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree. Will remove it and PR it later as a separate method",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-08T19:31:34Z",
      "diff_hunk" : "@@ -2012,6 +2032,12 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"          }\\n\"\n             \"        },\\n\"\n             \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r200850998",
      "id" : 200850998,
      "in_reply_to_id" : 200544556,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1MDk5OA==",
      "original_commit_id" : "625ac1e034dd66acc520cfb7203b016c15af7d45",
      "original_position" : 46,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 135242996,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200850998",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r201534239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201534239"
         }
      },
      "author_association" : "MEMBER",
      "body" : "From https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-393057791\r\n\r\n> > tx = scantxoutset(\"start\", { \"sweep_to\": address })[\"sweep_tx\"]\r\n> > fundrawtransaction(tx, { \"subtractFeeFromOutputs\": [0] })\r\n>\r\n>  @promag: would that also work without the wallet? My idea was to make `scantxoutset` work without a wallet.\r\n\r\n@sipa not sure if you are suggesting something similar to:\r\n```\r\nunspents = scantxoutset \"start\" ...\r\ntx = createrawtransaction unspents ...\r\ntx = fundrawtransaction ...\r\n```\r\nAnd how could it work without the wallet?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-11T00:20:29Z",
      "diff_hunk" : "@@ -2012,6 +2032,12 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"          }\\n\"\n             \"        },\\n\"\n             \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r201534239",
      "id" : 201534239,
      "in_reply_to_id" : 200544556,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTUzNDIzOQ==",
      "original_commit_id" : "625ac1e034dd66acc520cfb7203b016c15af7d45",
      "original_position" : 46,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136055090,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201534239",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r201632807"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201632807"
         }
      },
      "author_association" : "MEMBER",
      "body" : "AgreeÃ¢ÂÂif we can avoid introducing new methods to the CCoinsView interface, that's preferable, it is good to have it as a minimal interface class.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-11T10:00:41Z",
      "diff_hunk" : "@@ -19,6 +23,41 @@ bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n     return GetCoin(outpoint, coin);\n }\n \n+bool CCoinsView::FindScriptPubKey(std::atomic<int>& scan_progress, std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor& cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r201632807",
      "id" : 201632807,
      "in_reply_to_id" : 200543393,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTYzMjgwNw==",
      "original_commit_id" : "4c0bc9f11db1664b3a79fe6d70c1c7b4c609ee45",
      "original_position" : 15,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 136170259,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201632807",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r201751123"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201751123"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@promag, I just mean scantxoutset + createrawtransaction. Then a separate wallet RPC like \"walletestimatesignedrawtransactionsize\" (shorter names welcome...) can be used to guess the size of the tx ahead of time. \"fundrawtransaction\" already does this estimation internally.\n\n> Would that also work without the wallet?\n\nNo, that's the point. You cannot implement that without knowledge of the scripts involved.\n\nIt may be better to integrate this into PSBT, as it means there doesn't need to a single wallet that knows about all scripts in a transaction.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-11T16:05:43Z",
      "diff_hunk" : "@@ -2012,6 +2032,12 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n             \"          }\\n\"\n             \"        },\\n\"\n             \"      ]\\n\"\n+            \"3. \\\"options\\\"                               (object, optional)\\n\"\n+            \"      \\\"rawsweep\\\": {                        (object, optional) Optionally creates a raw sweep transaction\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r201751123",
      "id" : 201751123,
      "in_reply_to_id" : 200544556,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTc1MTEyMw==",
      "original_commit_id" : "625ac1e034dd66acc520cfb7203b016c15af7d45",
      "original_position" : 46,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136313391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201751123",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "* Moved the `FindScriptPubKey()` method to `rpc/blockchain.cpp` (changes are no longer spread in multiple commits).\r\n* Removed the sweep transaction creation code (see https://github.com/bitcoin/bitcoin/pull/12196#pullrequestreview-134880350)\r\n\r\nI kept the pubkey search option since I think this is very helpful. I agree that we should move to the descriptors specified by @sipa. IMO we define that we wanted to have xpub/pub support (according those descriptors) in the same release to avoid API breaks and @laanwj agreed to let this in after the code freeze in form of a bugfix.\r\nAdditionally, there is always the option to mark this RPC command \"experimental\" (API changes possible).",
      "created_at" : "2018-07-12T10:17:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-404464275",
      "id" : 404464275,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNDQ2NDI3NQ==",
      "updated_at" : "2018-07-12T10:17:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404464275",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202047203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202047203"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Add FindScriptPubKey() to search the UTXO set\"\r\n\r\nnit, unrelated change.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T14:05:16Z",
      "diff_hunk" : "@@ -7,6 +7,7 @@\n #include <consensus/consensus.h>\n #include <random.h>\n \n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202047203",
      "id" : 202047203,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA0NzIwMw==",
      "original_commit_id" : "c0258ed68770bc0ad6e6a7e4c8e5e74243fe8b76",
      "original_position" : 4,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 136665809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202047203",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202047655"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202047655"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Add FindScriptPubKey() to search the UTXO set\"\r\n\r\nnit, `CCoinsViewCursor* cursor`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T14:06:31Z",
      "diff_hunk" : "@@ -1916,6 +1916,35 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor *cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202047655",
      "id" : 202047655,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA0NzY1NQ==",
      "original_commit_id" : "c0258ed68770bc0ad6e6a7e4c8e5e74243fe8b76",
      "original_position" : 5,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136665809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202047655",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202054286"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202054286"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This should probably be true|false, not a string.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T14:24:56Z",
      "diff_hunk" : "@@ -1916,6 +1921,292 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor *cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    } else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            } else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array, temp keystore)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        FlushStateToDisk();\n+\n+        std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());\n+        assert(pcursor);\n+        bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins);\n+\n+        result.push_back(Pair(\"success\", res ? \"yes\" : \"no\"));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202054286",
      "id" : 202054286,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA1NDI4Ng==",
      "original_commit_id" : "c3c4b144d66f5f6a50cfcdd2de53891fa1dd025d",
      "original_position" : 289,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136674737,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202054286",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202069464"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202069464"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Blockchain/RPC: Add scantxoutset method to scan UTXO set\"\r\n\r\nMissing fix :trollface: ",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T15:04:47Z",
      "diff_hunk" : "@@ -1916,6 +1923,435 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202069464",
      "id" : 202069464,
      "in_reply_to_id" : 199562977,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA2OTQ2NA==",
      "original_commit_id" : "4782d23938a8a5297319f024aed3fc6e2c1651ac",
      "original_position" : 42,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 71,
      "pull_request_review_id" : 136665809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202069464",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202070688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202070688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Blockchain/RPC: Add scantxoutset method to scan UTXO set\"\r\n\r\nThis could be in the block below:\r\n```cpp\r\nCTxDestination witdest = WitnessV0KeyHash(key.GetID());\r\nif (type == OutputScriptType::P2SH_P2WPKH) {\r\n    CScript witprog = GetScriptForDestination(witdest);\r\n    return CScriptID(witprog);\r\n} else {\r\n    ...\r\n```",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T15:08:00Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202070688",
      "id" : 202070688,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA3MDY4OA==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 88,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136665809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202070688",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202071424"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202071424"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Blockchain/RPC: Add scantxoutset method to scan UTXO set\"\r\n\r\n> Nah. You can also call scantxoutset status\r\n\r\nRight.\r\n\r\nHowever should be `request.params.size() > 3` (instead of 2)?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T15:09:46Z",
      "diff_hunk" : "@@ -1597,6 +1599,236 @@ UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abourt_scan;\n+/** RAII object */\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (m_could_reserve) {\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202071424",
      "id" : 202071424,
      "in_reply_to_id" : 161719731,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA3MTQyNA==",
      "original_commit_id" : "4378347dea8cafc967c72e7e26816be208c8a33d",
      "original_position" : 52,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136665809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202071424",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202072038"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202072038"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Blockchain/RPC: Add scantxoutset method to scan UTXO set\"\r\n\r\nnit, add `( )` to `<scanobjects>` because `status` action has no more arguments.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T15:11:28Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202072038",
      "id" : 202072038,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA3MjAzOA==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 103,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136665809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202072038",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202072868"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202072868"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Commit \"Blockchain/RPC: Add scantxoutset method to scan UTXO set\"\r\n\r\nThe response is an object, not an array.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T15:13:42Z",
      "diff_hunk" : "@@ -1637,6 +1643,337 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+/** A dummy keystore for the txout-set scan in order to calculate the right fees for the sweep transaction */\n+static CPubKey pub_key(std::vector<unsigned char>(33)); // always use a compress pubkey\n+class CCoinsViewScanDummySignKeyStore : public CBasicKeyStore\n+{\n+public:\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const {\n+        // return dummy pubkey\n+        vchPubKeyOut = pub_key;\n+        return true;\n+    }\n+    bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const {\n+        // return a dummy TX_WITNESS_V0_KEYHASH script\n+        redeemScriptOut = CScript() << OP_0 << std::vector<unsigned char>(20);\n+        return true;\n+    }\n+};\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> {\\\"pubkeys\\\": [\\\"pubkey\\\",...], \\\"xpubs\\\":[{\\\"xpub\\\": \\\"<xpub>\\\"}]}\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                          \\\"start\\\" for starting a scan\\n\"\n+            \"                                          \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                          \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"options\\\"                      (object, optional)\\n\"\n+            \"      \\\"pubkeys\\\":[\\\"pubkey\\\",...]    (array of strings, optional) An array of HEX encoded public keys\\n\"\n+            \"      \\\"addresses\\\":[\\\"address\\\",...] (array of strings, optional) An array of bitcoin addresses\\n\"\n+            \"      \\\"xpubs\\\":                    (array of xpub objects that will be used to derive child keys with the given lookup window after m/0/k and m/1/k scheme)\\n\"\n+            \"           [\\n\"\n+            \"               {\\n\"\n+            \"                \\\"xpub\\\":\\\"<xpub>\\\",  (base58check encoded extended public key (xpub)\\n\"\n+            \"                \\\"lookupwindow\\\": [<startindex>, <stopindex>] (An array with two integers that does define the range of keys that will be deriven for the given xpubs, default is 0 to 1000)\\n\"\n+            \"                }\\n\"\n+            \"           ]\\n\"\n+            \"      \\\"rawsweep\\\": {\\n             (object, optional) Optionally creates a raw sweep transaction\\n\"\n+            \"          \\\"address\\\": \\\"address\\\",   (string, optional) Address where the funds should be sent to\\n\"\n+            \"          \\\"feerate\\\": n,           (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+            \"          \\\"conf_target\\\": n,       (numeric, optional) Confirmation target (in blocks), has no effect if feerate is provided\\n\"\n+             \"       }\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" received by the address\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \" \\\"rawsweep_tx\\\" : \\\"value\\\",       (string) The hex-encoded raw transaction of the optional sweep transaction\\n\"\n+            \" \\\"rawsweep_vsize\\\" : \\\"value\\\",     (numeric) virtual transaction size of the sweep transaction including signatures\\n\"\n+            \" \\\"rawsweep_fee\\\" : \\\"value\\\",       (numeric) Estimated fee for the sweep transaction in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202072868",
      "id" : 202072868,
      "in_reply_to_id" : 189996836,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjA3Mjg2OA==",
      "original_commit_id" : "94c727074b7aaac71f1560cdfc5b7d2a427d373f",
      "original_position" : 117,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136665809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202072868",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202121734"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202121734"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You should hold cs_main while calling FlushStateToDisk and creating the cursor, or there is no guarantee that the on-disk state is consistent.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T17:45:21Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                    CScript script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        FlushStateToDisk();\n+\n+        std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202121734",
      "id" : 202121734,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjEyMTczNA==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 239,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136758289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202121734",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202121869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202121869"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This looks unused.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T17:45:41Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202121869",
      "id" : 202121869,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjEyMTg2OQ==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 159,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136758289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202121869",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed issues:\r\n* holds now `cs_main` during coins view cursor creation and `FlushToDisk()`\r\n* Removed `temp_keystore` (relict from raw-sweep-tx).\r\n* Fixed \"yes\"/\"no\" instead of true/false JSON returns\r\n* Fixed nits",
      "created_at" : "2018-07-12T19:45:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-404628911",
      "id" : 404628911,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNDYyODkxMQ==",
      "updated_at" : "2018-07-12T19:45:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404628911",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202157824"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202157824"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks like some annotations or lock assertions could be added?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T19:50:02Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                    CScript script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        FlushStateToDisk();\n+\n+        std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202157824",
      "id" : 202157824,
      "in_reply_to_id" : 202121734,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE1NzgyNA==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 239,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136802571,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202157824",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202161517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202161517"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree with @promag, but unrelated to this PR.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T20:04:23Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                    CScript script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        FlushStateToDisk();\n+\n+        std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202161517",
      "id" : 202161517,
      "in_reply_to_id" : 202121734,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE2MTUxNw==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 239,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136807397,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202161517",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202164658"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202164658"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, I wasn't implying that. I'll follow up.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T20:15:51Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                    CScript script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        FlushStateToDisk();\n+\n+        std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202164658",
      "id" : 202164658,
      "in_reply_to_id" : 202121734,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE2NDY1OA==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 239,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136811307,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202164658",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202165603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202165603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ops, actually @sipa point is about locking during `FlushStateToDisk()` and `Cursor()`, so the lock must be added here, preferably in this PR IMO.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T20:19:05Z",
      "diff_hunk" : "@@ -1945,6 +1950,246 @@ bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>&\n     return true;\n }\n \n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        CScript witprog = GetScriptForDestination(witdest);\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> <scanobjects> ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CBasicKeyStore temp_keystore;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers (needles array, temp keystore)\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+                temp_keystore.AddWatchOnly(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                }\n+                else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+\n+                    CScript script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                    temp_keystore.AddWatchOnly(script);\n+                }\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        FlushStateToDisk();\n+\n+        std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202165603",
      "id" : 202165603,
      "in_reply_to_id" : 202121734,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE2NTYwMw==",
      "original_commit_id" : "85eb5ea3f949e2452b723abdc735a76c840f2e0c",
      "original_position" : 239,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136812445,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202165603",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202173967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202173967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: code for this seems like it's cropping up in a few different places, might be nice to have an abstraction for it.\r\n```\r\n $ git grep -C 1 \"/ 65536\" | cat\r\n\r\nsrc/index/txindex.cpp-                (static_cast<uint32_t>(*(txid.begin() + 1)) << 0);\r\nsrc/index/txindex.cpp:            int percentage_done = (int)(high_nibble * 100.0 / 65536.0 + 0.5);\r\nsrc/index/txindex.cpp-\r\n--\r\nsrc/txdb.cpp-                uint32_t high = 0x100 * *key.second.begin() + *(key.second.begin() + 1);\r\nsrc/txdb.cpp:                int percentageDone = (int)(high * 100.0 / 65536.0 + 0.5);\r\nsrc/txdb.cpp-                uiInterface.ShowProgress(_(\"Upgrading UTXO database\"), percentageDone, true);\r\n```",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T20:47:56Z",
      "diff_hunk" : "@@ -1916,6 +1920,289 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202173967",
      "id" : 202173967,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE3Mzk2Nw==",
      "original_commit_id" : "e24565cd412e08d550ba3480af98815946461b2d",
      "original_position" : 47,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 47,
      "pull_request_review_id" : 136822687,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202173967",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202176470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202176470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If scanobjects is required (per doc below), should it be in parens here?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T20:56:52Z",
      "diff_hunk" : "@@ -1916,6 +1920,289 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> ) ( <options> )\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202176470",
      "id" : 202176470,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE3NjQ3MA==",
      "original_commit_id" : "e24565cd412e08d550ba3480af98815946461b2d",
      "original_position" : 131,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136825897,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202176470",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202176661"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202176661"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also options doesn't seem to exist.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T20:57:35Z",
      "diff_hunk" : "@@ -1916,6 +1920,289 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> ) ( <options> )\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202176661",
      "id" : 202176661,
      "in_reply_to_id" : 202176470,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE3NjY2MQ==",
      "original_commit_id" : "e24565cd412e08d550ba3480af98815946461b2d",
      "original_position" : 131,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136826152,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202176661",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202181178"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202181178"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can we release `cs_main` after initializing `pcursor`? My impression is that CCoinsViewCursor can be used for read-only ops without holding it.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-12T21:13:12Z",
      "diff_hunk" : "@@ -1916,6 +1920,289 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> ) ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    } else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                }\n+            } else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        {\n+            LOCK(cs_main);\n+            FlushStateToDisk();\n+            std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());\n+            assert(pcursor);\n+            bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202181178",
      "id" : 202181178,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjE4MTE3OA==",
      "original_commit_id" : "e24565cd412e08d550ba3480af98815946461b2d",
      "original_position" : 283,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136831744,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202181178",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nHappy to do a more in-depth review. PR description looks in need of an update.",
      "created_at" : "2018-07-12T21:15:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-404653215",
      "id" : 404653215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNDY1MzIxNQ==",
      "updated_at" : "2018-07-12T21:15:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404653215",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202286777"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202286777"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh. Right. Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-13T08:57:55Z",
      "diff_hunk" : "@@ -1916,6 +1920,289 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> ) ( <options> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    } else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                }\n+            } else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        {\n+            LOCK(cs_main);\n+            FlushStateToDisk();\n+            std::unique_ptr<CCoinsViewCursor> pcursor(pcoinsdbview->Cursor());\n+            assert(pcursor);\n+            bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202286777",
      "id" : 202286777,
      "in_reply_to_id" : 202181178,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjI4Njc3Nw==",
      "original_commit_id" : "e24565cd412e08d550ba3480af98815946461b2d",
      "original_position" : 283,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 136956885,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202286777",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202286897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202286897"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IMO this should be done outside of this PR",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-13T08:58:19Z",
      "diff_hunk" : "@@ -1916,6 +1920,289 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202286897",
      "id" : 202286897,
      "in_reply_to_id" : 202173967,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjI4Njg5Nw==",
      "original_commit_id" : "e24565cd412e08d550ba3480af98815946461b2d",
      "original_position" : 47,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 47,
      "pull_request_review_id" : 136957042,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202286897",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed points reported by @jamesob.",
      "created_at" : "2018-07-13T08:58:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-404772258",
      "id" : 404772258,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNDc3MjI1OA==",
      "updated_at" : "2018-07-13T08:58:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404772258",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202354776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202354776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`res` is already a boolean...",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-13T13:48:11Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    } else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                }\n+            } else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        std::unique_ptr<CCoinsViewCursor> pcursor;\n+        {\n+            LOCK(cs_main);\n+            FlushStateToDisk();\n+            pcursor = std::unique_ptr<CCoinsViewCursor>(pcoinsdbview->Cursor());\n+            assert(pcursor);\n+        }\n+        bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins);\n+        result.pushKV(\"success\", res ? true : false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202354776",
      "id" : 202354776,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjM1NDc3Ng==",
      "original_commit_id" : "bc357cb0f3f44fef23091ca66c5b734c795a82e7",
      "original_position" : 286,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137042075,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202354776",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202451797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202451797"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ouch! Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-13T19:32:42Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    } else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                }\n+            } else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());\n+                // TODO: check script: max length, has OP, is unspenable etc.\n+                needles.insert(script);\n+            }\n+        }\n+\n+        // Scan the unspent transaction output set for inputs\n+        UniValue unspents(UniValue::VARR);\n+        std::vector<CTxOut> input_txos;\n+        std::map<COutPoint, Coin> coins;\n+        g_should_abort_scan = false;\n+        g_scan_progress = 0;\n+        int64_t count = 0;\n+        std::unique_ptr<CCoinsViewCursor> pcursor;\n+        {\n+            LOCK(cs_main);\n+            FlushStateToDisk();\n+            pcursor = std::unique_ptr<CCoinsViewCursor>(pcoinsdbview->Cursor());\n+            assert(pcursor);\n+        }\n+        bool res = FindScriptPubKey(g_scan_progress, g_should_abort_scan, count, pcursor.get(), needles, coins);\n+        result.pushKV(\"success\", res ? true : false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202451797",
      "id" : 202451797,
      "in_reply_to_id" : 202354776,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQ1MTc5Nw==",
      "original_commit_id" : "bc357cb0f3f44fef23091ca66c5b734c795a82e7",
      "original_position" : 286,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137163433,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202451797",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202503014"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202503014"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: use `GetScriptForRawPubKey`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-14T02:10:56Z",
      "diff_hunk" : "@@ -2141,8 +2141,13 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n                 for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n                     OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n                     if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n-\n-                    CScript script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202503014",
      "id" : 202503014,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjUwMzAxNA==",
      "original_commit_id" : "bd345b7611bb46b52bc5e1643914503094003314",
      "original_position" : 18,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137225613,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202503014",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202542855"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202542855"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Would be nice to store this repeated arg to a local",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T13:15:03Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202542855",
      "id" : 202542855,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0Mjg1NQ==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 183,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202542855",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202543477"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202543477"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You could remove most of the above with:\r\n```\r\nRPCTypeCheckObj(scanobject,\r\n    {\r\n        {\"address\", UniValueType(UniValue::VSTR)},\r\n        {\"pubkey\", UniValueType(UniValue::VOBJ)},\r\n        {\"script\", UniValueType(UniValue::VSTR)},\r\n    }, true /* fAllowNull */);\r\n```",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T13:36:49Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202543477",
      "id" : 202543477,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0MzQ3Nw==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 208,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 210,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202543477",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202543480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202543480"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: explicit precedence?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T13:36:51Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202543480",
      "id" : 202543480,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0MzQ4MA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 201,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 203,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202543480",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202544306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202544306"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could you document the \"status\" and \"abort\" results above?\r\n\r\nnit: I'd somewhat prefer each of these having their own rpc",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T14:09:36Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202544306",
      "id" : 202544306,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0NDMwNg==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 182,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202544306",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545250"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545250"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could throw above and do away with `UNKNOWN`",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T14:50:19Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545250",
      "id" : 202545250,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0NTI1MA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 250,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 251,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545250",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: maybe make this a unival to avoid translation below?\r\nnit: why not static?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T14:50:39Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545259",
      "id" : 202545259,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0NTI1OQ==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 89,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545259",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can construct `CPubKey` directly from the `ParseHexV` result.\r\nhttps://github.com/bitcoin/bitcoin/blob/8803c9132a78d8182bd828a29f7051fc7688f934/src/pubkey.h#L103",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T14:53:15Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545343",
      "id" : 202545343,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0NTM0Mw==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 242,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545343",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545375"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://github.com/bitcoin/bitcoin/blob/8803c9132a78d8182bd828a29f7051fc7688f934/src/pubkey.h#L103",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T14:54:22Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    } else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                }\n+            } else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545375",
      "id" : 202545375,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0NTM3NQ==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 265,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545375",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545504"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545504"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Tests for \"abort\" and \"status\"?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T14:59:23Z",
      "diff_hunk" : "@@ -0,0 +1,48 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScantxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.nodes[0].datadir, \"regtest\", 'wallets'))\n+        self.start_node(0)\n+        self.nodes[0].generate(110)\n+\n+        self.restart_node(0, ['-nowallet'])\n+        self.log.info(\"Test if we have found the non HD unspent outputs.\")\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}])['total_amount'], 6)\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"address\": addr_P2SH_SEGWIT}, {\"address\": addr_LEGACY}, {\"address\": addr_BECH32}])['total_amount'], 6)\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"address\": addr_P2SH_SEGWIT}, {\"address\": addr_LEGACY}, {\"pubkey\": {\"pubkey\": pubk3}} ])['total_amount'], 6)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545504",
      "id" : 202545504,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0NTUwNA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 41,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : 41,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545504",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545565"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `for` would localize the `cursor` access",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T15:03:04Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202545565",
      "id" : 202545565,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU0NTU2NQ==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 33,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 33,
      "pull_request_review_id" : 137266681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202545565",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202551704"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202551704"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I guess your proposed check does not ensure that one of the (either address, pubkey or script must be present, right?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T19:29:11Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202551704",
      "id" : 202551704,
      "in_reply_to_id" : 202543477,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1MTcwNA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 208,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 210,
      "pull_request_review_id" : 137275817,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202551704",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202551738"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202551738"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it helps for the readability? Or can you elaborate what you mean exactly?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T19:30:21Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202551738",
      "id" : 202551738,
      "in_reply_to_id" : 202543480,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1MTczOA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 201,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 203,
      "pull_request_review_id" : 137275845,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202551738",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202551937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202551937"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't understand your comment... can you rephrase or elaborate in detail?",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T19:38:14Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202551937",
      "id" : 202551937,
      "in_reply_to_id" : 202545250,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1MTkzNw==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 250,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 251,
      "pull_request_review_id" : 137276035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202551937",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202552486"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202552486"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Both would probably require additional code for adding time delays or temporary creation of a large utxo set.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T19:56:27Z",
      "diff_hunk" : "@@ -0,0 +1,48 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the scantxoutset rpc call.\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+import shutil\n+import os\n+\n+class ScantxoutsetTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+    def run_test(self):\n+        self.log.info(\"Mining blocks...\")\n+        self.nodes[0].generate(110)\n+\n+        addr_P2SH_SEGWIT = self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\")\n+        pubk1 = self.nodes[0].getaddressinfo(addr_P2SH_SEGWIT)['pubkey']\n+        addr_LEGACY = self.nodes[0].getnewaddress(\"\", \"legacy\")\n+        pubk2 = self.nodes[0].getaddressinfo(addr_LEGACY)['pubkey']\n+        addr_BECH32 = self.nodes[0].getnewaddress(\"\", \"bech32\")\n+        pubk3 = self.nodes[0].getaddressinfo(addr_BECH32)['pubkey']\n+        self.nodes[0].sendtoaddress(addr_P2SH_SEGWIT, 1)\n+        self.nodes[0].sendtoaddress(addr_LEGACY, 2)\n+        self.nodes[0].sendtoaddress(addr_BECH32, 3)\n+        self.nodes[0].generate(1)\n+\n+        self.log.info(\"Stop node, remove wallet, mine again some blocks...\")\n+        self.stop_node(0)\n+        shutil.rmtree(os.path.join(self.nodes[0].datadir, \"regtest\", 'wallets'))\n+        self.start_node(0)\n+        self.nodes[0].generate(110)\n+\n+        self.restart_node(0, ['-nowallet'])\n+        self.log.info(\"Test if we have found the non HD unspent outputs.\")\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}])['total_amount'], 6)\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"address\": addr_P2SH_SEGWIT}, {\"address\": addr_LEGACY}, {\"address\": addr_BECH32}])['total_amount'], 6)\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"address\": addr_P2SH_SEGWIT}, {\"address\": addr_LEGACY}, {\"pubkey\": {\"pubkey\": pubk3}} ])['total_amount'], 6)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202552486",
      "id" : 202552486,
      "in_reply_to_id" : 202545504,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1MjQ4Ng==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 41,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : 41,
      "pull_request_review_id" : 137276498,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202552486",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202553294"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202553294"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree. Made static.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T20:18:59Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202553294",
      "id" : 202553294,
      "in_reply_to_id" : 202545259,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1MzI5NA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 89,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137277137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202553294",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202553321"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202553321"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed. Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T20:19:43Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202553321",
      "id" : 202553321,
      "in_reply_to_id" : 202545343,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1MzMyMQ==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 242,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137277158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202553321",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202553323"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202553323"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T20:19:48Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n+                    CScript script;\n+                    if (script_type == OutputScriptType::P2PK) {\n+                        // support legacy P2PK scripts\n+                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n+                    } else {\n+                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n+                    }\n+                    assert(!script.empty());\n+                    needles.insert(script);\n+                }\n+            } else if (script_uni.isStr()) {\n+                // type: script\n+                // check and add the script to the scan containers (needles array)\n+                std::vector<unsigned char> scriptData(ParseHexV(script_uni, \"script\"));\n+                CScript script(scriptData.begin(), scriptData.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202553323",
      "id" : 202553323,
      "in_reply_to_id" : 202545375,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1MzMyMw==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 265,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 137277161,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T20:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202553323",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed relevant points from @Empact ",
      "created_at" : "2018-07-15T20:20:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-405115531",
      "id" : 405115531,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNTExNTUzMQ==",
      "updated_at" : "2018-07-15T20:20:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/405115531",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202554584"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202554584"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you `throw` on `UNKNOWN` within `GetOutputScriptTypeFromString`, then there is no other use of `UNKNOWN` as an `OutputScriptType`.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T21:07:20Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n+            } else if (address_uni.isStr()) {\n+                // type: address\n+                // decode destination and derive the scriptPubKey\n+                // add the script to the scan containers\n+                CTxDestination dest = DecodeDestination(address_uni.get_str());\n+                if (!IsValidDestination(dest)) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+                }\n+                CScript script = GetScriptForDestination(dest);\n+                assert(!script.empty());\n+                needles.insert(script);\n+            } else if (pubkey_uni.isObject()) {\n+                // type: pubkey\n+                // derive script(s) according to the script_type parameter\n+                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n+                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n+\n+                // check the script types and use the default if not provided\n+                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n+                } else if (script_types_uni.isNull()) {\n+                    // use the default script types\n+                    script_types_uni = UniValue(UniValue::VARR);\n+                    for (const char *t : g_default_scantxoutset_script_types) {\n+                        script_types_uni.push_back(t);\n+                    }\n+                }\n+\n+                // check the acctual pubkey\n+                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n+                }\n+                std::vector<unsigned char> data(ParseHexV(pubkeydata_uni, \"pubkey\"));\n+                CPubKey pubkey(data.begin(), data.end());\n+                if (!pubkey.IsFullyValid()) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+                }\n+\n+                // loop through the script types and derive the script\n+                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n+                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n+                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202554584",
      "id" : 202554584,
      "in_reply_to_id" : 202545250,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1NDU4NA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 250,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 251,
      "pull_request_review_id" : 137278365,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T21:07:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202554584",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202554618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202554618"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Suggesting to group the sum in parens so that it's more clear that there is only the one top-level condition.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T21:08:40Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202554618",
      "id" : 202554618,
      "in_reply_to_id" : 202543480,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1NDYxOA==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 201,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 203,
      "pull_request_review_id" : 137278398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T21:08:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202554618",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202554641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202554641"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, it just handles the type testing.",
      "commit_id" : "be98b2d9a8fcb5f0e29ea88f026d604442fe984c",
      "created_at" : "2018-07-15T21:09:21Z",
      "diff_hunk" : "@@ -1916,6 +1920,290 @@ static UniValue savemempool(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+//! Search for a given set of pubkey scripts\n+bool FindScriptPubKey(std::atomic<int>& scan_progress, const std::atomic<bool>& should_abort, int64_t& count, CCoinsViewCursor* cursor, const std::set<CScript>& needles, std::map<COutPoint, Coin>& out_results) {\n+    scan_progress = 0;\n+    count = 0;\n+    while (cursor->Valid()) {\n+        COutPoint key;\n+        Coin coin;\n+        if (!cursor->GetKey(key) || !cursor->GetValue(coin)) return false;\n+        if (++count % 8192 == 0) {\n+            boost::this_thread::interruption_point();\n+            if (should_abort) {\n+                // allow to abort the scan via the abort reference\n+                return false;\n+            }\n+        }\n+        if (count % 256 == 0) {\n+            // update progress reference every 256 item\n+            uint32_t high = 0x100 * *key.hash.begin() + *(key.hash.begin() + 1);\n+            scan_progress = (int)(high * 100.0 / 65536.0 + 0.5);\n+        }\n+        if (needles.count(coin.out.scriptPubKey)) {\n+            out_results.emplace(key, coin);\n+        }\n+        cursor->Next();\n+    }\n+    scan_progress = 100;\n+    return true;\n+}\n+\n+/** RAII object to prevent concurrency issue when scanning the txout set */\n+static std::mutex g_utxosetscan;\n+static std::atomic<int> g_scan_progress;\n+static std::atomic<bool> g_scan_in_progress;\n+static std::atomic<bool> g_should_abort_scan;\n+class CoinsViewScanReserver\n+{\n+private:\n+    bool m_could_reserve;\n+public:\n+    explicit CoinsViewScanReserver() : m_could_reserve(false) {}\n+\n+    bool reserve() {\n+        assert (!m_could_reserve);\n+        std::lock_guard<std::mutex> lock(g_utxosetscan);\n+        if (g_scan_in_progress) {\n+            return false;\n+        }\n+        g_scan_in_progress = true;\n+        m_could_reserve = true;\n+        return true;\n+    }\n+\n+    ~CoinsViewScanReserver() {\n+        if (m_could_reserve) {\n+            std::lock_guard<std::mutex> lock(g_utxosetscan);\n+            g_scan_in_progress = false;\n+        }\n+    }\n+};\n+\n+const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n+\n+enum class OutputScriptType {\n+    UNKNOWN,\n+    P2PK,\n+    P2PKH,\n+    P2SH_P2WPKH,\n+    P2WPKH\n+};\n+\n+static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n+{\n+    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n+    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n+    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n+    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n+    else return OutputScriptType::UNKNOWN;\n+}\n+\n+CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n+{\n+    switch (type) {\n+    case OutputScriptType::P2PKH: return key.GetID();\n+    case OutputScriptType::P2SH_P2WPKH:\n+    case OutputScriptType::P2WPKH: {\n+        if (!key.IsCompressed()) return key.GetID();\n+        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n+        if (type == OutputScriptType::P2SH_P2WPKH) {\n+            CScript witprog = GetScriptForDestination(witdest);\n+            return CScriptID(witprog);\n+        } else {\n+            return witdest;\n+        }\n+    }\n+    default: assert(false);\n+    }\n+}\n+\n+UniValue scantxoutset(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"scantxoutset <action> ( <scanobjects> )\\n\"\n+            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n+            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n+            \"                                      \\\"start\\\" for starting a scan\\n\"\n+            \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n+            \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n+            \"      [\\n\"\n+            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n+            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n+            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n+            \"          {\\n\"\n+            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n+            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n+            \"          }\\n\"\n+            \"        },\\n\"\n+            \"      ]\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"unspents\\\": [\\n\"\n+            \"    {\\n\"\n+            \"    \\\"txid\\\" : \\\"transactionid\\\",     (string) The transaction id\\n\"\n+            \"    \\\"vout\\\": n,                    (numeric) the vout value\\n\"\n+            \"    \\\"scriptPubKey\\\" : \\\"script\\\",    (string) the script key\\n\"\n+            \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount in \" + CURRENCY_UNIT + \" of the unspent output\\n\"\n+            \"    \\\"height\\\" : n,                 (numeric) Height of the unspent transaction output\\n\"\n+            \"   }\\n\"\n+            \"   ,...], \\n\"\n+            \" \\\"total_amount\\\" : x.xxx,          (numeric) The total amount of all found unspent outputs in \" + CURRENCY_UNIT + \"\\n\"\n+            \"]\\n\"\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR});\n+\n+    UniValue result(UniValue::VOBJ);\n+    if (request.params[0].get_str() == \"status\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            //no scan in progress\n+            return NullUniValue;\n+        }\n+        result.pushKV(\"progress\", g_scan_progress);\n+        return result;\n+    } else if (request.params[0].get_str() == \"abort\") {\n+        CoinsViewScanReserver reserver;\n+        if (reserver.reserve()) {\n+            return false;\n+        }\n+        g_should_abort_scan = true;\n+        return true;\n+    } else if (request.params[0].get_str() == \"start\") {\n+        CoinsViewScanReserver reserver;\n+        if (!reserver.reserve()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan already in progress, use action \\\"abort\\\" or \\\"status\\\"\");\n+        }\n+        std::set<CScript> needles;\n+        CAmount total_in = 0;\n+\n+        // loop through the scan objects\n+        for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n+            if (!scanobject.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n+            }\n+            UniValue address_uni = find_value(scanobject, \"address\");\n+            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n+            UniValue script_uni  = find_value(scanobject, \"script\");\n+\n+            // make sure only one object type is present\n+            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n+            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n+            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n+            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#discussion_r202554641",
      "id" : 202554641,
      "in_reply_to_id" : 202543477,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjU1NDY0MQ==",
      "original_commit_id" : "b9b59cc7ba742bb519d34f3011500f09a8c04911",
      "original_position" : 208,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 210,
      "pull_request_review_id" : 137278426,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12196",
      "updated_at" : "2018-07-15T21:09:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202554641",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK be98b2d.",
      "created_at" : "2018-07-17T14:39:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-405606018",
      "id" : 405606018,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNTYwNjAxOA==",
      "updated_at" : "2018-07-17T14:39:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/405606018",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Thanks for your great efforts implementing this feature, On Oct 01, 2020, When I run this RPC command on Bitcoin Node version 0.20.0, then its response is too slow, I am getting rpc response after 1-2 minutes. \r\n\r\nIs there any way to speed up this \"scantxoutset\" RPC command or any alternative available?\r\n\r\nI asked the same question over bitcoin stackexchange forum, but nobody responded. I know its not the right place to ask such questions, but I am stuck, our mobile wallet is live and we are unable to fetch user \"imported\" address balances on the fly.\r\n\r\nThanks.\r\n\r\nhttps://bitcoin.stackexchange.com/questions/99278/bitcoin-scantxoutset-rpc-command-return-response-too-slow\r\n\r\n",
      "created_at" : "2020-10-01T11:44:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-702078285",
      "id" : 702078285,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjA3ODI4NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-01T11:44:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702078285",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/38350367?v=4",
         "events_url" : "https://api.github.com/users/surindergiri/events{/privacy}",
         "followers_url" : "https://api.github.com/users/surindergiri/followers",
         "following_url" : "https://api.github.com/users/surindergiri/following{/other_user}",
         "gists_url" : "https://api.github.com/users/surindergiri/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/surindergiri",
         "id" : 38350367,
         "login" : "surindergiri",
         "node_id" : "MDQ6VXNlcjM4MzUwMzY3",
         "organizations_url" : "https://api.github.com/users/surindergiri/orgs",
         "received_events_url" : "https://api.github.com/users/surindergiri/received_events",
         "repos_url" : "https://api.github.com/users/surindergiri/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/surindergiri/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/surindergiri/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/surindergiri"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@surindergiri I'm unsure how applicable it can be to `scanttxoutsetinfo`, but #18000 and its separate PRs can make `gettxoutsetinfo` run much more quickly (under 2 seconds in my testing), thanks to indexes. Maybe have a look, test it, try to adapt it.",
      "created_at" : "2020-10-01T12:12:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-702091803",
      "id" : 702091803,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjA5MTgwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-01T12:27:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702091803",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I asked the same question over bitcoin stackexchange forum, but nobody responded\r\n\r\n@surindergiri that was like 3 hours before you posted here..",
      "created_at" : "2020-10-01T14:53:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12196#issuecomment-702191016",
      "id" : 702191016,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12196",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjE5MTAxNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-01T14:53:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702191016",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   }
]
