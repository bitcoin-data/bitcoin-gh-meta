[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [vasild](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1357776792), [brunoerg](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1363419724), [ajtowns](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1382390744), [mzumsande](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1388792230) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27213](https://github.com/bitcoin/bitcoin/pull/27213) (p2p: Diversify automatic outbound connections with respect to networks by amitiuttarwar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2023-03-06T19:47:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1456857488",
      "id" : 1456857488,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
      "node_id" : "IC_kwDOABII585W1eGQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456857488/reactions"
      },
      "updated_at" : "2023-04-17T19:29:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456857488",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127073061"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit (for 9bf078f66c8f286e1ab5e34b8eeed7d80290a897):\r\n```cpp\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex ec5b0213b..f608d60f0 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -722,15 +722,13 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\r\n     if (newOnly && nNew == 0) return {};\r\n \r\n     // Decide if we are going to search the new or tried table\r\n-    bool search_tried;\r\n+    bool search_tried{false};\r\n \r\n     // Use a 50% chance for choosing between tried and new table entries.\r\n     if (!newOnly &&\r\n        (nTried > 0 &&\r\n         (nNew == 0 || insecure_rand.randbool() == 0))) {\r\n         search_tried = true;\r\n-    } else {\r\n-        search_tried = false;\r\n     }\r\n \r\n     if (search_tried) {\r\n```",
      "commit_id" : "fdfeac9031049e85e7d5b1393227510ce54e247d",
      "created_at" : "2023-03-06T21:53:24Z",
      "diff_hunk" : "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127073061",
      "id" : 1127073061,
      "line" : 740,
      "node_id" : "PRRC_kwDOABII585DLcUl",
      "original_commit_id" : "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "original_line" : 725,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 8,
      "pull_request_review_id" : 1327252882,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T21:53:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127079909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "perhaps rename `newOnly` to `new_only`?",
      "commit_id" : "fdfeac9031049e85e7d5b1393227510ce54e247d",
      "created_at" : "2023-03-06T21:59:21Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127079909",
      "id" : 1127079909,
      "line" : 735,
      "node_id" : "PRRC_kwDOABII585DLd_l",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 735,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 24,
      "pull_request_review_id" : 1327260528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T21:59:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127083746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Suggestion:\r\n```diff\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex 8c36af13f..66d54d2b4 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -746,8 +746,7 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optiona\r\n         search_tried = insecure_rand.randbool();\r\n     }\r\n \r\n-    int bucket_count;\r\n-    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\r\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n     //  Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n```",
      "commit_id" : "fdfeac9031049e85e7d5b1393227510ce54e247d",
      "created_at" : "2023-03-06T22:03:42Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n \n     // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n     bool search_tried;\n-    int bucket_count;\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 &&\n-        (nNew == 0 || insecure_rand.randbool() == 0))) {\n+    if (newOnly || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n         search_tried = true;\n-        bucket_count = ADDRMAN_TRIED_BUCKET_COUNT;\n     } else {\n-        search_tried = false;\n-        bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\n+        search_tried = insecure_rand.randbool();\n     }\n \n+    int bucket_count;\n+    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127083746",
      "id" : 1127083746,
      "line" : 750,
      "node_id" : "PRRC_kwDOABII585DLe7i",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 750,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 48,
      "pull_request_review_id" : 1327266458,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T22:03:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127282542"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "hm, this suggestion makes sense within the context of the first commit. however, the `search_tried` logic gets updated over the commits so it would be expanded anyways. \r\n\r\nit would be possible to rework the end state to be a bit more nifty like this, but since this logic is pretty crucial to the function working as intended, I'm more inclined to leave the explicit assignment of new vs tried. ",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T02:42:20Z",
      "diff_hunk" : "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127282542",
      "id" : 1127282542,
      "in_reply_to_id" : 1127073061,
      "line" : 740,
      "node_id" : "PRRC_kwDOABII585DMPdu",
      "original_commit_id" : "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "original_line" : 725,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 72,
      "pull_request_review_id" : 1327548731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T02:43:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice, done",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T03:02:01Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n \n     // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n     bool search_tried;\n-    int bucket_count;\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 &&\n-        (nNew == 0 || insecure_rand.randbool() == 0))) {\n+    if (newOnly || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n         search_tried = true;\n-        bucket_count = ADDRMAN_TRIED_BUCKET_COUNT;\n     } else {\n-        search_tried = false;\n-        bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\n+        search_tried = insecure_rand.randbool();\n     }\n \n+    int bucket_count;\n+    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291828",
      "id" : 1127291828,
      "in_reply_to_id" : 1127083746,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DMRu0",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 750,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1327561910,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T03:02:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T03:02:11Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291922",
      "id" : 1127291922,
      "in_reply_to_id" : 1127079909,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DMRwS",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 735,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1327562027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T03:02:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks for the review @brunoerg ! responded to all your feedback",
      "created_at" : "2023-03-07T03:02:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1457435139",
      "id" : 1457435139,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
      "node_id" : "IC_kwDOABII585W3rID",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1457435139/reactions"
      },
      "updated_at" : "2023-03-07T03:02:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1457435139",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127730689"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n        const auto& address = addrman.Select(/*new_only=*/false, NET_I2P);\r\n```",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T11:39:44Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*newOnly*/false, NET_I2P);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127730689",
      "id" : 1127730689,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII585DN84B",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 145,
      "original_position" : 65,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 65,
      "pull_request_review_id" : 1328202519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T11:41:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127731998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, can leave this way. This suggestion I made while reviewing the first commit but considering the whole context, you can leave it.",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T11:41:00Z",
      "diff_hunk" : "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127731998",
      "id" : 1127731998,
      "in_reply_to_id" : 1127073061,
      "line" : 740,
      "node_id" : "PRRC_kwDOABII585DN9Me",
      "original_commit_id" : "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "original_line" : 725,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 72,
      "pull_request_review_id" : 1328205378,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T11:41:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128258413"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Interesting, perhaps #26261 would be a good fit :)",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-07T17:21:30Z",
      "diff_hunk" : "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128258413",
      "id" : 1128258413,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585DP9tt",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 82,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 19,
      "pull_request_review_id" : 1329133202,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T17:21:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128704427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ah, it looks like those changes would remove the need for this helper? ",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-07T22:52:34Z",
      "diff_hunk" : "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128704427",
      "id" : 1128704427,
      "in_reply_to_id" : 1128258413,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585DRqmr",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 82,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 19,
      "pull_request_review_id" : 1329678832,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T22:52:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128705089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good catch, updated. also realized there were stale comments in the addrman unit test, so updated those too.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-07T22:53:17Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*newOnly*/false, NET_I2P);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128705089",
      "id" : 1128705089,
      "in_reply_to_id" : 1127730689,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DRqxB",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 145,
      "original_position" : 65,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1329679553,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T22:53:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129220513"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, if it makes sense for you I'd appreciate your review there btw.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T10:16:15Z",
      "diff_hunk" : "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129220513",
      "id" : 1129220513,
      "in_reply_to_id" : 1128258413,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585DTomh",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 82,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 19,
      "pull_request_review_id" : 1330318402,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-08T10:16:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129434505"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: `Addrman` in the method name is redundant. Maybe `AddrManImpl::LookupEntry()` or even `AddrManImpl::Lookup()` or `AddrManImpl::Get()`.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T13:32:30Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129434505",
      "id" : 1129434505,
      "line" : 798,
      "node_id" : "PRRC_kwDOABII585DUc2J",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 155,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129439158"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would be good to have an assert that checks there is no out-of-bounds access. This method itself does not know what the callers will use for arguments or how they will be derived so better check.\r\n\r\nMaybe change the arrays to `std::array` and use `.at()` here.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T13:36:01Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129439158",
      "id" : 1129439158,
      "line" : 806,
      "node_id" : "PRRC_kwDOABII585DUd-2",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 806,
      "original_position" : 163,
      "original_start_line" : 802,
      "path" : "src/addrman.cpp",
      "position" : 163,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 802,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129442167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: I know it was using `int` to index the array, but those should be `size_t`. Now looks like a good time to fix that:\r\n```suggestion\r\nint AddrManImpl::LookupAddrmanEntry(bool use_tried, size_t bucket, size_t position) const\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T13:38:17Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129442167",
      "id" : 1129442167,
      "line" : 798,
      "node_id" : "PRRC_kwDOABII585DUet3",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 155,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129522848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`std::string` will do heap allocation. It is an overkill in this case.\r\n\r\n```suggestion\r\n            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), search_tried ? \"tried\" : \"new\");\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:26:56Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129522848",
      "id" : 1129522848,
      "line" : 789,
      "node_id" : "PRRC_kwDOABII585DUyag",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 789,
      "original_position" : 146,
      "original_start_line" : 787,
      "path" : "src/addrman.cpp",
      "position" : 146,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 787,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129539099"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: use `std::nullopt` instead of `{}` which I believe is more readable and consistent with the comment that says \"nullopt = all\". Like here:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/8d12127a9c19cb218d661a88ab9b6871c9d853b9/src/addrman.h#L109",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:37:16Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] network  Select only addresses of this network (nullopt = all)\n      * @return    CAddress The record for the selected peer.\n      *            seconds  The last time we attempted to connect to that peer.\n      */\n-    std::pair<CAddress, NodeSeconds> Select(bool newOnly = false) const;\n+    std::pair<CAddress, NodeSeconds> Select(bool new_only = false, std::optional<Network> network = {}) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129539099",
      "id" : 1129539099,
      "line" : 154,
      "node_id" : "PRRC_kwDOABII585DU2Yb",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 154,
      "original_position" : 11,
      "original_start_line" : 150,
      "path" : "src/addrman.h",
      "position" : 11,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 150,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129547711"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: I think it is good to be explicit and use `network.has_value()` here. Otherwise it can get confusing, especially with booleans (`network` is not boolean, but anyway). For example:\r\n\r\n```cpp\r\nstd::optional<bool> is_odd\r\n...\r\nif (is_odd) { // did the author mean is_odd.has_value() or *is_odd?\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:42:40Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129547711",
      "id" : 1129547711,
      "line" : 726,
      "node_id" : "PRRC_kwDOABII585DU4e_",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 726,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 58,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129552332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n\r\n```suggestion\r\n    if (new_count + tried_count == 0) return {};\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:45:28Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129552332",
      "id" : 1129552332,
      "line" : 736,
      "node_id" : "PRRC_kwDOABII585DU5nM",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 736,
      "original_position" : 68,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 68,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129566625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This maybe warrants a better description:\r\n\r\n```suggestion\r\n     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` guarantees either an address from the new table or an invalid return value. Passing `false` requests 50% chance of new or tried, it does not guarantee an entry from the tried table.\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:53:56Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129566625",
      "id" : 1129566625,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII585DU9Gh",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 149,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : 5,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129568636"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n    // Loop through the addrman table until we find an appropriate entry\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:55:10Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129568636",
      "id" : 1129568636,
      "line" : 751,
      "node_id" : "PRRC_kwDOABII585DU9l8",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 751,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 106,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129569710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: same as elsewhere: consider `network.has_value()`.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:55:51Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129569710",
      "id" : 1129569710,
      "line" : 765,
      "node_id" : "PRRC_kwDOABII585DU92u",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 765,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 120,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129577204"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: the code below has an assert after `find()`, good to have it here too:\r\n\r\n```suggestion\r\n                    const auto it{mapInfo.find(node_id)};\r\n                    assert(it != mapInfo.end());\r\n                    const auto info{it->second};\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T15:00:36Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129577204",
      "id" : 1129577204,
      "line" : 767,
      "node_id" : "PRRC_kwDOABII585DU_r0",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 767,
      "original_position" : 122,
      "original_start_line" : 766,
      "path" : "src/addrman.cpp",
      "position" : 122,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 766,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130661248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: in the commit message of `tests: add addrman_select_by_network test`: `s/newOnly/new_only` since it was already renamed before that commit",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T08:46:27Z",
      "diff_hunk" : "@@ -127,45 +127,47 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130661248",
      "id" : 1130661248,
      "line" : 128,
      "node_id" : "PRRC_kwDOABII585DZIWA",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 128,
      "original_position" : 2,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 2,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130664213"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: that should be `/*new_only=*/` for clang-tidy to check it and for consistency with the rest of the code base (here and elsewhere).",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T08:49:03Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130664213",
      "id" : 1130664213,
      "line" : 200,
      "node_id" : "PRRC_kwDOABII585DZJEV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 200,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 80,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130668333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be better to check that the returned result is `!IsValid()` and not rely on how an invalid address would be represented by `ToStringAddrPort()` (maybe even that method should assert that the object is valid).\r\n\r\n```suggestion\r\n    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV4).first.IsValid());\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T08:52:40Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130668333",
      "id" : 1130668333,
      "line" : 201,
      "node_id" : "PRRC_kwDOABII585DZKEt",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 201,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 81,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:25:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130699029"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: `250.1.1.1` is duplicated here and above. Maybe put it in a variable or avoid comparing through strings altogether (here and elsewhere):\r\n\r\n```suggestion\r\n    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_IPV4).first == addr1);\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:18:09Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130699029",
      "id" : 1130699029,
      "line" : 208,
      "node_id" : "PRRC_kwDOABII585DZRkV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 208,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 88,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130705627"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"new_only=true, some_nonexistent_network\" seems untested:\r\n\r\n```cpp\r\nBOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_CJDNS).first.IsValid());\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:23:41Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130705627",
      "id" : 1130705627,
      "line" : 226,
      "node_id" : "PRRC_kwDOABII585DZTLb",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 226,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 106,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130712887"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If this is changed to:\r\n```cpp\r\nCAddress i2p_addr;\r\n```\r\nand the rest of the code left as it is, then it will still work, but then `CAddress(i2p_addr, NODE_NONE)` which is duplicated below can be replaced with `i2p_addr`.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:29:46Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130712887",
      "id" : 1130712887,
      "line" : 217,
      "node_id" : "PRRC_kwDOABII585DZU83",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 217,
      "original_position" : 97,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 97,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130731456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This test will fail sporadically.\r\n\r\nAlso, if you are only going to check the size, then a counter suffices. If you are going to collect the strings, then you may as well check that they are as expected (`i2p_addr` and `i2p_addr2`).\r\n\r\nConsider this:\r\n\r\n```cpp\r\n    CAddress i2p_addr2;\r\n...\r\n    // ensure that both new and tried table are selected from\r\n    bool new_selected{false};\r\n    bool tried_selected{false};\r\n    while (!new_selected || !tried_selected) { \r\n        const CAddress selected{addrman->Select(/*new_only=*/false, NET_I2P).first};\r\n        BOOST_REQUIRE(selected == i2p_addr || selected == i2p_addr2);\r\n        if (selected == i2p_addr) {\r\n            tried_selected = true;\r\n        } else {\r\n            new_selected = true;\r\n        }\r\n    }  \r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:45:08Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130731456",
      "id" : 1130731456,
      "line" : 246,
      "node_id" : "PRRC_kwDOABII585DZZfA",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 246,
      "original_position" : 126,
      "original_start_line" : 241,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 126,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 241,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130754068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "For this test to be meaningful there must be some address also in the tried table. Otherwise:\r\n\r\n```\r\n740     bool search_tried;\r\n741     if (new_only || tried_count == 0) {\r\n742         search_tried = false;\r\n743     } else if (new_count == 0) {\r\n744         search_tried = true;\r\n745     } else {\r\n746         search_tried = insecure_rand.randbool();\r\n747     }\r\n```\r\n\r\nit will always go to the new table via line 742 because `tried_count == 0` and it will never execute line 746 which I guess is the purpose of this test.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T10:03:39Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130754068",
      "id" : 1130754068,
      "line" : 262,
      "node_id" : "PRRC_kwDOABII585DZfAU",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 142,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 259,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130835999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "String comparison is very non-effective and surely has an impact of performance in such a tight-loop cases. This may better be:\r\n\r\n```suggestion\r\n        const auto address = addrman.Select(/*new_only*/false, NET_I2P).first;\r\n        assert(address == i2p_address);\r\n```\r\n\r\nI think that this also does not need to check the result - now it is mixing bench + correctness test in such a way that the correctness check may skew the benchmark. We have the unit tests to ensure correctness. Thus, this may as well be:\r\n\r\n```suggestion\r\n        (void)addrman.Select(/*new_only*/false, NET_I2P);\r\n```\r\n\r\nto reduce the amount of noise.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T11:05:42Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\n+        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130835999",
      "id" : 1130835999,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585DZzAf",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 146,
      "original_position" : 66,
      "original_start_line" : 145,
      "path" : "src/bench/addrman.cpp",
      "position" : 66,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 145,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130840488"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is checking the port an indirect way to check that `Select()` returned a valid result? You can check that the returned value `IsValid()` for that. But same as for the other bench, this may as well be just `(void)addrman.Select();` to reduce the noise (and leave correctness checks to the unit tests).",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T11:10:13Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130840488",
      "id" : 1130840488,
      "line" : 126,
      "node_id" : "PRRC_kwDOABII585DZ0Go",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 126,
      "original_position" : 46,
      "original_start_line" : 125,
      "path" : "src/bench/addrman.cpp",
      "position" : 46,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 125,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130844842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It is excellent to see benchmark tests added! My only concern with this PR is that it will iterate through a lot of entries in addrman before finding one from the requested network. This in theory is `O(addrman size)`. And the benchmarks will help us assess that. So, it would be nice to compare, on the same, full addrman (e.g. 70k addresses):\r\n\r\n1. the speed of a regular `Select()`\r\n2. the speed of a `Select(network)` where the searched for address is ~near the end~ rare. In other words, worst case scenario, when ~70k addresses are iterated before finding the result.\r\n\r\nSomehow I don't see that from the added benchmarks. I will play with them to see if that's possible (~how to put an address \"at the end\"?~, that is nonsense, [there is no end](https://bitcoin-irc.chaincode.com/bitcoin-core-dev/2023-03-09#903165;)).\r\n\r\nBtw the results are unstable:\r\n```\r\n:wavy_dash: `AddrManSelectByNetwork` (Unstable with ~1.2 iters. Increase `minEpochIterations` to e.g. 12)\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T11:14:39Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130844842",
      "id" : 1130844842,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585DZ1Kq",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 130,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 50,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-10T12:20:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Let me elaborate why I think comparing 1. and 2. above is important (the benchmarks in this PR don't do that):\r\n\r\n* Right now, on `master`, when we pick a peer to connect to 1. happens.\r\n* With #27213 when we pick a peer to connect to 2. happens.\r\n* I assume most of the addrmans out there are full (tens of thousands of addresses, max 80k), thus testing on an empty addrman is not representative.\r\n\r\nSo, we will add security at the cost of making it a bit slower. To assess how much slower I tweaked the benchmark as this:\r\n\r\n<details>\r\n<summary>benchmark tweaks</summary>\r\n\r\n```diff\r\ndiff --git i/src/bench/addrman.cpp w/src/bench/addrman.cpp\r\nindex 9fe50f4ec2..d1def9e520 100644\r\n--- i/src/bench/addrman.cpp\r\n+++ w/src/bench/addrman.cpp\r\n@@ -12,13 +12,13 @@\r\n \r\n #include <optional>\r\n #include <vector>\r\n \r\n /* A \"source\" is a source address from which we have received a bunch of other addresses. */\r\n \r\n-static constexpr size_t NUM_SOURCES = 64;\r\n+static constexpr size_t NUM_SOURCES = 512; // fills addrman with ~55k addresses, instead of ~15k\r\n static constexpr size_t NUM_ADDRESSES_PER_SOURCE = 256;\r\n \r\n static NetGroupManager EMPTY_NETGROUPMAN{std::vector<bool>()};\r\n static constexpr uint32_t ADDRMAN_CONSISTENCY_CHECK_RATIO{0};\r\n \r\n static std::vector<CAddress> g_sources;\r\n@@ -137,16 +137,20 @@ static void AddrManSelectByNetwork(benchmark::Bench& bench)\r\n     CAddress i2p_address(i2p_service, NODE_NONE);\r\n     i2p_address.nTime = Now<NodeSeconds>();\r\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\r\n     addrman.Add({i2p_address}, source);\r\n \r\n     FillAddrMan(addrman);\r\n-\r\n-    bench.run([&] {\r\n-        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\r\n-        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\r\n+    fprintf(stderr, \"addrman size: %zu\\n\", addrman.Size());\r\n+\r\n+    bench.minEpochIterations(300).run([&] {\r\n+#if 0\r\n+        addrman.Select(/*new_only=*/false);\r\n+#else\r\n+        addrman.Select(/*new_only=*/false, NET_I2P);\r\n+#endif\r\n     });\r\n }\r\n \r\n static void AddrManGetAddr(benchmark::Bench& bench)\r\n {\r\n     AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\r\n```\r\n</details>\r\n\r\nThe results are:\r\n\r\n1. `Select()` takes 0.18 microseconds\r\n2. `Select(network)` takes 6000 microseconds\r\n\r\nNow, this is a big difference, but maybe that is ok. We don't `Select()` in a tight loop. However, it can be improved relatively easy. I observed that in 2. we visit between ~100 and ~600k bucket positions before finding a match. Given that there are 80k in addrman it means that we visit some multiple times, which is a waste of resources. This is avoided if we don't visit already visited buckets (but still visit buckets in random order). The patch below does that (on top of this PR):\r\n\r\n<details>\r\n<summary>don't visit already visited buckets</summary>\r\n\r\n```diff\r\ndiff --git i/src/addrman.cpp w/src/addrman.cpp\r\nindex 1023c3cbdb..0e196050b9 100644\r\n--- i/src/addrman.cpp\r\n+++ w/src/addrman.cpp\r\n@@ -16,12 +16,13 @@\r\n #include <streams.h>\r\n #include <tinyformat.h>\r\n #include <uint256.h>\r\n #include <util/check.h>\r\n #include <util/time.h>\r\n \r\n+#include <array>\r\n #include <cmath>\r\n #include <optional>\r\n \r\n /** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\r\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\r\n /** Over how many buckets entries with new addresses originating from a single group are spread */\r\n@@ -745,17 +746,39 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n     } else {\r\n         search_tried = insecure_rand.randbool();\r\n     }\r\n \r\n     const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n+    // We want to search buckets in random order and also prefer visiting a\r\n+    // bucket that we have not visited before instead of visiting an already\r\n+    // visited bucket. Thus shuffle the buckets and visit that shuffled list\r\n+    // in order.\r\n+\r\n+    std::array<uint16_t, std::max(ADDRMAN_TRIED_BUCKET_COUNT, ADDRMAN_NEW_BUCKET_COUNT)>\r\n+        shuffled_bucket_indexes;\r\n+    for (uint16_t i = 0; i < bucket_count; ++i) {\r\n+        shuffled_bucket_indexes[i] = i;\r\n+    }\r\n+    Shuffle(shuffled_bucket_indexes.begin(),\r\n+            shuffled_bucket_indexes.begin() + bucket_count,\r\n+            insecure_rand);\r\n+    // If we visit a bucket and find 0 matching addresses in it, mark it with\r\n+    // this and never visit it again.\r\n+    static constexpr uint16_t ALREADY_VISITED_AND_BORING{std::numeric_limits<uint16_t>::max()};\r\n+\r\n+    static_assert(ADDRMAN_TRIED_BUCKET_COUNT < ALREADY_VISITED_AND_BORING);\r\n+    static_assert(ADDRMAN_NEW_BUCKET_COUNT < ALREADY_VISITED_AND_BORING);\r\n+\r\n     //  Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n-    while (1) {\r\n-        // Pick a bucket, and an initial position in that bucket.\r\n-        int bucket = insecure_rand.randrange(bucket_count);\r\n+    for (uint16_t b = 0;; b = (b + 1) % bucket_count) {\r\n+        if (shuffled_bucket_indexes[b] == ALREADY_VISITED_AND_BORING) {\r\n+            continue;\r\n+        }\r\n+        const size_t bucket{shuffled_bucket_indexes[b]};\r\n         int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\r\n \r\n         // Iterate over the positions of that bucket, starting at the initial one,\r\n         // and looping around.\r\n         int i;\r\n         for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\r\n@@ -769,14 +792,19 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n                 } else {\r\n                     break;\r\n                 }\r\n             }\r\n         }\r\n \r\n-        // If the bucket is entirely empty, start over with a (likely) different one.\r\n-        if (i == ADDRMAN_BUCKET_SIZE) continue;\r\n+        // Start over with a different bucket if this one is entirely empty or\r\n+        // specific network was requested and it does not contain any addresses\r\n+        // from that network.\r\n+        if (i == ADDRMAN_BUCKET_SIZE) {\r\n+            shuffled_bucket_indexes[b] = ALREADY_VISITED_AND_BORING;\r\n+            continue;\r\n+        }\r\n \r\n         // Find the entry to return.\r\n         int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n         int nId = LookupAddrmanEntry(search_tried, bucket, position);\r\n         const auto it_found{mapInfo.find(nId)};\r\n         assert(it_found != mapInfo.end());\r\n```\r\n</details>\r\n\r\nIt changes `Select(network)` to about 3000 microseconds (down from 6000), but that result from the benchmark is averaged between executions that take anything between 100 and 600k iterations. What is more important is that with the change above it never takes more than ~60k iterations, that is - anything between 100 and 60k. Worst case lowered ~10 times.\r\n\r\nThe optimization brings some complexity but IMO it is worth it.\r\n",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-10T17:02:33Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513",
      "id" : 1132629513,
      "in_reply_to_id" : 1130844842,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585Dgo4J",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 130,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 50,
      "pull_request_review_id" : 1335246024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-10T17:02:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132740863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This looks like a nice speedup in the case where we only have a few addresses - however, due to the constant overhead of building the shuffled list of buckets in the beginning I'd expect performance to go down a bit for the case where we have many addresses to choose from. Do you see this in your benchmark?\r\nWhy does this need `ALREADY_VISITED_AND_BORING`? If we do a for-loop through a pre-shuffled list of buckets instead of a while loop, doesn't that already guarantee that we visit each bucket at most once?",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-10T18:37:32Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132740863",
      "id" : 1132740863,
      "in_reply_to_id" : 1130844842,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585DhED_",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 130,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 50,
      "pull_request_review_id" : 1335415244,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-10T18:37:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132837417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good point about checking bounds. one way to do that is with simple checks like `assert(bucket <= ADDRMAN_TRIED_BUCKET_COUNT)` etc. \r\n\r\n> Maybe change the arrays to std::array and use .at() here.\r\n\r\nbut I'd like to understand this option better. right now `vvTried` and `vvNew` are declared as C-style arrays. is your recommendation to change those `AddrManImpl` declarations so that we can utilize the bounds checking of the `.at()` function? ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-10T20:20:42Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132837417",
      "id" : 1132837417,
      "in_reply_to_id" : 1129439158,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585Dhbop",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 805,
      "original_position" : 163,
      "original_start_line" : 802,
      "path" : "src/addrman.cpp",
      "position" : 162,
      "pull_request_review_id" : 1335559840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 801,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-10T20:20:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132968822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "oh interesting, I thought that the compiler optimizes away these sort of named-variables-used-shortly-after patterns, but maybe it's different for `std::string`? I took it to compiler explorer to see if I could observe the allocation- https://godbolt.org/z/GG78zv3KT. are the calls to `std::allocator<char>` what you are referring to? ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-10T23:29:52Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132968822",
      "id" : 1132968822,
      "in_reply_to_id" : 1129522848,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dh7t2",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 789,
      "original_position" : 146,
      "original_start_line" : 787,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335744428,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-10T23:29:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133106788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "this test is actually covering the `tried_count == 0` logic. if it were to hit line 746, it would sometimes select the tried table and sometimes the new table, which means it should fail 50% of the time. this coverage is ensuring that the `tried_count` has the proper interactions with `network`, which gets assigned earlier in the function-\r\n\r\n```\r\n    if (network.has_value()) {\r\n        auto it = m_network_counts.find(*network);\r\n        if (it == m_network_counts.end()) return {};\r\n\r\n        auto counts = it->second;\r\n        new_count = counts.n_new;\r\n        tried_count = counts.n_tried;\r\n    }\r\n``` \r\n\r\nlmk if that makes sense ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T15:29:08Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133106788",
      "id" : 1133106788,
      "in_reply_to_id" : 1130754068,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DidZk",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335898315,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T15:29:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133112932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "if I am understanding this thread properly, it seems like there are two concepts being discussed:\r\n1. changes to the bench tests\r\n2. optimization to `AddrManImpl::Select_`\r\n\r\nRE 1, I'm slightly confused as to the desired coverage. Without the network parameter, I would expect the worst case of the current `Select_` function to happen when addrman is practically empty, which is why we introduced `AddrManSelectFromAlmostEmpty`. On mainnet, this case would be unlikely, which is represented by `AddrManSelect`. With the network parameter, I would expect worst case to be represented by `AddrManSelectByNetwork` where theres just 1 I2P address on an addrman filled with other addresses. @vasild can you clarify what feels absent or misrepresentative?\r\n\r\nalso happy to discuss 2 further, but a question there - does it feel relevant to these patches to improve performance, or is it an orthogonal improvement (since we see similar worst cases right now)?  ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T15:58:51Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133112932",
      "id" : 1133112932,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585Die5k",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1335901245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T15:58:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good point, updated to `GetEntry` to match the naming style of `GetAddr`",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:31:04Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131333",
      "id" : 1133131333,
      "in_reply_to_id" : 1129434505,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijZF",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920167,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:31:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131478"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "updated, my understanding is that `size_t` is unsigned and better optimizes for different platforms. does that track?",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:32:14Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131478",
      "id" : 1133131478,
      "in_reply_to_id" : 1129442167,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijbW",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920290,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:32:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "updated",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:32:45Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131507",
      "id" : 1133131507,
      "in_reply_to_id" : 1129522848,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijbz",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 789,
      "original_position" : 146,
      "original_start_line" : 787,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:32:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:33:05Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] network  Select only addresses of this network (nullopt = all)\n      * @return    CAddress The record for the selected peer.\n      *            seconds  The last time we attempted to connect to that peer.\n      */\n-    std::pair<CAddress, NodeSeconds> Select(bool newOnly = false) const;\n+    std::pair<CAddress, NodeSeconds> Select(bool new_only = false, std::optional<Network> network = {}) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131556",
      "id" : 1133131556,
      "in_reply_to_id" : 1129539099,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijck",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 154,
      "original_position" : 11,
      "original_start_line" : 150,
      "path" : "src/addrman.h",
      "position" : null,
      "pull_request_review_id" : 1335920364,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:33:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131581"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:33:20Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131581",
      "id" : 1133131581,
      "in_reply_to_id" : 1129547711,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijc9",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 726,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920380,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:33:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:33:30Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131605",
      "id" : 1133131605,
      "in_reply_to_id" : 1129552332,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijdV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 736,
      "original_position" : 68,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920400,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:33:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131667"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "updated but worded it a bit differently - the 50% is only true if there are matches in both tables (with network interactions). lmk if the new language seems reasonable to you",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:34:16Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131667",
      "id" : 1133131667,
      "in_reply_to_id" : 1129566625,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijeT",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 149,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : null,
      "pull_request_review_id" : 1335920465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:34:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:34:25Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131673",
      "id" : 1133131673,
      "in_reply_to_id" : 1129568636,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijeZ",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 751,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:34:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:34:48Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131714",
      "id" : 1133131714,
      "in_reply_to_id" : 1129569710,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijfC",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 765,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:34:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:02Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131741",
      "id" : 1133131741,
      "in_reply_to_id" : 1129577204,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijfd",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 768,
      "original_position" : 122,
      "original_start_line" : 766,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920533,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:09Z",
      "diff_hunk" : "@@ -127,45 +127,47 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131754",
      "id" : 1133131754,
      "in_reply_to_id" : 1130661248,
      "line" : 128,
      "node_id" : "PRRC_kwDOABII585Dijfq",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 128,
      "original_position" : 2,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 2,
      "pull_request_review_id" : 1335920546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131791"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ah, thanks. updated lots of comments, I think I caught them all?",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:33Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131791",
      "id" : 1133131791,
      "in_reply_to_id" : 1130664213,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijgP",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 200,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks, updated this in lots of places",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:48Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131815",
      "id" : 1133131815,
      "in_reply_to_id" : 1130668333,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijgn",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 201,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920605,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "incorporated this in many places in the tests I touched. definitely reads better",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:11Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131847",
      "id" : 1133131847,
      "in_reply_to_id" : 1130699029,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijhH",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 208,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "added",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:17Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131864",
      "id" : 1133131864,
      "in_reply_to_id" : 1130705627,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijhY",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 226,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131874"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:26Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131874",
      "id" : 1133131874,
      "in_reply_to_id" : 1130712887,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijhi",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 217,
      "original_position" : 97,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920656,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "great idea ! updated to use this while loop. also added you as co-author for this commit btw, thanks for the in depth review :)",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:58Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131929",
      "id" : 1133131929,
      "in_reply_to_id" : 1130731456,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijiZ",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 246,
      "original_position" : 126,
      "original_start_line" : 241,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131961"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "that makes sense, updated to remove correctness tests",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:37:28Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\n+        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131961",
      "id" : 1133131961,
      "in_reply_to_id" : 1130835999,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Diji5",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 146,
      "original_position" : 66,
      "original_start_line" : 145,
      "path" : "src/bench/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:37:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131985"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yeah it was, but updated to remove that assertion. ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:37:41Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131985",
      "id" : 1133131985,
      "in_reply_to_id" : 1130840488,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijjR",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 126,
      "original_position" : 46,
      "original_start_line" : 125,
      "path" : "src/bench/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920779,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:37:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "thank you for the in-depth review @vasild ! I have addressed all your review comments (incorporated most, left questions on a couple)",
      "created_at" : "2023-03-11T18:38:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1464978015",
      "id" : 1464978015,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
      "node_id" : "IC_kwDOABII585XUcpf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1464978015/reactions"
      },
      "updated_at" : "2023-03-11T18:38:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1464978015",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136853031"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@mzumsande,\r\n\r\n> I'd expect performance to go down a bit for the case where we have many addresses to choose from. Do you see this in your benchmark?\r\n\r\nYes, that slows down a bit the fast `Select()` (any network is ok). I observed that and think it is ok because it is still super fast with or without the shuffling.\r\n\r\n> Why does this need `ALREADY_VISITED_AND_BORING`?\r\n\r\nThe `for` loop could still repeat the whole array from the start if some address was found but was skipped. `ALREADY_VISITED_AND_BORING` is a further optimization to completely skip that bucket on the second and further passes through the array.\r\n\r\n@amitiuttarwar, you are right that I modified the newly added `AddrManSelectByNetwork()` so that, in general, it tests the same thing as `AddrManSelect()` which already exists in `master`. I did that in order to be sure that everything else is _identical_: the way addrman is filled, `minEpochIterations(300)` and the `GetPort()` call. Way too many times I have been bitten by chasing noise in benchmarks, so I wanted to be sure that this is the only difference in the two things I am comparing:\r\n\r\n```cpp\r\n#if 0 // flip to 1 to test the other case\r\n        addrman.Select(/*new_only=*/false);\r\n#else\r\n        addrman.Select(/*new_only=*/false, NET_I2P);\r\n#endif\r\n```\r\n\r\n> also happy to discuss 2 further, but a question there - does it feel relevant to these patches to improve performance, or is it an orthogonal improvement\r\n\r\nI think the performance improvement would be a nice addition to the work done by this PR (or maybe even a \"must have\"?)\r\n\r\n> (since we see similar worst cases right now)?\r\n\r\nHmm? Now on `master` on mainnet it takes 0.18 microseconds and with this PR on mainnet it will take 6000 microseconds. That is the average case (averaged by the benchmark executing `Select` about 3500 times). The difference in the worst case is even more pronounced.",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T10:40:18Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136853031",
      "id" : 1136853031,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585DwwAn",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1341141202,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T10:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136869429"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, but I am not saying to do it (use `std::array` and `.at()`). It is just an option, in case you have not considered it. Up to you.\r\n\r\nBtw, a difference between an `assert()` and `.at()` is that the former will call `abort()` and will inevitably cause the program to exit. OTOH `.at()` will throw `std::out_of_range` which the caller can catch and continue the execution. I don't have a strong opinion which one is more preferable to use here. Maybe either one is ok. Usually on such \"programmer error\" we want to really stop the whole program, OTOH `.at()` is much more elegant to write :) and if the exception is unhandled then it will also cause the program to exit.",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T10:54:20Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136869429",
      "id" : 1136869429,
      "in_reply_to_id" : 1129439158,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585Dw0A1",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 805,
      "original_position" : 163,
      "original_start_line" : 802,
      "path" : "src/addrman.cpp",
      "position" : 162,
      "pull_request_review_id" : 1341177551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 801,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-15T10:54:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136880077"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Oh, yes, now it makes sense! I was confused. I should have read the comment like:\r\n\"ensure that the new table gets selected even if new_only is false _(because the tried table is empty)_\"",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T11:03:24Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136880077",
      "id" : 1136880077,
      "in_reply_to_id" : 1130754068,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dw2nN",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1341203111,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-15T11:03:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136890366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes. Also std methods that take such \"indexes\" are usually `size_t`, e.g. https://en.cppreference.com/w/cpp/container/array/operator_at",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T11:12:37Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136890366",
      "id" : 1136890366,
      "in_reply_to_id" : 1129442167,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dw5H-",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1341228747,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T11:12:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137099484"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Where?",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T13:46:01Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137099484",
      "id" : 1137099484,
      "in_reply_to_id" : 1130705627,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DxsLc",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 226,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1341539035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T13:46:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137181909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think so, thanks!",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T14:32:05Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137181909",
      "id" : 1137181909,
      "in_reply_to_id" : 1130664213,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DyATV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 200,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1341641215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T14:32:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137526957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Hmm? Now on master on mainnet it takes 0.18 microseconds and with this PR on mainnet it will take 6000 microseconds. That is the average case (averaged by the benchmark executing Select about 3500 times). The difference in the worst case is even more pronounced.\r\n\r\nWe might be using slightly different terminology here: With \"worst case\", I mean the edge case where we have just one entry in AddrMan of the kind of address that we want. This is the benchmark `AddrManSelectFromAlmostEmpty` for unspecific selection and `AddrManSelectByNetwork` for network-specific selection. \r\n>#if 0 // flip to 1 to test the other case\r\n        addrman.Select(/*new_only=*/false);\r\n#else\r\n        addrman.Select(/*new_only=*/false, NET_I2P);\r\n#endif\r\n\r\nThis is not a meaningful comparison, because the first case is picking from an almost full AddrMan (\"best case\"), and the second case is the \"worst case\". If you replace `NET_I2P` by `NET_IPV4` in that example, I'd expect the network-specific performance to be basically identical to that of unspecific `Select()`, because AddrMan contains a single I2P address and ~50k IPV4 addresses in your setup.\r\n\r\nFluctuations due to RNG randomness within a given benchmark shouldn't be called \"worst case\" in my opinion, especially because there is no lower limit with the way `Select_()` currently works: for a given RNG seed, we might not visit the required bucket \"forever\" even if the probability for that will go to zero so quickly that it will never happen - there just is no distinct lower bound we could call \"worst case\" because it's probabilistic).\r\n\r\n> Yes, that slows down a bit the fast `Select()` (any network is ok).\r\n\r\nThe crucial question is by how much, because situations close to the \"worst case\" should be rather infrequent, while situations where we have multiple addresses to choose from should me much more common. With all the different methods of getting addresses, after a while of running your node you should at least know a couple dozens of addresses for each reachable network (even for CJDNS?!).\r\nSo there is the possibility that we might be optimizing for an edge case that is encountered very infrequently in the wild, while slightly slowing down the frequently encountered case at the same time. In this case, the change could be detrimental for performance overall!\r\n\r\nI'm not saying this would be the case here, but I want to do some more in-depth benchmarking myself later this week to convince myself a bit more that this would really be a clear performance improvement overall.",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T17:48:50Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137526957",
      "id" : 1137526957,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585DzUit",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1342072709,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T18:07:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1138102842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yeah, just to clarify- the tried table doesn't have to be empty, it just needs to have no matches for the specific network. I tried to capture that in the beginning of the comment: \"since the only ipv4 address is on the new table\", but let me know if there's something else that would help make that more clear",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-16T04:29:45Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1138102842",
      "id" : 1138102842,
      "in_reply_to_id" : 1130754068,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585D1hI6",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1342882508,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-16T04:29:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140727315"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I compared the performance of the PR branch with @vasild's [suggested optimization](https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513) (\"VD\") a bit more closely:\r\n\r\n**Test 1**: Reasonably full addrman (15k addresses): `./bench_bitcoin -filter=AddrManSelect -min-time=5000`\r\n=> The PR is much faster, since VD has a constant overhead due to the shuffling.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              142.41 |        7,021,818.47 |    0.2% |      5.50 | `AddrManSelect`    \r\n|              145.75 |        6,860,921.17 |    0.4% |      5.63 | `AddrManSelect`\r\n|              145.91 |        6,853,404.83 |    1.4% |      5.55 | `AddrManSelect`\r\n|              149.78 |        6,676,385.78 |    3.7% |      5.63 | `AddrManSelect`\r\n|              144.37 |        6,926,771.77 |    0.3% |      5.49 | `AddrManSelect`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           12,716.43 |           78,638.44 |    0.1% |      5.49 | `AddrManSelect`\r\n|           12,790.84 |           78,180.95 |    0.8% |      5.36 | `AddrManSelect`\r\n|           12,884.37 |           77,613.41 |    0.7% |      5.53 | `AddrManSelect`\r\n|           12,815.30 |           78,031.72 |    0.9% |      5.52 | `AddrManSelect`\r\n|           12,961.91 |           77,149.10 |    1.3% |      5.55 | `AddrManSelect`\r\n</details>\r\n\r\n\r\n<br />\r\n\r\n**Test 2**: A single address in AddrMan:  \r\n`bench_bitcoin -filter=AddrManSelectFromAlmostEmpty -min-time=5000`\r\n=> VD is faster by  a factor of 1.8\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           93,286.28 |           10,719.69 |    2.2% |      5.42 | `AddrManSelectFromAlmostEmpty`\r\n|           90,781.42 |           11,015.47 |    1.0% |      5.52 | `AddrManSelectFromAlmostEmpty`\r\n|           92,758.06 |           10,780.73 |    1.2% |      5.57 | `AddrManSelectFromAlmostEmpty`\r\n|           90,026.20 |           11,107.88 |    0.7% |      5.52 | `AddrManSelectFromAlmostEmpty`\r\n|           91,946.89 |           10,875.84 |    1.1% |      5.47 | `AddrManSelectFromAlmostEmpty`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           55,306.93 |           18,080.92 |    0.7% |      5.50 | `AddrManSelectFromAlmostEmpty`\r\n|           55,209.86 |           18,112.71 |    0.4% |      5.48 | `AddrManSelectFromAlmostEmpty`\r\n|           54,989.61 |           18,185.25 |    0.5% |      5.51 | `AddrManSelectFromAlmostEmpty`\r\n|           56,727.70 |           17,628.07 |    2.1% |      5.57 | `AddrManSelectFromAlmostEmpty`\r\n|           55,732.54 |           17,942.84 |    0.5% |      5.50 | `AddrManSelectFromAlmostEmpty`\r\n</details>\r\n\r\n**Test 3**: Three addresses in AddrMan:  set `NUM_SOURCES = 3`, `NUM_ADDRESSES_PER_SOURCE=1` then run \r\n`./bench_bitcoin -filter=AddrManSelect -min-time=5000`\r\n=> PR is slightly faster.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           30,034.99 |           33,294.50 |    0.7% |      5.51 | `AddrManSelect`\r\n|           30,370.28 |           32,926.92 |    1.1% |      5.17 | `AddrManSelect`\r\n|           30,574.52 |           32,706.98 |    2.1% |      5.20 | `AddrManSelect`\r\n|           29,883.53 |           33,463.25 |    0.7% |      5.52 | `AddrManSelect`\r\n|           29,944.31 |           33,395.33 |    0.5% |      5.52 | `AddrManSelect`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           34,126.18 |           29,303.02 |    0.7% |      5.30 | `AddrManSelect`\r\n|           34,660.26 |           28,851.49 |    0.9% |      5.32 | `AddrManSelect`\r\n|           34,075.81 |           29,346.33 |    0.7% |      5.30 | `AddrManSelect`\r\n|           34,628.06 |           28,878.31 |    1.3% |      5.36 | `AddrManSelect`\r\n|           34,300.57 |           29,154.03 |    0.6% |      5.31 | `AddrManSelect`\r\n</details>\r\n\r\n**Test 4**:\r\nQuery for a single network-specific address in an AddrMan filled with 15k IPV4 addresses we don't want\r\n`./bench_bitcoin -filter=AddrManSelectByNetwork -min-time=5000`\r\n=> VD is faster by a factor of ~2.1.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|        1,256,860.84 |              795.63 |    4.4% |      5.40 | `AddrManSelectByNetwork`\r\n|        1,269,322.70 |              787.82 |    2.6% |      5.50 | `AddrManSelectByNetwork`\r\n|        1,242,639.25 |              804.74 |    1.9% |      5.56 | `AddrManSelectByNetwork`\r\n|        1,246,311.65 |              802.37 |    2.9% |      5.69 | `AddrManSelectByNetwork`\r\n|        1,265,535.68 |              790.18 |    3.4% |      5.59 | `AddrManSelectByNetwork`\r\n\r\nVD\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          560,818.30 |            1,783.11 |    1.0% |      5.56 | `AddrManSelectByNetwork`\r\n|          558,351.91 |            1,790.99 |    0.9% |      5.53 | `AddrManSelectByNetwork`\r\n|          600,536.33 |            1,665.18 |    4.8% |      5.38 | `AddrManSelectByNetwork`\r\n|          569,208.08 |            1,756.83 |    1.7% |      5.45 | `AddrManSelectByNetwork`\r\n|          581,860.03 |            1,718.63 |    2.3% |      5.47 | `AddrManSelectByNetwork`\r\n</details>\r\n\r\n**Test 5**:\r\nQuery for 20 network-specific address in an AddrMan filled with 15k IPV4 addresses we don't want (changing the code a bit)\r\n`./bench_bitcoin -filter=AddrManSelectByNetwork -min-time=5000`\r\n=> Performance is approximately the same.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          109,388.10 |            9,141.76 |    1.6% |      5.40 | `AddrManSelectByNetwork`\r\n|          108,804.63 |            9,190.79 |    2.1% |      5.56 | `AddrManSelectByNetwork`\r\n|          111,333.16 |            8,982.05 |    2.0% |      5.61 | `AddrManSelectByNetwork`\r\n|          110,827.61 |            9,023.02 |    1.4% |      5.55 | `AddrManSelectByNetwork`\r\n|          122,518.06 |            8,162.06 |    1.4% |      5.47 | `AddrManSelectByNetwork`\r\n\r\nVD\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          106,806.78 |            9,362.70 |    2.5% |      5.51 | `AddrManSelectByNetwork`\r\n|          109,221.66 |            9,155.69 |    3.1% |      5.59 | `AddrManSelectByNetwork`\r\n|          107,870.77 |            9,270.35 |    3.8% |      5.41 | `AddrManSelectByNetwork`\r\n|          105,131.17 |            9,511.93 |    0.5% |      5.47 | `AddrManSelectByNetwork`\r\n|          106,080.47 |            9,426.81 |    1.2% |      5.48 | `AddrManSelectByNetwork`\r\n\r\n</details>\r\n\r\nIn conclusion, my results indicate that the suggested optimization is only faster in some specific scenarios because the pre-shuffling of the buckets adds a constant overhead that is not neglible:\r\nIn the case of non-network specific queries (which should be the bulk even after #27213 ), the PR is already faster when `AddrMan` has more than 3 addresses (which should virtually always be the case!)\r\nIn the case of network-specific queries, the tipping point is (because of the additional cost of looking up addrs in buckets that we can't use) at ~20 network-specific addresses (with 15k IPV4 addresses). This is a bit higher, but I would imagine that we should get more than 20 addresses of most alternative networks rather quickly.\r\nTo summarize, my results indicate that adding pre-shuffling AddrMan buckets to prevent repeated visits appears to be no clear performance improvement - in most cases, performance would go down.\r\n\r\n@vasild: Do you see similar numbers?\r\n",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-17T21:30:32Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140727315",
      "id" : 1140727315,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585D_h4T",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1346757351,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-18T00:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140873089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873089"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "maybe I was thinking of `BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_I2P).first.IsValid());`? \r\n\r\nnot sure, I [added](https://github.com/bitcoin/bitcoin/compare/09d514583f15860f3bc7ae0c89e640c94fae3c71..17e705428ddf80c7a7f31fe5430d966cf08a37d6#diff-34d1a0e093152df355fc3a6b5b06156f7a9b936bfffb26bb221e62828e44532fR211) `BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_CJDNS).first.IsValid());` for real this time ð ",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-18T01:05:54Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140873089",
      "id" : 1140873089,
      "in_reply_to_id" : 1130705627,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EAFeB",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 226,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1346856516,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873089/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-18T01:05:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140873566"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873566"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "opted for the simple assertions because its less invasive & I didn't feel like there was a big advantage of switching over",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-18T01:06:51Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140873566",
      "id" : 1140873566,
      "in_reply_to_id" : 1129439158,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EAFle",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 809,
      "original_position" : 163,
      "original_start_line" : 802,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1346856667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873566/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-18T01:06:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873566",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "two small updates:\r\n- added assertions for bounds checking in `GetEntry`\r\n- added the suggested test",
      "created_at" : "2023-03-18T01:10:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1474557343",
      "id" : 1474557343,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
      "node_id" : "IC_kwDOABII585X4_Wf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1474557343/reactions"
      },
      "updated_at" : "2023-03-18T01:10:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1474557343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1147633787"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147633787"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Just a suggestion to make the code a lit bit cleaner in case you have to touch it again, perhaps we don't need to create `position` and `nId` again after the loop.\r\n\r\n```diff\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex cdfd079fc..30ce2cadc 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -757,10 +757,10 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n \r\n         // Iterate over the positions of that bucket, starting at the initial one,\r\n         // and looping around.\r\n-        int i;\r\n+        int i, position, node_id;\r\n         for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\r\n-            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n-            int node_id = GetEntry(search_tried, bucket, position);\r\n+            position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n+            node_id = GetEntry(search_tried, bucket, position);\r\n             if (node_id != -1) {\r\n                 if (network.has_value()) {\r\n                     const auto it{mapInfo.find(node_id)};\r\n@@ -777,9 +777,7 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n         if (i == ADDRMAN_BUCKET_SIZE) continue;\r\n \r\n         // Find the entry to return.\r\n-        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n-        int nId = GetEntry(search_tried, bucket, position);\r\n-        const auto it_found{mapInfo.find(nId)};\r\n+        const auto it_found{mapInfo.find(node_id)};\r\n         assert(it_found != mapInfo.end());\r\n         const AddrInfo& info{it_found->second};\r\n```",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-24T14:11:43Z",
      "diff_hunk" : "@@ -714,72 +714,98 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network.has_value()) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if (new_count + tried_count == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    // Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1147633787",
      "id" : 1147633787,
      "line" : 760,
      "node_id" : "PRRC_kwDOABII585EZ4B7",
      "original_commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_line" : 760,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 115,
      "pull_request_review_id" : 1356788467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147633787/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-24T14:37:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147633787",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1147671339"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147671339"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "About the optimization in https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513, couldn't we simply use a vector to store the visited buckets?\r\n\r\njust an example:\r\n```cpp\r\n  std::vector<int> buckets_visited;\r\n  while (1) {\r\n      // Pick a bucket, and an initial position in that bucket.\r\n      int bucket = insecure_rand.randrange(bucket_count);\r\n      if (std::find(buckets_visited.begin(), buckets_visited.end(), bucket) != buckets_visited.end()) {\r\n          continue;\r\n      } else {\r\n          buckets_visited.push_back(bucket);\r\n      }\r\n```\r\n\r\nAlso, I ran same tests that @mzumsande did and got similar results.",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-24T14:36:47Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1147671339",
      "id" : 1147671339,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585EaBMr",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1356842496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147671339/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-24T14:36:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147671339",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1148304529"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148304529"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@mzumsande, I think you are missing my point, let me try to rephrase it: now on `master`, from `ThreadOpenConnections()` we call `Select()`. With the parent of this PR, we will be calling `Select(network)` which will bring some security (good) + some slowdown (bad).\r\n\r\nTry to asses how much is the slowdown. Use a full addrman (15k is not full) because that is what people out there are running on. If the slowdown is ok, then no further improvements are necessary on this PR or its parent.\r\n\r\nWhat is your \"Test 5\" doing? Does it call 20 times `Select(network)`?\r\n\r\nFurther thoughts if an improvement of performance of `Select(network)` is deemed necessary:\r\n* The shuffling can be done only if `network` is provided, to avoid slowing down of `Select()` without a network.\r\n* The shuffling can be removed altogether and just marking the buckets as boring to be left. This should still improve the 600k iterations in the worst case I observed.\r\n* The ultimate beast solution would be to have an index per network, e.g. `std::unordered_set<size_t> positions_in_vRandom_of_i2p_addresses`.\r\n\r\nI will try to compare on a snapshot of an addrman from my public full node, not on artificially filled addrman from the bench. Last time I checked it had ~70k addresses and also it will have at least a bunch of addresses from each network, not just 1 address. That would be more representative.",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-25T04:51:40Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1148304529",
      "id" : 1148304529,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585EcbyR",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1357774569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148304529/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-25T04:51:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148304529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1148307887"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148307887"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@brunoerg, yes, that should still bring some improvement. But only push it into the vector if we have visited all addresses in that bucket and found 0 from the requested network because it may happen that we visit a bucket with an address from the requested network, but only pick it up on some of the subsequent iterations, not from the first one. Change it to `std::unordered_set` so that lookup is fast (`O(1)`).",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-25T05:22:50Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1148307887",
      "id" : 1148307887,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585Eccmv",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1357777412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148307887/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-25T05:22:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148307887",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149579411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149579411"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Last time I checked it had ~70k addresses and also it will have at least a bunch of addresses from each network, not just 1 address.\r\n\r\n\"bunch of addresses from each network\", how much? Last time I checked my node (running with multiple networks) I remembered that the number of i2p addresses were so small compared to clearnet, for example.",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-27T17:27:04Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149579411",
      "id" : 1149579411,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585EhTCT",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1359554205,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149579411/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T17:27:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149579411",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149603943"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149603943"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> \"bunch of addresses from each network\", how much?\r\n\r\nIf helpful, my node knows 15k Tor, 1.2k I2P and 8 CJDNS recently active peers ATM for a bit more than 16k total non-clearnet peers.",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-27T17:51:04Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149603943",
      "id" : 1149603943,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585EhZBn",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1359589822,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149603943/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T17:51:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149603943",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149737863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149737863"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Try to asses how much is the slowdown. Use a full addrman (15k is not full) because that is what people out there are running on. If the slowdown is ok, then no further improvements are necessary on this PR or its parent.\r\n\r\nagreed that this is the fundamental thing we are trying to evaluate - is the performance difference significant & acceptable\r\n\r\n> I will try to compare on a snapshot of an addrman from my public full node, not on artificially filled addrman from the bench. Last time I checked it had ~70k addresses and also it will have at least a bunch of addresses from each network, not just 1 address. That would be more representative.\r\n\r\nwould be awesome if you could compare based on your addrman snapshot from mainnet! \r\n\r\nmy understanding of martin's benches is its trying to observe \"normal\" as well as \"worst case\". so the examples with 1 address are aiming towards \"worst case\". but of course \"normal\" would vary widely from node to node.",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-27T20:05:30Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149737863",
      "id" : 1149737863,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585Eh5uH",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1359793696,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149737863/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T20:05:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149737863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149790004"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149790004"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> What is your \"Test 5\" doing? Does it call 20 times `Select(network)`?\r\n\r\nNo, it calls `Select(network)` for an addrman that has 20 addresses of the selected network.\r\n\r\nI'll try to explain the idea behind my benchmarks better: \r\nStarting point is the observation that the suggested change makes `Select` slower if we already know a lot of addresses of the desired type, while making it faster if addrman has very few addresses of this type. This is true for botch `Select()` and `Select(network)`, which is why it is not obvious at first sight if the suggestion is an overall performance improvement or a degradation. \r\n\r\nSo my idea was to find the cutoff - how many addresses do we need such that both algorithms are equally fast - in situations where we have more addrs than this, the change would be a slowdown, when we have less it's a speedup. This cutoff turned out to be very small for `Select()` (3 addresses), while being a bit larger for `Select(network)` - it was approximately 20. It would be helpful to know how things change with a full addrman!\r\n\r\nSo if we used an addrman with counts similar to those reported by @jonatack, my results would suggest that the pre-shufffling change suggested [here](https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513) would be a speedup for CJDNS-specific queries, while being a slowdown for clearnet, onion, i2p and unspecific queries (all compared to this PR).",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-27T21:04:50Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149790004",
      "id" : 1149790004,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585EiGc0",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1359870138,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149790004/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:04:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149790004",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1153482086"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153482086"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I ran this on a mainnet `peers.dat`:\r\n```\r\naddrman size total: 72947\r\naddrman size IPv4:  47252\r\naddrman size IPv6:  11491\r\naddrman size Tor:   13305\r\naddrman size I2P:   893\r\naddrman size CJDNS: 6\r\n```\r\n\r\n<details>\r\n<summary>[patch] How to load /tmp/peers.dat from bench_bitcoin</summary>\r\n\r\n```diff\r\ndiff --git i/src/bench/addrman.cpp w/src/bench/addrman.cpp\r\nindex 8a5cab443f..b8ec4a4071 100644\r\n--- i/src/bench/addrman.cpp\r\n+++ w/src/bench/addrman.cpp\r\n@@ -1,17 +1,22 @@\r\n // Copyright (c) 2020-2022 The Bitcoin Core developers\r\n // Distributed under the MIT software license, see the accompanying\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n+#include <addrdb.h>\r\n #include <addrman.h>\r\n #include <bench/bench.h>\r\n+#include <chainparams.h>\r\n+#include <chainparamsbase.h>\r\n #include <netbase.h>\r\n #include <netgroup.h>\r\n #include <random.h>\r\n #include <util/check.h>\r\n+#include <util/system.h>\r\n #include <util/time.h>\r\n+#include <util/translation.h>\r\n \r\n #include <optional>\r\n #include <vector>\r\n \r\n /* A \"source\" is a source address from which we have received a bunch of other addresses. */\r\n \r\n@@ -21,12 +26,23 @@ static constexpr size_t NUM_ADDRESSES_PER_SOURCE = 256;\r\n static NetGroupManager EMPTY_NETGROUPMAN{std::vector<bool>()};\r\n static constexpr uint32_t ADDRMAN_CONSISTENCY_CHECK_RATIO{0};\r\n \r\n static std::vector<CAddress> g_sources;\r\n static std::vector<std::vector<CAddress>> g_addresses;\r\n \r\n+std::unique_ptr<AddrMan> LoadAddrmanFromPeersDat()\r\n+{\r\n+    SelectBaseParams(\"main\");\r\n+    SelectParams(\"main\");\r\n+    gArgs.ForceSetArg(\"-datadir\", \"/tmp\");\r\n+    std::unique_ptr<AddrMan> addrman;\r\n+    auto err = LoadAddrman(EMPTY_NETGROUPMAN, gArgs, addrman);\r\n+    assert(!err.has_value());\r\n+    return addrman;\r\n+}\r\n+\r\n static void CreateAddresses()\r\n {\r\n     if (g_sources.size() > 0) { // already created\r\n         return;\r\n     }\r\n \r\n@@ -69,19 +85,12 @@ static void FillAddrMan(AddrMan& addrman)\r\n {\r\n     CreateAddresses();\r\n \r\n     AddAddressesToAddrMan(addrman);\r\n }\r\n \r\n-static CNetAddr ResolveIP(const std::string& ip)\r\n-{\r\n-    CNetAddr addr;\r\n-    LookupHost(ip, addr, false);\r\n-    return addr;\r\n-}\r\n-\r\n static CService ResolveService(const std::string& ip, uint16_t port = 0)\r\n {\r\n     CService serv;\r\n     Lookup(ip, serv, port, false);\r\n     return serv;\r\n }\r\n@@ -125,26 +134,24 @@ static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\r\n         (void)addrman.Select();\r\n     });\r\n }\r\n \r\n static void AddrManSelectByNetwork(benchmark::Bench& bench)\r\n {\r\n-    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\r\n-\r\n-    // add single I2P address to new table\r\n-    CService i2p_service;\r\n-    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\r\n-    CAddress i2p_address(i2p_service, NODE_NONE);\r\n-    i2p_address.nTime = Now<NodeSeconds>();\r\n-    CNetAddr source = ResolveIP(\"252.2.2.2\");\r\n-    addrman.Add({i2p_address}, source);\r\n-\r\n-    FillAddrMan(addrman);\r\n+    auto addrman = LoadAddrmanFromPeersDat();\r\n+    std::cout << \"addrman size total: \" << addrman->Size() << std::endl\r\n+              << \"addrman size IPv4:  \" << addrman->Size(NET_IPV4) << std::endl\r\n+              << \"addrman size IPv6:  \" << addrman->Size(NET_IPV6) << std::endl\r\n+              << \"addrman size Tor:   \" << addrman->Size(NET_ONION) << std::endl\r\n+              << \"addrman size I2P:   \" << addrman->Size(NET_I2P) << std::endl\r\n+              << \"addrman size CJDNS: \" << addrman->Size(NET_CJDNS) << std::endl;\r\n \r\n     bench.run([&] {\r\n-        (void)addrman.Select(/*new_only=*/false, NET_I2P);\r\n+        //addrman->Select(/*new_only=*/false);\r\n+        //addrman->Select(/*new_only=*/false, NET_I2P);\r\n+        addrman->Select(/*new_only=*/false, NET_CJDNS);\r\n     });\r\n }\r\n \r\n static void AddrManGetAddr(benchmark::Bench& bench)\r\n {\r\n     AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\r\n```\r\n</details>\r\n\r\nResults:\r\n\r\n* `Select(/*new_only=*/false)`: 0.265 microseconds, this is what `master` is doing before this PR\r\n\r\nAfter this PR:\r\n\r\n* `Select(/*new_only=*/false, NET_IPV4)`: 0.5 microseconds\r\n* `Select(/*new_only=*/false, NET_IPV6)`:  1.7 microseconds\r\n* `Select(/*new_only=*/false, NET_ONION)`: 3.1 microseconds\r\n* `Select(/*new_only=*/false, NET_I2P)`: 27 microseconds\r\n* `Select(/*new_only=*/false, NET_CJDNS)`: 1600 microseconds\r\n\r\nIs this slowdown acceptable? Maybe yes. We don't call `Select` in a tight loop, so maybe even the 1600 microseconds is ok.\r\n\r\nWhat happens if we mark and subsequently skip buckets we have seen to contain 0 interesting addresses, without the shuffling? I guess that should bring most of the improvement from the above patch without the downside of the shuffling. Here is the change on top of this PR:\r\n\r\n<details>\r\n<summary>[patch] Skip boring</summary>\r\n\r\n```diff\r\ndiff --git i/src/addrman.cpp w/src/addrman.cpp\r\nindex cdfd079fcd..46f4de99be 100644\r\n--- i/src/addrman.cpp\r\n+++ w/src/addrman.cpp\r\n@@ -747,15 +747,19 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n     }\r\n \r\n     const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n     // Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n+    std::unordered_set<int> already_visited_and_boring_buckets;\r\n     while (1) {\r\n         // Pick a bucket, and an initial position in that bucket.\r\n         int bucket = insecure_rand.randrange(bucket_count);\r\n+        if (already_visited_and_boring_buckets.count(bucket) > 0) {\r\n+            continue;\r\n+        }\r\n         int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\r\n \r\n         // Iterate over the positions of that bucket, starting at the initial one,\r\n         // and looping around.\r\n         int i;\r\n         for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\r\n@@ -770,14 +774,19 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n                 } else {\r\n                     break;\r\n                 }\r\n             }\r\n         }\r\n \r\n-        // If the bucket is entirely empty, start over with a (likely) different one.\r\n-        if (i == ADDRMAN_BUCKET_SIZE) continue;\r\n+        // Start over with a different bucket if this one is entirely empty or\r\n+        // specific network was requested and it does not contain any addresses\r\n+        // from that network.\r\n+        if (i == ADDRMAN_BUCKET_SIZE) {\r\n+            already_visited_and_boring_buckets.insert(bucket);\r\n+            continue;\r\n+        }\r\n \r\n         // Find the entry to return.\r\n         int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n         int nId = GetEntry(search_tried, bucket, position);\r\n         const auto it_found{mapInfo.find(nId)};\r\n         assert(it_found != mapInfo.end());\r\n```\r\n</details>\r\n\r\nResult for `NET_CJDNS` where the slowdown is most pronounced: 1200 microseconds (vs 1600). Those numbers are averaged over many runs and they do not tell the whole story. Here are the distributions without \"skip boring\" (the height of a bar indicates how many addresses were checked before finding the result, e.g. if the bar that spans between 2500 and 3500 is tall 280, it means 280 of the runs checked 2500-3500 addresses before finding the result).\r\n\r\n![1](https://user-images.githubusercontent.com/266751/228896184-9e5fe576-8c0f-44d2-9f3d-f7061ac936e3.png)\r\n\r\nwith \"skip boring\":\r\n\r\n![2](https://user-images.githubusercontent.com/266751/228896576-20b8cc6d-a121-4836-b727-adc04079a55d.png)\r\n",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-03-30T16:04:54Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1153482086",
      "id" : 1153482086,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585EwL1m",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1365462147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153482086/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-30T16:04:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153482086",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1159230852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159230852"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't see why 1.6 milliseconds to choose an address would be a concern.",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-04-06T02:47:54Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1159230852",
      "id" : 1159230852,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585FGHWE",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1373978659,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159230852/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T02:47:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159230852",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1159242540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159242540"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "A simpler approach to skipping already tried buckets might be something like this:\r\n\r\n```c++\r\n    int n = 1 << 8; // power of 2\r\n    int initial_pos = random(n);\r\n    int step = random(n/2) * 2 + 1; // odd number\r\n    int i = initial_pos;\r\n    do {\r\n        if (check_bucket(i)) break;\r\n        i = (i + step) % n; // oops, try a new bucket\r\n    } while (i != initial_pos);\r\n```\r\n\r\nThat doesn't need a full shuffle, still hits every bucket, and only hits each bucket once (provided step and n are co-prime).\r\n\r\nBased on vasild's stats above, I think this is fine to merge without any improvement here, but it might be interesting to rebench with this approach -- performance should benefit a little from needing less randomness as well as avoiding repeated work...\r\n\r\nIf we wanted to making things actually reliably fast for cjdns-like networks lost in a sea of ipv4 addresses, then having separate addrman tables for each network might be worth exploring. That would probably help prevent an attacker from blocking valid ipv4 addresses with a mass of valid-but-sybiled tor addresses, which might be worthwhile.",
      "commit_id" : "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "created_at" : "2023-04-06T03:16:47Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1159242540",
      "id" : 1159242540,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585FGKMs",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1373996210,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159242540/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T03:16:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159242540",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks for the reviews! I'll address the outstanding comments in a followup ",
      "created_at" : "2023-04-17T21:51:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1512128741",
      "id" : 1512128741,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
      "node_id" : "IC_kwDOABII585aIUDl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1512128741/reactions"
      },
      "updated_at" : "2023-04-17T21:51:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1512128741",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This will be merged after branch-off. It would be good to either get the follow up opened in advance, so we can avoid any time between merging, and the potential for intermittent CI failures, or, if that change is straight-forward enough, you could push an additional commit here, leaving the rest of the branch as-is.",
      "created_at" : "2023-04-18T08:27:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1512672126",
      "id" : 1512672126,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
      "node_id" : "IC_kwDOABII585aKYt-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1512672126/reactions"
      },
      "updated_at" : "2023-04-18T08:27:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1512672126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   }
]
