[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#25572](https://github.com/bitcoin/bitcoin/pull/25572) (refactor: Introduce EvictionManager and use it for the inbound eviction logic by dergoegge)\n* [#24545](https://github.com/bitcoin/bitcoin/pull/24545) (BIP324: Enable v2 P2P encrypted transport by dhruv)\n* [#24170](https://github.com/bitcoin/bitcoin/pull/24170) (p2p, rpc: Manual block-relay-only connections with addnode by mzumsande)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-06-30T19:50:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1171614818",
      "id" : 1171614818,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585F1Wxi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1171614818/reactions"
      },
      "updated_at" : "2022-10-06T15:05:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1171614818",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Obvious concept ACK from me. This was one of the big motivators for #19398.",
      "created_at" : "2022-07-04T07:51:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1173474399",
      "id" : 1173474399,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585F8cxf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1173474399/reactions"
      },
      "updated_at" : "2022-07-04T07:51:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1173474399",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-07-04T21:06:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1174361336",
      "id" : 1174361336,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585F_1T4",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1174361336/reactions"
      },
      "updated_at" : "2022-07-04T21:06:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1174361336",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Nice, concept ACK",
      "created_at" : "2022-07-05T16:03:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1175229773",
      "id" : 1175229773,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585GDJVN",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1175229773/reactions"
      },
      "updated_at" : "2022-07-05T16:03:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1175229773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-07-12T15:14:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1181888851",
      "id" : 1181888851,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585GcjFT",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1181888851/reactions"
      },
      "updated_at" : "2022-07-12T15:14:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1181888851",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This PR is ready for review!",
      "created_at" : "2022-07-19T12:26:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1188989697",
      "id" : 1188989697,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585G3osB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1188989697/reactions"
      },
      "updated_at" : "2022-07-19T12:26:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1188989697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, light code review ACK 87fd3609ba87a74fa6ca74c56ffbdb39fd941ebf",
      "created_at" : "2022-08-25T08:10:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1226927000",
      "id" : 1226927000,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585JIWuY",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1226927000/reactions"
      },
      "updated_at" : "2022-08-25T08:10:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1226927000",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2022-09-14T13:25:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1246762839",
      "id" : 1246762839,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585KUBdX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1246762839/reactions"
      },
      "updated_at" : "2022-09-14T13:25:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1246762839",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2022-10-04T12:40:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1266933218",
      "id" : 1266933218,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585Lg93i",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1266933218/reactions"
      },
      "updated_at" : "2022-10-04T12:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1266933218",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-10-14T14:05:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#issuecomment-1279056559",
      "id" : 1279056559,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25515",
      "node_id" : "IC_kwDOABII585MPNqv",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1279056559/reactions"
      },
      "updated_at" : "2022-10-14T14:05:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1279056559",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r996975101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/996975101"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe I am missing something, but shouldn't this be `sending message %s to peer %d`?? ",
      "commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "created_at" : "2022-10-17T12:03:30Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"received message %s from peer %d\", msg.m_type, pnode->GetId()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r996975101",
      "id" : 996975101,
      "line" : 87,
      "node_id" : "PRRC_kwDOABII5847bKH9",
      "original_commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 87,
      "pull_request_review_id" : 1144030805,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/996975101/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-17T12:30:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/996975101",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/36541669?v=4",
         "events_url" : "https://api.github.com/users/rajarshimaitra/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rajarshimaitra/followers",
         "following_url" : "https://api.github.com/users/rajarshimaitra/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rajarshimaitra/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rajarshimaitra",
         "id" : 36541669,
         "login" : "rajarshimaitra",
         "node_id" : "MDQ6VXNlcjM2NTQxNjY5",
         "organizations_url" : "https://api.github.com/users/rajarshimaitra/orgs",
         "received_events_url" : "https://api.github.com/users/rajarshimaitra/received_events",
         "repos_url" : "https://api.github.com/users/rajarshimaitra/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rajarshimaitra/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rajarshimaitra/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rajarshimaitra"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r996987379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/996987379"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n    // Ping metrics have not been updated on the CNode object, and there is a ping outstanding\r\n```",
      "commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "created_at" : "2022-10-17T12:17:05Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"received message %s from peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const\n+{\n+    std::vector<uint8_t> ser_msg_header;\n+    node.m_serializer->prepareForTransport(ser_msg, ser_msg_header);\n+\n+    bool complete;\n+    NodeReceiveMsgBytes(node, ser_msg_header, complete);\n+    NodeReceiveMsgBytes(node, ser_msg.data, complete);\n+    return complete;\n+}\n+\n+BOOST_FIXTURE_TEST_SUITE(peerman_tests, TestingSetup)\n+\n+static void SendMessage(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node, CSerializedNetMsg& msg)\n+{\n+    std::atomic<bool> interrupt{false};\n+    (void)connman.ReceiveMsgFrom(node, msg);\n+    node.fPauseSend = false;\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+    peerman.ProcessMessages(&node, interrupt);\n+    peerman.SendMessages(&node);\n+}\n+\n+using HandshakeHookFn = std::function<void(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node)>;\n+static void Handshake(\n+    ConnectionsInterfaceMock& connman, PeerManager& peerman,\n+    CNode& node, ServiceFlags their_services,\n+    HandshakeHookFn pre_verack_hook = [](ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node) {}) noexcept\n+{\n+    // Send version message\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_version{\n+        mm.Make(NetMsgType::VERSION,\n+                PROTOCOL_VERSION,                              // current p2p version\n+                Using<CustomUintFormatter<8>>(their_services), // their service flags\n+                GetTime(),                                     // dummy time\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // dummy\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // ignored\n+                uint64_t{1},                                   // dummy nonce\n+                std::string{},                                 // dummy subver\n+                int32_t{},                                     // dummy starting_height\n+                true),                                         // fRelay\n+    };\n+    SendMessage(connman, peerman, node, msg_version);\n+    BOOST_CHECK(!node.fDisconnect);\n+    BOOST_CHECK_EQUAL(node.nVersion, PROTOCOL_VERSION);\n+    BOOST_CHECK_EQUAL(node.GetCommonVersion(), PROTOCOL_VERSION);\n+    CNodeStateStats stats;\n+    bool ret = peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(ret, true);\n+    BOOST_CHECK_EQUAL(stats.their_services, their_services);\n+\n+    pre_verack_hook(connman, peerman, node);\n+\n+    // Send verack message\n+    CSerializedNetMsg msg_verack{mm.Make(NetMsgType::VERACK)};\n+    SendMessage(connman, peerman, node, msg_verack);\n+    BOOST_CHECK_EQUAL(node.fSuccessfullyConnected, true);\n+\n+    TestOnlyResetTimeData();\n+}\n+\n+BOOST_AUTO_TEST_CASE(version_handshake)\n+{\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode node{/*id=*/0, /*sock=*/nullptr, addr1, /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERSION], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::WTXIDRELAY], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDADDRV2], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERACK], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETADDR], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDCMPCT], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETHEADERS], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::FEEFILTER], 1);\n+\n+    peerman->FinalizeNode(node);\n+}\n+\n+static void CheckPingTimes(CNode& node, PeerManager& peerman,\n+                           std::chrono::microseconds min_ping_time, std::chrono::microseconds last_ping_time, std::chrono::microseconds ping_wait)\n+{\n+    // Check min and last ping times\n+    BOOST_CHECK_EQUAL(node.m_min_ping_time.load().count(), min_ping_time.count());\n+    BOOST_CHECK_EQUAL(node.m_last_ping_time.load().count(), last_ping_time.count());\n+\n+    // Check if and how long current ping has been pending\n+    CNodeStateStats stats;\n+    peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(stats.m_ping_wait.count(), ping_wait.count());\n+}\n+\n+static void SendPong(CNode& node, ConnectionsInterfaceMock& connman,\n+                     PeerManager& peerman, std::optional<int64_t> nonce = {})\n+{\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_pong = nonce ? mm.Make(NetMsgType::PONG, nonce.value()) : mm.Make(NetMsgType::PONG);\n+    SendMessage(connman, peerman, node, msg_pong);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ping)\n+{\n+    // See PING_INTERVAL in net_processing.cpp\n+    constexpr int64_t PING_INTERVAL{2 * 60};\n+\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CNode node{/*id=*/0, /*sock=*/nullptr, CAddress(), /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    // Use mock time to control pings from node\n+    SetMockTime(GetTime());\n+\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_TEST_MESSAGE(\"Advanced mocktime and check that ping is sent after connection is established\");\n+    AdvanceMockTime(1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::PING], 1);\n+\n+    // The ping nonce should be non-zero\n+    BOOST_CHECK(connman->m_ping_nonce != 0);\n+\n+    // No pong response has been received yet, and current ping is outstanding\n+    CheckPingTimes(node, *peerman, std::chrono::microseconds::max(), 0us, 1s);\n+\n+    BOOST_TEST_MESSAGE(\"Reply without nonce cancels ping\");\n+    SendPong(node, *connman, *peerman, std::nullopt);\n+\n+    // Ping metrics have not been updated on the CNode object, and there is no ping outstanding\n+    CheckPingTimes(node, *peerman, std::chrono::microseconds::max(), 0us, 0us);\n+\n+    BOOST_TEST_MESSAGE(\"Reply without ping\");\n+    SendPong(node, *connman, *peerman, 0);\n+\n+    // Ping metrics have not been updated on the CNode object, and there is no ping outstanding\n+    CheckPingTimes(node, *peerman, std::chrono::microseconds::max(), 0us, 0us);\n+\n+    // Wait for next ping\n+    AdvanceMockTime(PING_INTERVAL + 1);\n+    connman->m_message_types_sent[NetMsgType::PING] = 0;\n+    WITH_LOCK(NetEventsInterface::g_msgproc_mutex, peerman->SendMessages(&node));\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::PING], 1);\n+\n+    BOOST_TEST_MESSAGE(\"Reply with wrong nonce does not cancel ping\");\n+    SendPong(node, *connman, *peerman, connman->m_ping_nonce + 1);\n+    AdvanceMockTime(1);\n+\n+    // Ping metrics have not been updated on the CNode object, and there is a ping outstandgin",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r996987379",
      "id" : 996987379,
      "line" : 282,
      "node_id" : "PRRC_kwDOABII5847bNHz",
      "original_commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "original_line" : 282,
      "original_position" : 282,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 282,
      "pull_request_review_id" : 1144030805,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/996987379/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-17T12:30:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/996987379",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/36541669?v=4",
         "events_url" : "https://api.github.com/users/rajarshimaitra/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rajarshimaitra/followers",
         "following_url" : "https://api.github.com/users/rajarshimaitra/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rajarshimaitra/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rajarshimaitra",
         "id" : 36541669,
         "login" : "rajarshimaitra",
         "node_id" : "MDQ6VXNlcjM2NTQxNjY5",
         "organizations_url" : "https://api.github.com/users/rajarshimaitra/orgs",
         "received_events_url" : "https://api.github.com/users/rajarshimaitra/received_events",
         "repos_url" : "https://api.github.com/users/rajarshimaitra/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rajarshimaitra/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rajarshimaitra/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rajarshimaitra"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r999513116"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/999513116"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Do we need to pass in the `complete` flag here?? Seems like we are overriding it anyway into `node.ReceiveMsgBytes`.. So can't we just initiate it locally??",
      "commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "created_at" : "2022-10-19T14:09:54Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"received message %s from peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r999513116",
      "id" : 999513116,
      "line" : 102,
      "node_id" : "PRRC_kwDOABII5847k1wc",
      "original_commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : 100,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 102,
      "pull_request_review_id" : 1147655474,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/999513116/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 100,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-19T18:36:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/999513116",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/36541669?v=4",
         "events_url" : "https://api.github.com/users/rajarshimaitra/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rajarshimaitra/followers",
         "following_url" : "https://api.github.com/users/rajarshimaitra/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rajarshimaitra/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rajarshimaitra",
         "id" : 36541669,
         "login" : "rajarshimaitra",
         "node_id" : "MDQ6VXNlcjM2NTQxNjY5",
         "organizations_url" : "https://api.github.com/users/rajarshimaitra/orgs",
         "received_events_url" : "https://api.github.com/users/rajarshimaitra/received_events",
         "repos_url" : "https://api.github.com/users/rajarshimaitra/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rajarshimaitra/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rajarshimaitra/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rajarshimaitra"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1001774399"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001774399"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could you suggest a change? I don't understand what you mean.\r\n\r\n`complete` is passed by reference and modified by `ReceiveMsgBytes`.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-10-21T13:16:24Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"received message %s from peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1001774399",
      "id" : 1001774399,
      "in_reply_to_id" : 999513116,
      "line" : 102,
      "node_id" : "PRRC_kwDOABII5847td0_",
      "original_commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : 100,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 102,
      "pull_request_review_id" : 1150940516,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001774399/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 100,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-21T13:16:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001774399",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1001776338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001776338"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, `PushMessage` is called to send a message to a peer. Done.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-10-21T13:18:15Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"received message %s from peer %d\", msg.m_type, pnode->GetId()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1001776338",
      "id" : 1001776338,
      "in_reply_to_id" : 996975101,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5847teTS",
      "original_commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1150943430,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001776338/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-21T13:18:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001776338",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1001861582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001861582"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think we could simplify `ReceiveMsgBytes` by not passing `complete` as reference and using the `bool` that this function returns. Does it make sense?\r\n\r\n",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-10-21T14:32:20Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"received message %s from peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1001861582",
      "id" : 1001861582,
      "in_reply_to_id" : 999513116,
      "line" : 102,
      "node_id" : "PRRC_kwDOABII5847tzHO",
      "original_commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : 100,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 102,
      "pull_request_review_id" : 1151065564,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001861582/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 100,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-21T14:32:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1001861582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1002733109"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1002733109"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think I would retrace back my comment.. These signatures are part of the interface itself.. So there might be valid reasons for them.. \r\n\r\nThough it seems like we are ultimately dropping the `bool` here in test case in .. The only place its used is inside `NodeReceiveMsgBytes`. So at first look passing in a value that we are internally processing and then dropping in final return  (in the line `(void)connman.ReceiveMsgFrom(node, msg);`) was confusing me.. I am probably still confused but my suggestion doesn't make any sense as it will modify the interface.. ",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-10-23T16:06:46Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"received message %s from peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1002733109",
      "id" : 1002733109,
      "in_reply_to_id" : 999513116,
      "line" : 102,
      "node_id" : "PRRC_kwDOABII5847xH41",
      "original_commit_id" : "f98a4e8d891dd7374ef7dc4c723797bf0705075f",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : 100,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 102,
      "pull_request_review_id" : 1152330274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1002733109/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 100,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-23T16:06:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1002733109",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/36541669?v=4",
         "events_url" : "https://api.github.com/users/rajarshimaitra/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rajarshimaitra/followers",
         "following_url" : "https://api.github.com/users/rajarshimaitra/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rajarshimaitra/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rajarshimaitra",
         "id" : 36541669,
         "login" : "rajarshimaitra",
         "node_id" : "MDQ6VXNlcjM2NTQxNjY5",
         "organizations_url" : "https://api.github.com/users/rajarshimaitra/orgs",
         "received_events_url" : "https://api.github.com/users/rajarshimaitra/received_events",
         "repos_url" : "https://api.github.com/users/rajarshimaitra/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rajarshimaitra/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rajarshimaitra/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rajarshimaitra"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1003010273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1003010273"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason to duplicate this from the test util? Are there plans to de-duplicate this?",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-10-24T08:17:50Z",
      "diff_hunk" : "@@ -0,0 +1,188 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1003010273",
      "id" : 1003010273,
      "line" : 119,
      "node_id" : "PRRC_kwDOABII5847yLjh",
      "original_commit_id" : "bdfe134ed6b13e69becc43c9e0a8f958e8931b0a",
      "original_line" : 98,
      "original_position" : 98,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 98,
      "pull_request_review_id" : 1152716506,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1003010273/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-24T08:17:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1003010273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012691719"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012691719"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`OnPing()` is called when sending a ping message, but the log says \"received ping\". Also, the comment of `m_ping_nonce` is \"Most recent ping nonce received\".",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T09:54:43Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012691719",
      "id" : 1012691719,
      "line" : 98,
      "node_id" : "PRRC_kwDOABII5848XHMH",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 98,
      "original_position" : 98,
      "original_start_line" : 85,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 98,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012691719/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 85,
      "start_side" : "RIGHT",
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012691719",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012698220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012698220"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This sequence is misleading. The ping message is sent immediately after the handshake. We do not need to \"wait\" 1 second for that to happen. So `AdvanceMockTime(1)` may be removed.\r\n",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T10:00:43Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const\n+{\n+    std::vector<uint8_t> ser_msg_header;\n+    node.m_serializer->prepareForTransport(ser_msg, ser_msg_header);\n+\n+    bool complete;\n+    NodeReceiveMsgBytes(node, ser_msg_header, complete);\n+    NodeReceiveMsgBytes(node, ser_msg.data, complete);\n+    return complete;\n+}\n+\n+BOOST_FIXTURE_TEST_SUITE(peerman_tests, TestingSetup)\n+\n+static void SendMessage(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node, CSerializedNetMsg& msg)\n+{\n+    std::atomic<bool> interrupt{false};\n+    (void)connman.ReceiveMsgFrom(node, msg);\n+    node.fPauseSend = false;\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+    peerman.ProcessMessages(&node, interrupt);\n+    peerman.SendMessages(&node);\n+}\n+\n+using HandshakeHookFn = std::function<void(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node)>;\n+static void Handshake(\n+    ConnectionsInterfaceMock& connman, PeerManager& peerman,\n+    CNode& node, ServiceFlags their_services,\n+    HandshakeHookFn pre_verack_hook = [](ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node) {}) noexcept\n+{\n+    // Send version message\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_version{\n+        mm.Make(NetMsgType::VERSION,\n+                PROTOCOL_VERSION,                              // current p2p version\n+                Using<CustomUintFormatter<8>>(their_services), // their service flags\n+                GetTime(),                                     // dummy time\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // dummy\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // ignored\n+                uint64_t{1},                                   // dummy nonce\n+                std::string{},                                 // dummy subver\n+                int32_t{},                                     // dummy starting_height\n+                true),                                         // fRelay\n+    };\n+    SendMessage(connman, peerman, node, msg_version);\n+    BOOST_CHECK(!node.fDisconnect);\n+    BOOST_CHECK_EQUAL(node.nVersion, PROTOCOL_VERSION);\n+    BOOST_CHECK_EQUAL(node.GetCommonVersion(), PROTOCOL_VERSION);\n+    CNodeStateStats stats;\n+    bool ret = peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(ret, true);\n+    BOOST_CHECK_EQUAL(stats.their_services, their_services);\n+\n+    pre_verack_hook(connman, peerman, node);\n+\n+    // Send verack message\n+    CSerializedNetMsg msg_verack{mm.Make(NetMsgType::VERACK)};\n+    SendMessage(connman, peerman, node, msg_verack);\n+    BOOST_CHECK_EQUAL(node.fSuccessfullyConnected, true);\n+\n+    TestOnlyResetTimeData();\n+}\n+\n+BOOST_AUTO_TEST_CASE(version_handshake)\n+{\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode node{/*id=*/0, /*sock=*/nullptr, addr1, /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERSION], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::WTXIDRELAY], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDADDRV2], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERACK], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETADDR], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDCMPCT], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETHEADERS], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::FEEFILTER], 1);\n+\n+    peerman->FinalizeNode(node);\n+}\n+\n+static void CheckPingTimes(CNode& node, PeerManager& peerman,\n+                           std::chrono::microseconds min_ping_time, std::chrono::microseconds last_ping_time, std::chrono::microseconds ping_wait)\n+{\n+    // Check min and last ping times\n+    BOOST_CHECK_EQUAL(node.m_min_ping_time.load().count(), min_ping_time.count());\n+    BOOST_CHECK_EQUAL(node.m_last_ping_time.load().count(), last_ping_time.count());\n+\n+    // Check if and how long current ping has been pending\n+    CNodeStateStats stats;\n+    peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(stats.m_ping_wait.count(), ping_wait.count());\n+}\n+\n+static void SendPong(CNode& node, ConnectionsInterfaceMock& connman,\n+                     PeerManager& peerman, std::optional<int64_t> nonce = {})\n+{\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_pong = nonce ? mm.Make(NetMsgType::PONG, nonce.value()) : mm.Make(NetMsgType::PONG);\n+    SendMessage(connman, peerman, node, msg_pong);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ping)\n+{\n+    // See PING_INTERVAL in net_processing.cpp\n+    constexpr int64_t PING_INTERVAL{2 * 60};\n+\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CNode node{/*id=*/0, /*sock=*/nullptr, CAddress(), /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    // Use mock time to control pings from node\n+    SetMockTime(GetTime());\n+\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_TEST_MESSAGE(\"Advanced mocktime and check that ping is sent after connection is established\");\n+    AdvanceMockTime(1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::PING], 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012698220",
      "id" : 1012698220,
      "line" : 252,
      "node_id" : "PRRC_kwDOABII5848XIxs",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 252,
      "original_position" : 252,
      "original_start_line" : 250,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 252,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012698220/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 250,
      "start_side" : "RIGHT",
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012698220",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012727306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012727306"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is duplicated from `ConnmanTestMsg::NodeReceiveMsgBytes()` + a subtle change.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T10:30:44Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012727306",
      "id" : 1012727306,
      "line" : 100,
      "node_id" : "PRRC_kwDOABII5848XP4K",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 100,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 100,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012727306/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012727306",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012742783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012742783"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The `AdvanceMockTime(1)` from above belongs to just before this call. If the \"1 second\" is put in a variable that will make it obvious that it is the same as the 4th argument to `CheckPingTimes()`.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T10:47:16Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const\n+{\n+    std::vector<uint8_t> ser_msg_header;\n+    node.m_serializer->prepareForTransport(ser_msg, ser_msg_header);\n+\n+    bool complete;\n+    NodeReceiveMsgBytes(node, ser_msg_header, complete);\n+    NodeReceiveMsgBytes(node, ser_msg.data, complete);\n+    return complete;\n+}\n+\n+BOOST_FIXTURE_TEST_SUITE(peerman_tests, TestingSetup)\n+\n+static void SendMessage(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node, CSerializedNetMsg& msg)\n+{\n+    std::atomic<bool> interrupt{false};\n+    (void)connman.ReceiveMsgFrom(node, msg);\n+    node.fPauseSend = false;\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+    peerman.ProcessMessages(&node, interrupt);\n+    peerman.SendMessages(&node);\n+}\n+\n+using HandshakeHookFn = std::function<void(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node)>;\n+static void Handshake(\n+    ConnectionsInterfaceMock& connman, PeerManager& peerman,\n+    CNode& node, ServiceFlags their_services,\n+    HandshakeHookFn pre_verack_hook = [](ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node) {}) noexcept\n+{\n+    // Send version message\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_version{\n+        mm.Make(NetMsgType::VERSION,\n+                PROTOCOL_VERSION,                              // current p2p version\n+                Using<CustomUintFormatter<8>>(their_services), // their service flags\n+                GetTime(),                                     // dummy time\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // dummy\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // ignored\n+                uint64_t{1},                                   // dummy nonce\n+                std::string{},                                 // dummy subver\n+                int32_t{},                                     // dummy starting_height\n+                true),                                         // fRelay\n+    };\n+    SendMessage(connman, peerman, node, msg_version);\n+    BOOST_CHECK(!node.fDisconnect);\n+    BOOST_CHECK_EQUAL(node.nVersion, PROTOCOL_VERSION);\n+    BOOST_CHECK_EQUAL(node.GetCommonVersion(), PROTOCOL_VERSION);\n+    CNodeStateStats stats;\n+    bool ret = peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(ret, true);\n+    BOOST_CHECK_EQUAL(stats.their_services, their_services);\n+\n+    pre_verack_hook(connman, peerman, node);\n+\n+    // Send verack message\n+    CSerializedNetMsg msg_verack{mm.Make(NetMsgType::VERACK)};\n+    SendMessage(connman, peerman, node, msg_verack);\n+    BOOST_CHECK_EQUAL(node.fSuccessfullyConnected, true);\n+\n+    TestOnlyResetTimeData();\n+}\n+\n+BOOST_AUTO_TEST_CASE(version_handshake)\n+{\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode node{/*id=*/0, /*sock=*/nullptr, addr1, /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERSION], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::WTXIDRELAY], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDADDRV2], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERACK], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETADDR], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDCMPCT], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETHEADERS], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::FEEFILTER], 1);\n+\n+    peerman->FinalizeNode(node);\n+}\n+\n+static void CheckPingTimes(CNode& node, PeerManager& peerman,\n+                           std::chrono::microseconds min_ping_time, std::chrono::microseconds last_ping_time, std::chrono::microseconds ping_wait)\n+{\n+    // Check min and last ping times\n+    BOOST_CHECK_EQUAL(node.m_min_ping_time.load().count(), min_ping_time.count());\n+    BOOST_CHECK_EQUAL(node.m_last_ping_time.load().count(), last_ping_time.count());\n+\n+    // Check if and how long current ping has been pending\n+    CNodeStateStats stats;\n+    peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(stats.m_ping_wait.count(), ping_wait.count());\n+}\n+\n+static void SendPong(CNode& node, ConnectionsInterfaceMock& connman,\n+                     PeerManager& peerman, std::optional<int64_t> nonce = {})\n+{\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_pong = nonce ? mm.Make(NetMsgType::PONG, nonce.value()) : mm.Make(NetMsgType::PONG);\n+    SendMessage(connman, peerman, node, msg_pong);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ping)\n+{\n+    // See PING_INTERVAL in net_processing.cpp\n+    constexpr int64_t PING_INTERVAL{2 * 60};\n+\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CNode node{/*id=*/0, /*sock=*/nullptr, CAddress(), /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    // Use mock time to control pings from node\n+    SetMockTime(GetTime());\n+\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_TEST_MESSAGE(\"Advanced mocktime and check that ping is sent after connection is established\");\n+    AdvanceMockTime(1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::PING], 1);\n+\n+    // The ping nonce should be non-zero\n+    BOOST_CHECK(connman->m_ping_nonce != 0);\n+\n+    // No pong response has been received yet, and current ping is outstanding\n+    CheckPingTimes(node, *peerman, std::chrono::microseconds::max(), 0us, 1s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012742783",
      "id" : 1012742783,
      "line" : 258,
      "node_id" : "PRRC_kwDOABII5848XTp_",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 258,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 258,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012742783/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012742783",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012749883"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012749883"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This function simulates _receiving_ a message from the peer. I find the name `SendMessage()` confusing. Naming elsewhere in the code is from our point of view.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T10:54:36Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const\n+{\n+    std::vector<uint8_t> ser_msg_header;\n+    node.m_serializer->prepareForTransport(ser_msg, ser_msg_header);\n+\n+    bool complete;\n+    NodeReceiveMsgBytes(node, ser_msg_header, complete);\n+    NodeReceiveMsgBytes(node, ser_msg.data, complete);\n+    return complete;\n+}\n+\n+BOOST_FIXTURE_TEST_SUITE(peerman_tests, TestingSetup)\n+\n+static void SendMessage(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node, CSerializedNetMsg& msg)\n+{\n+    std::atomic<bool> interrupt{false};\n+    (void)connman.ReceiveMsgFrom(node, msg);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012749883",
      "id" : 1012749883,
      "line" : 135,
      "node_id" : "PRRC_kwDOABII5848XVY7",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 135,
      "original_position" : 135,
      "original_start_line" : 132,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 135,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012749883/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 132,
      "start_side" : "RIGHT",
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012749883",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012752032"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012752032"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Same as `SendMessage()`: this is simulating the reception of a pong message from the peer and the name `SendPong()` is confusing.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T10:56:56Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const\n+{\n+    std::vector<uint8_t> ser_msg_header;\n+    node.m_serializer->prepareForTransport(ser_msg, ser_msg_header);\n+\n+    bool complete;\n+    NodeReceiveMsgBytes(node, ser_msg_header, complete);\n+    NodeReceiveMsgBytes(node, ser_msg.data, complete);\n+    return complete;\n+}\n+\n+BOOST_FIXTURE_TEST_SUITE(peerman_tests, TestingSetup)\n+\n+static void SendMessage(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node, CSerializedNetMsg& msg)\n+{\n+    std::atomic<bool> interrupt{false};\n+    (void)connman.ReceiveMsgFrom(node, msg);\n+    node.fPauseSend = false;\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+    peerman.ProcessMessages(&node, interrupt);\n+    peerman.SendMessages(&node);\n+}\n+\n+using HandshakeHookFn = std::function<void(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node)>;\n+static void Handshake(\n+    ConnectionsInterfaceMock& connman, PeerManager& peerman,\n+    CNode& node, ServiceFlags their_services,\n+    HandshakeHookFn pre_verack_hook = [](ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node) {}) noexcept\n+{\n+    // Send version message\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_version{\n+        mm.Make(NetMsgType::VERSION,\n+                PROTOCOL_VERSION,                              // current p2p version\n+                Using<CustomUintFormatter<8>>(their_services), // their service flags\n+                GetTime(),                                     // dummy time\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // dummy\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // ignored\n+                uint64_t{1},                                   // dummy nonce\n+                std::string{},                                 // dummy subver\n+                int32_t{},                                     // dummy starting_height\n+                true),                                         // fRelay\n+    };\n+    SendMessage(connman, peerman, node, msg_version);\n+    BOOST_CHECK(!node.fDisconnect);\n+    BOOST_CHECK_EQUAL(node.nVersion, PROTOCOL_VERSION);\n+    BOOST_CHECK_EQUAL(node.GetCommonVersion(), PROTOCOL_VERSION);\n+    CNodeStateStats stats;\n+    bool ret = peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(ret, true);\n+    BOOST_CHECK_EQUAL(stats.their_services, their_services);\n+\n+    pre_verack_hook(connman, peerman, node);\n+\n+    // Send verack message\n+    CSerializedNetMsg msg_verack{mm.Make(NetMsgType::VERACK)};\n+    SendMessage(connman, peerman, node, msg_verack);\n+    BOOST_CHECK_EQUAL(node.fSuccessfullyConnected, true);\n+\n+    TestOnlyResetTimeData();\n+}\n+\n+BOOST_AUTO_TEST_CASE(version_handshake)\n+{\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode node{/*id=*/0, /*sock=*/nullptr, addr1, /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERSION], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::WTXIDRELAY], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDADDRV2], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERACK], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETADDR], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDCMPCT], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETHEADERS], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::FEEFILTER], 1);\n+\n+    peerman->FinalizeNode(node);\n+}\n+\n+static void CheckPingTimes(CNode& node, PeerManager& peerman,\n+                           std::chrono::microseconds min_ping_time, std::chrono::microseconds last_ping_time, std::chrono::microseconds ping_wait)\n+{\n+    // Check min and last ping times\n+    BOOST_CHECK_EQUAL(node.m_min_ping_time.load().count(), min_ping_time.count());\n+    BOOST_CHECK_EQUAL(node.m_last_ping_time.load().count(), last_ping_time.count());\n+\n+    // Check if and how long current ping has been pending\n+    CNodeStateStats stats;\n+    peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(stats.m_ping_wait.count(), ping_wait.count());\n+}\n+\n+static void SendPong(CNode& node, ConnectionsInterfaceMock& connman,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012752032",
      "id" : 1012752032,
      "line" : 222,
      "node_id" : "PRRC_kwDOABII5848XV6g",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 222,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 222,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012752032/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012752032",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012768460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012768460"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe use `ASSERT_DEBUG_LOG(\"Unsolicited pong without ping\")` here.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T11:15:10Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const\n+{\n+    std::vector<uint8_t> ser_msg_header;\n+    node.m_serializer->prepareForTransport(ser_msg, ser_msg_header);\n+\n+    bool complete;\n+    NodeReceiveMsgBytes(node, ser_msg_header, complete);\n+    NodeReceiveMsgBytes(node, ser_msg.data, complete);\n+    return complete;\n+}\n+\n+BOOST_FIXTURE_TEST_SUITE(peerman_tests, TestingSetup)\n+\n+static void SendMessage(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node, CSerializedNetMsg& msg)\n+{\n+    std::atomic<bool> interrupt{false};\n+    (void)connman.ReceiveMsgFrom(node, msg);\n+    node.fPauseSend = false;\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+    peerman.ProcessMessages(&node, interrupt);\n+    peerman.SendMessages(&node);\n+}\n+\n+using HandshakeHookFn = std::function<void(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node)>;\n+static void Handshake(\n+    ConnectionsInterfaceMock& connman, PeerManager& peerman,\n+    CNode& node, ServiceFlags their_services,\n+    HandshakeHookFn pre_verack_hook = [](ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node) {}) noexcept\n+{\n+    // Send version message\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_version{\n+        mm.Make(NetMsgType::VERSION,\n+                PROTOCOL_VERSION,                              // current p2p version\n+                Using<CustomUintFormatter<8>>(their_services), // their service flags\n+                GetTime(),                                     // dummy time\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // dummy\n+                int64_t{},                                     // ignored service bits\n+                CService{},                                    // ignored\n+                uint64_t{1},                                   // dummy nonce\n+                std::string{},                                 // dummy subver\n+                int32_t{},                                     // dummy starting_height\n+                true),                                         // fRelay\n+    };\n+    SendMessage(connman, peerman, node, msg_version);\n+    BOOST_CHECK(!node.fDisconnect);\n+    BOOST_CHECK_EQUAL(node.nVersion, PROTOCOL_VERSION);\n+    BOOST_CHECK_EQUAL(node.GetCommonVersion(), PROTOCOL_VERSION);\n+    CNodeStateStats stats;\n+    bool ret = peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(ret, true);\n+    BOOST_CHECK_EQUAL(stats.their_services, their_services);\n+\n+    pre_verack_hook(connman, peerman, node);\n+\n+    // Send verack message\n+    CSerializedNetMsg msg_verack{mm.Make(NetMsgType::VERACK)};\n+    SendMessage(connman, peerman, node, msg_verack);\n+    BOOST_CHECK_EQUAL(node.fSuccessfullyConnected, true);\n+\n+    TestOnlyResetTimeData();\n+}\n+\n+BOOST_AUTO_TEST_CASE(version_handshake)\n+{\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n+    CNode node{/*id=*/0, /*sock=*/nullptr, addr1, /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERSION], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::WTXIDRELAY], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDADDRV2], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::VERACK], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETADDR], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::SENDCMPCT], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::GETHEADERS], 1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::FEEFILTER], 1);\n+\n+    peerman->FinalizeNode(node);\n+}\n+\n+static void CheckPingTimes(CNode& node, PeerManager& peerman,\n+                           std::chrono::microseconds min_ping_time, std::chrono::microseconds last_ping_time, std::chrono::microseconds ping_wait)\n+{\n+    // Check min and last ping times\n+    BOOST_CHECK_EQUAL(node.m_min_ping_time.load().count(), min_ping_time.count());\n+    BOOST_CHECK_EQUAL(node.m_last_ping_time.load().count(), last_ping_time.count());\n+\n+    // Check if and how long current ping has been pending\n+    CNodeStateStats stats;\n+    peerman.GetNodeStateStats(node.GetId(), stats);\n+    BOOST_CHECK_EQUAL(stats.m_ping_wait.count(), ping_wait.count());\n+}\n+\n+static void SendPong(CNode& node, ConnectionsInterfaceMock& connman,\n+                     PeerManager& peerman, std::optional<int64_t> nonce = {})\n+{\n+    const CNetMsgMaker mm{0};\n+    CSerializedNetMsg msg_pong = nonce ? mm.Make(NetMsgType::PONG, nonce.value()) : mm.Make(NetMsgType::PONG);\n+    SendMessage(connman, peerman, node, msg_pong);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ping)\n+{\n+    // See PING_INTERVAL in net_processing.cpp\n+    constexpr int64_t PING_INTERVAL{2 * 60};\n+\n+    auto connman = std::make_unique<ConnectionsInterfaceMock>();\n+    auto peerman = PeerManager::make(*connman, *m_node.addrman, nullptr,\n+                                     *m_node.chainman, *m_node.mempool, false);\n+\n+    // Mock an outbound peer\n+    CNode node{/*id=*/0, /*sock=*/nullptr, CAddress(), /*nKeyedNetGroupIn=*/0, /*nLocalHostNonceIn=*/0, CAddress(),\n+               /*addrNameIn=*/\"\", ConnectionType::OUTBOUND_FULL_RELAY, /*inbound_onion=*/false};\n+\n+    peerman->InitializeNode(node, /*our_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    // Use mock time to control pings from node\n+    SetMockTime(GetTime());\n+\n+    Handshake(*connman, *peerman, node, /*their_services=*/ServiceFlags(NODE_NETWORK | NODE_WITNESS));\n+\n+    BOOST_TEST_MESSAGE(\"Advanced mocktime and check that ping is sent after connection is established\");\n+    AdvanceMockTime(1);\n+    BOOST_CHECK_EQUAL(connman->m_message_types_sent[NetMsgType::PING], 1);\n+\n+    // The ping nonce should be non-zero\n+    BOOST_CHECK(connman->m_ping_nonce != 0);\n+\n+    // No pong response has been received yet, and current ping is outstanding\n+    CheckPingTimes(node, *peerman, std::chrono::microseconds::max(), 0us, 1s);\n+\n+    BOOST_TEST_MESSAGE(\"Reply without nonce cancels ping\");\n+    SendPong(node, *connman, *peerman, std::nullopt);\n+\n+    // Ping metrics have not been updated on the CNode object, and there is no ping outstanding\n+    CheckPingTimes(node, *peerman, std::chrono::microseconds::max(), 0us, 0us);\n+\n+    BOOST_TEST_MESSAGE(\"Reply without ping\");\n+    SendPong(node, *connman, *peerman, 0);\n+\n+    // Ping metrics have not been updated on the CNode object, and there is no ping outstanding\n+    CheckPingTimes(node, *peerman, std::chrono::microseconds::max(), 0us, 0us);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012768460",
      "id" : 1012768460,
      "line" : 270,
      "node_id" : "PRRC_kwDOABII5848XZ7M",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 270,
      "original_position" : 270,
      "original_start_line" : 266,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 270,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012768460/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 266,
      "start_side" : "RIGHT",
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012768460",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012809634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012809634"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is very similar to `ConnmanTestMsg::Handshake()`. To avoid code duplication, can it be used instead?",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T12:00:58Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <span.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <optional>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+static void AdvanceMockTime(int64_t delta)\n+{\n+    auto time_before{GetMockTime()};\n+    SetMockTime(time_before + std::chrono::seconds(delta));\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+    void OnPing(CDataStream& data);\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+    /** Most recent ping nonce received. */\n+    uint64_t m_ping_nonce{0};\n+\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+\n+    CDataStream data{msg.data, SER_NETWORK, PROTOCOL_VERSION};\n+    if (msg.m_type == NetMsgType::PING) OnPing(data);\n+}\n+\n+void ConnectionsInterfaceMock::OnPing(CDataStream& data)\n+{\n+    data >> m_ping_nonce;\n+    BOOST_TEST_MESSAGE(strprintf(\"received ping. Nonce:%d\", m_ping_nonce));\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }\n+}\n+\n+bool ConnectionsInterfaceMock::ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const\n+{\n+    std::vector<uint8_t> ser_msg_header;\n+    node.m_serializer->prepareForTransport(ser_msg, ser_msg_header);\n+\n+    bool complete;\n+    NodeReceiveMsgBytes(node, ser_msg_header, complete);\n+    NodeReceiveMsgBytes(node, ser_msg.data, complete);\n+    return complete;\n+}\n+\n+BOOST_FIXTURE_TEST_SUITE(peerman_tests, TestingSetup)\n+\n+static void SendMessage(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node, CSerializedNetMsg& msg)\n+{\n+    std::atomic<bool> interrupt{false};\n+    (void)connman.ReceiveMsgFrom(node, msg);\n+    node.fPauseSend = false;\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\n+    peerman.ProcessMessages(&node, interrupt);\n+    peerman.SendMessages(&node);\n+}\n+\n+using HandshakeHookFn = std::function<void(ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node)>;\n+static void Handshake(\n+    ConnectionsInterfaceMock& connman, PeerManager& peerman,\n+    CNode& node, ServiceFlags their_services,\n+    HandshakeHookFn pre_verack_hook = [](ConnectionsInterfaceMock& connman, PeerManager& peerman, CNode& node) {}) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1012809634",
      "id" : 1012809634,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII5848Xj-i",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 146,
      "original_position" : 146,
      "original_start_line" : 143,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 146,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012809634/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 143,
      "start_side" : "RIGHT",
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1012809634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1013142021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013142021"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "According to our coding guidelines, [assertions shouldn't have side-effects](https://github.com/bitcoin/bitcoin/blob/28653a596ab7e0811ffec3bbb7632e17d54f8e43/doc/developer-notes.md?plain=1#L725).\r\n```suggestion\r\n    bool success = node.ReceiveMsgBytes(msg_bytes, complete);\r\n    assert(success);\r\n```",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T16:30:34Z",
      "diff_hunk" : "@@ -0,0 +1,188 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1013142021",
      "id" : 1013142021,
      "line" : 102,
      "node_id" : "PRRC_kwDOABII5848Y1IF",
      "original_commit_id" : "bdfe134ed6b13e69becc43c9e0a8f958e8931b0a",
      "original_line" : 81,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 81,
      "pull_request_review_id" : 1167285173,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013142021/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-03T16:44:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013142021",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1013149806"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013149806"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: Seems like a lot of these includes are unnecessary and can be removed; e.g. I don't see any arith_uint256-, pubkey- or script-related stuff used in the unit test. With the following diff it still compiles:\r\n```diff\r\ndiff --git a/src/test/peerman_tests.cpp b/src/test/peerman_tests.cpp\r\nindex 8ab87be6b..9d0c02fd0 100644\r\n--- a/src/test/peerman_tests.cpp\r\n+++ b/src/test/peerman_tests.cpp\r\n@@ -2,16 +2,11 @@\r\n // Distributed under the MIT software license, see the accompanying\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n\r\n-#include <arith_uint256.h>\r\n #include <banman.h>\r\n #include <chainparams.h>\r\n #include <net.h>\r\n #include <net_processing.h>\r\n #include <netmessagemaker.h>\r\n-#include <pubkey.h>\r\n-#include <script/sign.h>\r\n-#include <script/signingprovider.h>\r\n-#include <script/standard.h>\r\n #include <serialize.h>\r\n #include <span.h>\r\n #include <test/util/net.h>\r\n@@ -22,7 +17,6 @@\r\n #include <timedata.h>\r\n #include <validation.h>\r\n\r\n-#include <array>\r\n #include <optional>\r\n #include <stdint.h>\r\n\r\n```",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-03T16:35:54Z",
      "diff_hunk" : "@@ -0,0 +1,188 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1013149806",
      "id" : 1013149806,
      "line" : 14,
      "node_id" : "PRRC_kwDOABII5848Y3Bu",
      "original_commit_id" : "bdfe134ed6b13e69becc43c9e0a8f958e8931b0a",
      "original_line" : 14,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 14,
      "pull_request_review_id" : 1167285173,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013149806/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-03T16:44:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013149806",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1014128036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1014128036"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that the tests added in this PR can be done without virtualizing `CConnman` and without touching the source code at all, by capturing the sent and received messages (see `net_tests/initial_advertise_from_version_message` for an example).",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-04T14:57:49Z",
      "diff_hunk" : "@@ -663,7 +664,64 @@ class NetEventsInterface\n     ~NetEventsInterface() = default;\n };\n \n-class CConnman\n+/** Interface class for interacting with CConnman */\n+class ConnectionsInterface",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1014128036",
      "id" : 1014128036,
      "line" : 668,
      "node_id" : "PRRC_kwDOABII5848cl2k",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 668,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 14,
      "pull_request_review_id" : 1166581907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1014128036/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T15:00:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1014128036",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1014164912"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1014164912"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Huh I have not seen that before, thanks for bringing it up! While we could do that, i think that virtualizing `CConnman` is just the right thing to do for several reasons.\r\n\r\n- Defining an interface for it gets us a step closer to hiding more implementation details of our net module (similar to what we did with net processing. See `net_processing.h`, it (almost) only has the interface definition for `PeerManager`).\r\n- Mocking `CConnman` is much easier if such an interface definition exists. That's nice for unit tests but also nice for fuzz testing as we could have a `FuzzedConnman` (similar to your work on `FuzzedSock`).\r\n- Future tests might need more functionality besides capturing messages, so having the ability to mock the entire `CConnman` would be nice.\r\n",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-04T15:24:49Z",
      "diff_hunk" : "@@ -663,7 +664,64 @@ class NetEventsInterface\n     ~NetEventsInterface() = default;\n };\n \n-class CConnman\n+/** Interface class for interacting with CConnman */\n+class ConnectionsInterface",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1014164912",
      "id" : 1014164912,
      "in_reply_to_id" : 1014128036,
      "line" : 668,
      "node_id" : "PRRC_kwDOABII5848cu2w",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 668,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 14,
      "pull_request_review_id" : 1168753395,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1014164912/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T15:24:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1014164912",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1015336054"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1015336054"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> ... i think that virtualizing `CConnman` is just the right thing to do for several reasons\r\n\r\nMaybe put those in the OP to make the case for virtualizing stronger.\r\n\r\n> Defining an interface for it gets us a step closer to hiding more implementation details ...\r\n\r\nIn general, I wonder if we are going a step too far with \"hiding implementation details\". Are we aiming to remove `private:` sections from classes defined in header files?\r\n\r\nPImpl and virtualization have their use cases but IMO shouldn't be used as if they are universally good (as in \"lets pimpl and virtualize everything because the code will become better just by doing that\"). They could have adverse effects if abused.\r\n\r\n> * Mocking `CConnman` is much easier if such an interface definition exists ...\r\n> * Future tests might need more functionality besides capturing messages ...\r\n\r\nI agree.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-07T11:57:34Z",
      "diff_hunk" : "@@ -663,7 +664,64 @@ class NetEventsInterface\n     ~NetEventsInterface() = default;\n };\n \n-class CConnman\n+/** Interface class for interacting with CConnman */\n+class ConnectionsInterface",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1015336054",
      "id" : 1015336054,
      "in_reply_to_id" : 1014128036,
      "line" : 668,
      "node_id" : "PRRC_kwDOABII5848hMx2",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 668,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 14,
      "pull_request_review_id" : 1170268723,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1015336054/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-07T11:57:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1015336054",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1022470321"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1022470321"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> the tests added in this PR can be done without ... touching the source code at all\r\n\r\nYes, that works. Here it is:\r\n\r\n<details>\r\n<summary>tests</summary>\r\n\r\n```diff\r\ndiff --git a/src/test/net_tests.cpp b/src/test/net_tests.cpp\r\nindex f24509dd97..105f4e4487 100644\r\n--- a/src/test/net_tests.cpp\r\n+++ b/src/test/net_tests.cpp\r\n@@ -11,12 +11,14 @@\r\n #include <netaddress.h>\r\n #include <netbase.h>\r\n #include <netmessagemaker.h>\r\n #include <serialize.h>\r\n #include <span.h>\r\n #include <streams.h>\r\n+#include <test/util/logging.h>\r\n+#include <test/util/net.h>\r\n #include <test/util/setup_common.h>\r\n #include <test/util/validation.h>\r\n #include <timedata.h>\r\n #include <util/strencodings.h>\r\n #include <util/string.h>\r\n #include <util/system.h>\r\n@@ -902,7 +904,213 @@ BOOST_AUTO_TEST_CASE(initial_advertise_from_version_message)\r\n     // PeerManager::ProcessMessage() calls AddTimeData() which changes the internal state\r\n     // in timedata.cpp and later confuses the test \"timedata_tests/addtimedata\". Thus reset\r\n     // that state as it was before our test was run.\r\n     TestOnlyResetTimeData();\r\n }\r\n \r\n+BOOST_AUTO_TEST_CASE(initial_messages_sent)\r\n+{\r\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\r\n+\r\n+    m_node.args->ForceSetArg(\"-capturemessages\", \"1\");\r\n+\r\n+    auto& connman = static_cast<ConnmanTestMsg&>(*m_node.connman);\r\n+    auto& peerman = *m_node.peerman;\r\n+\r\n+    CNode outbound_peer{\r\n+        /*id=*/NodeId{0},\r\n+        /*sock=*/nullptr,\r\n+        /*addrIn=*/CAddress{CService{CNetAddr{in_addr{.s_addr = htonl(0x01020304)}}, 8333}, NODE_NONE},\r\n+        /*nKeyedNetGroupIn=*/0,\r\n+        /*nLocalHostNonceIn=*/0,\r\n+        /*addrBindIn=*/CAddress{},\r\n+        /*addrNameIn=*/\"\",\r\n+        /*conn_type_in=*/ConnectionType::OUTBOUND_FULL_RELAY,\r\n+        /*inbound_onion=*/false};\r\n+\r\n+    std::unordered_map<std::string, size_t> count_sent_messages;\r\n+\r\n+    const auto CaptureMessageOrig = CaptureMessage;\r\n+    CaptureMessage = [&count_sent_messages](const CAddress& addr,\r\n+                                            const std::string& msg_type,\r\n+                                            Span<const unsigned char> data,\r\n+                                            bool is_incoming) -> void {\r\n+        if (!is_incoming) {\r\n+            count_sent_messages[msg_type]++;\r\n+        }\r\n+    };\r\n+\r\n+    connman.Handshake(\r\n+        /*node=*/outbound_peer,\r\n+        /*successfully_connected=*/true,\r\n+        /*remote_services=*/ServiceFlags{NODE_NETWORK | NODE_WITNESS},\r\n+        /*local_services=*/ServiceFlags{NODE_NETWORK | NODE_WITNESS},\r\n+        /*version=*/PROTOCOL_VERSION,\r\n+        /*relay_txs=*/true);\r\n+\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::VERSION], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::WTXIDRELAY], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::SENDADDRV2], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::VERACK], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::GETADDR], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::SENDCMPCT], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::PING], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::GETHEADERS], 1);\r\n+    BOOST_CHECK_EQUAL(count_sent_messages[NetMsgType::FEEFILTER], 1);\r\n+\r\n+    peerman.FinalizeNode(outbound_peer);\r\n+\r\n+    CaptureMessage = CaptureMessageOrig;\r\n+    m_node.args->ForceSetArg(\"-capturemessages\", \"0\");\r\n+    // PeerManager::ProcessMessage() calls AddTimeData() which changes the internal state\r\n+    // in timedata.cpp and later confuses the test \"timedata_tests/addtimedata\". Thus reset\r\n+    // that state as it was before our test was run.\r\n+    TestOnlyResetTimeData();\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(pingpong)\r\n+{\r\n+    // See PING_INTERVAL in net_processing.cpp\r\n+    static constexpr auto PING_INTERVAL{2min};\r\n+\r\n+    m_node.args->ForceSetArg(\"-capturemessages\", \"1\");\r\n+\r\n+    auto& connman = static_cast<ConnmanTestMsg&>(*m_node.connman);\r\n+    auto& peerman = *m_node.peerman;\r\n+\r\n+    CNode outbound_peer{\r\n+        /*id=*/NodeId{0},\r\n+        /*sock=*/nullptr,\r\n+        /*addrIn=*/CAddress{CService{CNetAddr{in_addr{.s_addr = htonl(0x01020304)}}, 8333}, NODE_NONE},\r\n+        /*nKeyedNetGroupIn=*/0,\r\n+        /*nLocalHostNonceIn=*/0,\r\n+        /*addrBindIn=*/CAddress{},\r\n+        /*addrNameIn=*/\"\",\r\n+        /*conn_type_in=*/ConnectionType::OUTBOUND_FULL_RELAY,\r\n+        /*inbound_onion=*/false};\r\n+\r\n+    auto CheckPingTimes = [&peerman, &outbound_peer](std::chrono::microseconds min_ping_time,\r\n+                                                     std::chrono::microseconds last_ping_time,\r\n+                                                     std::chrono::microseconds ping_wait) {\r\n+        // Check min and last ping times\r\n+        BOOST_CHECK_EQUAL(outbound_peer.m_min_ping_time.load().count(), min_ping_time.count());\r\n+        BOOST_CHECK_EQUAL(outbound_peer.m_last_ping_time.load().count(), last_ping_time.count());\r\n+\r\n+        // Check if and how long current ping has been pending\r\n+        CNodeStateStats stats;\r\n+        BOOST_REQUIRE(peerman.GetNodeStateStats(outbound_peer.GetId(), stats));\r\n+        BOOST_CHECK_EQUAL(stats.m_ping_wait.count(), ping_wait.count());\r\n+    };\r\n+\r\n+    uint64_t ping_nonce_sent;\r\n+\r\n+    const auto CaptureMessageOrig = CaptureMessage;\r\n+    CaptureMessage = [&ping_nonce_sent](const CAddress& addr,\r\n+                                        const std::string& msg_type,\r\n+                                        Span<const unsigned char> data,\r\n+                                        bool is_incoming) {\r\n+        if (!is_incoming && msg_type == NetMsgType::PING) {\r\n+            CDataStream stream{data, SER_NETWORK, PROTOCOL_VERSION};\r\n+            stream >> ping_nonce_sent;\r\n+        }\r\n+    };\r\n+\r\n+    const auto SendPing = [&peerman, &outbound_peer, &ping_nonce_sent]() EXCLUSIVE_LOCKS_REQUIRED(NetEventsInterface::g_msgproc_mutex) {\r\n+        SetMockTime(GetMockTime() + PING_INTERVAL + 1s);\r\n+        ping_nonce_sent = 0;\r\n+        peerman.SendMessages(&outbound_peer);\r\n+        BOOST_REQUIRE(ping_nonce_sent != 0);\r\n+    };\r\n+\r\n+    const auto ReceiveAndProcessMessage = [&connman, &outbound_peer](CSerializedNetMsg& msg) EXCLUSIVE_LOCKS_REQUIRED(NetEventsInterface::g_msgproc_mutex) {\r\n+        connman.ReceiveMsgFrom(outbound_peer, msg);\r\n+        // The send buffer CConnman::nSendBufferMaxSize happens to be 0 during tests which\r\n+        // trips fPauseSend to be set to true which cancels processing of incoming messages.\r\n+        outbound_peer.fPauseSend = false;\r\n+        connman.ProcessMessagesOnce(outbound_peer);\r\n+    };\r\n+\r\n+    // Use mock time to control pings from node\r\n+    SetMockTime(GetTime());\r\n+\r\n+    ping_nonce_sent = 0;\r\n+\r\n+    LOCK(NetEventsInterface::g_msgproc_mutex);\r\n+\r\n+    connman.Handshake(\r\n+        /*node=*/outbound_peer,\r\n+        /*successfully_connected=*/true,\r\n+        /*remote_services=*/ServiceFlags{NODE_NETWORK | NODE_WITNESS},\r\n+        /*local_services=*/ServiceFlags{NODE_NETWORK | NODE_WITNESS},\r\n+        /*version=*/PROTOCOL_VERSION,\r\n+        /*relay_txs=*/true);\r\n+    BOOST_REQUIRE(ping_nonce_sent != 0);\r\n+\r\n+    auto time_elapsed = 1s;\r\n+    SetMockTime(GetMockTime() + time_elapsed);\r\n+    // No pong response has been received and current ping is outstanding.\r\n+    CheckPingTimes(std::chrono::microseconds::max(), 0us, time_elapsed);\r\n+\r\n+    CSerializedNetMsg pong_msg;\r\n+\r\n+    BOOST_TEST_MESSAGE(\"Receiving a PONG without nonce cancels our PING\");\r\n+    {\r\n+        ASSERT_DEBUG_LOG(\"Short payload\");\r\n+        pong_msg = CNetMsgMaker{PROTOCOL_VERSION}.Make(NetMsgType::PONG);\r\n+        ReceiveAndProcessMessage(pong_msg);\r\n+    }\r\n+    // Ping metrics have not been updated and there is no ping outstanding.\r\n+    CheckPingTimes(std::chrono::microseconds::max(), 0us, 0us);\r\n+\r\n+    BOOST_TEST_MESSAGE(\"Receiving an unrequested PONG is logged and ignored\");\r\n+    {\r\n+        ASSERT_DEBUG_LOG(\"Unsolicited pong without ping\");\r\n+        pong_msg = CNetMsgMaker{PROTOCOL_VERSION}.Make(NetMsgType::PONG, /*nonce=*/(uint64_t)0);\r\n+        ReceiveAndProcessMessage(pong_msg);\r\n+    }\r\n+    // Ping metrics have not been updated and there is no ping outstanding.\r\n+    CheckPingTimes(std::chrono::microseconds::max(), 0us, 0us);\r\n+\r\n+    SendPing();\r\n+\r\n+    BOOST_TEST_MESSAGE(\"Receiving a PONG with the wrong nonce does not cancel our PING\");\r\n+    {\r\n+        ASSERT_DEBUG_LOG(\"Nonce mismatch\");\r\n+        pong_msg = CNetMsgMaker{PROTOCOL_VERSION}.Make(NetMsgType::PONG, /*nonce=*/ping_nonce_sent + 1);\r\n+        ReceiveAndProcessMessage(pong_msg);\r\n+    }\r\n+    // Ping metrics have not been updated and there is an outstanding ping.\r\n+    time_elapsed = 5s;\r\n+    SetMockTime(GetMockTime() + time_elapsed);\r\n+    CheckPingTimes(std::chrono::microseconds::max(), 0us, time_elapsed);\r\n+\r\n+    BOOST_TEST_MESSAGE(\"Receiving a PONG with nonce=0 cancels our PING\");\r\n+    {\r\n+        ASSERT_DEBUG_LOG(\"Nonce zero\");\r\n+        pong_msg = CNetMsgMaker{PROTOCOL_VERSION}.Make(NetMsgType::PONG, /*nonce=*/(uint64_t)0);\r\n+        ReceiveAndProcessMessage(pong_msg);\r\n+    }\r\n+    // Ping metrics have not been updated and there is no ping outstanding.\r\n+    CheckPingTimes(std::chrono::microseconds::max(), 0us, 0us);\r\n+\r\n+    SendPing();\r\n+\r\n+    time_elapsed = 5s;\r\n+    SetMockTime(GetMockTime() + time_elapsed);\r\n+\r\n+    BOOST_TEST_MESSAGE(\"Receiving a PONG with the correct nonce cancels our PING\");\r\n+    pong_msg = CNetMsgMaker{PROTOCOL_VERSION}.Make(NetMsgType::PONG, ping_nonce_sent);\r\n+    ReceiveAndProcessMessage(pong_msg);\r\n+    // Ping metrics have been updated and there is no ping outstanding.\r\n+    CheckPingTimes(time_elapsed, time_elapsed, 0us);\r\n+\r\n+    peerman.FinalizeNode(outbound_peer);\r\n+\r\n+    CaptureMessage = CaptureMessageOrig;\r\n+    m_node.args->ForceSetArg(\"-capturemessages\", \"0\");\r\n+    // PeerManager::ProcessMessage() calls AddTimeData() which changes the internal state\r\n+    // in timedata.cpp and later confuses the test \"timedata_tests/addtimedata\". Thus reset\r\n+    // that state as it was before our test was run.\r\n+    TestOnlyResetTimeData();\r\n+}\r\n+\r\n BOOST_AUTO_TEST_SUITE_END()\r\n```\r\n</details>\r\n",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2022-11-15T08:19:53Z",
      "diff_hunk" : "@@ -663,7 +664,64 @@ class NetEventsInterface\n     ~NetEventsInterface() = default;\n };\n \n-class CConnman\n+/** Interface class for interacting with CConnman */\n+class ConnectionsInterface",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1022470321",
      "id" : 1022470321,
      "in_reply_to_id" : 1014128036,
      "line" : 668,
      "node_id" : "PRRC_kwDOABII58488aix",
      "original_commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "original_line" : 668,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 14,
      "pull_request_review_id" : 1180407764,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1022470321/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-15T08:19:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1022470321",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1135979252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135979252"
         }
      },
      "author_association" : "MEMBER",
      "body" : "#27257 dedupes this code across the entire code base, reviewing that would help move this forward.",
      "commit_id" : "9c04c32101cd458c336de1d66ad296dc7f1cf35d",
      "created_at" : "2023-03-14T17:49:26Z",
      "diff_hunk" : "@@ -0,0 +1,188 @@\n+// Copyright (c) 2011-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <arith_uint256.h>\n+#include <banman.h>\n+#include <chainparams.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netmessagemaker.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <script/standard.h>\n+#include <serialize.h>\n+#include <test/util/net.h>\n+#include <test/util/setup_common.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+#include <timedata.h>\n+#include <validation.h>\n+\n+#include <array>\n+#include <stdint.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static CService ip(uint32_t i)\n+{\n+    struct in_addr s;\n+    s.s_addr = i;\n+    return CService(CNetAddr(s), Params().GetDefaultPort());\n+}\n+\n+/** Mock the connections interface. */\n+class ConnectionsInterfaceMock : public ConnectionsInterface\n+{\n+public:\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func) override { return true; };\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func) override {};\n+    void ForEachNode(const NodeFn& func) const override {};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) override;\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const override { return {0, 0}; };\n+    void WakeMessageHandler() override {};\n+    bool OutboundTargetReached(bool historicalBlockServingLimit) const override { return true; };\n+    std::vector<CAddress> GetAddresses(size_t max_addresses,\n+                                       size_t max_pct,\n+                                       std::optional<Network> network) const override { return {}; };\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct) override { return {}; };\n+    bool DisconnectNode(const CNetAddr& addr) override { return true; };\n+    unsigned int GetReceiveFloodSize() const override { return 0; };\n+    int GetExtraFullOutboundCount() const override { return 0; };\n+    int GetExtraBlockRelayCount() const override { return 0; };\n+    void SetTryNewOutboundPeer(bool flag) override {};\n+    bool GetTryNewOutboundPeer() const override { return true; };\n+    bool GetNetworkActive() const override { return true; };\n+    bool GetUseAddrmanOutgoing() const override { return true; };\n+    void StartExtraBlockRelayPeers() override {};\n+    bool ShouldRunInactivityChecks(const CNode& node, std::chrono::seconds now) const override { return true; };\n+    bool CheckIncomingNonce(uint64_t nonce) override { return true; };\n+\n+    void NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const;\n+    bool ReceiveMsgFrom(CNode& node, CSerializedNetMsg& ser_msg) const;\n+\n+    virtual ~ConnectionsInterfaceMock() {}\n+\n+    /** Count of number of each message type sent */\n+    std::map<std::string, uint64_t> m_message_types_sent;\n+};\n+\n+void ConnectionsInterfaceMock::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n+{\n+    BOOST_TEST_MESSAGE(strprintf(\"sending message %s to peer %d\", msg.m_type, pnode->GetId()));\n+    m_message_types_sent[msg.m_type]++;\n+}\n+\n+void ConnectionsInterfaceMock::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_bytes, bool& complete) const\n+{\n+    assert(node.ReceiveMsgBytes(msg_bytes, complete));\n+    if (complete) {\n+        size_t nSizeAdded = 0;\n+        auto it(node.vRecvMsg.begin());\n+        for (; it != node.vRecvMsg.end(); ++it) {\n+            // vRecvMsg contains only completed CNetMessage\n+            // the single possible partially deserialized message are held by TransportDeserializer\n+            nSizeAdded += it->m_raw_message_size;\n+        }\n+        {\n+            LOCK(node.cs_vProcessMsg);\n+            node.vProcessMsg.splice(node.vProcessMsg.end(), node.vRecvMsg, node.vRecvMsg.begin(), it);\n+            node.nProcessQueueSize += nSizeAdded;\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25515#discussion_r1135979252",
      "id" : 1135979252,
      "line" : 116,
      "node_id" : "PRRC_kwDOABII585Dtar0",
      "original_commit_id" : "bdfe134ed6b13e69becc43c9e0a8f958e8931b0a",
      "original_line" : 95,
      "original_position" : 95,
      "original_start_line" : 83,
      "path" : "src/test/peerman_tests.cpp",
      "position" : 116,
      "pull_request_review_id" : 1339941979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135979252/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 104,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-14T17:49:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135979252",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   }
]
