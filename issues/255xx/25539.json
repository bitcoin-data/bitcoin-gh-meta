{
   "active_lock_reason" : null,
   "assignee" : null,
   "assignees" : [],
   "author_association" : "CONTRIBUTOR",
   "body" : "An undo file is written to disk in `WriteUndoDataForBlock`. If the related block file has nFile = 2, then the undo file will also have nFile = 2. It can be flushed to disk in 4 ways:\r\n- `FlushStateToDisk` calls `FlushBlockFile()`. This flushes the last block and undo files on disk.\r\n- When the current block file is full and fKnown=false, `FindBlockPos` will flush the last block file. It will flush the corresponding undo file if the last height in the file is equal to the current tip height.\r\n- It seems that it is possible for the last block and undo files to be flushed if fKnown=true and nFile < last block file, but that's irrelevant here.\r\n- In `WriteUndoDataForBlock`, if the undo file is not the last file and the height whose undo data being written is the last height in the file.\r\n\r\nThe `UndoWriteToDisk` function opens a CAutoFile and writes the data. When it returns, the CAutoFile destructor is called which calls fclose, which flushes (via `fflush`) the buffered data to the OS (at this point it's in dirty pages).\r\n\r\nA simplified version of what can happen:\r\n\r\nTime 1:\r\n- tip=3\r\n- blockfile 2 has blocks: [5, 7, 8], so nHeightLast=8\r\n- blockfile 2 is unflushed\r\n- undo 2 does not exist since tip=3\r\n- the blocks being stored in this way is possible if the headers are received, then the blocks are OOO\r\n\r\nTime 2:\r\n- tip=3\r\n- block 4 arrives, but cannot fit in blockfile 2\r\n  - `FindBlockPos` is called, blockfile 2 is flushed. Note that nHeightLast=8 for this file and tip=3 since the tip is updated later. Therefore undo file 2 isn't flushed here (it also doesn't exist).\r\n- blockfile 3 has blocks: [4]\r\n- blockfile 3 is unflushed\r\n- `ActivateBestChain` will update to tip=4\r\n- `WriteUndoDataForBlock` is called for 4\r\n  - undo file 3 is created for block 4 (in dirty pages)\r\n  - the BLOCK_HAVE_UNDO status flag is set for the related CBlockIndex* for block 4\r\n- `ActivateBestChain` will update to tip=5\r\n- `WriteUndoDataForBlock` is called for 5\r\n  - undo file 2 is created for block 5 (in dirty pages)\r\n  - the BLOCK_HAVE_UNDO status flag is set for CBlockIndex* 5\r\n\r\nTime 3:\r\n- tip=5\r\n- undo file 2, 3 are still in dirty pages\r\n- `FlushStateToDisk` is called:\r\n  - `FlushBlockFile` is called which flushes the *last* block+undo file to disk (3)\r\n  - `WriteBlockIndexDB` is called and flushes the block index state to disk.\r\n\r\nNote: At this point, block 5 has persisted the BLOCK_HAVE_UNDO status flag. Undo file 2 may still be in dirty pages and a power loss would mean that block 5 doesn't actually have rev data. The log would look like this on restart:\r\n\r\n```\r\n2022-07-04T04:15:07.917838Z [init] [validation.cpp:3931] [VerifyDB] Verifying last 4 blocks at level 3\r\n2022-07-04T04:15:07.917847Z [init] [validation.cpp:3938] [VerifyDB] [0%]...ERROR: UndoReadFromDisk: Deserialize or I/O error - CAutoFile::read: end of file: unspecified iostream_category error\r\n2022-07-04T04:15:07.918012Z [init] [util/system.h:50] [error] ERROR: VerifyDB(): *** found bad undo data at 4, hash=221d40281e7719cd139503506649647ca50cc8bf9babaa1d1f91b9f80c4f48dd\r\n```\r\n\r\nTo aid in testing, I set the linux vm.dirty_writeback_centisecs tunable to a high value so that the kernel would wait a while before flushing dirty pages. This made sure that files with fsync called on them would get flushed way before the non-fsync'd dirty pages.\r\n\r\nIf I'm right, then it is corruption but a lot of things have to go wrong for it to happen.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 0,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25539/comments",
   "created_at" : "2022-07-04T11:36:08Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25539/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/25539",
   "id" : 1293046244,
   "labels" : [],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25539/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "I_kwDOABII585NElHk",
   "number" : 25539,
   "performed_via_github_app" : null,
   "reactions" : {
      "+1" : 0,
      "-1" : 0,
      "confused" : 0,
      "eyes" : 0,
      "heart" : 0,
      "hooray" : 0,
      "laugh" : 0,
      "rocket" : 0,
      "total_count" : 0,
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25539/reactions"
   },
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "state_reason" : null,
   "timeline_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25539/timeline",
   "title" : "possible corruption: missing undo file",
   "updated_at" : "2022-07-04T11:36:08Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25539",
   "user" : {
      "avatar_url" : "https://avatars.githubusercontent.com/u/15145615?v=4",
      "events_url" : "https://api.github.com/users/Crypt-iQ/events{/privacy}",
      "followers_url" : "https://api.github.com/users/Crypt-iQ/followers",
      "following_url" : "https://api.github.com/users/Crypt-iQ/following{/other_user}",
      "gists_url" : "https://api.github.com/users/Crypt-iQ/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/Crypt-iQ",
      "id" : 15145615,
      "login" : "Crypt-iQ",
      "node_id" : "MDQ6VXNlcjE1MTQ1NjE1",
      "organizations_url" : "https://api.github.com/users/Crypt-iQ/orgs",
      "received_events_url" : "https://api.github.com/users/Crypt-iQ/received_events",
      "repos_url" : "https://api.github.com/users/Crypt-iQ/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/Crypt-iQ/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/Crypt-iQ/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/Crypt-iQ"
   }
}
