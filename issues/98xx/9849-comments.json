[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r102890169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102890169"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`le` is the same name as the first argument here, it will bring shadow warning.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-02-24T07:19:20Z",
      "diff_hunk" : "@@ -0,0 +1,788 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (!isLogRowContinuation(row)) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r102890169",
      "id" : 102890169,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMjg5MDE2OQ==",
      "original_commit_id" : "563ec9e94744e0050ced5aff9d3db54c2fffb3ee",
      "original_position" : 552,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 23659997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102890169",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6848764?v=4",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "node_id" : "MDQ6VXNlcjY4NDg3NjQ=",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "This is how it looks like here on testnet:\r\n\r\n<img width=\"1167\" alt=\"screen shot 2017-02-24 at 08 22 39\" src=\"https://cloud.githubusercontent.com/assets/6848764/23294190/86f5186e-fa6a-11e6-83bd-dfa5811b8b68.png\">\r\n",
      "created_at" : "2017-02-24T07:24:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-282222921",
      "id" : 282222921,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDI4MjIyMjkyMQ==",
      "updated_at" : "2017-02-24T07:24:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282222921",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6848764?v=4",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "node_id" : "MDQ6VXNlcjY4NDg3NjQ=",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks. Will review.\r\nI just played a bit with it and had massive locking issues on mainnet during catch-up of 2-3 weeks.",
      "created_at" : "2017-02-24T07:30:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-282223846",
      "id" : 282223846,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDI4MjIyMzg0Ng==",
      "updated_at" : "2017-02-24T07:30:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282223846",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Running this PR (built over gitian: https://bitcoin.jonasschnelli.ch/build/54) makes Bitcoin-Qt and also the rest of my apps almost unusable. Had to force kill the process.",
      "created_at" : "2017-03-17T15:26:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-287385325",
      "id" : 287385325,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDI4NzM4NTMyNQ==",
      "updated_at" : "2017-03-17T15:26:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/287385325",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106676794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106676794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IMO reading each block will cause a massive slow down during IBD / catchup.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T15:29:26Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106676794",
      "id" : 106676794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjY3Njc5NA==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 619,
      "path" : "src/qt/netwatch.cpp",
      "position" : 649,
      "pull_request_review_id" : 27613799,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106676794",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106677143"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106677143"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What we probably should do is adding each blocks size and vtx.size() to CBlockIndex* (would require to alter the block index, migration, etc. yes).",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T15:30:54Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106677143",
      "id" : 106677143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjY3NzE0Mw==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 623,
      "path" : "src/qt/netwatch.cpp",
      "position" : 653,
      "pull_request_review_id" : 27614161,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106677143",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The OS should have the data cached already?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T22:49:33Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759495",
      "id" : 106759495,
      "in_reply_to_id" : 106676794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjc1OTQ5NQ==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 619,
      "path" : "src/qt/netwatch.cpp",
      "position" : 649,
      "pull_request_review_id" : 27703245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759594"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That wouldn't change anything here...?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T22:50:26Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759594",
      "id" : 106759594,
      "in_reply_to_id" : 106677143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjc1OTU5NA==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 623,
      "path" : "src/qt/netwatch.cpp",
      "position" : 653,
      "pull_request_review_id" : 27703327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759594",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I like having this, though we have to be sure that there is *no* performance impact when the monitor is not running, and as little as possible when it is.",
      "created_at" : "2018-03-06T22:54:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-370958712",
      "id" : 370958712,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM3MDk1ODcxMg==",
      "updated_at" : "2018-03-06T22:54:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/370958712",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The code is (already) disabled until the first time it is opened.",
      "created_at" : "2018-03-07T02:46:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-371004084",
      "id" : 371004084,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM3MTAwNDA4NA==",
      "updated_at" : "2018-03-07T02:46:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/371004084",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-10-30T17:18:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434392012",
      "id" : 434392012,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDM5MjAxMg==",
      "updated_at" : "2018-10-30T17:18:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434392012",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-10-30T18:04:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434408869",
      "id" : 434408869,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDQwODg2OQ==",
      "updated_at" : "2018-10-30T18:04:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434408869",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Oops, had rebased onto 0.17 instead of master. Rebased for real this time.",
      "created_at" : "2018-10-30T20:13:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434452220",
      "id" : 434452220,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDQ1MjIyMA==",
      "updated_at" : "2018-10-30T20:13:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434452220",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229475953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229475953"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Might want to use the new connect syntax in this file?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T20:35:55Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    validation_interface(new NetWatchValidationInterface(*this)),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());\n+    const size_t vout_count = CountNonDatacarrierOutputs(block.vtx[0]);\n+    LogAddEntry(LogEntry(GetTime(), *pblockindex), vout_count);\n+}\n+\n+void NetWatchLogModel::LogTransaction(const CTransactionRef& tx)\n+{\n+    const size_t vout_count = CountNonDatacarrierOutputs(tx);\n+    LogAddEntry(LogEntry(GetTime(), tx), vout_count);\n+}\n+\n+void NetWatchLogModel::setClientModel(ClientModel *model)\n+{\n+    if (clientModel) {\n+        disconnect(clientModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n+    }\n+    clientModel = model;\n+    if (model) {\n+        connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229475953",
      "id" : 229475953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTQ3NTk1Mw==",
      "original_commit_id" : "ae96c0d67879d1ede4e44fbacdd787800376fd87",
      "original_position" : 681,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 169987255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229475953",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229509157"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229509157"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Let me know if I got it right...",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T22:28:11Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    validation_interface(new NetWatchValidationInterface(*this)),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());\n+    const size_t vout_count = CountNonDatacarrierOutputs(block.vtx[0]);\n+    LogAddEntry(LogEntry(GetTime(), *pblockindex), vout_count);\n+}\n+\n+void NetWatchLogModel::LogTransaction(const CTransactionRef& tx)\n+{\n+    const size_t vout_count = CountNonDatacarrierOutputs(tx);\n+    LogAddEntry(LogEntry(GetTime(), tx), vout_count);\n+}\n+\n+void NetWatchLogModel::setClientModel(ClientModel *model)\n+{\n+    if (clientModel) {\n+        disconnect(clientModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n+    }\n+    clientModel = model;\n+    if (model) {\n+        connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229509157",
      "id" : 229509157,
      "in_reply_to_id" : 229475953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUwOTE1Nw==",
      "original_commit_id" : "ae96c0d67879d1ede4e44fbacdd787800376fd87",
      "original_position" : 681,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170028006,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229509157",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229521971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229521971"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could rebase with #14123 to replace these calls with `GUIUtil::bringToFront`.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:27:49Z",
      "diff_hunk" : "@@ -661,6 +676,18 @@ void BitcoinGUI::aboutClicked()\n     dlg.exec();\n }\n \n+void BitcoinGUI::showNetWatch()\n+{\n+    if (!NetWatch) {\n+        NetWatch = new GuiNetWatch(platformStyle, netStyle);\n+        NetWatch->setClientModel(clientModel);\n+    }\n+    NetWatch->showNormal();\n+    NetWatch->show();\n+    NetWatch->raise();\n+    NetWatch->activateWindow();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229521971",
      "id" : 229521971,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMTk3MQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 86,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229521971",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522523"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:30:50Z",
      "diff_hunk" : "@@ -73,7 +74,8 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     m_node(node),\n-    platformStyle(_platformStyle)\n+    platformStyle(_platformStyle),\n+    netStyle(networkStyle)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522523",
      "id" : 229522523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjUyMw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 14,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522523",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522740"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit 2018.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:31:55Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522740",
      "id" : 229522740,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjc0MA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 1,
      "path" : "src/qt/netwatch.h",
      "position" : 1,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522740",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, sort.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:32:18Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class PlatformStyle;\n+class NetworkStyle;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522794",
      "id" : 229522794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjc5NA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 26,
      "path" : "src/qt/netwatch.h",
      "position" : 25,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522794",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522918"
         }
      },
      "author_association" : "MEMBER",
      "body" : "move to .cpp? nit, follow code convention.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:33:01Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class PlatformStyle;\n+class NetworkStyle;\n+\n+static const int nLongestAddress = 35;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522918",
      "id" : 229522918,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjkxOA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 28,
      "path" : "src/qt/netwatch.h",
      "position" : 28,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522918",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229523638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229523638"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FYI in #14573 I'm proposing a Window menu.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:37:07Z",
      "diff_hunk" : "@@ -397,6 +404,7 @@ void BitcoinGUI::createMenuBar()\n     settings->addAction(optionsAction);\n \n     QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\n+    help->addAction(NetWatchAction);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229523638",
      "id" : 229523638,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMzYzOA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 48,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229523638",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525155"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `m_show_netwatch_action`.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:45:51Z",
      "diff_hunk" : "@@ -127,6 +128,7 @@ class BitcoinGUI : public QMainWindow\n     QAction* backupWalletAction = nullptr;\n     QAction* changePassphraseAction = nullptr;\n     QAction* aboutQtAction = nullptr;\n+    QAction* NetWatchAction = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525155",
      "id" : 229525155,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTE1NQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 12,
      "path" : "src/qt/bitcoingui.h",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525155",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525358"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525358"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `} // namespace`",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:46:58Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525358",
      "id" : 229525358,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTM1OA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 76,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525358",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525551"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525551"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, s/LET/log_entry_type.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:48:00Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525551",
      "id" : 229525551,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTU1MQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 78,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525551",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "const?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:48:25Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525623",
      "id" : 229525623,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTYyMw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 52,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525623",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525695"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, one line `if (...) continue`;",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:48:56Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525695",
      "id" : 229525695,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTY5NQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 53,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525695",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525742"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525742"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same as above.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:49:20Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525742",
      "id" : 229525742,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTc0Mg==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 65,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525742",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525862"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same as above.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:49:58Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525862",
      "id" : 229525862,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTg2Mg==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 68,
      "path" : "src/qt/netwatch.cpp",
      "position" : 64,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525862",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525879"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`nullptr`.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:50:05Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525879",
      "id" : 229525879,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTg3OQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 73,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525879",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525965"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525965"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, 2018",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:50:38Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525965",
      "id" : 229525965,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTk2NQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 1,
      "path" : "src/qt/netwatch.cpp",
      "position" : 1,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525965",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229527763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229527763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should use/extend `interfaces::Node` instead?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T00:00:40Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229527763",
      "id" : 229527763,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNzc2Mw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 265,
      "path" : "src/qt/netwatch.cpp",
      "position" : 261,
      "pull_request_review_id" : 170049486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229527763",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529387"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529387"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's needed...",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T00:11:14Z",
      "diff_hunk" : "@@ -73,7 +74,8 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     m_node(node),\n-    platformStyle(_platformStyle)\n+    platformStyle(_platformStyle),\n+    netStyle(networkStyle)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529387",
      "id" : 229529387,
      "in_reply_to_id" : 229522523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyOTM4Nw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 14,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170051449,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529387",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529437"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529437"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2018 is wrong. This code hasn't been substantially changed since 2017.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T00:11:31Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529437",
      "id" : 229529437,
      "in_reply_to_id" : 229522740,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyOTQzNw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 1,
      "path" : "src/qt/netwatch.h",
      "position" : 1,
      "pull_request_review_id" : 170051515,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529437",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229555020"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229555020"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IMO this one is clearer split out.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T03:38:51Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229555020",
      "id" : 229555020,
      "in_reply_to_id" : 229525862,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTU1NTAyMA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 68,
      "path" : "src/qt/netwatch.cpp",
      "position" : 64,
      "pull_request_review_id" : 170082703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229555020",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16612](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16612.html) (qt: Remove menu icons by laanwj)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-10-31T03:44:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434550974",
      "id" : 434550974,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDU1MDk3NA==",
      "updated_at" : "2019-08-15T22:19:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434550974",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229659095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229659095"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use `nullptr` instead of `NULL`. Applies throughout this PR :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T11:39:27Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {\n+        auto pn = reinterpret_cast<std::uintptr_t>(ptr);\n+        auto aligned = (pn + alignment - 1) & -alignment;\n+        auto new_space = space - (aligned - pn);\n+        if (new_space < size) {\n+            return nullptr;\n+        }\n+        space = new_space;\n+        return ptr = reinterpret_cast<void *>(aligned);\n+    }\n+\n+    void init(const LogEntry&);\n+    void init(int32_t relTimestamp, const CBlockIndex&);\n+    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);\n+    void clear();\n+\n+public:\n+    enum LogEntryType {\n+        LET_BLOCK,\n+        LET_TX,\n+    };\n+    static const QString LogEntryTypeAbbreviation(LogEntryType);\n+\n+    LogEntry(const LogEntry&);\n+    LogEntry() : data(NULL) { }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229659095",
      "id" : 229659095,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTY1OTA5NQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 80,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170207391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229659095",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229693133"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229693133"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry, forgot to delete this comment while reviewing..",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T13:32:19Z",
      "diff_hunk" : "@@ -73,7 +74,8 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     m_node(node),\n-    platformStyle(_platformStyle)\n+    platformStyle(_platformStyle),\n+    netStyle(networkStyle)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229693133",
      "id" : 229693133,
      "in_reply_to_id" : 229522523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTY5MzEzMw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 14,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170251037,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229693133",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229707702"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229707702"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Sort includes :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:07:34Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229707702",
      "id" : 229707702,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcwNzcwMg==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 17,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170269519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229707702",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229708001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229708001"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Make parameter names match between declaration and definition.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:08:17Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {\n+        auto pn = reinterpret_cast<std::uintptr_t>(ptr);\n+        auto aligned = (pn + alignment - 1) & -alignment;\n+        auto new_space = space - (aligned - pn);\n+        if (new_space < size) {\n+            return nullptr;\n+        }\n+        space = new_space;\n+        return ptr = reinterpret_cast<void *>(aligned);\n+    }\n+\n+    void init(const LogEntry&);\n+    void init(int32_t relTimestamp, const CBlockIndex&);\n+    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);\n+    void clear();\n+\n+public:\n+    enum LogEntryType {\n+        LET_BLOCK,\n+        LET_TX,\n+    };\n+    static const QString LogEntryTypeAbbreviation(LogEntryType);\n+\n+    LogEntry(const LogEntry&);\n+    LogEntry() : data(NULL) { }\n+    explicit LogEntry(int32_t relTimestamp, const CBlockIndex&);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionWeakref&, bool weak = true);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionRef&, bool weak = false);\n+    ~LogEntry();\n+\n+    LogEntry& operator=(const LogEntry& other);\n+\n+    explicit operator bool() const;\n+    int32_t getRelTimestamp() const;\n+    uint64_t getTimestamp(uint64_t now) const;\n+    LogEntryType getType() const;\n+\n+    template <typename T> T* get() const {\n+        void *p = data + sizeof(meta_t);\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        return (T*)p;\n+    }\n+\n+    const CBlockIndex& getBlockIndex() const;\n+    CTransactionRef getTransactionRef() const;\n+    bool isWeak() const;\n+    bool expired() const;\n+    void makeWeak();\n+};\n+\n+class NetWatchLogModel;\n+\n+class NetWatchLogSearch {\n+public:\n+    QString query;\n+\n+    bool fCheckType;\n+    bool fCheckId;\n+    bool fCheckAddr;\n+    bool fCheckValue;\n+\n+    NetWatchLogSearch(const QString& query, int displayunit);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229708001",
      "id" : 229708001,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcwODAwMQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 119,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170269875,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229708001",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229709154"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229709154"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be `explicit`? :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:10:53Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229709154",
      "id" : 229709154,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcwOTE1NA==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 266,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170271290,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229709154",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229710344"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229710344"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: `!block.vtx.empty()` communicates intention more clearly than `block.vtx.size()`?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:13:36Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229710344",
      "id" : 229710344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMDM0NA==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 343,
      "path" : "src/qt/netwatch.cpp",
      "position" : 343,
      "pull_request_review_id" : 170272787,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229710344",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229711281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229711281"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This `if` statement is unnecessary. Deleting a null pointer is a noop.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:16:00Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229711281",
      "id" : 229711281,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMTI4MQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 546,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170274029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229711281",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712203"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be made `explicit`?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:18:09Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {\n+        auto pn = reinterpret_cast<std::uintptr_t>(ptr);\n+        auto aligned = (pn + alignment - 1) & -alignment;\n+        auto new_space = space - (aligned - pn);\n+        if (new_space < size) {\n+            return nullptr;\n+        }\n+        space = new_space;\n+        return ptr = reinterpret_cast<void *>(aligned);\n+    }\n+\n+    void init(const LogEntry&);\n+    void init(int32_t relTimestamp, const CBlockIndex&);\n+    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);\n+    void clear();\n+\n+public:\n+    enum LogEntryType {\n+        LET_BLOCK,\n+        LET_TX,\n+    };\n+    static const QString LogEntryTypeAbbreviation(LogEntryType);\n+\n+    LogEntry(const LogEntry&);\n+    LogEntry() : data(NULL) { }\n+    explicit LogEntry(int32_t relTimestamp, const CBlockIndex&);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionWeakref&, bool weak = true);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionRef&, bool weak = false);\n+    ~LogEntry();\n+\n+    LogEntry& operator=(const LogEntry& other);\n+\n+    explicit operator bool() const;\n+    int32_t getRelTimestamp() const;\n+    uint64_t getTimestamp(uint64_t now) const;\n+    LogEntryType getType() const;\n+\n+    template <typename T> T* get() const {\n+        void *p = data + sizeof(meta_t);\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        return (T*)p;\n+    }\n+\n+    const CBlockIndex& getBlockIndex() const;\n+    CTransactionRef getTransactionRef() const;\n+    bool isWeak() const;\n+    bool expired() const;\n+    void makeWeak();\n+};\n+\n+class NetWatchLogModel;\n+\n+class NetWatchLogSearch {\n+public:\n+    QString query;\n+\n+    bool fCheckType;\n+    bool fCheckId;\n+    bool fCheckAddr;\n+    bool fCheckValue;\n+\n+    NetWatchLogSearch(const QString& query, int displayunit);\n+    bool match(const NetWatchLogModel& model, int row) const;\n+};\n+\n+class NetWatchValidationInterface;\n+\n+class NetWatchLogModel : public QAbstractTableModel\n+{\n+    Q_OBJECT\n+\n+private:\n+    QWidget * const widget;\n+    ClientModel *clientModel = nullptr;\n+\n+    NetWatchValidationInterface *validation_interface;\n+\n+    mutable CCriticalSection cs;\n+    std::vector<LogEntry> log;\n+    static const size_t logsizelimit = 0x400;\n+    size_t logpos = 0;\n+    size_t logskip = 0;\n+\n+    static const size_t max_nonweak_txouts = 0x200;\n+    static const size_t max_vout_per_tx = 0x100;\n+\n+    NetWatchLogSearch *currentSearch = nullptr;\n+\n+    const LogEntry& getLogEntryRow(int row) const;\n+    LogEntry& getLogEntryRow(int row);\n+    void log_append(const LogEntry&, size_t& rows_used);\n+\n+public:\n+    static const int NWLMHeaderCount = 5;\n+    enum Header {\n+        NWLMH_TIME,\n+        NWLMH_TYPE,\n+        NWLMH_ID,\n+        NWLMH_ADDR,\n+        NWLMH_VALUE,\n+    };\n+\n+    NetWatchLogModel(QWidget *parent);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712203",
      "id" : 229712203,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjIwMw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 160,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170275230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712203",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712598"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be marked `override`?",
      "commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "created_at" : "2018-10-31T14:19:03Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712598",
      "id" : 229712598,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjU5OA==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 273,
      "path" : "src/qt/netwatch.cpp",
      "position" : 273,
      "pull_request_review_id" : 170275740,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2018-10-31T14:19:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712598",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712853"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be marked `override`?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:19:39Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712853",
      "id" : 229712853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjg1Mw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 278,
      "path" : "src/qt/netwatch.cpp",
      "position" : 278,
      "pull_request_review_id" : 170276064,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712853",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712885"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712885"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be marked `override`?",
      "commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "created_at" : "2018-10-31T14:19:44Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712885",
      "id" : 229712885,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjg4NQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 285,
      "path" : "src/qt/netwatch.cpp",
      "position" : 285,
      "pull_request_review_id" : 170276106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2018-10-31T14:19:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712885",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229713713"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229713713"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove extra spaces after `(` and before `)` :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:21:39Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229713713",
      "id" : 229713713,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMzcxMw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 56,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170277164,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229713713",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229830322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229830322"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure. The intent is only to make sure `vtx[0]` below is an acceptable dereference.\r\n\r\nThe actual check for block data is above, with `if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA))`",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:08:05Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229830322",
      "id" : 229830322,
      "in_reply_to_id" : 229710344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzMDMyMg==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 343,
      "path" : "src/qt/netwatch.cpp",
      "position" : 343,
      "pull_request_review_id" : 170424601,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229830322",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229836085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229836085"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\nqt/netwatch.cpp:273:70: error: virt-specifiers in Ã¢ÂÂValidationInterfaceUnregisteringÃ¢ÂÂ not allowed outside a class definition\r\n```\r\n\r\nAdding it to only the class def instead...",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:26:52Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229836085",
      "id" : 229836085,
      "in_reply_to_id" : 229712853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzNjA4NQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 278,
      "path" : "src/qt/netwatch.cpp",
      "position" : 278,
      "pull_request_review_id" : 170432166,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229836085",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837477"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837477"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see -- makes sense :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:31:40Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837477",
      "id" : 229837477,
      "in_reply_to_id" : 229710344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzNzQ3Nw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 343,
      "path" : "src/qt/netwatch.cpp",
      "position" : 343,
      "pull_request_review_id" : 170434054,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837477",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sounds good. I commented on the wrong line :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:33:11Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837851",
      "id" : 229837851,
      "in_reply_to_id" : 229712853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzNzg1MQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 278,
      "path" : "src/qt/netwatch.cpp",
      "position" : 278,
      "pull_request_review_id" : 170434583,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837851",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r230554831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230554831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see this assertion on Windows in testing, haven't take a look at the code.\r\n\r\n![image](https://user-images.githubusercontent.com/11154118/47952673-edfe4380-dfad-11e8-8e40-a667be01659c.png)\r\n",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-11-03T13:17:38Z",
      "diff_hunk" : "@@ -0,0 +1,827 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/networkstyle.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QVBoxLayout>\n+#include <QWidget>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.m_data) {\n+        m_data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.m_data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    m_data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)m_data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    m_data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);\n+        new (m_data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (m_data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)m_data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!m_data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)m_data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete m_data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return m_data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)m_data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    explicit NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering() override;\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void TransactionAddedToMempool(const CTransactionRef &) override;\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    m_widget(parent),\n+    m_validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(m_validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (m_validation_interface) {\n+        UnregisterValidationInterface(m_validation_interface);\n+        delete m_validation_interface;\n+        m_validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete m_validation_interface;\n+    m_validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return m_log.size() - m_logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (m_client_model) {\n+                return BitcoinUnits::format(m_client_model->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return m_widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return m_widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = m_widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (m_client_model) {\n+                return BitcoinUnits::getAmountColumnTitle(m_client_model->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& query, int display_unit) :\n+    m_query(query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    m_check_type = m_query.length() < 4 && reType.exactMatch(m_query);\n+    m_check_id = m_query.length() <= 64 && reHex.exactMatch(m_query);\n+    m_check_addr = m_query.length() <= nLongestAddress;\n+    CAmount val;\n+    m_check_value = BitcoinUnits::parse(display_unit, m_query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(m_query)) {\n+        return true;\n+    } else if (m_check_type && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_id && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_addr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_value && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(m_query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = m_client_model->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->m_check_addr || newsearch->m_check_value) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = nullptr;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (m_logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --m_logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!m_logpos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r230554831",
      "id" : 230554831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU1NDgzMQ==",
      "original_commit_id" : "654f66d9e0f7a31e3c9b9ac6af30da5f5bdb4fb1",
      "original_position" : 577,
      "path" : "src/qt/netwatch.cpp",
      "position" : 577,
      "pull_request_review_id" : 171327281,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230554831",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r238032221"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238032221"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This could go to window menu, which is added in #14573.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-11-30T23:23:51Z",
      "diff_hunk" : "@@ -397,6 +404,7 @@ void BitcoinGUI::createMenuBar()\n     settings->addAction(optionsAction);\n \n     QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\n+    help->addAction(m_show_netwatch_action);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r238032221",
      "id" : 238032221,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODAzMjIyMQ==",
      "original_commit_id" : "654f66d9e0f7a31e3c9b9ac6af30da5f5bdb4fb1",
      "original_position" : 48,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 180487486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238032221",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-12-16T07:13:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-447622632",
      "id" : 447622632,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NzYyMjYzMg==",
      "updated_at" : "2018-12-16T07:13:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447622632",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256072587"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256072587"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any idea how?>",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2019-02-12T17:51:52Z",
      "diff_hunk" : "@@ -0,0 +1,827 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/networkstyle.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QVBoxLayout>\n+#include <QWidget>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.m_data) {\n+        m_data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.m_data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    m_data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)m_data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    m_data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);\n+        new (m_data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (m_data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)m_data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!m_data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)m_data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete m_data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return m_data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)m_data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    explicit NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering() override;\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void TransactionAddedToMempool(const CTransactionRef &) override;\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    m_widget(parent),\n+    m_validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(m_validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (m_validation_interface) {\n+        UnregisterValidationInterface(m_validation_interface);\n+        delete m_validation_interface;\n+        m_validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete m_validation_interface;\n+    m_validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return m_log.size() - m_logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (m_client_model) {\n+                return BitcoinUnits::format(m_client_model->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return m_widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return m_widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = m_widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (m_client_model) {\n+                return BitcoinUnits::getAmountColumnTitle(m_client_model->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& query, int display_unit) :\n+    m_query(query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    m_check_type = m_query.length() < 4 && reType.exactMatch(m_query);\n+    m_check_id = m_query.length() <= 64 && reHex.exactMatch(m_query);\n+    m_check_addr = m_query.length() <= nLongestAddress;\n+    CAmount val;\n+    m_check_value = BitcoinUnits::parse(display_unit, m_query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(m_query)) {\n+        return true;\n+    } else if (m_check_type && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_id && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_addr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_value && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(m_query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = m_client_model->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->m_check_addr || newsearch->m_check_value) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = nullptr;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (m_logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --m_logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!m_logpos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256072587",
      "id" : 256072587,
      "in_reply_to_id" : 230554831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NjA3MjU4Nw==",
      "original_commit_id" : "654f66d9e0f7a31e3c9b9ac6af30da5f5bdb4fb1",
      "original_position" : 577,
      "path" : "src/qt/netwatch.cpp",
      "position" : 577,
      "pull_request_review_id" : 202815929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T17:51:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256072587",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256345224"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256345224"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Shift overflow?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2019-02-13T11:00:48Z",
      "diff_hunk" : "@@ -0,0 +1,827 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/networkstyle.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <util/time.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QVBoxLayout>\n+#include <QWidget>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.m_data) {\n+        m_data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.m_data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    m_data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)m_data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    m_data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);\n+        new (m_data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (m_data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)m_data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!m_data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)m_data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete m_data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return m_data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)m_data) |= (3 << 30);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256345224",
      "id" : 256345224,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NjM0NTIyNA==",
      "original_commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "original_position" : 258,
      "path" : "src/qt/netwatch.cpp",
      "position" : 258,
      "pull_request_review_id" : 203146959,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-13T11:00:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256345224",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-08-16T07:41:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-521918656",
      "id" : 521918656,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyMTkxODY1Ng==",
      "updated_at" : "2019-08-16T07:41:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/521918656",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "As this PR has been inactive for a long time, I'm closing this (but marking \"up for grabs\").",
      "created_at" : "2019-09-30T11:53:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-536527746",
      "id" : 536527746,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzNjUyNzc0Ng==",
      "updated_at" : "2019-09-30T11:53:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/536527746",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   }
]
