[
   {
      "author_association" : "MEMBER",
      "body" : "@sanket1729 @apoelstra may be interested too",
      "created_at" : "2020-01-21T17:01:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-576778692",
      "id" : 576778692,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3Njc3ODY5Mg==",
      "updated_at" : "2020-01-21T17:01:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/576778692",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369175249"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369175249"
         }
      },
      "author_association" : "NONE",
      "body" : "should be `=` rather than `+=` in two lines above, otherwise `child_is_e` will be converted to int and will always be `>= 1`",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-01-21T18:41:15Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_y.p.f and (child_x.p.f or child_z.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_y.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_z.p.s and (child_x.p.s or child_y.p.s) else \"\"\n+        self._construct(NodeType.ANDOR, Property().from_string(prop_str),\n+                        [child_x, child_y, child_z],\n+                        self._andor_sat, self._andor_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[\n+                        OP_ELSE]+child_y._script+[OP_ENDIF],\n+                        \"andor(\"+child_x.desc+\",\"+child_y.desc+\",\"\n+                        + child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_a(self, child_x):\n+        prop_str = \"\"\n+        prop_str += \"W\" if child_x.p.B else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"a\" if Node._is_wrapper(child_x) else \"a:\"\n+        self._construct(NodeType.WRAP_A, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._a_sat, self._a_dsat,\n+                        [OP_TOALTSTACK]+child_x._script+[OP_FROMALTSTACK],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_s(self, child_x):\n+        assert (child_x.p.B and child_x.p.o)\n+        prop_str = \"W\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"s\" if Node._is_wrapper(child_x) else \"s:\"\n+        self._construct(NodeType.WRAP_S, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._s_sat, self._s_dsat,\n+                        [OP_SWAP]+child_x._script, tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_c(self, child_x):\n+        assert child_x.p.K\n+        prop_str = \"Bu\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"c\" if Node._is_wrapper(child_x) else \"c:\"\n+        self._construct(NodeType.WRAP_C, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._c_sat, self._c_dsat,\n+                        child_x._script+[OP_CHECKSIG], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_t(self, child_x):\n+        prop_str = \"uf\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"t\" if Node._is_wrapper(child_x) else \"t:\"\n+        self._construct(NodeType.WRAP_T, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._t_sat, self._t_dsat,\n+                        child_x._script+[1], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_d(self, child_x):\n+        assert(child_x.p.z)\n+        prop_str = \"nud\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"d\" if Node._is_wrapper(child_x) else \"d:\"\n+        self._construct(NodeType.WRAP_D, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._d_sat, self._d_dsat,\n+                        [OP_DUP, OP_IF]+child_x._script+[OP_ENDIF],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_v(self, child_x):\n+        assert child_x.p.B\n+        prop_str = \"V\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"f\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"v\" if Node._is_wrapper(child_x) else \"v:\"\n+        # Combine OP_CHECKSIG/OP_CHECKMULTISIG/OP_EQUAL with OP_VERIFY.\n+        if child_x._script[-1] == OP_CHECKSIG:\n+            script = child_x._script[:-1]+[OP_CHECKSIGVERIFY]\n+        elif child_x._script[-1] == OP_CHECKMULTISIG:\n+            script = child_x._script[:-1]+[OP_CHECKMULTISIGVERIFY]\n+        elif child_x._script[-1] == OP_EQUAL:\n+            script = child_x._script[:-1]+[OP_EQUALVERIFY]\n+        else:\n+            script = child_x._script+[OP_VERIFY]\n+        self._construct(NodeType.WRAP_V, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._v_sat, self._v_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_j(self, child_x):\n+        assert(child_x.p.n)\n+        prop_str = \"nd\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"j\" if Node._is_wrapper(child_x) else \"j:\"\n+        script = [OP_SIZE, OP_0NOTEQUAL, OP_IF]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_J, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._j_sat, self._j_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_n(self, child_x):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"n\" if Node._is_wrapper(child_x) else \"n:\"\n+        self._construct(NodeType.WRAP_N, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._n_sat, self._n_dsat,\n+                        child_x._script+[OP_0NOTEQUAL], tag+child_x.desc)\n+        return self\n+\n+    def construct_l(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"l\" if Node._is_wrapper(child_x) else \"l:\"\n+        script = [OP_IF, 0, OP_ELSE]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_L, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._l_sat, self._l_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_u(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"u\" if Node._is_wrapper(child_x) else \"u:\"\n+        script = [OP_IF]+child_x._script+[OP_ELSE, 0, OP_ENDIF]\n+        self._construct(NodeType.WRAP_U, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._u_sat, self._u_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_thresh(self, k, children_n):\n+        n = len(children_n)\n+        assert n > k > 1\n+        child_is_z_count = 0\n+        child_is_o_count = 0\n+        child_is_s_count = 0\n+        child_is_e = True\n+        child_is_m = True\n+        for idx, child in enumerate(children_n):\n+            assert child.p.d and child.p.u\n+            child_is_z_count += 1 if child.p.z else 0\n+            child_is_o_count += 1 if child.p.o else 0\n+            child_is_s_count += 1 if child.p.s else 0\n+            child_is_e += child_is_e and child.p.e\n+            child_is_m += child_is_m and child.p.m",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369175249",
      "id" : 369175249,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3NTI0OQ==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1301,
      "original_position" : 1301,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 346103997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369175249",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/43240089?v=4",
         "events_url" : "https://api.github.com/users/dgpv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgpv/followers",
         "following_url" : "https://api.github.com/users/dgpv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgpv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgpv",
         "id" : 43240089,
         "login" : "dgpv",
         "node_id" : "MDQ6VXNlcjQzMjQwMDg5",
         "organizations_url" : "https://api.github.com/users/dgpv/orgs",
         "received_events_url" : "https://api.github.com/users/dgpv/received_events",
         "repos_url" : "https://api.github.com/users/dgpv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgpv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgpv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgpv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369181782"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369181782"
         }
      },
      "author_association" : "NONE",
      "body" : "why not `child.t.name.startswith('WRAP_')` ?",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-01-21T18:54:09Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_y.p.f and (child_x.p.f or child_z.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_y.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_z.p.s and (child_x.p.s or child_y.p.s) else \"\"\n+        self._construct(NodeType.ANDOR, Property().from_string(prop_str),\n+                        [child_x, child_y, child_z],\n+                        self._andor_sat, self._andor_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[\n+                        OP_ELSE]+child_y._script+[OP_ENDIF],\n+                        \"andor(\"+child_x.desc+\",\"+child_y.desc+\",\"\n+                        + child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_a(self, child_x):\n+        prop_str = \"\"\n+        prop_str += \"W\" if child_x.p.B else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"a\" if Node._is_wrapper(child_x) else \"a:\"\n+        self._construct(NodeType.WRAP_A, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._a_sat, self._a_dsat,\n+                        [OP_TOALTSTACK]+child_x._script+[OP_FROMALTSTACK],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_s(self, child_x):\n+        assert (child_x.p.B and child_x.p.o)\n+        prop_str = \"W\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"s\" if Node._is_wrapper(child_x) else \"s:\"\n+        self._construct(NodeType.WRAP_S, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._s_sat, self._s_dsat,\n+                        [OP_SWAP]+child_x._script, tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_c(self, child_x):\n+        assert child_x.p.K\n+        prop_str = \"Bu\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"c\" if Node._is_wrapper(child_x) else \"c:\"\n+        self._construct(NodeType.WRAP_C, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._c_sat, self._c_dsat,\n+                        child_x._script+[OP_CHECKSIG], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_t(self, child_x):\n+        prop_str = \"uf\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"t\" if Node._is_wrapper(child_x) else \"t:\"\n+        self._construct(NodeType.WRAP_T, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._t_sat, self._t_dsat,\n+                        child_x._script+[1], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_d(self, child_x):\n+        assert(child_x.p.z)\n+        prop_str = \"nud\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"d\" if Node._is_wrapper(child_x) else \"d:\"\n+        self._construct(NodeType.WRAP_D, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._d_sat, self._d_dsat,\n+                        [OP_DUP, OP_IF]+child_x._script+[OP_ENDIF],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_v(self, child_x):\n+        assert child_x.p.B\n+        prop_str = \"V\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"f\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"v\" if Node._is_wrapper(child_x) else \"v:\"\n+        # Combine OP_CHECKSIG/OP_CHECKMULTISIG/OP_EQUAL with OP_VERIFY.\n+        if child_x._script[-1] == OP_CHECKSIG:\n+            script = child_x._script[:-1]+[OP_CHECKSIGVERIFY]\n+        elif child_x._script[-1] == OP_CHECKMULTISIG:\n+            script = child_x._script[:-1]+[OP_CHECKMULTISIGVERIFY]\n+        elif child_x._script[-1] == OP_EQUAL:\n+            script = child_x._script[:-1]+[OP_EQUALVERIFY]\n+        else:\n+            script = child_x._script+[OP_VERIFY]\n+        self._construct(NodeType.WRAP_V, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._v_sat, self._v_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_j(self, child_x):\n+        assert(child_x.p.n)\n+        prop_str = \"nd\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"j\" if Node._is_wrapper(child_x) else \"j:\"\n+        script = [OP_SIZE, OP_0NOTEQUAL, OP_IF]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_J, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._j_sat, self._j_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_n(self, child_x):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"n\" if Node._is_wrapper(child_x) else \"n:\"\n+        self._construct(NodeType.WRAP_N, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._n_sat, self._n_dsat,\n+                        child_x._script+[OP_0NOTEQUAL], tag+child_x.desc)\n+        return self\n+\n+    def construct_l(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"l\" if Node._is_wrapper(child_x) else \"l:\"\n+        script = [OP_IF, 0, OP_ELSE]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_L, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._l_sat, self._l_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_u(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"u\" if Node._is_wrapper(child_x) else \"u:\"\n+        script = [OP_IF]+child_x._script+[OP_ELSE, 0, OP_ENDIF]\n+        self._construct(NodeType.WRAP_U, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._u_sat, self._u_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_thresh(self, k, children_n):\n+        n = len(children_n)\n+        assert n > k > 1\n+        child_is_z_count = 0\n+        child_is_o_count = 0\n+        child_is_s_count = 0\n+        child_is_e = True\n+        child_is_m = True\n+        for idx, child in enumerate(children_n):\n+            assert child.p.d and child.p.u\n+            child_is_z_count += 1 if child.p.z else 0\n+            child_is_o_count += 1 if child.p.o else 0\n+            child_is_s_count += 1 if child.p.s else 0\n+            child_is_e += child_is_e and child.p.e\n+            child_is_m += child_is_m and child.p.m\n+            if idx == 0:\n+                is_B = child.p.B\n+            else:\n+                is_B = is_B and child.p.W\n+        prop_str = \"Wdu\" if not is_B else \"Bdu\"\n+        if child_is_z_count == n:\n+            prop_str += \"z\"\n+        elif (child_is_z_count == n-1) and (child_is_o_count == 1):\n+            prop_str += \"o\"\n+        if child_is_e and (child_is_s_count is n):\n+            prop_str += \"e\"\n+        if child_is_e and child_is_m and child_is_s_count >= (n-k):\n+            prop_str += \"m\"\n+        if child_is_s_count >= (n-k+1):\n+            prop_str += \"s\"\n+        script = []\n+        script.extend(children_n[0]._script)\n+        for child in children_n[1:]:\n+            script.extend(child._script+[OP_ADD])\n+        script.extend([k] + [OP_EQUAL])\n+        self._k = k\n+\n+        desc = \"thresh(\"+str(k)+\",\"\n+        for idx, child in enumerate(children_n):\n+            desc += child.desc\n+            desc += \",\" if idx != (n-1) else \")\"\n+\n+        self._construct(NodeType.THRESH, Property().from_string(prop_str),\n+                        children_n,\n+                        self._thresh_sat, self._thresh_dsat,\n+                        script, desc\n+                        )\n+        return self\n+\n+    def _construct(self,\n+                   node_type, node_prop,\n+                   children,\n+                   sat, dsat,\n+                   script, desc):\n+        self.t = node_type\n+        self.p = node_prop\n+        self.children = children\n+        self._sat = sat\n+        self._dsat = dsat\n+        self.sat = self._lift_sat()\n+        self.dsat = self._lift_dsat()\n+        self._sat_ncan = self._lift_sat_ncan()\n+        self._dsat_ncan = self._lift_dsat_ncan()\n+        self._script = script\n+        self.desc = desc\n+\n+    # sat/dsat methods for terminal node types:\n+    def _just_1_sat(self):\n+        return [[]]\n+\n+    def _just_1_dsat(self):\n+        return [[]]\n+\n+    def _just_0_sat(self):\n+        return [[]]\n+\n+    def _just_0_dsat(self):\n+        return [[]]\n+\n+    def _pk_sat(self):\n+        # Returns (SIGNATURE, 33B_PK) tuple.\n+        return [[(SatType.SIGNATURE, self._pk[0])]]\n+\n+    def _pk_dsat(self):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _pk_h_sat(self):\n+        # Returns (SIGNATURE, 32B_PK_HASH) tuple.\n+        return [[(SatType.SIGNATURE, self._pk_h),\n+                 (SatType.KEY_AND_HASH160_PREIMAGE, self._pk_h)]]\n+\n+    def _pk_h_dsat(self):\n+        return [[(SatType.DATA, b''),\n+                (SatType.KEY_AND_HASH160_PREIMAGE, self._pk_h)]]\n+\n+    def _older_sat(self):\n+        return [[(SatType.OLDER, self._delay)]]\n+\n+    def _older_dsat(self):\n+        return [[]]\n+\n+    def _after_sat(self):\n+        return [[(SatType.AFTER, self._time)]]\n+\n+    def _after_dsat(self):\n+        return [[]]\n+\n+    def _sha256_sat(self):\n+        return [[(SatType.SHA256_PREIMAGE, self._sha256)]]\n+\n+    def _sha256_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _hash256_sat(self):\n+        return [[(SatType.HASH256_PREIMAGE, self._hash256)]]\n+\n+    def _hash256_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _ripemd160_sat(self):\n+        return [[(SatType.RIPEMD160_PREIMAGE, self._ripemd160)]]\n+\n+    def _ripemd160_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _hash160_sat(self):\n+        return [[(SatType.HASH160_PREIMAGE, self._hash160)]]\n+\n+    def _hash160_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _thresh_m_sat(self):\n+        thresh_m_sat_ls = []\n+        n = len(self._pk_n)\n+        for i in range(2**n):\n+            if bin(i).count(\"1\") == self._k:\n+                sat = [(SatType.DATA, b'')]\n+                for j in range(n):\n+                    if ((1 << j) & i) != 0:\n+                        sat.append((SatType.SIGNATURE, self._pk_n[j]))\n+                thresh_m_sat_ls.append(sat)\n+        return thresh_m_sat_ls\n+\n+    def _thresh_m_dsat(self):\n+        return [[(SatType.DATA, b'')]*(self._k+1)]\n+\n+    # sat/dsat methods for node types with children:\n+        # sat must return list of possible satisfying witnesses.\n+        # dsat must return (unique) non-satisfying witness if available.\n+\n+    # child_sat_set: [child_x_sat, child_y_dsat, ...]\n+    # dsat child_dsat_set: [child_x_dsat, child_y_dsat, ...]\n+\n+    def _and_v_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_v_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _and_b_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_b_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _and_n_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_n_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _or_b_sat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_b_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _or_d_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_d_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _or_c_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_c_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _or_i_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')],\n+                child_sat_set[1]+[(SatType.DATA, b'')]]\n+\n+    def _or_i_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'\\x01')]+child_dsat_set[1] + [\n+                (SatType.DATA, b'')]]\n+\n+    def _andor_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0],\n+                child_sat_set[2]+child_dsat_set[0]]\n+\n+    def _andor_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[2]+child_dsat_set[0]]\n+\n+    def _a_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _a_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _s_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _s_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _c_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _c_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _t_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _t_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _d_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')]]\n+\n+    def _d_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _v_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _v_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _j_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _j_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _n_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _n_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _l_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'')]]\n+\n+    def _l_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'\\x01')]]\n+\n+    def _u_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')]]\n+\n+    def _u_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _thresh_sat(self, child_sat_set, child_dsat_set):\n+        thresh_sat_ls = []\n+        n = len(self.children)\n+        for i in range(2**n):\n+            if bin(i).co",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369181782",
      "id" : 369181782,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4MTc4Mg==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1697,
      "original_position" : 1697,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 346112175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369181782",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/43240089?v=4",
         "events_url" : "https://api.github.com/users/dgpv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgpv/followers",
         "following_url" : "https://api.github.com/users/dgpv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgpv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgpv",
         "id" : 43240089,
         "login" : "dgpv",
         "node_id" : "MDQ6VXNlcjQzMjQwMDg5",
         "organizations_url" : "https://api.github.com/users/dgpv/orgs",
         "received_events_url" : "https://api.github.com/users/dgpv/received_events",
         "repos_url" : "https://api.github.com/users/dgpv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgpv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgpv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgpv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369203105"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369203105"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's much better. Thx.",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-01-21T19:38:32Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_y.p.f and (child_x.p.f or child_z.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_y.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_z.p.s and (child_x.p.s or child_y.p.s) else \"\"\n+        self._construct(NodeType.ANDOR, Property().from_string(prop_str),\n+                        [child_x, child_y, child_z],\n+                        self._andor_sat, self._andor_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[\n+                        OP_ELSE]+child_y._script+[OP_ENDIF],\n+                        \"andor(\"+child_x.desc+\",\"+child_y.desc+\",\"\n+                        + child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_a(self, child_x):\n+        prop_str = \"\"\n+        prop_str += \"W\" if child_x.p.B else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"a\" if Node._is_wrapper(child_x) else \"a:\"\n+        self._construct(NodeType.WRAP_A, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._a_sat, self._a_dsat,\n+                        [OP_TOALTSTACK]+child_x._script+[OP_FROMALTSTACK],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_s(self, child_x):\n+        assert (child_x.p.B and child_x.p.o)\n+        prop_str = \"W\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"s\" if Node._is_wrapper(child_x) else \"s:\"\n+        self._construct(NodeType.WRAP_S, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._s_sat, self._s_dsat,\n+                        [OP_SWAP]+child_x._script, tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_c(self, child_x):\n+        assert child_x.p.K\n+        prop_str = \"Bu\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"c\" if Node._is_wrapper(child_x) else \"c:\"\n+        self._construct(NodeType.WRAP_C, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._c_sat, self._c_dsat,\n+                        child_x._script+[OP_CHECKSIG], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_t(self, child_x):\n+        prop_str = \"uf\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"t\" if Node._is_wrapper(child_x) else \"t:\"\n+        self._construct(NodeType.WRAP_T, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._t_sat, self._t_dsat,\n+                        child_x._script+[1], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_d(self, child_x):\n+        assert(child_x.p.z)\n+        prop_str = \"nud\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"d\" if Node._is_wrapper(child_x) else \"d:\"\n+        self._construct(NodeType.WRAP_D, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._d_sat, self._d_dsat,\n+                        [OP_DUP, OP_IF]+child_x._script+[OP_ENDIF],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_v(self, child_x):\n+        assert child_x.p.B\n+        prop_str = \"V\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"f\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"v\" if Node._is_wrapper(child_x) else \"v:\"\n+        # Combine OP_CHECKSIG/OP_CHECKMULTISIG/OP_EQUAL with OP_VERIFY.\n+        if child_x._script[-1] == OP_CHECKSIG:\n+            script = child_x._script[:-1]+[OP_CHECKSIGVERIFY]\n+        elif child_x._script[-1] == OP_CHECKMULTISIG:\n+            script = child_x._script[:-1]+[OP_CHECKMULTISIGVERIFY]\n+        elif child_x._script[-1] == OP_EQUAL:\n+            script = child_x._script[:-1]+[OP_EQUALVERIFY]\n+        else:\n+            script = child_x._script+[OP_VERIFY]\n+        self._construct(NodeType.WRAP_V, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._v_sat, self._v_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_j(self, child_x):\n+        assert(child_x.p.n)\n+        prop_str = \"nd\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"j\" if Node._is_wrapper(child_x) else \"j:\"\n+        script = [OP_SIZE, OP_0NOTEQUAL, OP_IF]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_J, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._j_sat, self._j_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_n(self, child_x):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"n\" if Node._is_wrapper(child_x) else \"n:\"\n+        self._construct(NodeType.WRAP_N, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._n_sat, self._n_dsat,\n+                        child_x._script+[OP_0NOTEQUAL], tag+child_x.desc)\n+        return self\n+\n+    def construct_l(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"l\" if Node._is_wrapper(child_x) else \"l:\"\n+        script = [OP_IF, 0, OP_ELSE]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_L, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._l_sat, self._l_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_u(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"u\" if Node._is_wrapper(child_x) else \"u:\"\n+        script = [OP_IF]+child_x._script+[OP_ELSE, 0, OP_ENDIF]\n+        self._construct(NodeType.WRAP_U, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._u_sat, self._u_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_thresh(self, k, children_n):\n+        n = len(children_n)\n+        assert n > k > 1\n+        child_is_z_count = 0\n+        child_is_o_count = 0\n+        child_is_s_count = 0\n+        child_is_e = True\n+        child_is_m = True\n+        for idx, child in enumerate(children_n):\n+            assert child.p.d and child.p.u\n+            child_is_z_count += 1 if child.p.z else 0\n+            child_is_o_count += 1 if child.p.o else 0\n+            child_is_s_count += 1 if child.p.s else 0\n+            child_is_e += child_is_e and child.p.e\n+            child_is_m += child_is_m and child.p.m\n+            if idx == 0:\n+                is_B = child.p.B\n+            else:\n+                is_B = is_B and child.p.W\n+        prop_str = \"Wdu\" if not is_B else \"Bdu\"\n+        if child_is_z_count == n:\n+            prop_str += \"z\"\n+        elif (child_is_z_count == n-1) and (child_is_o_count == 1):\n+            prop_str += \"o\"\n+        if child_is_e and (child_is_s_count is n):\n+            prop_str += \"e\"\n+        if child_is_e and child_is_m and child_is_s_count >= (n-k):\n+            prop_str += \"m\"\n+        if child_is_s_count >= (n-k+1):\n+            prop_str += \"s\"\n+        script = []\n+        script.extend(children_n[0]._script)\n+        for child in children_n[1:]:\n+            script.extend(child._script+[OP_ADD])\n+        script.extend([k] + [OP_EQUAL])\n+        self._k = k\n+\n+        desc = \"thresh(\"+str(k)+\",\"\n+        for idx, child in enumerate(children_n):\n+            desc += child.desc\n+            desc += \",\" if idx != (n-1) else \")\"\n+\n+        self._construct(NodeType.THRESH, Property().from_string(prop_str),\n+                        children_n,\n+                        self._thresh_sat, self._thresh_dsat,\n+                        script, desc\n+                        )\n+        return self\n+\n+    def _construct(self,\n+                   node_type, node_prop,\n+                   children,\n+                   sat, dsat,\n+                   script, desc):\n+        self.t = node_type\n+        self.p = node_prop\n+        self.children = children\n+        self._sat = sat\n+        self._dsat = dsat\n+        self.sat = self._lift_sat()\n+        self.dsat = self._lift_dsat()\n+        self._sat_ncan = self._lift_sat_ncan()\n+        self._dsat_ncan = self._lift_dsat_ncan()\n+        self._script = script\n+        self.desc = desc\n+\n+    # sat/dsat methods for terminal node types:\n+    def _just_1_sat(self):\n+        return [[]]\n+\n+    def _just_1_dsat(self):\n+        return [[]]\n+\n+    def _just_0_sat(self):\n+        return [[]]\n+\n+    def _just_0_dsat(self):\n+        return [[]]\n+\n+    def _pk_sat(self):\n+        # Returns (SIGNATURE, 33B_PK) tuple.\n+        return [[(SatType.SIGNATURE, self._pk[0])]]\n+\n+    def _pk_dsat(self):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _pk_h_sat(self):\n+        # Returns (SIGNATURE, 32B_PK_HASH) tuple.\n+        return [[(SatType.SIGNATURE, self._pk_h),\n+                 (SatType.KEY_AND_HASH160_PREIMAGE, self._pk_h)]]\n+\n+    def _pk_h_dsat(self):\n+        return [[(SatType.DATA, b''),\n+                (SatType.KEY_AND_HASH160_PREIMAGE, self._pk_h)]]\n+\n+    def _older_sat(self):\n+        return [[(SatType.OLDER, self._delay)]]\n+\n+    def _older_dsat(self):\n+        return [[]]\n+\n+    def _after_sat(self):\n+        return [[(SatType.AFTER, self._time)]]\n+\n+    def _after_dsat(self):\n+        return [[]]\n+\n+    def _sha256_sat(self):\n+        return [[(SatType.SHA256_PREIMAGE, self._sha256)]]\n+\n+    def _sha256_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _hash256_sat(self):\n+        return [[(SatType.HASH256_PREIMAGE, self._hash256)]]\n+\n+    def _hash256_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _ripemd160_sat(self):\n+        return [[(SatType.RIPEMD160_PREIMAGE, self._ripemd160)]]\n+\n+    def _ripemd160_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _hash160_sat(self):\n+        return [[(SatType.HASH160_PREIMAGE, self._hash160)]]\n+\n+    def _hash160_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _thresh_m_sat(self):\n+        thresh_m_sat_ls = []\n+        n = len(self._pk_n)\n+        for i in range(2**n):\n+            if bin(i).count(\"1\") == self._k:\n+                sat = [(SatType.DATA, b'')]\n+                for j in range(n):\n+                    if ((1 << j) & i) != 0:\n+                        sat.append((SatType.SIGNATURE, self._pk_n[j]))\n+                thresh_m_sat_ls.append(sat)\n+        return thresh_m_sat_ls\n+\n+    def _thresh_m_dsat(self):\n+        return [[(SatType.DATA, b'')]*(self._k+1)]\n+\n+    # sat/dsat methods for node types with children:\n+        # sat must return list of possible satisfying witnesses.\n+        # dsat must return (unique) non-satisfying witness if available.\n+\n+    # child_sat_set: [child_x_sat, child_y_dsat, ...]\n+    # dsat child_dsat_set: [child_x_dsat, child_y_dsat, ...]\n+\n+    def _and_v_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_v_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _and_b_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_b_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _and_n_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_n_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _or_b_sat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_b_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _or_d_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_d_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _or_c_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_c_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _or_i_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')],\n+                child_sat_set[1]+[(SatType.DATA, b'')]]\n+\n+    def _or_i_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'\\x01')]+child_dsat_set[1] + [\n+                (SatType.DATA, b'')]]\n+\n+    def _andor_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0],\n+                child_sat_set[2]+child_dsat_set[0]]\n+\n+    def _andor_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[2]+child_dsat_set[0]]\n+\n+    def _a_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _a_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _s_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _s_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _c_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _c_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _t_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _t_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _d_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')]]\n+\n+    def _d_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _v_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _v_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _j_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _j_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _n_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _n_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _l_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'')]]\n+\n+    def _l_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'\\x01')]]\n+\n+    def _u_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')]]\n+\n+    def _u_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _thresh_sat(self, child_sat_set, child_dsat_set):\n+        thresh_sat_ls = []\n+        n = len(self.children)\n+        for i in range(2**n):\n+            if bin(i).co",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369203105",
      "id" : 369203105,
      "in_reply_to_id" : 369181782,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwMzEwNQ==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1697,
      "original_position" : 1697,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 346139623,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369203105",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369204453"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369204453"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Excellent catch. Thank you for review.",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-01-21T19:41:32Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_y.p.f and (child_x.p.f or child_z.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_y.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_z.p.s and (child_x.p.s or child_y.p.s) else \"\"\n+        self._construct(NodeType.ANDOR, Property().from_string(prop_str),\n+                        [child_x, child_y, child_z],\n+                        self._andor_sat, self._andor_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[\n+                        OP_ELSE]+child_y._script+[OP_ENDIF],\n+                        \"andor(\"+child_x.desc+\",\"+child_y.desc+\",\"\n+                        + child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_a(self, child_x):\n+        prop_str = \"\"\n+        prop_str += \"W\" if child_x.p.B else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"a\" if Node._is_wrapper(child_x) else \"a:\"\n+        self._construct(NodeType.WRAP_A, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._a_sat, self._a_dsat,\n+                        [OP_TOALTSTACK]+child_x._script+[OP_FROMALTSTACK],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_s(self, child_x):\n+        assert (child_x.p.B and child_x.p.o)\n+        prop_str = \"W\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"s\" if Node._is_wrapper(child_x) else \"s:\"\n+        self._construct(NodeType.WRAP_S, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._s_sat, self._s_dsat,\n+                        [OP_SWAP]+child_x._script, tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_c(self, child_x):\n+        assert child_x.p.K\n+        prop_str = \"Bu\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"c\" if Node._is_wrapper(child_x) else \"c:\"\n+        self._construct(NodeType.WRAP_C, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._c_sat, self._c_dsat,\n+                        child_x._script+[OP_CHECKSIG], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_t(self, child_x):\n+        prop_str = \"uf\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"t\" if Node._is_wrapper(child_x) else \"t:\"\n+        self._construct(NodeType.WRAP_T, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._t_sat, self._t_dsat,\n+                        child_x._script+[1], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_d(self, child_x):\n+        assert(child_x.p.z)\n+        prop_str = \"nud\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"d\" if Node._is_wrapper(child_x) else \"d:\"\n+        self._construct(NodeType.WRAP_D, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._d_sat, self._d_dsat,\n+                        [OP_DUP, OP_IF]+child_x._script+[OP_ENDIF],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_v(self, child_x):\n+        assert child_x.p.B\n+        prop_str = \"V\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"f\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"v\" if Node._is_wrapper(child_x) else \"v:\"\n+        # Combine OP_CHECKSIG/OP_CHECKMULTISIG/OP_EQUAL with OP_VERIFY.\n+        if child_x._script[-1] == OP_CHECKSIG:\n+            script = child_x._script[:-1]+[OP_CHECKSIGVERIFY]\n+        elif child_x._script[-1] == OP_CHECKMULTISIG:\n+            script = child_x._script[:-1]+[OP_CHECKMULTISIGVERIFY]\n+        elif child_x._script[-1] == OP_EQUAL:\n+            script = child_x._script[:-1]+[OP_EQUALVERIFY]\n+        else:\n+            script = child_x._script+[OP_VERIFY]\n+        self._construct(NodeType.WRAP_V, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._v_sat, self._v_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_j(self, child_x):\n+        assert(child_x.p.n)\n+        prop_str = \"nd\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"j\" if Node._is_wrapper(child_x) else \"j:\"\n+        script = [OP_SIZE, OP_0NOTEQUAL, OP_IF]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_J, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._j_sat, self._j_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_n(self, child_x):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"n\" if Node._is_wrapper(child_x) else \"n:\"\n+        self._construct(NodeType.WRAP_N, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._n_sat, self._n_dsat,\n+                        child_x._script+[OP_0NOTEQUAL], tag+child_x.desc)\n+        return self\n+\n+    def construct_l(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"l\" if Node._is_wrapper(child_x) else \"l:\"\n+        script = [OP_IF, 0, OP_ELSE]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_L, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._l_sat, self._l_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_u(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"u\" if Node._is_wrapper(child_x) else \"u:\"\n+        script = [OP_IF]+child_x._script+[OP_ELSE, 0, OP_ENDIF]\n+        self._construct(NodeType.WRAP_U, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._u_sat, self._u_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_thresh(self, k, children_n):\n+        n = len(children_n)\n+        assert n > k > 1\n+        child_is_z_count = 0\n+        child_is_o_count = 0\n+        child_is_s_count = 0\n+        child_is_e = True\n+        child_is_m = True\n+        for idx, child in enumerate(children_n):\n+            assert child.p.d and child.p.u\n+            child_is_z_count += 1 if child.p.z else 0\n+            child_is_o_count += 1 if child.p.o else 0\n+            child_is_s_count += 1 if child.p.s else 0\n+            child_is_e += child_is_e and child.p.e\n+            child_is_m += child_is_m and child.p.m",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369204453",
      "id" : 369204453,
      "in_reply_to_id" : 369175249,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwNDQ1Mw==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1301,
      "original_position" : 1301,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 346141375,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369204453",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "This looks great. To get the concept ACK I'm wondering what the arguments against are. I think (I may be mistaken) these are broadly long term motivations and sketched out roadmap-like issues.\r\n\r\n1) Does Bitcoin Core *need* to be able to recognize Miniscript in the future? Are the future upsides sufficiently material to introduce it? Presumably Miniscript could always be translated to Script externally to Core at little cost?\r\n\r\n2) Is this a stepping stone towards greater support for Miniscript (and possibly a policy language too) in Core? What impact does this have on the use and ongoing development of external libraries like the [Rust Miniscript library](https://github.com/apoelstra/rust-miniscript)?\r\n\r\n3) I'm not convinced of the rationale \"entry point for developers\" as a motivation. Does Miniscript support in the test framework provide any material assistance/assurance to external wallet developers? \r\n\r\nI'm excited by the potential of Miniscript and look forward to following future work on this.\r\n\r\n",
      "created_at" : "2020-01-22T09:41:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-577095603",
      "id" : 577095603,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3NzA5NTYwMw==",
      "updated_at" : "2020-01-22T09:41:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/577095603",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/16323900?v=4",
         "events_url" : "https://api.github.com/users/michaelfolkson/events{/privacy}",
         "followers_url" : "https://api.github.com/users/michaelfolkson/followers",
         "following_url" : "https://api.github.com/users/michaelfolkson/following{/other_user}",
         "gists_url" : "https://api.github.com/users/michaelfolkson/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/michaelfolkson",
         "id" : 16323900,
         "login" : "michaelfolkson",
         "node_id" : "MDQ6VXNlcjE2MzIzOTAw",
         "organizations_url" : "https://api.github.com/users/michaelfolkson/orgs",
         "received_events_url" : "https://api.github.com/users/michaelfolkson/received_events",
         "repos_url" : "https://api.github.com/users/michaelfolkson/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/michaelfolkson/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/michaelfolkson/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/michaelfolkson"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369540740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369540740"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Please change this to \"The Bitcoin Core developers\" or add your name on line 105 in https://github.com/bitcoin/bitcoin/blob/master/contrib/devtools/copyright_header.py\r\n\r\nOtherwise it will get overridden by the copyright-headers script",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-01-22T12:51:08Z",
      "diff_hunk" : "@@ -0,0 +1,433 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369540740",
      "id" : 369540740,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0MDc0MA==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 2,
      "original_position" : 2,
      "original_start_line" : null,
      "path" : "test/functional/feature_miniscript.py",
      "position" : null,
      "pull_request_review_id" : 346562311,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369540740",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/12272949?v=4",
         "events_url" : "https://api.github.com/users/emilengler/events{/privacy}",
         "followers_url" : "https://api.github.com/users/emilengler/followers",
         "following_url" : "https://api.github.com/users/emilengler/following{/other_user}",
         "gists_url" : "https://api.github.com/users/emilengler/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/emilengler",
         "id" : 12272949,
         "login" : "emilengler",
         "node_id" : "MDQ6VXNlcjEyMjcyOTQ5",
         "organizations_url" : "https://api.github.com/users/emilengler/orgs",
         "received_events_url" : "https://api.github.com/users/emilengler/received_events",
         "repos_url" : "https://api.github.com/users/emilengler/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/emilengler/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/emilengler/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/emilengler"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369549291"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369549291"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thank you for the review and tip, will gladly amend copyright header as you suggested!",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-01-22T13:10:34Z",
      "diff_hunk" : "@@ -0,0 +1,433 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r369549291",
      "id" : 369549291,
      "in_reply_to_id" : 369540740,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU0OTI5MQ==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 2,
      "original_position" : 2,
      "original_start_line" : null,
      "path" : "test/functional/feature_miniscript.py",
      "position" : null,
      "pull_request_review_id" : 346573444,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369549291",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jachiang\r\n\r\nVery nice to see another Miniscript implementation! I love Miniscript! :)\r\n\r\nYou might want to check your Python implementation for the following issues I've reported in the C++ and Rust implementations:\r\n* [Issues reported in the C++ implementation (7 of which I would consider bugs)](https://github.com/sipa/miniscript/issues?utf8=%E2%9C%93&q=is%3Aissue+author%3Apracticalswift+)\r\n* [Issues reported in the Rust implementation (8 of which I would consider bugs)](https://github.com/apoelstra/rust-miniscript/issues?utf8=%E2%9C%93&q=is%3Aissue+author%3Apracticalswift+)\r\n\r\nThe bugs are somewhat overlapping across implementations.\r\n\r\nAs you can see six of the seven bugs in the Rust implementation have been resolved, and hopefully the eight bugs in the C++ implementation will be resolved soon :)\r\n\r\nOf the eight bugs in the C++ implementation only one bug affects the initial Bitcoin Core Miniscript PR #16800 (\"Basic Miniscript support in output descriptors\"). That is a heap out-of-bounds read in `Node::CalcOps` (called indirectly from `miniscript::FromScript`) which I reported in https://github.com/bitcoin/bitcoin/pull/16800#issuecomment-530808234 and suggested a solution for in https://github.com/sipa/miniscript/pull/18 (\"Avoid heap out-of-bounds read in Node::CalcOps (test case: OP_0 OP_2 OP_EQUAL) and assertion failure in ComputeType (test case: OP_0 OP_0 OP_EQUAL)\").",
      "created_at" : "2020-01-22T13:38:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-577185437",
      "id" : 577185437,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3NzE4NTQzNw==",
      "updated_at" : "2020-01-22T13:38:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/577185437",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK. Moving these high level questions to a RFC (#18040) so as not to hold up review of the details of this PR. https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-577095603",
      "created_at" : "2020-01-31T13:21:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-580730613",
      "id" : 580730613,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MDczMDYxMw==",
      "updated_at" : "2020-01-31T13:21:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/580730613",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/16323900?v=4",
         "events_url" : "https://api.github.com/users/michaelfolkson/events{/privacy}",
         "followers_url" : "https://api.github.com/users/michaelfolkson/followers",
         "following_url" : "https://api.github.com/users/michaelfolkson/following{/other_user}",
         "gists_url" : "https://api.github.com/users/michaelfolkson/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/michaelfolkson",
         "id" : 16323900,
         "login" : "michaelfolkson",
         "node_id" : "MDQ6VXNlcjE2MzIzOTAw",
         "organizations_url" : "https://api.github.com/users/michaelfolkson/orgs",
         "received_events_url" : "https://api.github.com/users/michaelfolkson/received_events",
         "repos_url" : "https://api.github.com/users/michaelfolkson/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/michaelfolkson/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/michaelfolkson/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/michaelfolkson"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373809703"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373809703"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this should be ` prop_str += \"f\" if child_x.p.s or child_y.p.f else \"\" ` . Since the left child must have a base type`V`, it always has malleability property `f`. The above statement will make all `and_v` has property `f`. \r\nThere is only one possible non-canonical dissat being [sat(X), dissat(Y)] which gives us self.f = `sx or fy`. \r\n\r\nOne valid miniscript counter-example: `and_v(vc:pk(A),and_v(v:after(10),sha256(H)))` where right branch of first `and_v` is not an `f`.",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T00:07:28Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373809703",
      "id" : 373809703,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwOTcwMw==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 943,
      "original_position" : 943,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351911145,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373809703",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373816993"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373816993"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be `f=fxfy or sxfx or syfy`",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T03:47:30Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373816993",
      "id" : 373816993,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxNjk5Mw==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 962,
      "original_position" : 962,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373816993",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373819067"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373819067"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit: Always `d`",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T04:48:41Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373819067",
      "id" : 373819067,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxOTA2Nw==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 982,
      "original_position" : 982,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373819067",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373819524"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373819524"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit: Can never be f. Convert to an assertion?",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T05:00:18Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373819524",
      "id" : 373819524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxOTUyNA==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 983,
      "original_position" : 983,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373819524",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373820402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373820402"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this should be `or` instead of `and`?",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T05:23:56Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373820402",
      "id" : 373820402,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMDQwMg==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 988,
      "original_position" : 988,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373820402",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373820482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373820482"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "unnecessary since it's already added at the start of function",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T05:26:40Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373820482",
      "id" : 373820482,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMDQ4Mg==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1005,
      "original_position" : 1005,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373820482",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373820527"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373820527"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This should never happen. Maybe replace it with an assertion?",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T05:28:17Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373820527",
      "id" : 373820527,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMDUyNw==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1006,
      "original_position" : 1006,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373820527",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373821064"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373821064"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing both V condition",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T05:46:31Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373821064",
      "id" : 373821064,
      "line" : 1064,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMTA2NA==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1064,
      "original_position" : 1064,
      "original_start_line" : 1063,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : 1064,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : 1063,
      "start_side" : "RIGHT",
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373821064",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373821331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373821331"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "f = fz and (sx or fy)",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T05:52:16Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_y.p.f and (child_x.p.f or child_z.p.f) else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373821331",
      "id" : 373821331,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMTMzMQ==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1094,
      "original_position" : 1094,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373821331",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373822958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373822958"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be if \"Bdu\" if is_B, otherwise \"\"",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T06:31:47Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_y.p.f and (child_x.p.f or child_z.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_y.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_z.p.s and (child_x.p.s or child_y.p.s) else \"\"\n+        self._construct(NodeType.ANDOR, Property().from_string(prop_str),\n+                        [child_x, child_y, child_z],\n+                        self._andor_sat, self._andor_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[\n+                        OP_ELSE]+child_y._script+[OP_ENDIF],\n+                        \"andor(\"+child_x.desc+\",\"+child_y.desc+\",\"\n+                        + child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_a(self, child_x):\n+        prop_str = \"\"\n+        prop_str += \"W\" if child_x.p.B else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"a\" if Node._is_wrapper(child_x) else \"a:\"\n+        self._construct(NodeType.WRAP_A, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._a_sat, self._a_dsat,\n+                        [OP_TOALTSTACK]+child_x._script+[OP_FROMALTSTACK],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_s(self, child_x):\n+        assert (child_x.p.B and child_x.p.o)\n+        prop_str = \"W\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"s\" if Node._is_wrapper(child_x) else \"s:\"\n+        self._construct(NodeType.WRAP_S, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._s_sat, self._s_dsat,\n+                        [OP_SWAP]+child_x._script, tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_c(self, child_x):\n+        assert child_x.p.K\n+        prop_str = \"Bu\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"c\" if Node._is_wrapper(child_x) else \"c:\"\n+        self._construct(NodeType.WRAP_C, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._c_sat, self._c_dsat,\n+                        child_x._script+[OP_CHECKSIG], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_t(self, child_x):\n+        prop_str = \"uf\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"t\" if Node._is_wrapper(child_x) else \"t:\"\n+        self._construct(NodeType.WRAP_T, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._t_sat, self._t_dsat,\n+                        child_x._script+[1], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_d(self, child_x):\n+        assert(child_x.p.z)\n+        prop_str = \"nud\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"d\" if Node._is_wrapper(child_x) else \"d:\"\n+        self._construct(NodeType.WRAP_D, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._d_sat, self._d_dsat,\n+                        [OP_DUP, OP_IF]+child_x._script+[OP_ENDIF],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_v(self, child_x):\n+        assert child_x.p.B\n+        prop_str = \"V\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"f\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"v\" if Node._is_wrapper(child_x) else \"v:\"\n+        # Combine OP_CHECKSIG/OP_CHECKMULTISIG/OP_EQUAL with OP_VERIFY.\n+        if child_x._script[-1] == OP_CHECKSIG:\n+            script = child_x._script[:-1]+[OP_CHECKSIGVERIFY]\n+        elif child_x._script[-1] == OP_CHECKMULTISIG:\n+            script = child_x._script[:-1]+[OP_CHECKMULTISIGVERIFY]\n+        elif child_x._script[-1] == OP_EQUAL:\n+            script = child_x._script[:-1]+[OP_EQUALVERIFY]\n+        else:\n+            script = child_x._script+[OP_VERIFY]\n+        self._construct(NodeType.WRAP_V, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._v_sat, self._v_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_j(self, child_x):\n+        assert(child_x.p.n)\n+        prop_str = \"nd\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"j\" if Node._is_wrapper(child_x) else \"j:\"\n+        script = [OP_SIZE, OP_0NOTEQUAL, OP_IF]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_J, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._j_sat, self._j_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_n(self, child_x):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"n\" if Node._is_wrapper(child_x) else \"n:\"\n+        self._construct(NodeType.WRAP_N, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._n_sat, self._n_dsat,\n+                        child_x._script+[OP_0NOTEQUAL], tag+child_x.desc)\n+        return self\n+\n+    def construct_l(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"l\" if Node._is_wrapper(child_x) else \"l:\"\n+        script = [OP_IF, 0, OP_ELSE]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_L, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._l_sat, self._l_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_u(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"u\" if Node._is_wrapper(child_x) else \"u:\"\n+        script = [OP_IF]+child_x._script+[OP_ELSE, 0, OP_ENDIF]\n+        self._construct(NodeType.WRAP_U, Property().from_string(prop_str),\n+                        [child_x],\n+                        self._u_sat, self._u_dsat,\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_thresh(self, k, children_n):\n+        n = len(children_n)\n+        assert n > k > 1\n+        child_is_z_count = 0\n+        child_is_o_count = 0\n+        child_is_s_count = 0\n+        child_is_e = True\n+        child_is_m = True\n+        for idx, child in enumerate(children_n):\n+            assert child.p.d and child.p.u\n+            child_is_z_count += 1 if child.p.z else 0\n+            child_is_o_count += 1 if child.p.o else 0\n+            child_is_s_count += 1 if child.p.s else 0\n+            child_is_e += child_is_e and child.p.e\n+            child_is_m += child_is_m and child.p.m\n+            if idx == 0:\n+                is_B = child.p.B\n+            else:\n+                is_B = is_B and child.p.W\n+        prop_str = \"Wdu\" if not is_B else \"Bdu\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373822958",
      "id" : 373822958,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjk1OA==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1306,
      "original_position" : 1306,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351917030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373822958",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6881849?v=4",
         "events_url" : "https://api.github.com/users/sanket1729/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sanket1729/followers",
         "following_url" : "https://api.github.com/users/sanket1729/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sanket1729/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sanket1729",
         "id" : 6881849,
         "login" : "sanket1729",
         "node_id" : "MDQ6VXNlcjY4ODE4NDk=",
         "organizations_url" : "https://api.github.com/users/sanket1729/orgs",
         "received_events_url" : "https://api.github.com/users/sanket1729/received_events",
         "repos_url" : "https://api.github.com/users/sanket1729/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sanket1729/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sanket1729/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sanket1729"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829160"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes absolutely! Thanks for the correction!",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T08:40:08Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829160",
      "id" : 373829160,
      "in_reply_to_id" : 373820402,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyOTE2MA==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 988,
      "original_position" : 988,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351927150,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829160",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829295"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829295"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah yes, both V are from revised rules.",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T08:42:29Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829295",
      "id" : 373829295,
      "in_reply_to_id" : 373821064,
      "line" : 1064,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyOTI5NQ==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1064,
      "original_position" : 1064,
      "original_start_line" : 1063,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : 1064,
      "pull_request_review_id" : 351927243,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : 1063,
      "start_side" : "RIGHT",
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829295",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829390"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829390"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Got it, revised rules again :)",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T08:44:16Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_y.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert(child_x.p.d and child_z.p.d)\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert(child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_y.p.f and (child_x.p.f or child_z.p.f) else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829390",
      "id" : 373829390,
      "in_reply_to_id" : 373821331,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyOTM5MA==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 1094,
      "original_position" : 1094,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351927315,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829390",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829712"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This was a mistake in encoding the property rules, thank you.",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-02-02T08:50:02Z",
      "diff_hunk" : "@@ -0,0 +1,1709 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 James Chiang\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_y.p.f else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r373829712",
      "id" : 373829712,
      "in_reply_to_id" : 373809703,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyOTcxMg==",
      "original_commit_id" : "5d31fb46b621a4cd9c17987df7541f2637baa529",
      "original_line" : 943,
      "original_position" : 943,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : null,
      "pull_request_review_id" : 351927610,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-03-14T13:52:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373829712",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2020-02-05T13:57:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-582419401",
      "id" : 582419401,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MjQxOTQwMQ==",
      "updated_at" : "2020-02-05T13:57:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/582419401",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Apologies for the delay updating this PR. \r\n\r\nf8a30b4c7 includes rebase and changes suggested by reviewers so far. ",
      "created_at" : "2020-03-14T13:56:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-599064494",
      "id" : 599064494,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5OTA2NDQ5NA==",
      "updated_at" : "2020-03-14T13:56:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/599064494",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r449902553"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/449902553"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be type \"V\" if both \"V\".",
      "commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "created_at" : "2020-07-05T17:54:07Z",
      "diff_hunk" : "@@ -0,0 +1,1694 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+from enum import Enum\n+from itertools import product\n+\n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert (hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29\n+\n+\n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        self._just_1_sat, self._just_1_dsat,\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        self._just_0_sat, self._just_0_dsat,\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        self._pk_sat, self._pk_dsat,\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._older_sat, self._older_dsat,\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        self._after_sat, self._after_dsat,\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._sha256_sat, self._sha256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash256_sat, self._hash256_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        self._hash160_sat, self._hash160_dsat,\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.s or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if (child_x.p.f and child_y.p.f) or \\\n+            (child_x.p.s and child_x.p.f) or \\\n+            (child_y.p.s and child_y.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert (child_x.p.d and child_x.p.u)\n+        assert (child_x.p.f and child_y.p.f) is False\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert (child_x.p.d and child_z.p.d)\n+        assert (child_x.p.f or child_z.p.f) is False\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert (child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert (child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_z.p.V else \"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#discussion_r449902553",
      "id" : 449902553,
      "line" : 1065,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkwMjU1Mw==",
      "original_commit_id" : "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "original_line" : 1065,
      "original_position" : 1065,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/miniscript.py",
      "position" : 1065,
      "pull_request_review_id" : 442695452,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17975",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-05T17:54:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/449902553",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Another option here which might not be too bad in the scheme of things would be to check in a WASM blob that is gitian built of e.g. rust miniscript, and then call it using a wasm runtime https://github.com/wasmerio/wasmer-python\r\n\r\nthe main benefit being we don't have to check in yet another implementation of miniscript to maintain as miniscript evolves, we can use the rust or c++ one today, and when the C++ becomes merged & available as an RPC we can drop it.",
      "created_at" : "2021-08-06T15:51:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-894352293",
      "id" : 894352293,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII5841Trul",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-06T15:52:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/894352293",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> the main benefit being we don't have to check in yet another implementation of miniscript to maintain as miniscript evolves, we can use the rust or c++ one today, and when the C++ becomes merged & available as an RPC we can drop it.\r\n\r\nIn the absence of a formal, (mechanizable) specification of Miniscript (MS), separate implementations have higher chances of finding bugs or problems than a single, canonical one. I think this should be a goal of the test-framework. Having said that, I believe the biggest challenge here is the lack of a formal specification of MS and by extension, Script itself, without which, the correctness of the MS type-system is impossible to verify. One must assume the MS authors are working on this.",
      "created_at" : "2021-08-07T13:51:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-894657750",
      "id" : 894657750,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII5841U2TW",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-07T13:52:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/894657750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/26572234?v=4",
         "events_url" : "https://api.github.com/users/jachiang/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jachiang/followers",
         "following_url" : "https://api.github.com/users/jachiang/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jachiang/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jachiang",
         "id" : 26572234,
         "login" : "jachiang",
         "node_id" : "MDQ6VXNlcjI2NTcyMjM0",
         "organizations_url" : "https://api.github.com/users/jachiang/orgs",
         "received_events_url" : "https://api.github.com/users/jachiang/received_events",
         "repos_url" : "https://api.github.com/users/jachiang/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jachiang/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jachiang"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> In the absence of a formal, (mechanizable) specification of Miniscript (MS), separate implementations have higher chances of finding bugs or problems than a single, canonical one. I think this should be a goal of the test-framework.\r\n\r\nAgreed. Concept ACK.\r\n",
      "created_at" : "2021-12-08T07:35:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-988569170",
      "id" : 988569170,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII58467F5S",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/988569170/reactions"
      },
      "updated_at" : "2021-12-08T07:35:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/988569170",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm assuming this PR could be closed then @darosior? Direct interested parties for Python Miniscript/Miniscript support in test framework to https://github.com/darosior/python-bip380? When that's in a ready state a new PR will be opened in this repo?",
      "created_at" : "2022-05-25T11:23:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-1137120731",
      "id" : 1137120731,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII585DxxXb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1137120731/reactions"
      },
      "updated_at" : "2022-05-25T11:23:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1137120731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/16323900?v=4",
         "events_url" : "https://api.github.com/users/michaelfolkson/events{/privacy}",
         "followers_url" : "https://api.github.com/users/michaelfolkson/followers",
         "following_url" : "https://api.github.com/users/michaelfolkson/following{/other_user}",
         "gists_url" : "https://api.github.com/users/michaelfolkson/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/michaelfolkson",
         "id" : 16323900,
         "login" : "michaelfolkson",
         "node_id" : "MDQ6VXNlcjE2MzIzOTAw",
         "organizations_url" : "https://api.github.com/users/michaelfolkson/orgs",
         "received_events_url" : "https://api.github.com/users/michaelfolkson/received_events",
         "repos_url" : "https://api.github.com/users/michaelfolkson/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/michaelfolkson/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/michaelfolkson/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/michaelfolkson"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@michaelfolkson it's not my PR to close. :sweat_smile:\r\n\r\n> When that's in a ready state a new PR will be opened in this repo?\r\n\r\nI think having multiple implementations of Miniscript is good, but having multiple ones *as part of this repo* would only have marginal benefits, if at all.",
      "created_at" : "2022-05-25T12:54:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-1137203345",
      "id" : 1137203345,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII585DyFiR",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1137203345/reactions"
      },
      "updated_at" : "2022-05-25T12:55:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1137203345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> @michaelfolkson it's not my PR to close\r\n\r\nOk up to @jachiang then. Your repo is building on his work and he should be credited when a new PR is opened (which I'm sure you would anyway)",
      "created_at" : "2022-05-25T13:02:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-1137210785",
      "id" : 1137210785,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII585DyHWh",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1137210785/reactions"
      },
      "updated_at" : "2022-05-25T13:02:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1137210785",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/16323900?v=4",
         "events_url" : "https://api.github.com/users/michaelfolkson/events{/privacy}",
         "followers_url" : "https://api.github.com/users/michaelfolkson/followers",
         "following_url" : "https://api.github.com/users/michaelfolkson/following{/other_user}",
         "gists_url" : "https://api.github.com/users/michaelfolkson/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/michaelfolkson",
         "id" : 16323900,
         "login" : "michaelfolkson",
         "node_id" : "MDQ6VXNlcjE2MzIzOTAw",
         "organizations_url" : "https://api.github.com/users/michaelfolkson/orgs",
         "received_events_url" : "https://api.github.com/users/michaelfolkson/received_events",
         "repos_url" : "https://api.github.com/users/michaelfolkson/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/michaelfolkson/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/michaelfolkson/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/michaelfolkson"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> @michaelfolkson it's not my PR to close. ð\r\n> \r\n> > When that's in a ready state a new PR will be opened in this repo?\r\n> \r\n> I think having multiple implementations of Miniscript is good, but having multiple ones _as part of this repo_ would only have marginal benefits, if at all.\r\n\r\nA good set of test vectors is one way to compare implementations. Lacking that, it's nice if we can generate a few thousand miniscripts in Python and compare them with what the C++ code does.\r\n\r\nNow that #24148 has landed, it should be more straight forward to rebase this PR and do the comparison by e.g. calling `deriveaddresses` on various `wsh(some_miniscript)`.",
      "created_at" : "2022-07-16T13:33:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-1186186233",
      "id" : 1186186233,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII585Gs8P5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1186186233/reactions"
      },
      "updated_at" : "2022-07-16T13:33:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1186186233",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "We did have those, but for some reason we dropped them in the C++ test framework. We can probably add those back. Dmitri generated thousands of Miniscripts (for testing timelock mixes initially) we tested rust-miniscript and the C++ implem against.\n\nIf you want an up to dare Python implem i have one at https://github.com/darosior/python-bip380. But again i'm not convinced we should maintain it as part of this repo.\n-------- Original Message --------\nOn Jul 16, 2022, 3:33 PM, Sjors Provoost wrote:\n\n>> ***@***.***(https://github.com/michaelfolkson) it's not my PR to close. ð\n>>\n>>> When that's in a ready state a new PR will be opened in this repo?\n>>\n>> I think having multiple implementations of Miniscript is good, but having multiple ones as part of this repo would only have marginal benefits, if at all.\n>\n> A good set of test vectors is one way to compare implementations. Lacking that, it's nice if we can generate a few thousand miniscripts in Python and compare them with what the C++ code does.\n>\n> Now that [#24148](https://github.com/bitcoin/bitcoin/pull/24148) has landed, it should be more straight forward to rebase this PR and do the comparison by e.g. calling deriveaddresses on various wsh(some_miniscript).\n>\n> â\n> Reply to this email directly, [view it on GitHub](https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-1186186233), or [unsubscribe](https://github.com/notifications/unsubscribe-auth/AFLK3FZCTEHAKZMQRZ5WGU3VUK23RANCNFSM4KJWWXTA).\n> You are receiving this because you were mentioned.Message ID: ***@***.***>",
      "created_at" : "2022-07-16T20:18:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-1186282978",
      "id" : 1186282978,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII585GtT3i",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1186282978/reactions"
      },
      "updated_at" : "2022-07-16T20:18:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1186282978",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Closing this as it has not had any activity in a while. If you are interested in continuing work on this, please leave a comment so that it can be reopened.",
      "created_at" : "2022-10-12T18:05:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17975#issuecomment-1276549331",
      "id" : 1276549331,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17975",
      "node_id" : "IC_kwDOABII585MFpjT",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276549331/reactions"
      },
      "updated_at" : "2022-10-12T18:05:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276549331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
