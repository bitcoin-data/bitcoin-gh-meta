{
   "assignee" : null,
   "assignees" : [],
   "author_association" : "CONTRIBUTOR",
   "body" : "As mentioned https://botbot.me/freenode/bitcoin-core-dev/msg/83983170/, in Qt making slow or blocking calls in the event loop thread makes the user interface nonresponsive. Keyboard and mouse events are not processed and the display is not updated. There are different places in the code where this can happen, so this github issue is intended to be an umbrella issue to figure out a general strategy for turning synchronous calls into asynchronous ones and dealing with the problem.\r\n\r\n# Background\r\n\r\nIn Qt, there are two different ways to keep the event thread responsive when handling an event that triggers an asynchronous operation:\r\n\r\n1. Return from the event handler right away after starting the operation (usually in some worker thread) so the main event loop can keep processing events.\r\n2. Run a [nested event loop](https://doc.qt.io/archives/qq/qq27-responsive-guis.html#waitinginalocaleventloop) in the event handling function in parallel with the asynchronous operation.\r\n\r\nApproach 1 requires using a using continuation style of programming that works best when an event only needs to trigger a single operation and UI update.\r\n\r\nApproach 2 can be more convenient when handling events that do more than trigger a single slow operation followed by a UI update. It can be a lot easier to implement than approach 1 in existing code, where separating all the slow operations from the ui updates could require rewriting control flow.\r\n\r\nApproach 2 doesn't work well when the user interface needs to support multiple async operations running in parallel. (For example if there are two buttons that both trigger async operations with nested event loops followed by UI updates, and you click the first button then the second button before the first operation completes, then the first ui update will be blocked until after the second nested loop exits even if the first operation completes first.)\r\n\r\n# Strategies for improvement\r\n\r\nGiven choices between returning to the main event loop or using nested loops, different strategies are possible for making slow synchronous operations asynchronous and making the GUI more responsive:\r\n\r\n1. Rewriting all blocking operations in the event thread in continuation style, never blocking in any event handler, and always returning immediately to the main event loop. This is pretty easy to do in new code, but would require rewriting a lot of existing code.\r\n\r\n2. Making a helper function using a nested event loop and a worker thread that would allow blocking code in event handlers to be easily replaced by asynchronous code, without having to change control flow. E.g. a `DoAsync` function that allows mechanically replacing code like:\r\n\r\n```\r\nResultType result = SomeSlowOperation();\r\nwidget->updateState(result);\r\n```\r\n\r\nwith:\r\n\r\n```\r\nResultType result = DoAsync([&]() { return SomeSlowOperation(); });\r\nwidget->updateState(result);\r\n```\r\n\r\n3. Running nested event loops as part of the framework introduced by #10244, using the approach described in https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294094610. This would allow code in Qt that appears to be blocking just transparently handle events in the background.\r\n\r\nRegardless of which of the above strategies are used, it could make sense to use the #10244 refactoring as a starting point because it makes blocking calls in Qt code easy to identify (they all happen through m_node / m_wallet accesses), and in a few places it combines scattered operations into single calls.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 3,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10504/comments",
   "created_at" : "2017-06-01T18:32:21Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10504/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/10504",
   "id" : 232969863,
   "labels" : [
      {
         "color" : "ebd775",
         "default" : false,
         "id" : 64584,
         "name" : "Brainstorming",
         "node_id" : "MDU6TGFiZWw2NDU4NA==",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Brainstorming"
      },
      {
         "color" : "02d7e1",
         "default" : false,
         "id" : 135946,
         "name" : "GUI",
         "node_id" : "MDU6TGFiZWwxMzU5NDY=",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/GUI"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10504/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDU6SXNzdWUyMzI5Njk4NjM=",
   "number" : 10504,
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "title" : "GUI unresponsive during slow operations",
   "updated_at" : "2018-03-16T16:06:34Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10504",
   "user" : {
      "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
      "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
      "followers_url" : "https://api.github.com/users/ryanofsky/followers",
      "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/ryanofsky",
      "id" : 7133040,
      "login" : "ryanofsky",
      "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
      "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
      "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
      "repos_url" : "https://api.github.com/users/ryanofsky/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/ryanofsky"
   }
}
