[
   {
      "body" : "Kinda inclined to NACK the floating relay fee idea here. (though everything else looks fine)\r\n\r\nWith the mempool limited in size, the minimum relay fee loses the purpose of protecting nodes from running out of RAM - that I'm sure we can agree on!\r\n\r\nFor miners, it still has the (sort of accidental) purpose of ensuring they don't fill up their blocks with useless txs that cost them more to mine in orphan risk than fee revenue. (although it's probably something like 10x or more too low for that)\r\n\r\nFor relay nodes, first let's consider transactions with a high probability of getting mined eventually. By that I mean if not for high demand the tx will eventually get mined and the sender isn't intending to double-spend it anytime soon. Here we're converging towards a more and more valuable mempool, so regardless what the minimum is bandwidth usage will diminish as the mempool value increases, eventually reaching a steady state. If I understand the floating relay fee idea, this is the same outcome, basically.\r\n\r\nWhat an attacker can game is the case where your node is accepting transactions that have a low probability of getting mined. For instance, at the extreme if we have another sigop-like bug, the attacker can fill the mempool by broadcasting high fee txs, using up bandwidth, double-spending them, and repeating. Without a floating relay fee, after each one of those cycles your relay node is immediately back to normal, helping move txs. With a floating relay fee the attacker could succeed in increasing the minimum to the point where other txs aren't getting propagated - bad!\r\n\r\nI've got some more ideas on this, but I'll save them for the list...",
      "created_at" : "2015-07-18T18:04:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122572058",
      "id" : 122572058,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T18:04:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122572058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "I'll try to explain the reasoning behind it.\r\n\r\n1) The mempool limitation uses a rule that the new, replacing transaction should pay for the relay of both the replaced transaction and the new transaction. That means that if we previously accepted low-fee transactions into the mempool (perhaps because a block was just mined, and there is now space), we've now made it unnecessarily expensive for new transactions to get in.\r\n\r\n2) The mempool limitation code uses heuristics to avoid bad performance, but this means it also makes suboptimal decisions. After many replacements, with the bottom filled with big \"packages\", it may become impossible for a significant portion of the transactions to get in, and thus, to get relayed.\r\n\r\n3) The above would even happen if the mempool code did an exhaustive search for the best possible replacement, as it is still only a per-incoming-transaction decision, and single transactions will rarely beat the fee requirements to replace a set of dependent transactions.\r\n\r\n4) The effective feerate to get relaying on the network is a sawtooth function when purely the limitation code is being used, more or less synchronized across the network. I believe it's not good for predictability to have such sharp changes - e.g., people may aim to suddenly broadcast right after a block to increase inclusion chances.\r\n\r\n5) The DoS protection with mempool limitation is still based on having a marginal price per byte on the network, and if that value drifts to much, it becomes ineffective. This also includes dust protection, which IMHO needs feedback from the network to avoid having a fixed configured value.",
      "created_at" : "2015-07-18T18:34:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122576820",
      "id" : 122576820,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T18:34:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122576820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "I do understand the worry about mempools becoming filled with high-fee but unconfirming transactions, leading to (ever) increasing fees until the mempool clears. I've thought about using fees actually in the mempool, or time-based experation. Perhaps a rule that the relay fee in case of \"high water\" mempool (above the aimed size) cannot go above the lowest feerate actually in the mempool.\r\n\r\nIn practice, what I'm seeing so far with this code in the current network conditions is that the relay fee actually goes back to the default often, and only rises a bit for a few hours at a time.",
      "created_at" : "2015-07-18T18:48:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122580009",
      "id" : 122580009,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T18:48:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122580009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "mempools are guaranteed not to fill with unconfirming transactions if you use an accurate sampling method: time-based expiration + blocks naturally confirming and clearing out transactions.\r\n\r\nAll other methods - this PR, abs size limit, floating relay fee - must be treated as inaccurate fallbacks for situations such as transaction bursts when time-based expiration fails to cap the mempool at an absolute size - because transaction replacement is fundamentally an inaccurate guess at what is best to be removed.\r\n\r\nThe solution needs to be considered holistically (and this PR is a good attempt at that):\r\n- time based expiration + natural block confs, the best way to sample what miners are actually confirming\r\n- an absolute cap, to deal with short term traffic bursts.  good local node defense.\r\n- a floating relay fee, to deal with floods and filter out will-not-confirm traffic\r\n\r\n",
      "created_at" : "2015-07-18T21:41:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122598669",
      "id" : 122598669,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T21:41:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122598669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/494411?v=3",
         "events_url" : "https://api.github.com/users/jgarzik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jgarzik/followers",
         "following_url" : "https://api.github.com/users/jgarzik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jgarzik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jgarzik",
         "id" : 494411,
         "login" : "jgarzik",
         "organizations_url" : "https://api.github.com/users/jgarzik/orgs",
         "received_events_url" : "https://api.github.com/users/jgarzik/received_events",
         "repos_url" : "https://api.github.com/users/jgarzik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jgarzik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jgarzik"
      }
   },
   {
      "body" : "Added default-48h expiry to the mempool; thanks to @ashleyholman's indexed mempool this is trivial.\r\n\r\nI was previously of the opinion that expiration doesn't really help as rebroadcast (by anyone can always override it), but in combination with floating relay fee I think it makes sense as extra protection against divergent behaviour.",
      "created_at" : "2015-07-19T00:03:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122607639",
      "id" : 122607639,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T00:03:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122607639",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "The floating fee is node-specific, which could lead to lumpy minimum fees across the network.  When some nodes raise their minimum, other nodes will see reduced traffic without having had to raise theirs.\r\n\r\nRather than just integrating with fee estimation, I wonder if fee estimation could be improved to where it serves as the dynamic fee rate mechanism.  The advantage is that it's based on the global blockchain data set.",
      "created_at" : "2015-07-19T21:06:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122707156",
      "id" : 122707156,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T21:06:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122707156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "It is true that this results in dynamic effectice relay fees across the\nnetwork, however that is inevitable with a limited memory pool linked to\nrelay.\n\nThe purpose of the floating relay is to dampen the effect of that limit,\nand make it more constant over time.\n",
      "created_at" : "2015-07-19T22:08:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122710335",
      "id" : 122710335,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T22:08:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122710335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "For the goal of maximizing fees, filling the mempool by **fee rate** is a heuristic.  Truly maximizing fees would require filling by absolute fee, subject to the size constraint, continually re-solving a **knapsack problem**.\r\n\r\nIn particular, the feerate heuristic is unkind to an efficient large-size transaction if its feerate is slightly lower than another smaller-sized transaction, and there is not enough room for both.\r\n\r\nBut for a relay node, the **goal** itself of maximizing fees does not seem right.  It allows a transaction that pays greater fees than necessary for 1-conf to push earlier transactions out, and cause fee estimates to increase.  That's good for miners, but not good for users.  A relay node should be agnostic between miners and users.\r\n\r\nThe dependent handling logic is complex.  It would be simpler if **dependents** were made **less attractive** directly because they are dependent, and to make them even less attractive for being multiple levels deep.  A nice property of this is that they automatically get more attractive later, once their parents are confirmed.\r\n\r\nAll of these reasons suggest relay nodes use a **different metric** for filling their mempool than miners use for filling blocks.  A relay node has no revenue, so profit maximization is equivalent to cost minimization.  A relay node's cost of carrying a transaction in the mempool is proportional to two main factors: the size of the transaction and the amount of time it spends in the mempool.  Therefore a possible metric for relay nodes is ``sizeBytes * expectedBlocksToConfirm(feeRate)``.  The values stored for this on mempool entries could be updated as the fee rate structure changes.",
      "created_at" : "2015-07-19T23:08:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716041",
      "id" : 122716041,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:08:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122716041",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "@sipa \r\n\r\n> 1) The mempool limitation uses a rule that the new, replacing transaction should pay for the relay of both the replaced transaction and the new transaction. That means that if we previously accepted low-fee transactions into the mempool (perhaps because a block was just mined, and there is now space), we've now made it unnecessarily expensive for new transactions to get in.\r\n>\r\n> 2) The mempool limitation code uses heuristics to avoid bad performance, but this means it also makes suboptimal decisions. After many replacements, with the bottom filled with big \"packages\", it may become impossible for a significant portion of the transactions to get in, and thus, to get relayed.\r\n>\r\n> 3) The above would even happen if the mempool code did an exhaustive search for the best possible replacement, as it is still only a per-incoming-transaction decision, and single transactions will rarely beat the fee requirements to replace a set of dependent transactions.\r\n\r\nAll these issues with large chains of unconfirmed transactions make me think it makes sense to just put a size limit on them, e.g. no single set of unconfirmed txs should be more than 125KB in size, and contain more than 100 txs. When you think about it, large unconfirmed sets are inherently problematic to mine, because it's hard to \"fit\" them in with other transactions in optimal ways. So why not just stop relaying them? The use-case is both rare, and often associated with abusive behaviors.\r\n\r\nWith that limit in place, the size difference between the largest possible package to replace, and a single transaction, would be about 625:1 (125KB to 0.2KB) If we replaced txs purely on a fee/KB basis, that'd mean the trick of replacing large transactions with small ones could get you 625x cheaper bandwidth DoS attacks - not great. However from a miner's profitability point of view, given that the mempool is much larger than a single block, it's probably still a economically rational decision. (for replace-by-fee this logic probably should be modified, but that's my problem, not yours!)\r\n\r\nNow suppose instead that we set the minimum relay fee based purely on bandwidth used. E.g. grow min relay fee during times of high bandwidth and let it decay back to the absolute minimum during lulls. In that case the attempting to do a bandwidth DoS with repeated replacements would just drive up the relay fee, quickly limiting the effectiveness of the attack to the pre-defined bandwidth limit. Having such a mechanism would also be useful for RBF. \r\n\r\n> 4) The effective feerate to get relaying on the network is a sawtooth function when purely the limitation code is being used, more or less synchronized across the network. I believe it's not good for predictability to have such sharp changes - e.g., people may aim to suddenly broadcast right after a block to increase inclusion chances.\r\n\r\nIs that actually such a bad thing? Basically what such a change would say is \"previously there was no chance that your tx would get mined, but that suddenly changed, so rebroadcast it now\" I think that's a better outcome than unnecessarily preventing perfectly valid and profitable-to-mine transactions  from getting to miners.\r\n\r\n> I do understand the worry about mempools becoming filled with high-fee but unconfirming transactions, leading to (ever) increasing fees until the mempool clears. I've thought about using fees actually in the mempool, or time-based experation. Perhaps a rule that the relay fee in case of \"high water\" mempool (above the aimed size) cannot go above the lowest feerate actually in the mempool.\r\n\r\nSo, really you have two conflicting problems with the unminable transaction issue:\r\n\r\n1) Bandwidth usage\r\n\r\n2) Unnecessarily high fees\r\n\r\nExpiration improves the situation for #2, but makes #1 worse as it lets the attacker re-use the txouts faster. OTOH, they're probably doing that anyway, because they can double-spend the outputs. Limiting total unconfirmed tx chain depth also helps here in a few ways, such as forcing the attacker to tie up more txouts in the attack. The attacker is limited by how much BTC they have access to; the larger the mempool the more BTC they need to pull off the attack.\r\n\r\nEach time a block is found and a tx is not included in that block, it's essentially a sign that the economic feerate of the tx may be lower than the apparent feerate we calculated. So quickly reducing the apparent feerate on every block for the top 1MB * x transactions found probably makes sense for the mempool. (though the mining code should use the actual feerates!) For instance, halving the feerate each time a block is found for those txs probably makes sense; the remaining part of the mempool would then act to make the bandwidth attack expensive to pull off. \r\n\r\nFinally for worst-case recovery, I agree that a 48-hour expiration can't hurt.",
      "created_at" : "2015-07-19T23:19:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716680",
      "id" : 122716680,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:19:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122716680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "As Peter Todd noted, if relay behaviour and miner behaviour are allowed to\ndiverge, there is no real need anymore to keep a mempool at all, if a\nsolution is found to deal with dependent transactions (for example,\nrelaying by package of dependent transactions).\n\nThe strategy here is trying to maintain a solution that applies to both\nrelaying and mining, trying to optimize for what is most economic to be\nmined.\n",
      "created_at" : "2015-07-19T23:22:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716820",
      "id" : 122716820,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:22:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122716820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@dgenr8 Relaying transactions that miners aren't interested in mining is pointless and just wastes bandwidth; go too far with that philosophy and large miners will start creating alternate tx submission mechanisms, which is harmful to decentralization.\r\n\r\nRe: the knapsack problem, so long as the mempool is much larger than the blocksize limit and we have a maximum transaction size well under the blocksize limit - and better yet maximum unconfirmed tx package size - ignoring the knapsack stuff is a reasonable approximation of ideal behavior anyway. There's very little legit use-cases for creating extremely large transactions, especially not extremely large chains of them. In particular, note how the efficiency gain of large transactions quickly goes down as the number of outputs goes up, while very long chains of txs are much more efficiently done with a few large single transactions.",
      "created_at" : "2015-07-19T23:30:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122717577",
      "id" : 122717577,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122717577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "@sipa @petertodd It sounds like you don't think fee estimation works?\r\n\r\nExperience with min relay fee, non-validating mining, blacklists, RBF, and other examples show that miners will always want to diverge from relay policy.\r\n\r\nThere's no point in worrying about miners creating submission mechanisms.  If it's a major worry though, creating a private miner relay network was an odd thing to do (but consistent with having the p2p relay network act in miners' interest).",
      "created_at" : "2015-07-20T00:46:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122723010",
      "id" : 122723010,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-20T00:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122723010",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "@petertodd Earlier you suggested a \"size limit on them, e.g. no single set of unconfirmed txs should be more than 125KB in size, and contain more than 100 txs,\" What is the rationale for that particular proposed limit in kB size?  It seemed arbitrary and static rather than dynamic or heuristic.\r\n\r\nI do note that you stated, \"With a floating relay fee the attacker could succeed in increasing the minimum to the point where other txs aren't getting propagated,\" but I thought @sipa's remarks in response significantly addressed your issues.\r\n\r\nRegarding that comment above in which you state in part that \"Relaying transactions that miners aren't interested in mining is pointless,\" ~ that's incorrect, and for research to support my position, please see this remark in [another recently closed pull request](https://github.com/bitcoin/bitcoin/pull/6201#issuecomment-122438594). \r\n\r\nNoted from prior remarks that a mempool is not necessarily needed (e.g., relay nodes would not need to be using a mempool; the wallet nodes, would be using a mempool, as has been indicated).\r\n\r\nQuestions:  ~ for @sipa / @petertodd \r\n\r\n- How is the mempool to be limited?\r\n (I am assuming a description very general or holistic as per @jgarzik could be described as)\r\n a) time based expiration + natural block confs,\r\n b) an absolute cap, to deal with short term traffic bursts. good local node defense.\r\n c) a floating relay fee, to deal with floods\r\n- What is the mechanism by which the UTXO set is stored (or proposed\r\nto be stored)?\r\n- How would dynamic fee determinations be calculated?\r\n- Please describe more how the general purpose messaging network might work? (described elsewhere in bitcoin-dev message thread 'Do we really need a mempool?' as \"a general-purpose messaging network paid by coin ownership if the UTXO set is split up, and some kind of expiration over time policy is implemented\")\r\n\r\nThank you",
      "created_at" : "2015-07-20T03:39:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122749234",
      "id" : 122749234,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-20T03:39:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122749234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4469280?v=3",
         "events_url" : "https://api.github.com/users/ABISprotocol/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ABISprotocol/followers",
         "following_url" : "https://api.github.com/users/ABISprotocol/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ABISprotocol/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ABISprotocol",
         "id" : 4469280,
         "login" : "ABISprotocol",
         "organizations_url" : "https://api.github.com/users/ABISprotocol/orgs",
         "received_events_url" : "https://api.github.com/users/ABISprotocol/received_events",
         "repos_url" : "https://api.github.com/users/ABISprotocol/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ABISprotocol/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ABISprotocol/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ABISprotocol"
      }
   },
   {
      "body" : "@dgenr8 If private tx submission mechanisms to miners are a significant method of getting txs to them, that places small miners at a serious disadvantage.\r\n\r\n@ABISprotocol Your discussion is mostly off-topic for this pull-req; please take it to the dev list; \"how the UTXO set is stored\" has pretty much nothing to do with the mempool; general purpose messaging is not what this pull-req is about. Above all, we're trying to fix a real and immediate issue and get a fix deployed relatively soon - maybe even in v0.11.1 That's not the time to delve too deep into long-term design issues.",
      "created_at" : "2015-07-20T13:35:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122886149",
      "id" : 122886149,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-20T13:35:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122886149",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "A general way to find transactions to be evicted (from discussion with @sipa @morcos @petertodd):\r\n\r\n* In the mempool entry, include the total size and total fees of all of the tx's ancestors.  The values used in the fee rate index are these sums, with the size and fee values of the tx itself added in.\r\n\r\n* In CompareTxMemPoolEntryByFeeRate, use 2 tiebreakers.  After feerate, 1st tiebreaker is size, 2nd tiebreaker is arrival time.  The goal is for the first to-be-removed transaction to be the largest transaction with the worst feerate, preferring to remove the later arrival if the first two values are tied.\r\n\r\n* Iterating through the list, skip any transactions with children we haven't seen yet.  Those children have a higher feerate than the parent we are looking at, and will include it. I finally got why @petertodd kept saying this.\r\n\r\n* Accumulate tx size until either enough space for new tx is found (-> evict), or feerate is higher than new tx's feerate (-> abort).",
      "created_at" : "2015-07-20T23:12:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-123085013",
      "id" : 123085013,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-21T14:18:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/123085013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "Turning off CPFP in the above scheme is a matter of simply NOT skipping parents in the third step above.  Instead, add the descendants into the eviction set.  This could make sense for relay nodes, until most miners support CPFP.",
      "created_at" : "2015-07-21T14:19:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-123330354",
      "id" : 123330354,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-21T14:19:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/123330354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35108209"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35108209"
         }
      },
      "body" : "Why not just move these things to StageTrimToSize to save the nFeesDeleted variable?\r\nFrom looking at some of @morcos work, it seems these checks can use more information from there later. ",
      "commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "created_at" : "2015-07-21T14:31:39Z",
      "diff_hunk" : "@@ -859,22 +894,29 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n+        // Try to make space in mempool\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+        if (!mempool.StageTrimToSize(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, entry, stagedelete, nFeesDeleted)) {\n+            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+        }\n+\n         // Don't accept it if it can't get into a block\n         CAmount txMinFee = GetMinRelayFee(tx, nSize, true);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35108209",
      "id" : 35108209,
      "original_commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "original_position" : 102,
      "path" : "src/main.cpp",
      "position" : 102,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455",
      "updated_at" : "2015-07-21T14:31:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35108209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35108238"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35108238"
         }
      },
      "body" : "nit s/mempool/pool",
      "commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "created_at" : "2015-07-21T14:31:55Z",
      "diff_hunk" : "@@ -859,22 +894,29 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n+        // Try to make space in mempool\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+        if (!mempool.StageTrimToSize(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, entry, stagedelete, nFeesDeleted)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35108238",
      "id" : 35108238,
      "original_commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "original_position" : 97,
      "path" : "src/main.cpp",
      "position" : 97,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455",
      "updated_at" : "2015-07-21T14:31:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35108238",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35109198"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35109198"
         }
      },
      "body" : "This loop is similar to the one in https://github.com/bitcoin/bitcoin/blob/master/src/main.cpp#L785\r\nIt would be nice to take that one here too, not only to DRY, but also because it's what alternatives to the first seen policy have needed for long. I bet petertodd's RBF release could get much simpler if we had done an equivalent movement before 0.11 (or before 0.10 when @luke-jr proposed it).",
      "commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "created_at" : "2015-07-21T14:39:05Z",
      "diff_hunk" : "@@ -429,5 +438,129 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+}\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeesRemoved) {\n+    size_t nSizeRemoved = 0;\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35109198",
      "id" : 35109198,
      "original_commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "original_position" : 187,
      "path" : "src/txmempool.cpp",
      "position" : 187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455",
      "updated_at" : "2015-07-21T14:39:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35109198",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35110771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35110771"
         }
      },
      "body" : "I'm aware it is similar, but I chose to reimplement it to be more efficient\nin this case (eviction needs to be fast, so we can try multiple\ncombinations).\n\nI'm planning on refactoring some of the code to reuse a common way of\niterating all dependencies of a transaction, but I'd prefer to wait with\nthat until the approach and necessary code paths are clear.\n",
      "commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "created_at" : "2015-07-21T14:50:48Z",
      "diff_hunk" : "@@ -429,5 +438,129 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+}\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeesRemoved) {\n+    size_t nSizeRemoved = 0;\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35110771",
      "id" : 35110771,
      "original_commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "original_position" : 187,
      "path" : "src/txmempool.cpp",
      "position" : 187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455",
      "updated_at" : "2015-07-21T14:50:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35110771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa @petertodd OK I think we're making some progress.\r\n\r\nPlease take a look at https://github.com/morcos/bitcoin/tree/softcap.\r\nIt builds off of this pull with two commits.  The first commit is this notion of being able to accept a transaction into the reserve space between the soft cap and hard cap if it pays a multiple of the relay rate.  I've been measuring the reject rate of all transactions with high feerates for 7/6 - 7/14 with a mempool limited at 32MB.  (note the soft cap was 70% of 32MB, while maintaining a hard cap at 32MB) \r\n\r\nHere are the reject rates:  \r\ntx > 30k sat/kB feerate:\r\n6455: 5%\r\n6455 with soft cap: 0.5%\r\npackage system (sorting mempool by entire packages feerate and/or fee): 1%\r\npackage with soft cap: 0.2%\r\n\r\ntx  > 60k sat/kB feerate:\r\n6455: 3%\r\n6455 with soft cap: 0.2%\r\npackage (w or wout soft cap): 0.05%\r\n\r\n\r\nI think the package system can be a second step if @sdaftuar gets it production ready in time.  But if you're ok with the soft cap idea then I think with some more tweaks we'd be close to something that's better than the status quo.  I still need to work out the proper interaction with the soft cap and your relay multiplier and the code is just a quick hack.  But if you agree with concept I'll polish it up.\r\n\r\nThe second commit is something I mentioned before, it doesn't make any sense to try to find a package to delete that uses up all of the incoming transactions fees and doesn't leave it any to pay for its own relay.  Although I think its a relatively minor effect.",
      "created_at" : "2015-07-22T02:50:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-123543826",
      "id" : 123543826,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-22T02:50:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/123543826",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "@Alex what if you cut out the floating fees, and just have a\nsoftcap/hardcap, but no target even below it?\n",
      "created_at" : "2015-07-22T12:07:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-123696341",
      "id" : 123696341,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-22T12:07:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/123696341",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35389933"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35389933"
         }
      },
      "body" : "Ok, that sounds good.\r\nBut wouldn't it be nice to have both similar loops close to each other by moving the other one here already?\r\nBoth things are about replacements. This shouldn't make the later refactor harder. All I'm asking is putting some commits before others.\r\n",
      "commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "created_at" : "2015-07-24T01:48:11Z",
      "diff_hunk" : "@@ -429,5 +438,129 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+}\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage, CAmount& nFeesRemoved) {\n+    size_t nSizeRemoved = 0;\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#discussion_r35389933",
      "id" : 35389933,
      "original_commit_id" : "2be5db0792b0991e51d246828241e0f35327595c",
      "original_position" : 187,
      "path" : "src/txmempool.cpp",
      "position" : 187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6455",
      "updated_at" : "2015-07-24T01:48:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35389933",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Superceded by #6470.",
      "created_at" : "2015-07-27T16:28:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-125264773",
      "id" : 125264773,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-27T16:28:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125264773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
