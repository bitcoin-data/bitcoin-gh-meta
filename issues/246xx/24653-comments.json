[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you can just assign to `orig_txid_2` to minimize the diff (also elsewhere)",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:15:23Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461415",
      "id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xrZyn",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919057464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:15:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461590"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590"
         }
      },
      "author_association" : "MEMBER",
      "body" : "?",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:15:33Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # Flush old notifications until evicted tx original entry\n+        (hash_str, label, mempool_seq) = seq.receive_sequence()\n+        while hash_str != orig_tx['txid']:\n+<<<<<<< HEAD\n+>>>>>>> ec13426c0d (self_transfer)\n+=======\n+>>>>>>> ead059e477 ([move only] remove `is_wallet_compiled` checks)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461590",
      "id" : 833461590,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xrZ1W",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 417,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : null,
      "pull_request_review_id" : 919057464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:15:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833462771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "whoops! fixing",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:16:27Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # Flush old notifications until evicted tx original entry\n+        (hash_str, label, mempool_seq) = seq.receive_sequence()\n+        while hash_str != orig_tx['txid']:\n+<<<<<<< HEAD\n+>>>>>>> ec13426c0d (self_transfer)\n+=======\n+>>>>>>> ead059e477 ([move only] remove `is_wallet_compiled` checks)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833462771",
      "id" : 833462771,
      "in_reply_to_id" : 833461590,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xraHz",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 417,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : null,
      "pull_request_review_id" : 919059221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:16:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833492049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "fixed! in the other cases where i reassign, i belive its because i need both the txid, wtxid, and tx body. but ill double check",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:44:01Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833492049",
      "id" : 833492049,
      "in_reply_to_id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xrhRR",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919100082,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:44:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833559426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "okay, in https://github.com/bitcoin/bitcoin/pull/24653/commits/7f943aa1e0543765f499b2f50697281d5fe22adf ive got the diff down",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T17:47:44Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833559426",
      "id" : 833559426,
      "in_reply_to_id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xrxuC",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919196158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T17:47:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833947744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this is fixed?",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-24T06:10:44Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833947744",
      "id" : 833947744,
      "in_reply_to_id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xtQhg",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919754477,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-24T06:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834105068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834105068"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "where are you still seeing an issue? I renamed `orig_tx_2` -> `orig_txid_2` and also added `payment_txid` as a variable to avoid touching lines just to rename `payment_txid` -> `payment_tx['txid']`",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-24T09:39:10Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834105068",
      "id" : 834105068,
      "in_reply_to_id" : 833461415,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xt27s",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : null,
      "pull_request_review_id" : 919974957,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834105068/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-24T09:39:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834105068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834108910"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834108910"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> where are you still seeing an issue?\r\n\r\nIn GitHub.\r\n\r\nUsually GitHub will display \"outdated\" if a review comment was addressed.\r\n\r\nYou can also check the files tab and use your browsers search feature to see that the `orig_tx_2` still exists.",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-24T09:43:12Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834108910",
      "id" : 834108910,
      "in_reply_to_id" : 833461415,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xt33u",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : null,
      "pull_request_review_id" : 919980271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834108910/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-24T09:43:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834108910",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834115287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834115287"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "sorry, you're right! it was fixed in the first commit, but not in the second commit. it's fixed now.",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-24T09:50:12Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834115287",
      "id" : 834115287,
      "in_reply_to_id" : 833461415,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xt5bX",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : null,
      "pull_request_review_id" : 919989498,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834115287/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-24T09:50:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834115287",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Nice, Concept ACK, will review this one soon!\r\n> \r\n> Some quick findings: Note that there's a typo in the PR title (s/zmg/zmq/), also I'm not sure if \"refactor\" is really applying here. For the second commit, adding a review suggestion for ignoring whitespace (not tested, but the very popular `--color-moved=dimmed-zebra` should work) would be probably very helpful for reviewers.\r\n\r\nthanks for the suggestions, @theStack ! I updated the title and also added a note for reviewers. I found that `git diff -w master` worked best for me",
      "created_at" : "2022-03-24T10:14:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#issuecomment-1077460242",
      "id" : 1077460242,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24653",
      "node_id" : "IC_kwDOABII585AOL0S",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1077460242/reactions"
      },
      "updated_at" : "2022-03-24T10:14:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1077460242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#23127](https://github.com/bitcoin/bitcoin/pull/23127) (tests: Use test framework utils where possible by vincenzopalazzo)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-03-24T15:48:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#issuecomment-1077775787",
      "id" : 1077775787,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24653",
      "node_id" : "IC_kwDOABII585APY2r",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1077775787/reactions"
      },
      "updated_at" : "2022-03-24T15:48:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1077775787",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834660130"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834660130"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unrelated: It looks like this array is unused beside the last value? Could remove it and just assign the last value to a non-array name?",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-24T19:35:28Z",
      "diff_hunk" : "@@ -455,10 +452,10 @@ def test_mempool_sync(self):\n \n         # Some transactions have been happening but we aren't consuming zmq notifications yet\n         # or we lost a ZMQ message somehow and want to start over\n-        txids = []\n+        txs = []",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834660130",
      "id" : 834660130,
      "line" : 455,
      "node_id" : "PRRC_kwDOABII584xv-ci",
      "original_commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "original_line" : 455,
      "original_position" : 331,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 331,
      "pull_request_review_id" : 920783427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834660130/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-24T19:37:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834660130",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834661173"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834661173"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I recall that you asked on IRC whether it makes sense to introduce a bumpfee method for the wallet. On a second thought, I think it could make sense.\r\n\r\nCurrently it looks like `send_self_transfer` will put an utxo in the wallet which will never exist if the tx is bumped?\r\n\r\nSo a helper could drop the utxo(s?) and even add the new ones?",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-24T19:36:56Z",
      "diff_hunk" : "@@ -484,11 +481,12 @@ def test_mempool_sync(self):\n         # Things continue to happen in the \"interim\" while waiting for snapshot results\n         # We have node 0 do all these to avoid p2p races with RBF announcements\n         for _ in range(num_txs):\n-            txids.append(self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True))\n-        self.nodes[0].bumpfee(txids[-1])\n+            txs.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+        txs[-1]['tx'].vout[0].nValue -= 1000\n+        self.nodes[0].sendrawtransaction(txs[-1]['tx'].serialize().hex())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834661173",
      "id" : 834661173,
      "line" : 486,
      "node_id" : "PRRC_kwDOABII584xv-s1",
      "original_commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "original_line" : 486,
      "original_position" : 347,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 347,
      "pull_request_review_id" : 920783427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834661173/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-24T19:37:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834661173",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835182795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835182795"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "agreed, was very confused by this array. ended up leaving it alone just to minimize my changes to just `MiniWallet`",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-25T11:24:46Z",
      "diff_hunk" : "@@ -455,10 +452,10 @@ def test_mempool_sync(self):\n \n         # Some transactions have been happening but we aren't consuming zmq notifications yet\n         # or we lost a ZMQ message somehow and want to start over\n-        txids = []\n+        txs = []",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835182795",
      "id" : 835182795,
      "in_reply_to_id" : 834660130,
      "line" : 455,
      "node_id" : "PRRC_kwDOABII584xx-DL",
      "original_commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "original_line" : 455,
      "original_position" : 331,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 331,
      "pull_request_review_id" : 921515194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835182795/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-25T11:24:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835182795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835202270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835202270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, it is good to keep unrelated changes for separate commits and/or follow-ups.",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-25T11:54:39Z",
      "diff_hunk" : "@@ -455,10 +452,10 @@ def test_mempool_sync(self):\n \n         # Some transactions have been happening but we aren't consuming zmq notifications yet\n         # or we lost a ZMQ message somehow and want to start over\n-        txids = []\n+        txs = []",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835202270",
      "id" : 835202270,
      "in_reply_to_id" : 834660130,
      "line" : 455,
      "node_id" : "PRRC_kwDOABII584xyCze",
      "original_commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "original_line" : 455,
      "original_position" : 331,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 331,
      "pull_request_review_id" : 921543206,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835202270/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-25T11:54:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835202270",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835210505"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835210505"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yep, I think it would be a useful method to have. I'll open a follow-up PR for adding it as a method to `MiniWallet`",
      "commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "created_at" : "2022-03-25T12:07:17Z",
      "diff_hunk" : "@@ -484,11 +481,12 @@ def test_mempool_sync(self):\n         # Things continue to happen in the \"interim\" while waiting for snapshot results\n         # We have node 0 do all these to avoid p2p races with RBF announcements\n         for _ in range(num_txs):\n-            txids.append(self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True))\n-        self.nodes[0].bumpfee(txids[-1])\n+            txs.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+        txs[-1]['tx'].vout[0].nValue -= 1000\n+        self.nodes[0].sendrawtransaction(txs[-1]['tx'].serialize().hex())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835210505",
      "id" : 835210505,
      "in_reply_to_id" : 834661173,
      "line" : 486,
      "node_id" : "PRRC_kwDOABII584xyE0J",
      "original_commit_id" : "bc90b8d86916d43867762a391633664676550bd8",
      "original_line" : 486,
      "original_position" : 347,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 347,
      "pull_request_review_id" : 921555336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835210505/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-25T12:07:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835210505",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   }
]
