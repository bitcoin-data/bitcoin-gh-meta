[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [josibake](https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1499652736) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "created_at" : "2023-03-28T21:10:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1487595867",
      "id" : 1487595867,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585Yqulb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1487595867/reactions"
      },
      "updated_at" : "2023-04-06T21:31:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1487595867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151165179"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151165179"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2e187ffafc9cb0490eedd079ce1cfffafecd9dba: trailing whitespace\r\n```suggestion\r\n  - you can run the packaged `verifybinaries.py ... --import-keys` script to\r\n```",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-28T21:22:48Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151165179",
      "id" : 1151165179,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EnWL7",
      "original_commit_id" : "dd6b1ce5d956fe585a8f4ecab2cdda9c6aba352b",
      "original_line" : 20,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : null,
      "pull_request_review_id" : 1361927312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151165179/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-28T21:22:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151165179",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151491320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151491320"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nittiest of nits: There already is a `verify-commits`, so I think the directory should be `verify-binaries`.",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-29T07:16:46Z",
      "diff_hunk" : "@@ -0,0 +1,59 @@\n+#!/usr/bin/env python3",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151491320",
      "id" : 1151491320,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII585Eolz4",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/test.py",
      "position" : 1,
      "pull_request_review_id" : 1362398649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151491320/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-29T09:40:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151491320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151503567"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151503567"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Where is this packaging step renaming `verify.py` to `verifybinaries.py` defined?",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-29T07:28:22Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151503567",
      "id" : 1151503567,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585EoozP",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 20,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 24,
      "pull_request_review_id" : 1362398649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151503567/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-29T09:40:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151503567",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151519024"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151519024"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "These examples lack the the `pub` or `bin` args, no?",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-29T07:42:38Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151519024",
      "id" : 1151519024,
      "line" : 45,
      "node_id" : "PRRC_kwDOABII585Eoskw",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 45,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 49,
      "pull_request_review_id" : 1362398649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151519024/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-29T09:40:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151519024",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151524134"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151524134"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What is the rationale for adding the `bitcoin-core` prefix to the example?",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-29T07:47:23Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0\n+./contrib/verifybinaries/verify.py 22.0-rc2\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1151524134",
      "id" : 1151524134,
      "line" : 47,
      "node_id" : "PRRC_kwDOABII585Eot0m",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 47,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 51,
      "pull_request_review_id" : 1362398649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151524134/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-29T09:40:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151524134",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Fetching and local verification seem to work as intended for me.\r\n\r\nCan you post your commands? Nothing is currently working as advertised in the README for me ^^.",
      "created_at" : "2023-03-29T08:17:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1488142360",
      "id" : 1488142360,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585Ys0AY",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488142360/reactions"
      },
      "updated_at" : "2023-03-29T08:17:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488142360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@TheCharlatan I see it working using e.g. the `pub` subcommand. You need to choose `pub` or `bin` to verify either the publicly-hosted binaries, or `bin` for a local binary. But you are correct the docs are now outdated...\r\n\r\n```fish\r\nâ¿ ./contrib/verifybinaries/verify.py pub bitcoin-core-23.0-x86_64\r\n[INFO] got file https://bitcoincore.org/bin/bitcoin-core-23.0/SHA256SUMS.asc as SHA256SUMS.asc\r\n[WARNING] https://bitcoin.org failed to provide file (https://bitcoin.org/bin/bitcoin-core-23.0/SHA256SUMS.asc). Continuing based solely upon https://bitcoincore.org.\r\n[INFO] got file https://bitcoincore.org/bin/bitcoin-core-23.0/SHA256SUMS as SHA256SUMS\r\n[WARNING] https://bitcoin.org failed to provide file (https://bitcoin.org/bin/bitcoin-core-23.0/SHA256SUMS). Continuing based solely upon https://bitcoincore.org.\r\n[INFO] got 17 good signatures\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('17565732E08E5E41', 'Andrew Chow <andrew@achow101.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('D7CC770B81FD22A8', 'Ben Carman <benthecarman@live.com>', trusted=False, status='expired')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('E13FC145CD3F4304', 'Antoine Poinsot <darosior@protonmail.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('ED357015286A333D', 'Duncan Dean <duncangleeddean@gmail.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('3152347D07DA627C', 'Stephan Oeste (it) <it@oeste.de>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('2EEB9F5CC09526C1', 'Michael Ford (bitcoin-otc) <fanquake@gmail.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('8E4256593F177720', 'Oliver Gugger <gugger@gmail.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('410108112E7EA81F', 'Hennadii Stepanov (GitHub key) <32963518+hebasto@users.noreply.github.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('D11BD4F33F1DB499', 'jackielove4u <jackielove4u@hotmail.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('DD78544CF91B1514', 'Jonas Ott (jonas-ott) <git@jonas-ott.de>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('F62711DBDCA8AE56', 'Dimitri <kvaciral@protonmail.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('1E4AED62986CD25D', 'Wladimir J. van der Laan <laanwj@protonmail.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('BD02942421F4889F', 'Luke Dashjr <luke@dashjr.org>', trusted=False, status='revoked')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('0A41BDC3F4FAFF1C', 'Aaron Clauson (sipsorcery) <aaron@sipsorcery.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('7E296D555E7F63A7', 'Sjors Provoost <sjors@purpledunes.com>', trusted=False, status='')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('A7BEB2621678D37D', 'vertion <vertion@protonmail.com>', trusted=False, status='expired')\r\n[INFO] GOOD SIGNATURE (untrusted): SigData('099BAD163C70FBFA', 'Will Clark <will8clark@gmail.com>', trusted=False, status='')\r\n[WARNING] key D7CC770B81FD22A8 for Ben Carman <benthecarman@live.com> is expired\r\n[WARNING] key A7BEB2621678D37D for vertion <vertion@protonmail.com> is expired\r\n[INFO] removing *-unsigned binaries (bitcoin-23.0-arm64-apple-darwin-unsigned.dmg, bitcoin-23.0-arm64-apple-darwin-unsigned.tar.gz, bitcoin-23.0-x86_64-apple-darwin-unsigned.dmg, bitcoin-23.0-x86_64-apple-darwin-unsigned.tar.gz, bitcoin-23.0-win64-setup-unsigned.exe, bitcoin-23.0-win64-unsigned.tar.gz) from verification since https://bitcoincore.org does not host *-unsigned binaries\r\n[INFO] removing *-debug binaries (bitcoin-23.0-aarch64-linux-gnu-debug.tar.gz, bitcoin-23.0-arm-linux-gnueabihf-debug.tar.gz, bitcoin-23.0-powerpc64-linux-gnu-debug.tar.gz, bitcoin-23.0-powerpc64le-linux-gnu-debug.tar.gz, bitcoin-23.0-riscv64-linux-gnu-debug.tar.gz, bitcoin-23.0-x86_64-linux-gnu-debug.tar.gz, bitcoin-23.0-win64-debug.zip) from verification since https://bitcoincore.org does not host *-debug binaries\r\n[INFO] removing *-codesignatures binaries (bitcoin-23.0-codesignatures-e36a046909ad.tar.gz) from verification since https://bitcoincore.org does not host *-codesignatures binaries\r\n[INFO] downloading bitcoin-23.0-aarch64-linux-gnu.tar.gz\r\n [INFO] downloading bitcoin-23.0-arm-linux-gnueabihf.tar.gz\r\n[INFO] downloading bitcoin-23.0-arm64-apple-darwin.dmg\r\n[INFO] downloading bitcoin-23.0-arm64-apple-darwin.tar.gz\r\n[INFO] downloading bitcoin-23.0.tar.gz\r\n[INFO] downloading bitcoin-23.0-powerpc64-linux-gnu.tar.gz\r\n[INFO] downloading bitcoin-23.0-powerpc64le-linux-gnu.tar.gz\r\n[INFO] downloading bitcoin-23.0-riscv64-linux-gnu.tar.gz\r\n[INFO] downloading bitcoin-23.0-x86_64-apple-darwin.dmg\r\n[INFO] downloading bitcoin-23.0-x86_64-apple-darwin.tar.gz\r\n[INFO] downloading bitcoin-23.0-x86_64-linux-gnu.tar.gz\r\n[INFO] downloading bitcoin-23.0-win64-setup.exe\r\n[INFO] downloading bitcoin-23.0-win64.zip\r\n[INFO] did not clean up /tmp/bitcoin_verify_binaries.bitcoin-core-23.0-x86_64\r\nVERIFIED: bitcoin-23.0-aarch64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-23.0-arm-linux-gnueabihf.tar.gz\r\nVERIFIED: bitcoin-23.0-arm64-apple-darwin.dmg\r\nVERIFIED: bitcoin-23.0-arm64-apple-darwin.tar.gz\r\nVERIFIED: bitcoin-23.0.tar.gz\r\nVERIFIED: bitcoin-23.0-powerpc64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-23.0-powerpc64le-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-23.0-riscv64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-23.0-x86_64-apple-darwin.dmg\r\nVERIFIED: bitcoin-23.0-x86_64-apple-darwin.tar.gz\r\nVERIFIED: bitcoin-23.0-x86_64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-23.0-win64-setup.exe\r\nVERIFIED: bitcoin-23.0-win64.zip\r\n```",
      "created_at" : "2023-03-29T09:33:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1488262940",
      "id" : 1488262940,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585YtRcc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488262940/reactions"
      },
      "updated_at" : "2023-03-29T09:33:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488262940",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> @TheCharlatan I see it working using e.g. the pub subcommand. You need to choose pub or bin to verify either the publicly-hosted binaries, or bin for a local binary. But you are correct the docs are now outdated...\r\n\r\nMmh, shouldn't the sample command you posted only have verified x86_64 binaries?",
      "created_at" : "2023-03-29T09:37:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1488268728",
      "id" : 1488268728,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585YtS24",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488268728/reactions"
      },
      "updated_at" : "2023-03-29T09:37:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488268728",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, there does seem to be quite a few other issues in testing currently. Just wanted to let you know how to get the thing running :)",
      "created_at" : "2023-03-29T09:38:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1488270531",
      "id" : 1488270531,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585YtTTD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488270531/reactions"
      },
      "updated_at" : "2023-03-29T09:38:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1488270531",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1153728573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153728573"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This isn't clear to me either.",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-30T19:57:56Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0\n+./contrib/verifybinaries/verify.py 22.0-rc2\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1153728573",
      "id" : 1153728573,
      "in_reply_to_id" : 1151524134,
      "line" : 47,
      "node_id" : "PRRC_kwDOABII585ExIA9",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 47,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 51,
      "pull_request_review_id" : 1365835441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153728573/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-30T19:57:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153728573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> > @TheCharlatan I see it working using e.g. the pub subcommand. You need to choose pub or bin to verify either the publicly-hosted binaries, or bin for a local binary. But you are correct the docs are now outdated...\r\n> \r\n> Mmh, shouldn't the sample command you posted only have verified x86_64 binaries?\r\n\r\nMmm, yeah, this is awkward. @achow101's original changes forced the user to specify which binaries should be checked. I requested using the contents of the SHA256SUMS file instead.\r\n\r\nThe problem with teaching the `bin` command the version syntax from `pub` is that that syntax is pretty remote-url centric. So I'm not sure it makes sense to allow the user to use the same type of filter for `bin`.\r\n\r\nShould we just go back to requiring the user to specify the bins? Downloading to a clean dir and using a wildcard should still work for tooling I think. @TheBlueMatt ?",
      "created_at" : "2023-03-30T20:02:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1490874473",
      "id" : 1490874473,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585Y3PBp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1490874473/reactions"
      },
      "updated_at" : "2023-03-30T20:02:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1490874473",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1154356697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154356697"
         }
      },
      "author_association" : "MEMBER",
      "body" : "[I mentioned in the original PR, that I think this can just be dropped](https://github.com/bitcoin/bitcoin/pull/23020#discussion_r1117049036). We know we are downloading bitcoin-core, so I'm not sure why we need to support anything other than just passing in a version number.",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-31T11:23:46Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0\n+./contrib/verifybinaries/verify.py 22.0-rc2\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1154356697",
      "id" : 1154356697,
      "in_reply_to_id" : 1151524134,
      "line" : 47,
      "node_id" : "PRRC_kwDOABII585EzhXZ",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 47,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 51,
      "pull_request_review_id" : 1366757806,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154356697/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-31T11:23:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154356697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1154358057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154358057"
         }
      },
      "author_association" : "MEMBER",
      "body" : "From https://github.com/bitcoin/bitcoin/pull/23020#discussion_r1117050954\r\n> Should we just add an explicit `--delete` argument to the script, rather than \"append a random anything\", as was proposed in https://github.com/bitcoin/bitcoin/pull/26985.",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-03-31T11:25:12Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0\n+./contrib/verifybinaries/verify.py 22.0-rc2\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0-rc1\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py 22.0-x86 --json\n+```\n+\n+Don't trust builder-keys by default, and rely only on local GPG state and manually\n+specified keys, while requiring a threshold of at least 10 trusted signatures:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py 22.0-x86 \\\n+    --no-trust-builder-keys \\\n+    --trusted-keys 74E2DEF5D77260B98BC19438099BAD163C70FBFA,9D3CC86A72F8494342EA5FD10A41BDC3F4FAFF1C \\\n+    --min-trusted-sigs 10\n ```\n \n If you only want to download the binaries of certain platform, add the corresponding suffix, e.g.:\n \n ```sh\n-./verify.py bitcoin-core-0.11.2-osx\n-./verify.py 0.12.0-linux\n-./verify.py bitcoin-core-0.13.0-rc3-win64\n+./contrib/verifybinaries/verify.py bitcoin-core-22.0-osx\n+./contrib/verifybinaries/verify.py bitcoin-core-22.0-rc2-win64\n ```\n \n If you do not want to keep the downloaded binaries, specify anything as the second parameter.\n \n ```sh\n-./verify.py bitcoin-core-0.13.0 delete\n+./contrib/verifybinaries/verify.py bitcoin-core-22.0 delete",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1154358057",
      "id" : 1154358057,
      "line" : 76,
      "node_id" : "PRRC_kwDOABII585Ezhsp",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 76,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 87,
      "pull_request_review_id" : 1366759702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154358057/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-31T11:25:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154358057",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1155770419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1155770419"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: it would be nice to have a `bin` example as well\r\n```suggestion\r\n./contrib/verifybinaries/verify.py pub bitcoin-core-23.0-rc1\r\n./contrib/verifybinaries/verify.py bin ~/Downloads/SHA256SUMS ~/Downloads/bitcoin-24.0.1-x86_64-linux-gnu.tar.gz\r\n```",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-04-03T10:21:45Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0\n+./contrib/verifybinaries/verify.py 22.0-rc2\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0-rc1",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1155770419",
      "id" : 1155770419,
      "line" : 48,
      "node_id" : "PRRC_kwDOABII585E46gz",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 48,
      "original_position" : 52,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 52,
      "pull_request_review_id" : 1368737986,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1155770419/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-03T10:53:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1155770419",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1155785561"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1155785561"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: This seems like it can be deleted, since 2 is an allowed return code and missing \"the Bitcoin Core binary release signing key\" doesn't apply\r\n\r\n```suggestion\r\n```",
      "commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "created_at" : "2023-04-03T10:35:26Z",
      "diff_hunk" : "@@ -47,136 +172,441 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    args = [\n+        'gpg', '--yes', '--decrypt', '--verify-options', 'show-primary-uid-only',\n+        '--output', output_filename if output_filename else '', signature_filename]\n+\n+    env = dict(os.environ, LANGUAGE='en')\n+    result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout}')\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^\\s*(gpg:)?(\\s+)' + patt, line)\n+\n+    detected_name = ''\n+\n+    for i, line in enumerate(output):\n+        if line_begins_with(r\"using (ECDSA|RSA) key (0x[0-9a-fA-F]{16}|[0-9a-fA-F]{40})$\", line):\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if line_begins_with(r\"Can't check signature: No public key$\", line):\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, detected_name, False, ''))\n+            detected_name = ''\n+            curr_key = None\n+\n+        if line_begins_with(r'Good signature from (\".+\")(\\s+)(\\[.+\\])$', line):\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if line_begins_with(\"issuer \", line):\n+            detected_name = line.split(\"issuer \")[-1].strip('\"')\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if line_begins_with('Signature made ', line):\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> t.Tuple[str, str]:\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sigfilename: str, args: argparse.Namespace):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n+\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] >= 22:\n+        min_good_sigs = args.min_good_sigs\n+        gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+        got_sums_status = get_files_from_hosts_and_compare(\n+            hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+        if got_sums_status != ReturnCode.SUCCESS:\n+            return got_sums_status\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_multisig(SIGNATUREFILENAME, args)\n+    else:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        if gpg_retval == 2:\n+            log.critical(\n+                \"gpg error. Do you have the Bitcoin Core binary release \"\n+                \"signing key installed?\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1155785561",
      "id" : 1155785561,
      "line" : 384,
      "node_id" : "PRRC_kwDOABII585E4-NZ",
      "original_commit_id" : "37c9fb7a59a3179b90ed1deaebaabb539976504b",
      "original_line" : 488,
      "original_position" : 551,
      "original_start_line" : 485,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 407,
      "pull_request_review_id" : 1368737986,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1155785561/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 381,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-04-03T10:53:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1155785561",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Downloading to a clean dir and using a wildcard should still work for tooling I think. @TheBlueMatt ?\r\n\r\nNot sure exactly what you mean here - part of the goal is to have tooling to verify all the binaries sitting in a folder? If you can \"download\" all of them in one go from `file:///` I guess that works too?",
      "created_at" : "2023-04-03T18:44:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1494803900",
      "id" : 1494803900,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZGOW8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1494803900/reactions"
      },
      "updated_at" : "2023-04-03T18:44:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1494803900",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1157778909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1157778909"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure what you mean, I think this just intends to say `verify.py` ?",
      "commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "created_at" : "2023-04-04T21:17:56Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1157778909",
      "id" : 1157778909,
      "in_reply_to_id" : 1151503567,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585FAk3d",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 20,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 24,
      "pull_request_review_id" : 1371805525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1157778909/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-04T21:17:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1157778909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1157782969"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1157782969"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks like this has been implemented as `pub --cleanup`. A quick test shows it working as intended. Will update the doc.",
      "commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "created_at" : "2023-04-04T21:22:51Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0\n+./contrib/verifybinaries/verify.py 22.0-rc2\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0\n+./contrib/verifybinaries/verify.py bitcoin-core-23.0-rc1\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py 22.0-x86 --json\n+```\n+\n+Don't trust builder-keys by default, and rely only on local GPG state and manually\n+specified keys, while requiring a threshold of at least 10 trusted signatures:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py 22.0-x86 \\\n+    --no-trust-builder-keys \\\n+    --trusted-keys 74E2DEF5D77260B98BC19438099BAD163C70FBFA,9D3CC86A72F8494342EA5FD10A41BDC3F4FAFF1C \\\n+    --min-trusted-sigs 10\n ```\n \n If you only want to download the binaries of certain platform, add the corresponding suffix, e.g.:\n \n ```sh\n-./verify.py bitcoin-core-0.11.2-osx\n-./verify.py 0.12.0-linux\n-./verify.py bitcoin-core-0.13.0-rc3-win64\n+./contrib/verifybinaries/verify.py bitcoin-core-22.0-osx\n+./contrib/verifybinaries/verify.py bitcoin-core-22.0-rc2-win64\n ```\n \n If you do not want to keep the downloaded binaries, specify anything as the second parameter.\n \n ```sh\n-./verify.py bitcoin-core-0.13.0 delete\n+./contrib/verifybinaries/verify.py bitcoin-core-22.0 delete",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1157782969",
      "id" : 1157782969,
      "in_reply_to_id" : 1154358057,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585FAl25",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 76,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : null,
      "pull_request_review_id" : 1371811631,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1157782969/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-04T21:22:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1157782969",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I believe I've addressed the comments here. I've chosen to add fresh comments on top rather than squashing to avoid mixing up my changes on top of @jamesob's/@achow101's.\r\n\r\nThe os/arch filters like `verify.py 22.0-osx` no longer work for me and I'm not quite sure why. Otherwise remote/local verification seem to work ok.",
      "created_at" : "2023-04-04T21:38:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1496637445",
      "id" : 1496637445,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZNOAF",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1496637445/reactions"
      },
      "updated_at" : "2023-04-04T21:38:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1496637445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158526427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158526427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can drop `VERSIONPREFIX` from this output.",
      "commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "created_at" : "2023-04-05T13:32:19Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158526427",
      "id" : 1158526427,
      "line" : 290,
      "node_id" : "PRRC_kwDOABII585FDbXb",
      "original_commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "original_line" : 290,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 315,
      "pull_request_review_id" : 1372922838,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158526427/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-05T13:43:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158526427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158530776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158530776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "note that the keyserver we currently \"recommend\" is `hkps://keys.openpgp.org`. See #22688, #23466.",
      "commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "created_at" : "2023-04-05T13:35:27Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sums_file, sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sums_file, sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n-def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n+\n+def verify_shasums_signature(\n+    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n+) -> t.Tuple[\n+   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n+]:\n+    min_good_sigs = args.min_good_sigs\n+    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        else:\n+            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough goods to fulfill\n+    # our threshold.\n+    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted) + len(good_untrusted)\n+    log.info(f\"got {num_trusted} good signatures\")\n+\n+    if num_trusted < min_good_sigs:\n+        log.info(\"Maybe you need to import \"\n+                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n+                  \"some of the following keys: \")\n+        log.info('')\n+        for sig in unknown:\n+            log.info(f\"    {sig.key} ({sig.name})\")\n+        log.info('')\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_good_sigs})\")\n+\n+        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n+\n+    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n+\n+\n+def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n+    # extract hashes/filenames of binaries to verify from hash file;\n+    # each line has the following format: \"<hash> <binary_filename>\"\n+    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n+        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n+\n+\n+def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n+    offending_files = []\n+    files_to_hashes = {}\n+\n+    for hash_expected, binary_filename in hashes_to_verify:\n+        with open(binary_filename, 'rb') as binary_file:\n+            hash_calculated = sha256(binary_file.read()).hexdigest()\n+        if hash_calculated != hash_expected:\n+            offending_files.append(binary_filename)\n+        else:\n+            files_to_hashes[binary_filename] = hash_calculated\n+\n+    if offending_files:\n+        joined_files = '\\n'.join(offending_files)\n+        log.critical(\n+            \"Hashes don't match.\\n\"\n+            f\"Offending files:\\n{joined_files}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n+\n+    return (ReturnCode.SUCCESS, files_to_hashes)\n+\n+\n+def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n \n-    # extract hashes/filenames of binaries to verify from hash file;\n-    # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] < 22:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    got_sums_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+    if got_sums_status != ReturnCode.SUCCESS:\n+        return got_sums_status\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n+            cleanup()\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(SUMS_FILENAME, os_filter)\n     if not hashes_to_verify:\n-        print(\"error: no files matched the platform specified\")\n-        return 7\n+        log.error(\"no files matched the platform specified\")\n+        return ReturnCode.NO_BINARIES_MATCH\n+\n+    # remove binaries that are known not to be hosted by bitcoincore.org\n+    fragments_to_remove = ['-unsigned', '-debug', '-codesignatures']\n+    for fragment in fragments_to_remove:\n+        nobinaries = [i for i in hashes_to_verify if fragment in i[1]]\n+        if nobinaries:\n+            remove_str = ', '.join(i[1] for i in nobinaries)\n+            log.info(\n+                f\"removing *{fragment} binaries ({remove_str}) from verification \"\n+                f\"since {HOST1} does not host *{fragment} binaries\")\n+            hashes_to_verify = [i for i in hashes_to_verify if fragment not in i[1]]\n \n     # download binaries\n     for _, binary_filename in hashes_to_verify:\n-        print(f\"Downloading {binary_filename}\")\n-        download_with_wget(HOST1 + remote_dir + binary_filename)\n+        log.info(f\"downloading {binary_filename}\")\n+        success, output = download_with_wget(\n+            HOST1 + remote_dir + binary_filename, binary_filename)\n+\n+        if not success:\n+            log.error(\n+                f\"failed to download {binary_filename}\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.BINARY_DOWNLOAD_FAILED\n \n     # verify hashes\n-    offending_files = []\n-    for hash_expected, binary_filename in hashes_to_verify:\n-        with open(binary_filename, 'rb') as binary_file:\n-            hash_calculated = sha256(binary_file.read()).hexdigest()\n-        if hash_calculated != hash_expected:\n-            offending_files.append(binary_filename)\n-    if offending_files:\n-        print(\"Hashes don't match.\")\n-        print(\"Offending files:\")\n-        print('\\n'.join(offending_files))\n-        return 1\n-    verified_binaries = [entry[1] for entry in hashes_to_verify]\n-\n-    # clean up files if desired\n-    if len(args) >= 2:\n-        print(\"Clean up the binaries\")\n-        remove_files([sigfile1, sigfile2] + verified_binaries)\n+    hashes_status, files_to_hashes = verify_binary_hashes(hashes_to_verify)\n+    if hashes_status != ReturnCode.SUCCESS:\n+        return hashes_status\n+\n+\n+    if args.cleanup:\n+        cleanup()\n+    else:\n+        log.info(f\"did not clean up {WORKINGDIR}\")\n+\n+    if args.json:\n+        output = {\n+            'good_trusted_sigs': [str(s) for s in good_trusted],\n+            'good_untrusted_sigs': [str(s) for s in good_untrusted],\n+            'unknown_sigs': [str(s) for s in unknown],\n+            'bad_sigs': [str(s) for s in bad],\n+            'verified_binaries': files_to_hashes,\n+        }\n+        print(json.dumps(output, indent=2))\n     else:\n-        print(f\"Keep the binaries in {WORKINGDIR}\")\n+        for filename in files_to_hashes:\n+            print(f\"VERIFIED: {filename}\")\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def verify_binaries_handler(args: argparse.Namespace) -> ReturnCode:\n+    binary_to_basename = {}\n+    for file in args.binary:\n+        binary_to_basename[PurePath(file).name] = file\n+\n+    sums_sig_path = None\n+    if args.sums_sig_file:\n+        sums_sig_path = Path(args.sums_sig_file)\n+    else:\n+        log.info(f\"No signature file specified, assuming it is {args.sums_file}.asc\")\n+        sums_sig_path = Path(args.sums_file).with_suffix(\".asc\")\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(sums_sig_path, args.sums_file, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(args.sums_file, [k for k, n in binary_to_basename.items()])\n+    if not hashes_to_verify:\n+        log.error(f\"No files in {args.sums_file} match the specified binaries\")\n+        return ReturnCode.NO_BINARIES_MATCH\n+\n+    # Make sure all files are accounted for\n+    sums_file_path = Path(args.sums_file)\n+    missing_files = []\n+    files_to_hash = []\n+    if len(binary_to_basename) > 0:\n+        for file_hash, file in hashes_to_verify:\n+            files_to_hash.append([file_hash, binary_to_basename[file]])\n+            del binary_to_basename[file]\n+        if len(binary_to_basename) > 0:\n+            log.error(f\"Not all specified binaries are in {args.sums_file}\")\n+            return ReturnCode.NO_BINARIES_MATCH\n+    else:\n+        log.info(f\"No binaries specified, assuming all files specified in {args.sums_file} are located relatively\")\n+        for file_hash, file in hashes_to_verify:\n+            file_path = Path(sums_file_path.parent.joinpath(file))\n+            if file_path.exists():\n+                files_to_hash.append([file_hash, str(file_path)])\n+            else:\n+                missing_files.append(file)\n+\n+    # verify hashes\n+    hashes_status, files_to_hashes = verify_binary_hashes(files_to_hash)\n+    if hashes_status != ReturnCode.SUCCESS:\n+        return hashes_status\n+\n+    if args.json:\n+        output = {\n+            'good_trusted_sigs': [str(s) for s in good_trusted],\n+            'good_untrusted_sigs': [str(s) for s in good_untrusted],\n+            'unknown_sigs': [str(s) for s in unknown],\n+            'bad_sigs': [str(s) for s in bad],\n+            'verified_binaries': files_to_hashes,\n+            \"missing_binaries\": missing_files,\n+        }\n+        print(json.dumps(output, indent=2))\n+    else:\n+        for filename in files_to_hashes:\n+            print(f\"VERIFIED: {filename}\")\n+        for filename in missing_files:\n+            print(f\"MISSING: {filename}\")\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=__doc__)\n+    parser.add_argument(\n+        '-v', '--verbose', action='store_true',\n+        default=bool_from_env('BINVERIFY_VERBOSE'),\n+    )\n+    parser.add_argument(\n+        '-q', '--quiet', action='store_true',\n+        default=bool_from_env('BINVERIFY_QUIET'),\n+    )\n+    parser.add_argument(\n+        '--import-keys', action='store_true',\n+        default=bool_from_env('BINVERIFY_IMPORTKEYS'),\n+        help='if specified, ask to import each unknown builder key'\n+    )\n+    parser.add_argument(\n+        '--min-good-sigs', type=int, action='store', nargs='?',\n+        default=int(os.environ.get('BINVERIFY_MIN_GOOD_SIGS', 3)),\n+        help=(\n+            'The minimum number of good signatures to require successful termination.'),\n+    )\n+    parser.add_argument(\n+        '--keyserver', action='store', nargs='?',\n+        default=os.environ.get('BINVERIFY_KEYSERVER', 'hkp://keyserver.ubuntu.com'),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158530776",
      "id" : 1158530776,
      "line" : 659,
      "node_id" : "PRRC_kwDOABII585FDcbY",
      "original_commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "original_line" : 659,
      "original_position" : 760,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 760,
      "pull_request_review_id" : 1372922838,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158530776/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-05T13:43:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158530776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158537830"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158537830"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`--no-trust-builder-keys` is no-longer a thing? Arguments here need re-ordering as well.",
      "commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "created_at" : "2023-04-05T13:40:50Z",
      "diff_hunk" : "@@ -1,30 +1,89 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json\n+```\n+\n+Don't trust builder-keys by default, and rely only on local GPG state and manually\n+specified keys, while requiring a threshold of at least 10 trusted signatures:\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 \\\n+    --no-trust-builder-keys \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158537830",
      "id" : 1158537830,
      "line" : 59,
      "node_id" : "PRRC_kwDOABII585FDeJm",
      "original_commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "original_line" : 59,
      "original_position" : 66,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 66,
      "pull_request_review_id" : 1372922838,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158537830/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-05T13:43:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158537830",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158540308"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158540308"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    --min-good-sigs 10\r\n```",
      "commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "created_at" : "2023-04-05T13:42:45Z",
      "diff_hunk" : "@@ -1,30 +1,89 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json\n+```\n+\n+Don't trust builder-keys by default, and rely only on local GPG state and manually\n+specified keys, while requiring a threshold of at least 10 trusted signatures:\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 \\\n+    --no-trust-builder-keys \\\n+    --trusted-keys 74E2DEF5D77260B98BC19438099BAD163C70FBFA,9D3CC86A72F8494342EA5FD10A41BDC3F4FAFF1C \\\n+    --min-trusted-sigs 10",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1158540308",
      "id" : 1158540308,
      "line" : 61,
      "node_id" : "PRRC_kwDOABII585FDewU",
      "original_commit_id" : "da864a554d75ab440907fbce2476e2c8d0ac2e93",
      "original_line" : 61,
      "original_position" : 68,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 68,
      "pull_request_review_id" : 1372922838,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158540308/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-05T13:43:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1158540308",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for the review @fanquake, comments addressed.\r\n\r\nLMK if you'd like me to squash. I could either squash mine into the original authors' or mine all into one \"fixup\" on top of theirs.\r\n\r\nEdit: @glozow thanks for the review as well!",
      "created_at" : "2023-04-05T15:59:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1497743020",
      "id" : 1497743020,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZRb6s",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1497743020/reactions"
      },
      "updated_at" : "2023-04-05T22:13:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1497743020",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@theuni I don't particularly mind. I think the commits here look ok as-is. If you want to squash them all down into a fixup, that's probably also ok, but going to be a bit messy. Squashing all the changes back into the original commits is probably going to be more messy again.",
      "created_at" : "2023-04-05T16:07:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1497757188",
      "id" : 1497757188,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZRfYE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1497757188/reactions"
      },
      "updated_at" : "2023-04-05T16:07:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1497757188",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159499828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159499828"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n./contrib/verifybinaries/verify.py --json pub 22.0-x86\r\n```\r\n\r\notherwise i get this:\r\n```\r\n$ ./contrib/verifybinaries/verify.py pub 22.0-x86 --json\r\nusage: verify.py [-h] [-v] [-q] [--import-keys] [--min-good-sigs [MIN_GOOD_SIGS]] [--keyserver [KEYSERVER]] [--trusted-keys [TRUSTED_KEYS]] [--json] {pub,bin} ...\r\nverify.py: error: unrecognized arguments: --json\r\n```",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T09:03:52Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159499828",
      "id" : 1159499828,
      "line" : 52,
      "node_id" : "PRRC_kwDOABII585FHJA0",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 52,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 59,
      "pull_request_review_id" : 1374386088,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159499828/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T09:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159499828",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159536722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159536722"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n\r\n```suggestion\r\nIf you only want to download the binaries for a certain platform, add the corresponding suffix, e.g.:\r\n```",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T09:33:35Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json\n+```\n+\n+Rely only on local GPG state and manually specified keys, while requiring a\n+threshold of at least 10 trusted signatures:\n+```sh\n+./contrib/verifybinaries/verify.py \\\n+    --trusted-keys 74E2DEF5D77260B98BC19438099BAD163C70FBFA,9D3CC86A72F8494342EA5FD10A41BDC3F4FAFF1C \\\n+    --min-good-sigs 10 pub 22.0-x86\n ```\n \n If you only want to download the binaries of certain platform, add the corresponding suffix, e.g.:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159536722",
      "id" : 1159536722,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII585FHSBS",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 63,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 70,
      "pull_request_review_id" : 1374445179,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159536722/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:04:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159536722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159541958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159541958"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: would avoid using the term multisig because of its meaning in other bitcoin contexts\r\n\r\n```suggestion\r\n    print(\"- testing verification (22.0)\", flush=True)\r\n```",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T09:36:36Z",
      "diff_hunk" : "@@ -0,0 +1,59 @@\n+#!/usr/bin/env python3\n+\n+import json\n+import sys\n+import subprocess\n+from pathlib import Path\n+\n+\n+def main():\n+    \"\"\"Tests ordered roughly from faster to slower.\"\"\"\n+    expect_code(run_verify(\"\", \"pub\", '0.32'), 4, \"Nonexistent version should fail\")\n+    expect_code(run_verify(\"\", \"pub\", '0.32.awefa.12f9h'), 11, \"Malformed version should fail\")\n+    expect_code(run_verify('--min-good-sigs 20', \"pub\", \"22.0\"), 9, \"--min-good-sigs 20 should fail\")\n+\n+    print(\"- testing multisig verification (22.0)\", flush=True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159541958",
      "id" : 1159541958,
      "line" : 15,
      "node_id" : "PRRC_kwDOABII585FHTTG",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 15,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/test.py",
      "position" : 15,
      "pull_request_review_id" : 1374445179,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159541958/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:02:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159541958",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159545267"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159545267"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n  - you can run the packaged `verify.py ... --import-keys` script to\r\n- ```",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T09:39:37Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159545267",
      "id" : 1159545267,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585FHUGz",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 20,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 24,
      "pull_request_review_id" : 1374445179,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159545267/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:02:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159545267",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159559235"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159559235"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "kinda weird that the scripts are relative to the root, and not the `README.md`? ",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T09:48:50Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159559235",
      "id" : 1159559235,
      "line" : 46,
      "node_id" : "PRRC_kwDOABII585FHXhD",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 46,
      "original_position" : 53,
      "original_start_line" : 45,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 53,
      "pull_request_review_id" : 1374445179,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159559235/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 45,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:02:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159559235",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159566098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159566098"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "when I ran this command, it still downloaded and verified everything (as opposed to just `-x86`)",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T09:54:11Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json\n+```\n+\n+Rely only on local GPG state and manually specified keys, while requiring a\n+threshold of at least 10 trusted signatures:\n+```sh\n+./contrib/verifybinaries/verify.py \\\n+    --trusted-keys 74E2DEF5D77260B98BC19438099BAD163C70FBFA,9D3CC86A72F8494342EA5FD10A41BDC3F4FAFF1C \\\n+    --min-good-sigs 10 pub 22.0-x86",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159566098",
      "id" : 1159566098,
      "line" : 60,
      "node_id" : "PRRC_kwDOABII585FHZMS",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 60,
      "original_position" : 67,
      "original_start_line" : 58,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 67,
      "pull_request_review_id" : 1374445179,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159566098/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 58,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:02:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159566098",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159570134"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159570134"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "running `./verify.py --json pub 22.0-x86` downloads everything",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T09:58:09Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159570134",
      "id" : 1159570134,
      "line" : 52,
      "node_id" : "PRRC_kwDOABII585FHaLW",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 52,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 59,
      "pull_request_review_id" : 1374445179,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159570134/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:02:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159570134",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159578384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159578384"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I was inferring that there may be some undocumented step copying and renaming this file into the distributed tar archives for verification purposes. If this is not the case, then I think this indeed should just say `verify.py`.",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T10:04:14Z",
      "diff_hunk" : "@@ -1,30 +1,77 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159578384",
      "id" : 1159578384,
      "in_reply_to_id" : 1151503567,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585FHcMQ",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 20,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 24,
      "pull_request_review_id" : 1374510279,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159578384/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:04:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159578384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159579891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159579891"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "+1 ",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T10:05:21Z",
      "diff_hunk" : "@@ -0,0 +1,59 @@\n+#!/usr/bin/env python3",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159579891",
      "id" : 1159579891,
      "in_reply_to_id" : 1151491320,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII585FHcjz",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/test.py",
      "position" : 1,
      "pull_request_review_id" : 1374512266,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159579891/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:05:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159579891",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159606675"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159606675"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n    hashes_to_verify = parse_sums_file(SUMS_FILENAME, [os_filter])\r\n```\r\n",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T10:29:12Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"{VERSION_FORMAT} \"\n+            f\"(example: {VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sums_file, sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sums_file, sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n-def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n+\n+def verify_shasums_signature(\n+    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n+) -> t.Tuple[\n+   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n+]:\n+    min_good_sigs = args.min_good_sigs\n+    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        else:\n+            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough goods to fulfill\n+    # our threshold.\n+    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted) + len(good_untrusted)\n+    log.info(f\"got {num_trusted} good signatures\")\n+\n+    if num_trusted < min_good_sigs:\n+        log.info(\"Maybe you need to import \"\n+                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n+                  \"some of the following keys: \")\n+        log.info('')\n+        for sig in unknown:\n+            log.info(f\"    {sig.key} ({sig.name})\")\n+        log.info('')\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_good_sigs})\")\n+\n+        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n+\n+    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n+\n+\n+def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n+    # extract hashes/filenames of binaries to verify from hash file;\n+    # each line has the following format: \"<hash> <binary_filename>\"\n+    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n+        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n+\n+\n+def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n+    offending_files = []\n+    files_to_hashes = {}\n+\n+    for hash_expected, binary_filename in hashes_to_verify:\n+        with open(binary_filename, 'rb') as binary_file:\n+            hash_calculated = sha256(binary_file.read()).hexdigest()\n+        if hash_calculated != hash_expected:\n+            offending_files.append(binary_filename)\n+        else:\n+            files_to_hashes[binary_filename] = hash_calculated\n+\n+    if offending_files:\n+        joined_files = '\\n'.join(offending_files)\n+        log.critical(\n+            \"Hashes don't match.\\n\"\n+            f\"Offending files:\\n{joined_files}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n+\n+    return (ReturnCode.SUCCESS, files_to_hashes)\n+\n+\n+def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n \n-    # extract hashes/filenames of binaries to verify from hash file;\n-    # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] < 22:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    got_sums_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+    if got_sums_status != ReturnCode.SUCCESS:\n+        return got_sums_status\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n+            cleanup()\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(SUMS_FILENAME, os_filter)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159606675",
      "id" : 1159606675,
      "line" : 514,
      "node_id" : "PRRC_kwDOABII585FHjGT",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 514,
      "original_position" : 593,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 593,
      "pull_request_review_id" : 1374562702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159606675/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:30:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159606675",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159607865"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159607865"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`parse_sums_file` expects a list of strings. This should fix the download selection filter.",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T10:30:06Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"{VERSION_FORMAT} \"\n+            f\"(example: {VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sums_file, sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sums_file, sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n-def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n+\n+def verify_shasums_signature(\n+    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n+) -> t.Tuple[\n+   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n+]:\n+    min_good_sigs = args.min_good_sigs\n+    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        else:\n+            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough goods to fulfill\n+    # our threshold.\n+    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted) + len(good_untrusted)\n+    log.info(f\"got {num_trusted} good signatures\")\n+\n+    if num_trusted < min_good_sigs:\n+        log.info(\"Maybe you need to import \"\n+                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n+                  \"some of the following keys: \")\n+        log.info('')\n+        for sig in unknown:\n+            log.info(f\"    {sig.key} ({sig.name})\")\n+        log.info('')\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_good_sigs})\")\n+\n+        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n+\n+    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n+\n+\n+def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n+    # extract hashes/filenames of binaries to verify from hash file;\n+    # each line has the following format: \"<hash> <binary_filename>\"\n+    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n+        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n+\n+\n+def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n+    offending_files = []\n+    files_to_hashes = {}\n+\n+    for hash_expected, binary_filename in hashes_to_verify:\n+        with open(binary_filename, 'rb') as binary_file:\n+            hash_calculated = sha256(binary_file.read()).hexdigest()\n+        if hash_calculated != hash_expected:\n+            offending_files.append(binary_filename)\n+        else:\n+            files_to_hashes[binary_filename] = hash_calculated\n+\n+    if offending_files:\n+        joined_files = '\\n'.join(offending_files)\n+        log.critical(\n+            \"Hashes don't match.\\n\"\n+            f\"Offending files:\\n{joined_files}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n+\n+    return (ReturnCode.SUCCESS, files_to_hashes)\n+\n+\n+def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n \n-    # extract hashes/filenames of binaries to verify from hash file;\n-    # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] < 22:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    got_sums_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+    if got_sums_status != ReturnCode.SUCCESS:\n+        return got_sums_status\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n+            cleanup()\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(SUMS_FILENAME, os_filter)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159607865",
      "id" : 1159607865,
      "in_reply_to_id" : 1159606675,
      "line" : 514,
      "node_id" : "PRRC_kwDOABII585FHjY5",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 514,
      "original_position" : 593,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 593,
      "pull_request_review_id" : 1374562702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159607865/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T10:30:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159607865",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit: After discovering https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159606675 I ran `mypy verify.py` and:\r\n```\r\nverify.py:129: error: Module has no attribute \"HTTPError\"\r\nverify.py:588: error: Argument 1 to \"verify_shasums_signature\" has incompatible type \"Path\"; expected \"str\"\r\nFound 2 errors in 1 file (checked 1 source file)\r\n```",
      "created_at" : "2023-04-06T10:35:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1498855527",
      "id" : 1498855527,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZVrhn",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1498855527/reactions"
      },
      "updated_at" : "2023-04-06T10:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1498855527",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8421793?v=4",
         "events_url" : "https://api.github.com/users/TheCharlatan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheCharlatan/followers",
         "following_url" : "https://api.github.com/users/TheCharlatan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheCharlatan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheCharlatan",
         "id" : 8421793,
         "login" : "TheCharlatan",
         "node_id" : "MDQ6VXNlcjg0MjE3OTM=",
         "organizations_url" : "https://api.github.com/users/TheCharlatan/orgs",
         "received_events_url" : "https://api.github.com/users/TheCharlatan/received_events",
         "repos_url" : "https://api.github.com/users/TheCharlatan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheCharlatan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheCharlatan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheCharlatan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159666836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159666836"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "confirmed this does fix the download selection filter",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T11:20:08Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"{VERSION_FORMAT} \"\n+            f\"(example: {VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sums_file, sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sums_file, sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n-def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n+\n+def verify_shasums_signature(\n+    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n+) -> t.Tuple[\n+   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n+]:\n+    min_good_sigs = args.min_good_sigs\n+    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        else:\n+            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough goods to fulfill\n+    # our threshold.\n+    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted) + len(good_untrusted)\n+    log.info(f\"got {num_trusted} good signatures\")\n+\n+    if num_trusted < min_good_sigs:\n+        log.info(\"Maybe you need to import \"\n+                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n+                  \"some of the following keys: \")\n+        log.info('')\n+        for sig in unknown:\n+            log.info(f\"    {sig.key} ({sig.name})\")\n+        log.info('')\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_good_sigs})\")\n+\n+        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n+\n+    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n+\n+\n+def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n+    # extract hashes/filenames of binaries to verify from hash file;\n+    # each line has the following format: \"<hash> <binary_filename>\"\n+    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n+        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n+\n+\n+def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n+    offending_files = []\n+    files_to_hashes = {}\n+\n+    for hash_expected, binary_filename in hashes_to_verify:\n+        with open(binary_filename, 'rb') as binary_file:\n+            hash_calculated = sha256(binary_file.read()).hexdigest()\n+        if hash_calculated != hash_expected:\n+            offending_files.append(binary_filename)\n+        else:\n+            files_to_hashes[binary_filename] = hash_calculated\n+\n+    if offending_files:\n+        joined_files = '\\n'.join(offending_files)\n+        log.critical(\n+            \"Hashes don't match.\\n\"\n+            f\"Offending files:\\n{joined_files}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n+\n+    return (ReturnCode.SUCCESS, files_to_hashes)\n+\n+\n+def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n \n-    # extract hashes/filenames of binaries to verify from hash file;\n-    # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] < 22:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    got_sums_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+    if got_sums_status != ReturnCode.SUCCESS:\n+        return got_sums_status\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n+            cleanup()\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(SUMS_FILENAME, os_filter)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159666836",
      "id" : 1159666836,
      "in_reply_to_id" : 1159606675,
      "line" : 514,
      "node_id" : "PRRC_kwDOABII585FHxyU",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 514,
      "original_position" : 593,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 593,
      "pull_request_review_id" : 1374659853,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159666836/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T11:20:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159666836",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159670307"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159670307"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: it would be nice to have it also print out the destination, e.g \"downloading {binary_filename} to {destination}\"",
      "commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "created_at" : "2023-04-06T11:24:10Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"{VERSION_FORMAT} \"\n+            f\"(example: {VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sums_file, sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sums_file, sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n-def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n+\n+def verify_shasums_signature(\n+    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n+) -> t.Tuple[\n+   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n+]:\n+    min_good_sigs = args.min_good_sigs\n+    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        else:\n+            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough goods to fulfill\n+    # our threshold.\n+    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted) + len(good_untrusted)\n+    log.info(f\"got {num_trusted} good signatures\")\n+\n+    if num_trusted < min_good_sigs:\n+        log.info(\"Maybe you need to import \"\n+                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n+                  \"some of the following keys: \")\n+        log.info('')\n+        for sig in unknown:\n+            log.info(f\"    {sig.key} ({sig.name})\")\n+        log.info('')\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_good_sigs})\")\n+\n+        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n+\n+    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n+\n+\n+def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n+    # extract hashes/filenames of binaries to verify from hash file;\n+    # each line has the following format: \"<hash> <binary_filename>\"\n+    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n+        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n+\n+\n+def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n+    offending_files = []\n+    files_to_hashes = {}\n+\n+    for hash_expected, binary_filename in hashes_to_verify:\n+        with open(binary_filename, 'rb') as binary_file:\n+            hash_calculated = sha256(binary_file.read()).hexdigest()\n+        if hash_calculated != hash_expected:\n+            offending_files.append(binary_filename)\n+        else:\n+            files_to_hashes[binary_filename] = hash_calculated\n+\n+    if offending_files:\n+        joined_files = '\\n'.join(offending_files)\n+        log.critical(\n+            \"Hashes don't match.\\n\"\n+            f\"Offending files:\\n{joined_files}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n+\n+    return (ReturnCode.SUCCESS, files_to_hashes)\n+\n+\n+def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n \n-    # extract hashes/filenames of binaries to verify from hash file;\n-    # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] < 22:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    got_sums_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+    if got_sums_status != ReturnCode.SUCCESS:\n+        return got_sums_status\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n+            cleanup()\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(SUMS_FILENAME, os_filter)\n     if not hashes_to_verify:\n-        print(\"error: no files matched the platform specified\")\n-        return 7\n+        log.error(\"no files matched the platform specified\")\n+        return ReturnCode.NO_BINARIES_MATCH\n+\n+    # remove binaries that are known not to be hosted by bitcoincore.org\n+    fragments_to_remove = ['-unsigned', '-debug', '-codesignatures']\n+    for fragment in fragments_to_remove:\n+        nobinaries = [i for i in hashes_to_verify if fragment in i[1]]\n+        if nobinaries:\n+            remove_str = ', '.join(i[1] for i in nobinaries)\n+            log.info(\n+                f\"removing *{fragment} binaries ({remove_str}) from verification \"\n+                f\"since {HOST1} does not host *{fragment} binaries\")\n+            hashes_to_verify = [i for i in hashes_to_verify if fragment not in i[1]]\n \n     # download binaries\n     for _, binary_filename in hashes_to_verify:\n-        print(f\"Downloading {binary_filename}\")\n-        download_with_wget(HOST1 + remote_dir + binary_filename)\n+        log.info(f\"downloading {binary_filename}\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1159670307",
      "id" : 1159670307,
      "line" : 532,
      "node_id" : "PRRC_kwDOABII585FHyoj",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 532,
      "original_position" : 615,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 615,
      "pull_request_review_id" : 1374667038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159670307/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T11:24:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159670307",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1160166441"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160166441"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks!",
      "commit_id" : "754fb6bb8125317575edec7c20b5617ad27a9bdd",
      "created_at" : "2023-04-06T19:17:42Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"{VERSION_FORMAT} \"\n+            f\"(example: {VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sums_file, sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sums_file, sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n-def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n+\n+def verify_shasums_signature(\n+    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n+) -> t.Tuple[\n+   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n+]:\n+    min_good_sigs = args.min_good_sigs\n+    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        else:\n+            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough goods to fulfill\n+    # our threshold.\n+    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted) + len(good_untrusted)\n+    log.info(f\"got {num_trusted} good signatures\")\n+\n+    if num_trusted < min_good_sigs:\n+        log.info(\"Maybe you need to import \"\n+                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n+                  \"some of the following keys: \")\n+        log.info('')\n+        for sig in unknown:\n+            log.info(f\"    {sig.key} ({sig.name})\")\n+        log.info('')\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_good_sigs})\")\n+\n+        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n+\n+    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n+\n+\n+def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n+    # extract hashes/filenames of binaries to verify from hash file;\n+    # each line has the following format: \"<hash> <binary_filename>\"\n+    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n+        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n+\n+\n+def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n+    offending_files = []\n+    files_to_hashes = {}\n+\n+    for hash_expected, binary_filename in hashes_to_verify:\n+        with open(binary_filename, 'rb') as binary_file:\n+            hash_calculated = sha256(binary_file.read()).hexdigest()\n+        if hash_calculated != hash_expected:\n+            offending_files.append(binary_filename)\n+        else:\n+            files_to_hashes[binary_filename] = hash_calculated\n+\n+    if offending_files:\n+        joined_files = '\\n'.join(offending_files)\n+        log.critical(\n+            \"Hashes don't match.\\n\"\n+            f\"Offending files:\\n{joined_files}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n+\n+    return (ReturnCode.SUCCESS, files_to_hashes)\n+\n+\n+def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n \n-    # extract hashes/filenames of binaries to verify from hash file;\n-    # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] < 22:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    got_sums_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+    if got_sums_status != ReturnCode.SUCCESS:\n+        return got_sums_status\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n+            cleanup()\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(SUMS_FILENAME, os_filter)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1160166441",
      "id" : 1160166441,
      "in_reply_to_id" : 1159606675,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585FJrwp",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 514,
      "original_position" : 593,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 1375436955,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160166441/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T19:17:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160166441",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1160167278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160167278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks. I'll squashed this into another commit.",
      "commit_id" : "754fb6bb8125317575edec7c20b5617ad27a9bdd",
      "created_at" : "2023-04-06T19:18:33Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1160167278",
      "id" : 1160167278,
      "in_reply_to_id" : 1159499828,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585FJr9u",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 52,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : null,
      "pull_request_review_id" : 1375438018,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160167278/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T19:18:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160167278",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for the review @TheCharlatan and @josibake. I've addressed most of the feedback with the exception of a few nits as I don't want this to drag out forever.\r\n\r\nI squashed some of the readme changes to keep the number of commits down. The diff from the previous changes can be seen with: `git diff 96344222f3..754fb6bb81` .",
      "created_at" : "2023-04-06T20:02:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1499550445",
      "id" : 1499550445,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZYVLt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1499550445/reactions"
      },
      "updated_at" : "2023-04-06T20:02:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1499550445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1160211457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160211457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Makes sense to me but I'd rather keep the changes down in this PR. Let's do as a follow-up?",
      "commit_id" : "754fb6bb8125317575edec7c20b5617ad27a9bdd",
      "created_at" : "2023-04-06T20:14:39Z",
      "diff_hunk" : "@@ -0,0 +1,59 @@\n+#!/usr/bin/env python3",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1160211457",
      "id" : 1160211457,
      "in_reply_to_id" : 1151491320,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII585FJ2wB",
      "original_commit_id" : "7a6e7ffd066a42c5fbb7d69effbe074fb982936b",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/test.py",
      "position" : 1,
      "pull_request_review_id" : 1375504488,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160211457/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-06T20:14:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1160211457",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK https://github.com/bitcoin/bitcoin/pull/27358/commits/754fb6bb8125317575edec7c20b5617ad27a9bdd",
      "created_at" : "2023-04-06T21:31:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1499652736",
      "id" : 1499652736,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZYuKA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1499652736/reactions"
      },
      "updated_at" : "2023-04-06T21:31:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1499652736",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "We can have a followup, to address any further issues/improvements.",
      "created_at" : "2023-04-07T07:26:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1500021194",
      "id" : 1500021194,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZaIHK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500021194/reactions"
      },
      "updated_at" : "2023-04-07T07:26:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500021194",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Followup suggestions:\r\n\r\n1. allow user to specify the domain(s), e.g. `--domain=bitcoincore.org` so you don't get warnings about bitcoin.org, which only has up to version 22.0 at the moment. Conversely, it will make a future domain evacuation safer.\r\n\r\n2. \"osx\" in the documentation example should be \"macos\" (but it doesn't work either way as @theuni found)\r\n\r\n3. \"The os/arch filters like verify.py 22.0-osx no longer work for me and I'm not quite sure why.\" - would be nice to restore this, or just file a Github issue and remove it from the docs\r\n",
      "created_at" : "2023-04-07T11:38:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1500209136",
      "id" : 1500209136,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585Za1_w",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500209136/reactions"
      },
      "updated_at" : "2023-04-07T11:39:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500209136",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors That filter problem should've been fixed by https://github.com/bitcoin/bitcoin/pull/27358/commits/4b23b488d2c5662215d78e4963ef5a2b86b4e25b, my comment was from before then. Is what's now in master still broken for you?\r\n\r\nEdit: Also, agreed on your first suggestion.",
      "created_at" : "2023-04-07T13:53:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1500309723",
      "id" : 1500309723,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZbOjb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500309723/reactions"
      },
      "updated_at" : "2023-04-07T13:55:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500309723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@theuni yes. On Intel macOS 13.3:\r\n\r\n```\r\n % ./contrib/verifybinaries/verify.py pub 24.0.1-osx \r\nâ¦\r\n[ERROR] no files matched the platform specified\r\n```\r\n\r\nDitto for `24.0.1-macos`\r\n\r\nAh, `-darwin` works, so it's just a matter of updating the doc.",
      "created_at" : "2023-04-07T14:39:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1500348764",
      "id" : 1500348764,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZbYFc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500348764/reactions"
      },
      "updated_at" : "2023-04-07T14:39:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500348764",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors the filter works almost like a grep, so it depends on the release. Starting with v23 the apple binaries were renamed.",
      "created_at" : "2023-04-07T15:28:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1500389847",
      "id" : 1500389847,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZbiHX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500389847/reactions"
      },
      "updated_at" : "2023-04-07T15:28:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1500389847",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1161264962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See 27440.",
      "commit_id" : "754fb6bb8125317575edec7c20b5617ad27a9bdd",
      "created_at" : "2023-04-09T10:50:27Z",
      "diff_hunk" : "@@ -1,30 +1,88 @@\n ### Verify Binaries\n \n-#### Usage:\n+#### Preparation\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin-core/guix.sigs/tree/main/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+You can obtain these keys by\n+  - through a browser using a key server (e.g. keyserver.ubuntu.com),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - you can run the packaged `verifybinaries.py ... --import-keys` script to\n+    have it automatically retrieve unrecognized keys.\n \n+#### Usage\n \n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n+\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n+\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+can prompt the user as to whether they'd like to download the pubkeys. To enable\n+this behavior, use the `--import-keys` flag.\n+\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n+\n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py pub 22.0\n+./contrib/verifybinaries/verify.py pub 22.0-rc2\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py pub 22.0-x86 --json\n+```\n+\n+Rely only on local GPG state and manually specified keys, while requiring a\n+threshold of at least 10 trusted signatures:\n+```sh\n+./contrib/verifybinaries/verify.py \\\n+    --trusted-keys 74E2DEF5D77260B98BC19438099BAD163C70FBFA,9D3CC86A72F8494342EA5FD10A41BDC3F4FAFF1C \\\n+    --min-good-sigs 10 pub 22.0-x86\n ```\n \n If you only want to download the binaries of certain platform, add the corresponding suffix, e.g.:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1161264962",
      "id" : 1161264962,
      "in_reply_to_id" : 1159536722,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII585FN39C",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 63,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 70,
      "pull_request_review_id" : 1376891891,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264962/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-09T10:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264962",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1161264975"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264975"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done in 27440",
      "commit_id" : "754fb6bb8125317575edec7c20b5617ad27a9bdd",
      "created_at" : "2023-04-09T10:50:36Z",
      "diff_hunk" : "@@ -0,0 +1,59 @@\n+#!/usr/bin/env python3\n+\n+import json\n+import sys\n+import subprocess\n+from pathlib import Path\n+\n+\n+def main():\n+    \"\"\"Tests ordered roughly from faster to slower.\"\"\"\n+    expect_code(run_verify(\"\", \"pub\", '0.32'), 4, \"Nonexistent version should fail\")\n+    expect_code(run_verify(\"\", \"pub\", '0.32.awefa.12f9h'), 11, \"Malformed version should fail\")\n+    expect_code(run_verify('--min-good-sigs 20', \"pub\", \"22.0\"), 9, \"--min-good-sigs 20 should fail\")\n+\n+    print(\"- testing multisig verification (22.0)\", flush=True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1161264975",
      "id" : 1161264975,
      "in_reply_to_id" : 1159541958,
      "line" : 15,
      "node_id" : "PRRC_kwDOABII585FN39P",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 15,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/test.py",
      "position" : 15,
      "pull_request_review_id" : 1376891914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264975/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-09T10:50:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264975",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1161264990"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264990"
         }
      },
      "author_association" : "MEMBER",
      "body" : "added to 27440.",
      "commit_id" : "754fb6bb8125317575edec7c20b5617ad27a9bdd",
      "created_at" : "2023-04-09T10:50:45Z",
      "diff_hunk" : "@@ -47,137 +115,598 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return (True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    filename,\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    with tempfile.NamedTemporaryFile() as status_file:\n+        args = [\n+            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n+            '--output', output_filename if output_filename else '', signature_filename, filename]\n+\n+        env = dict(os.environ, LANGUAGE='en')\n+        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+\n+        gpg_data = status_file.read().decode().rstrip()\n+\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n+    log.debug(f\"{gpg_data}\")\n+    return result.returncode, gpg_data\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self):\n+        self.key = None\n+        self.name = \"\"\n+        self.trusted = False\n+        self.status = \"\"\n+\n+    def __bool__(self):\n+        return self.key is not None\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(\n+    output: t.List[str]\n+) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs: t.List[SigData] = []\n+    unknown_sigs: t.List[SigData] = []\n+    bad_sigs: t.List[SigData] = []\n+    total_resolved_sigs = 0\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n+        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n+\n+    curr_sigs = unknown_sigs\n+    curr_sigdata = SigData()\n+\n+    for line in output:\n+        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n+            total_resolved_sigs += 1\n+            if curr_sigdata:\n+                curr_sigs.append(curr_sigdata)\n+                curr_sigdata = SigData()\n+            newsig_split = line.split()\n+            if len(newsig_split) == 3:\n+                curr_sigdata.name = newsig_split[2]\n+\n+        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+\n+        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"expired\"\n+\n+        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = good_sigs\n+            curr_sigdata.status = \"revoked\"\n+\n+        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n+            curr_sigs = bad_sigs\n+\n+        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n+            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n+            curr_sigs = unknown_sigs\n+\n+        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = False\n+\n+        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n+            curr_sigdata.trusted = True\n+\n+    # The last one won't have been added, so add it now\n+    assert curr_sigdata\n+    curr_sigs.append(curr_sigdata)\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"{VERSION_FORMAT} \"\n+            f\"(example: {VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sums_file, sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    if unknown and args.import_keys:\n+        # Retrieve unknown keys and then try GPG again.\n+        for unsig in unknown:\n+            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n+                ran = subprocess.run(\n+                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key}\")\n+\n+        # Reparse the GPG output now that we have more keys\n+        retval, output = verify_with_gpg(sums_file, sigfilename)\n+        good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n-def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+def prompt_yn(prompt) -> bool:\n+    \"\"\"Return true if the user inputs 'y'.\"\"\"\n+    got = ''\n+    while got not in ['y', 'n']:\n+        got = input(prompt).lower()\n+    return got == 'y'\n+\n+def verify_shasums_signature(\n+    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n+) -> t.Tuple[\n+   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n+]:\n+    min_good_sigs = args.min_good_sigs\n+    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+\n+    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n+        else:\n+            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough goods to fulfill\n+    # our threshold.\n+    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted) + len(good_untrusted)\n+    log.info(f\"got {num_trusted} good signatures\")\n+\n+    if num_trusted < min_good_sigs:\n+        log.info(\"Maybe you need to import \"\n+                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n+                  \"some of the following keys: \")\n+        log.info('')\n+        for sig in unknown:\n+            log.info(f\"    {sig.key} ({sig.name})\")\n+        log.info('')\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_good_sigs})\")\n+\n+        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n+\n+    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n+\n+\n+def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n+    # extract hashes/filenames of binaries to verify from hash file;\n+    # each line has the following format: \"<hash> <binary_filename>\"\n+    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n+        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n+\n+\n+def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n+    offending_files = []\n+    files_to_hashes = {}\n+\n+    for hash_expected, binary_filename in hashes_to_verify:\n+        with open(binary_filename, 'rb') as binary_file:\n+            hash_calculated = sha256(binary_file.read()).hexdigest()\n+        if hash_calculated != hash_expected:\n+            offending_files.append(binary_filename)\n+        else:\n+            files_to_hashes[binary_filename] = hash_calculated\n+\n+    if offending_files:\n+        joined_files = '\\n'.join(offending_files)\n+        log.critical(\n+            \"Hashes don't match.\\n\"\n+            f\"Offending files:\\n{joined_files}\")\n+        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n+\n+    return (ReturnCode.SUCCESS, files_to_hashes)\n+\n+\n+def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    try:\n+        version_base, version_rc, os_filter = parse_version_string(args.version)\n+        version_tuple = [int(i) for i in version_base.split('.')]\n+    except Exception as e:\n+        log.debug(e)\n+        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n+        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n+        return ReturnCode.BAD_VERSION\n+\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    hosts = [HOST1, HOST2]\n \n-    # extract hashes/filenames of binaries to verify from hash file;\n-    # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    if version_tuple[0] < 22:\n+        log.error(\"Version too old - single sig not supported. Use a previous \"\n+                  \"version of this script from the repo.\")\n+        return ReturnCode.BAD_VERSION\n+\n+    got_sums_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+    if got_sums_status != ReturnCode.SUCCESS:\n+        return got_sums_status\n+\n+    # Verify the signature on the SHA256SUMS file\n+    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n+    if sigs_status != ReturnCode.SUCCESS:\n+        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n+            cleanup()\n+        return sigs_status\n+\n+    # Extract hashes and filenames\n+    hashes_to_verify = parse_sums_file(SUMS_FILENAME, os_filter)\n     if not hashes_to_verify:\n-        print(\"error: no files matched the platform specified\")\n-        return 7\n+        log.error(\"no files matched the platform specified\")\n+        return ReturnCode.NO_BINARIES_MATCH\n+\n+    # remove binaries that are known not to be hosted by bitcoincore.org\n+    fragments_to_remove = ['-unsigned', '-debug', '-codesignatures']\n+    for fragment in fragments_to_remove:\n+        nobinaries = [i for i in hashes_to_verify if fragment in i[1]]\n+        if nobinaries:\n+            remove_str = ', '.join(i[1] for i in nobinaries)\n+            log.info(\n+                f\"removing *{fragment} binaries ({remove_str}) from verification \"\n+                f\"since {HOST1} does not host *{fragment} binaries\")\n+            hashes_to_verify = [i for i in hashes_to_verify if fragment not in i[1]]\n \n     # download binaries\n     for _, binary_filename in hashes_to_verify:\n-        print(f\"Downloading {binary_filename}\")\n-        download_with_wget(HOST1 + remote_dir + binary_filename)\n+        log.info(f\"downloading {binary_filename}\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#discussion_r1161264990",
      "id" : 1161264990,
      "in_reply_to_id" : 1159670307,
      "line" : 533,
      "node_id" : "PRRC_kwDOABII585FN39e",
      "original_commit_id" : "96344222f307048ef917cd3741cc12d0bd9e82ae",
      "original_line" : 533,
      "original_position" : 615,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 616,
      "pull_request_review_id" : 1376891928,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27358",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264990/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-04-09T10:50:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1161264990",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Covered most of the followup requests in #27440.",
      "created_at" : "2023-04-09T10:51:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27358#issuecomment-1501099918",
      "id" : 1501099918,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27358",
      "node_id" : "IC_kwDOABII585ZePeO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1501099918/reactions"
      },
      "updated_at" : "2023-04-09T10:51:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1501099918",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   }
]
