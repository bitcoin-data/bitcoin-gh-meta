[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Interesting idea. Can this be exposed as a testing only RPC? Or do real users need it?\r\n\r\nThere are privacy implications of using sweep as well -- if it's just to be used for e.g. taking an old potentially compromised wallet and migrating to a new one is it better to do a sweep that splits into a number of normal-ish looking txns?",
      "created_at" : "2022-01-20T22:42:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1017991367",
      "id" : 1017991367,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5848rVDH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1017991367/reactions"
      },
      "updated_at" : "2022-01-20T22:42:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1017991367",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Cool, concept ACK\r\n\r\nTests look nice",
      "created_at" : "2022-01-20T22:43:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1017991697",
      "id" : 1017991697,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5848rVIR",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1017991697/reactions"
      },
      "updated_at" : "2022-01-20T22:43:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1017991697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Subtract fee from amount has historically been used for sweeping and there exist some issues on this repo that illustrate that there is usage.\r\n\r\nYou could achieve a \"normal\" looking transaction by specifying two recipients and setting an amount on one of them. There are examples to illustrate this usage in the RPC help text.",
      "created_at" : "2022-01-20T22:50:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1017995727",
      "id" : 1017995727,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5848rWHP",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1017995727/reactions"
      },
      "updated_at" : "2022-01-20T22:50:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1017995727",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#22751](https://github.com/bitcoin/bitcoin/pull/22751) (rpc/wallet: add simulaterawtransaction RPC by kallewoof)\n* [#21576](https://github.com/bitcoin/bitcoin/pull/21576) (rpc, gui: bumpfee signer support by Sjors)\n* [#21283](https://github.com/bitcoin/bitcoin/pull/21283) (Implement BIP 370 PSBTv2 by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-01-21T07:54:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1018265067",
      "id" : 1018265067,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5848sX3r",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1018265067/reactions"
      },
      "updated_at" : "2022-02-17T19:20:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1018265067",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-01-21T14:16:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1018541892",
      "id" : 1018541892,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5848tbdE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1018541892/reactions"
      },
      "updated_at" : "2022-01-21T14:16:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1018541892",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I prefer this to #23534.",
      "created_at" : "2022-01-21T15:15:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1018599962",
      "id" : 1018599962,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5848tpoa",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1018599962/reactions"
      },
      "updated_at" : "2022-01-21T15:15:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1018599962",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-01-22T09:58:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1019147257",
      "id" : 1019147257,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5848vvP5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1019147257/reactions"
      },
      "updated_at" : "2022-01-22T09:58:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1019147257",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/94266259?v=4",
         "events_url" : "https://api.github.com/users/w0xlt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/w0xlt/followers",
         "following_url" : "https://api.github.com/users/w0xlt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/w0xlt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/w0xlt",
         "id" : 94266259,
         "login" : "w0xlt",
         "node_id" : "U_kgDOBZ5jkw",
         "organizations_url" : "https://api.github.com/users/w0xlt/orgs",
         "received_events_url" : "https://api.github.com/users/w0xlt/received_events",
         "repos_url" : "https://api.github.com/users/w0xlt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/w0xlt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/w0xlt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/w0xlt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142312"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The fee_rate is defined twice:\r\n1. As an argument\r\n2. As an option object\r\n\r\nI presume this is an intentional design choice. But I can't seem to grasp the reason behind doing so.",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-22T13:23:07Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142312",
      "id" : 790142312,
      "line" : 1188,
      "node_id" : "PRRC_kwDOABII584vGJ1o",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1188,
      "original_position" : 37,
      "original_start_line" : 1184,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 37,
      "pull_request_review_id" : 860205889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142312/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1184,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-22T13:37:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142312",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142638"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Two Questions:\r\n\r\n1. If I pass the `conf_target` argument and `estimate_mode` under the options object, this will cause an error. But should there be an error in such a scenario?\r\n\r\n2. `conf_target` and `estimate_mode` can be options objects, but they are not explicitly defined in the RPC help message under the options column as is done with the fee_rate object. Is it a deliberate decision?",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-22T13:26:53Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142638",
      "id" : 790142638,
      "line" : 1237,
      "node_id" : "PRRC_kwDOABII584vGJ6u",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1237,
      "original_position" : 86,
      "original_start_line" : 1235,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 86,
      "pull_request_review_id" : 860205889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142638/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1235,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-22T13:37:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142638",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142798"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\nI think it's better to replace `key-value` -> `key:value`, because that's how the pair is originally expressed in arguments.",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-22T13:29:02Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142798",
      "id" : 790142798,
      "line" : 1176,
      "node_id" : "PRRC_kwDOABII584vGJ9O",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1176,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 25,
      "pull_request_review_id" : 860205889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142798/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-22T13:37:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142798",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142893"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142893"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think you can add a `self.log.info(..)` statement here.",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-22T13:30:03Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sweep RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+class WalletSweepTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def generate_initial_utxos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    def clean_up(self):\n+        if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+            self.wallet.sweep([self.return_addr_remainder])\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def sweep_two_utxos(self):\n+        self.log.info(\"Testing basic sweep case without specific amounts\")\n+        self.generate_initial_utxos([10, 11])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        output = tx_from_wallet[\"decoded\"][\"vout\"][0]\n+        assert_equal(output[\"value\"], wallet_balance_before_sweep + tx_from_wallet[\"fee\"]) # fee is negative\n+        assert_equal(output[\"scriptPubKey\"][\"address\"], self.return_addr_remainder)\n+\n+    def sweep_to_two_outputs(self):\n+        self.log.info(\"Testing sweep where one output has specified amount\")\n+        self.generate_initial_utxos([8, 13])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([{self.return_addr_with_amount: 5}, self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 2)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_with_amount, 5)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_remainder)\n+\n+        self.assert_balance_swept_completely(tx_from_wallet, wallet_balance_before_sweep)\n+\n+    def sweep_invalid_receiver_addresses(self):\n+        self.log.info(\"Testing sweep only with specified amount\")\n+        self.generate_initial_utxos([12, 9])\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-8, \"Must provide at least one address without a specified amount\" , self.wallet.sweep, [{self.return_addr_with_amount: 5}])\n+\n+        self.clean_up()\n+\n+    def sweep_invalid_amounts(self):\n+        self.log.info(\"Try sweeping more than balance\")\n+        self.generate_initial_utxos([7, 14])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        expected_tx = self.wallet.sweep(receivers=[{self.return_addr_with_amount: 5}, self.return_addr_remainder], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\" , self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep + 1}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.return_addr_with_amount), self.wallet.sweep, [{self.return_addr_with_amount: 0.00000001}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee - Decimal(0.00000010)}, self.return_addr_remainder])\n+\n+        self.clean_up()\n+\n+    def sweep_negative_effective_value(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142893",
      "id" : 790142893,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII584vGJ-t",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sweep.py",
      "position" : 107,
      "pull_request_review_id" : 860205889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142893/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-22T13:37:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142893",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142968"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142968"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Here also, a `self.log.info(..)` statement can be added.",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-22T13:31:04Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sweep RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+class WalletSweepTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def generate_initial_utxos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    def clean_up(self):\n+        if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+            self.wallet.sweep([self.return_addr_remainder])\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def sweep_two_utxos(self):\n+        self.log.info(\"Testing basic sweep case without specific amounts\")\n+        self.generate_initial_utxos([10, 11])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        output = tx_from_wallet[\"decoded\"][\"vout\"][0]\n+        assert_equal(output[\"value\"], wallet_balance_before_sweep + tx_from_wallet[\"fee\"]) # fee is negative\n+        assert_equal(output[\"scriptPubKey\"][\"address\"], self.return_addr_remainder)\n+\n+    def sweep_to_two_outputs(self):\n+        self.log.info(\"Testing sweep where one output has specified amount\")\n+        self.generate_initial_utxos([8, 13])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([{self.return_addr_with_amount: 5}, self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 2)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_with_amount, 5)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_remainder)\n+\n+        self.assert_balance_swept_completely(tx_from_wallet, wallet_balance_before_sweep)\n+\n+    def sweep_invalid_receiver_addresses(self):\n+        self.log.info(\"Testing sweep only with specified amount\")\n+        self.generate_initial_utxos([12, 9])\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-8, \"Must provide at least one address without a specified amount\" , self.wallet.sweep, [{self.return_addr_with_amount: 5}])\n+\n+        self.clean_up()\n+\n+    def sweep_invalid_amounts(self):\n+        self.log.info(\"Try sweeping more than balance\")\n+        self.generate_initial_utxos([7, 14])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        expected_tx = self.wallet.sweep(receivers=[{self.return_addr_with_amount: 5}, self.return_addr_remainder], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\" , self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep + 1}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.return_addr_with_amount), self.wallet.sweep, [{self.return_addr_with_amount: 0.00000001}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee - Decimal(0.00000010)}, self.return_addr_remainder])\n+\n+        self.clean_up()\n+\n+    def sweep_negative_effective_value(self):\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\", dust_wallet.sweep, receivers=[self.return_addr_remainder], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    def sweep_with_sendmax(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790142968",
      "id" : 790142968,
      "line" : 120,
      "node_id" : "PRRC_kwDOABII584vGJ_4",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 120,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sweep.py",
      "position" : 120,
      "pull_request_review_id" : 860205889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142968/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-22T13:37:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790142968",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790143305"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790143305"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Though it's not very difficult grasping the meaning of each section, I think it would be better if you added a comment:\r\n```\r\nsweep with sendmax enabled.\r\n```\r\nBefore line 127. And statement:\r\n```\r\nsweep with sendmax disabled.\r\n```\r\nBefore line 138.",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-22T13:34:45Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sweep RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+class WalletSweepTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def generate_initial_utxos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    def clean_up(self):\n+        if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+            self.wallet.sweep([self.return_addr_remainder])\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def sweep_two_utxos(self):\n+        self.log.info(\"Testing basic sweep case without specific amounts\")\n+        self.generate_initial_utxos([10, 11])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        output = tx_from_wallet[\"decoded\"][\"vout\"][0]\n+        assert_equal(output[\"value\"], wallet_balance_before_sweep + tx_from_wallet[\"fee\"]) # fee is negative\n+        assert_equal(output[\"scriptPubKey\"][\"address\"], self.return_addr_remainder)\n+\n+    def sweep_to_two_outputs(self):\n+        self.log.info(\"Testing sweep where one output has specified amount\")\n+        self.generate_initial_utxos([8, 13])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([{self.return_addr_with_amount: 5}, self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 2)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_with_amount, 5)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_remainder)\n+\n+        self.assert_balance_swept_completely(tx_from_wallet, wallet_balance_before_sweep)\n+\n+    def sweep_invalid_receiver_addresses(self):\n+        self.log.info(\"Testing sweep only with specified amount\")\n+        self.generate_initial_utxos([12, 9])\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-8, \"Must provide at least one address without a specified amount\" , self.wallet.sweep, [{self.return_addr_with_amount: 5}])\n+\n+        self.clean_up()\n+\n+    def sweep_invalid_amounts(self):\n+        self.log.info(\"Try sweeping more than balance\")\n+        self.generate_initial_utxos([7, 14])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        expected_tx = self.wallet.sweep(receivers=[{self.return_addr_with_amount: 5}, self.return_addr_remainder], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\" , self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep + 1}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.return_addr_with_amount), self.wallet.sweep, [{self.return_addr_with_amount: 0.00000001}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee - Decimal(0.00000010)}, self.return_addr_remainder])\n+\n+        self.clean_up()\n+\n+    def sweep_negative_effective_value(self):\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\", dust_wallet.sweep, receivers=[self.return_addr_remainder], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    def sweep_with_sendmax(self):\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 0.00000300)\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        sweep_tx_receipt = self.wallet.sweep(receivers=[self.return_addr_remainder], fee_rate=300, options={\"sendmax\": True})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790143305",
      "id" : 790143305,
      "line" : 127,
      "node_id" : "PRRC_kwDOABII584vGKFJ",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 127,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sweep.py",
      "position" : 127,
      "pull_request_review_id" : 860205889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790143305/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-22T13:37:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790143305",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790144111"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790144111"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\r\n```\r\n\r\nnit: no need for newline",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-22T13:44:44Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790144111",
      "id" : 790144111,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584vGKRv",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1166,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 860207447,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790144111/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T08:18:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790144111",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790189815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790189815"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is there a place where this string is used? I could see only this declaration.",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-22T22:08:04Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"conf_target\", request.params[1]);\n+                options.pushKV(\"estimate_mode\", request.params[2]);\n+            }\n+            if (options.exists(\"fee_rate\")) {\n+                if (!request.params[3].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"fee_rate\", request.params[3]);\n+            }\n+\n+            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n+            }\n+\n+            bool rbf = pwallet->m_signal_rbf;\n+            if (options.exists(\"replaceable\")) {\n+                rbf = options[\"replaceable\"].get_bool();\n+            }\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(NullUniValue, receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+            AvailableCoins(*pwallet, all_the_utxos, &coin_control, /* sweep 0-value utxos*/ 0);\n+\n+            const bool sendmax = options.exists(\"sendmax\") && options[\"sendmax\"].get_bool();\n+            CAmount total_input_value(0);\n+            for (const COutput& output : all_the_utxos) {\n+                CHECK_NONFATAL(output.nInputBytes > 0);\n+                if (sendmax && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                    continue;\n+                }\n+                CTxIn input(output.tx->GetHash(), output.i);\n+                rawTx.vin.push_back(input);\n+                total_input_value += output.tx->tx->vout[output.i].nValue; // The horrors. Why doesn't this just have an alias on COutput?\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (sendmax) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed(0);\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            CAmount remainder = effective_value - output_amounts_claimed;\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            bool add_to_wallet = true;\n+            if (options.exists(\"add_to_wallet\")) {\n+                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            }\n+\n+            // Make a blank psbt\n+            PartiallySignedTransaction psbtx(rawTx);\n+\n+            // First fill transaction with our data without signing,\n+            // so external signers are not asked sign more than once.\n+            bool complete;\n+            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+            // Other than the name suggests, this actually will sign the transaction if possible\n+            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n+            if (err != TransactionError::OK) {\n+                throw JSONRPCTransactionError(err);\n+            }\n+\n+            CMutableTransaction mtx;\n+            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : mtx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }\n+\n+\n+            UniValue result(UniValue::VOBJ);\n+\n+            if (psbt_opt_in || !complete || !add_to_wallet) {\n+                // Serialize the PSBT\n+                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+                ssTx << psbtx;\n+                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            }\n+\n+            if (complete) {\n+                std::string err_string;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r790189815",
      "id" : 790189815,
      "line" : 1407,
      "node_id" : "PRRC_kwDOABII584vGVb3",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1407,
      "original_position" : 256,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 256,
      "pull_request_review_id" : 860245638,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790189815/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-22T22:08:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/790189815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791134867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791134867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`replaceable` is not documented",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-24T20:42:16Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"conf_target\", request.params[1]);\n+                options.pushKV(\"estimate_mode\", request.params[2]);\n+            }\n+            if (options.exists(\"fee_rate\")) {\n+                if (!request.params[3].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"fee_rate\", request.params[3]);\n+            }\n+\n+            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n+            }\n+\n+            bool rbf = pwallet->m_signal_rbf;\n+            if (options.exists(\"replaceable\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791134867",
      "id" : 791134867,
      "line" : 1284,
      "node_id" : "PRRC_kwDOABII584vJ8KT",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1284,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 133,
      "pull_request_review_id" : 861495232,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791134867/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-24T20:43:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791134867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791135520"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791135520"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Needs to handle `rbf` and set the right sequence number\r\n\r\n```suggestion\r\n                CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\r\n```",
      "commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "created_at" : "2022-01-24T20:43:14Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"conf_target\", request.params[1]);\n+                options.pushKV(\"estimate_mode\", request.params[2]);\n+            }\n+            if (options.exists(\"fee_rate\")) {\n+                if (!request.params[3].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"fee_rate\", request.params[3]);\n+            }\n+\n+            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n+            }\n+\n+            bool rbf = pwallet->m_signal_rbf;\n+            if (options.exists(\"replaceable\")) {\n+                rbf = options[\"replaceable\"].get_bool();\n+            }\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(NullUniValue, receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+            AvailableCoins(*pwallet, all_the_utxos, &coin_control, /* sweep 0-value utxos*/ 0);\n+\n+            const bool sendmax = options.exists(\"sendmax\") && options[\"sendmax\"].get_bool();\n+            CAmount total_input_value(0);\n+            for (const COutput& output : all_the_utxos) {\n+                CHECK_NONFATAL(output.nInputBytes > 0);\n+                if (sendmax && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                    continue;\n+                }\n+                CTxIn input(output.tx->GetHash(), output.i);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791135520",
      "id" : 791135520,
      "line" : 1312,
      "node_id" : "PRRC_kwDOABII584vJ8Ug",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1312,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 161,
      "pull_request_review_id" : 861495232,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791135520/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-24T20:43:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791135520",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The GUI will need access to this functionality too. It would be nice if the sweeping logic was refactored into a function in `src/wallet/spend.cpp` so that the GUI can access it.\r\n\r\nEdit: Actually that can wait until we figure out what the GUI is going to do for sweep.",
      "created_at" : "2022-01-24T22:28:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1020615011",
      "id" : 1020615011,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII58481Vlj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1020615011/reactions"
      },
      "updated_at" : "2022-01-25T18:42:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1020615011",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791932606"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791932606"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is consistent with how all other transaction creating RPCs permit setting the `fee_rate`, not offering both options may surprise some of the users.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:01:31Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791932606",
      "id" : 791932606,
      "in_reply_to_id" : 790142312,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584vM-6-",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1188,
      "original_position" : 37,
      "original_start_line" : 1184,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 862598415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791932606/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-25T17:01:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791932606",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791952687"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791952687"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Good catch, thanks. I'll make sure that the `conf_target` and `estimate_mode` appear in the documentation of the options.\r\n\r\nRegarding the error when `conf_target` and `estimate_mode` are passed in different ways, this is consistent with what `send` does.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:23:32Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791952687",
      "id" : 791952687,
      "in_reply_to_id" : 790142638,
      "line" : 1254,
      "node_id" : "PRRC_kwDOABII584vND0v",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1254,
      "original_position" : 86,
      "original_start_line" : 1235,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 178,
      "pull_request_review_id" : 862626593,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791952687/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1252,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-25T17:23:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791952687",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791954002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791954002"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"key-value\" is the prevalent way of describing this sort of datum.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:24:55Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791954002",
      "id" : 791954002,
      "in_reply_to_id" : 790142798,
      "line" : 1188,
      "node_id" : "PRRC_kwDOABII584vNEJS",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1188,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 112,
      "pull_request_review_id" : 862628344,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791954002/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T17:24:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791954002",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791957317"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791957317"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:28:38Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sweep RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+class WalletSweepTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def generate_initial_utxos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    def clean_up(self):\n+        if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+            self.wallet.sweep([self.return_addr_remainder])\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def sweep_two_utxos(self):\n+        self.log.info(\"Testing basic sweep case without specific amounts\")\n+        self.generate_initial_utxos([10, 11])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        output = tx_from_wallet[\"decoded\"][\"vout\"][0]\n+        assert_equal(output[\"value\"], wallet_balance_before_sweep + tx_from_wallet[\"fee\"]) # fee is negative\n+        assert_equal(output[\"scriptPubKey\"][\"address\"], self.return_addr_remainder)\n+\n+    def sweep_to_two_outputs(self):\n+        self.log.info(\"Testing sweep where one output has specified amount\")\n+        self.generate_initial_utxos([8, 13])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([{self.return_addr_with_amount: 5}, self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 2)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_with_amount, 5)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_remainder)\n+\n+        self.assert_balance_swept_completely(tx_from_wallet, wallet_balance_before_sweep)\n+\n+    def sweep_invalid_receiver_addresses(self):\n+        self.log.info(\"Testing sweep only with specified amount\")\n+        self.generate_initial_utxos([12, 9])\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-8, \"Must provide at least one address without a specified amount\" , self.wallet.sweep, [{self.return_addr_with_amount: 5}])\n+\n+        self.clean_up()\n+\n+    def sweep_invalid_amounts(self):\n+        self.log.info(\"Try sweeping more than balance\")\n+        self.generate_initial_utxos([7, 14])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        expected_tx = self.wallet.sweep(receivers=[{self.return_addr_with_amount: 5}, self.return_addr_remainder], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\" , self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep + 1}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.return_addr_with_amount), self.wallet.sweep, [{self.return_addr_with_amount: 0.00000001}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee - Decimal(0.00000010)}, self.return_addr_remainder])\n+\n+        self.clean_up()\n+\n+    def sweep_negative_effective_value(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791957317",
      "id" : 791957317,
      "in_reply_to_id" : 790142893,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII584vNE9F",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sweep.py",
      "position" : 107,
      "pull_request_review_id" : 862632846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791957317/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T17:28:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791957317",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791957352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791957352"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:28:40Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sweep RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+class WalletSweepTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def generate_initial_utxos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    def clean_up(self):\n+        if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+            self.wallet.sweep([self.return_addr_remainder])\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def sweep_two_utxos(self):\n+        self.log.info(\"Testing basic sweep case without specific amounts\")\n+        self.generate_initial_utxos([10, 11])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        output = tx_from_wallet[\"decoded\"][\"vout\"][0]\n+        assert_equal(output[\"value\"], wallet_balance_before_sweep + tx_from_wallet[\"fee\"]) # fee is negative\n+        assert_equal(output[\"scriptPubKey\"][\"address\"], self.return_addr_remainder)\n+\n+    def sweep_to_two_outputs(self):\n+        self.log.info(\"Testing sweep where one output has specified amount\")\n+        self.generate_initial_utxos([8, 13])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([{self.return_addr_with_amount: 5}, self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 2)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_with_amount, 5)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_remainder)\n+\n+        self.assert_balance_swept_completely(tx_from_wallet, wallet_balance_before_sweep)\n+\n+    def sweep_invalid_receiver_addresses(self):\n+        self.log.info(\"Testing sweep only with specified amount\")\n+        self.generate_initial_utxos([12, 9])\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-8, \"Must provide at least one address without a specified amount\" , self.wallet.sweep, [{self.return_addr_with_amount: 5}])\n+\n+        self.clean_up()\n+\n+    def sweep_invalid_amounts(self):\n+        self.log.info(\"Try sweeping more than balance\")\n+        self.generate_initial_utxos([7, 14])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        expected_tx = self.wallet.sweep(receivers=[{self.return_addr_with_amount: 5}, self.return_addr_remainder], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\" , self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep + 1}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.return_addr_with_amount), self.wallet.sweep, [{self.return_addr_with_amount: 0.00000001}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee - Decimal(0.00000010)}, self.return_addr_remainder])\n+\n+        self.clean_up()\n+\n+    def sweep_negative_effective_value(self):\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\", dust_wallet.sweep, receivers=[self.return_addr_remainder], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    def sweep_with_sendmax(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791957352",
      "id" : 791957352,
      "in_reply_to_id" : 790142968,
      "line" : 121,
      "node_id" : "PRRC_kwDOABII584vNE9o",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 121,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sweep.py",
      "position" : 121,
      "pull_request_review_id" : 862632892,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791957352/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T17:28:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791957352",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791958764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791958764"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I've added comments as suggested.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:30:14Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sweep RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+class WalletSweepTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def generate_initial_utxos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    def clean_up(self):\n+        if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+            self.wallet.sweep([self.return_addr_remainder])\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def sweep_two_utxos(self):\n+        self.log.info(\"Testing basic sweep case without specific amounts\")\n+        self.generate_initial_utxos([10, 11])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        output = tx_from_wallet[\"decoded\"][\"vout\"][0]\n+        assert_equal(output[\"value\"], wallet_balance_before_sweep + tx_from_wallet[\"fee\"]) # fee is negative\n+        assert_equal(output[\"scriptPubKey\"][\"address\"], self.return_addr_remainder)\n+\n+    def sweep_to_two_outputs(self):\n+        self.log.info(\"Testing sweep where one output has specified amount\")\n+        self.generate_initial_utxos([8, 13])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        sweep_tx_receipt = self.wallet.sweep([{self.return_addr_with_amount: 5}, self.return_addr_remainder])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+        assert_equal(sweep_tx_receipt[\"complete\"], True)\n+        tx_from_wallet = self.wallet.gettransaction(txid = sweep_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 2)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_with_amount, 5)\n+        self.assert_tx_has_output(tx_from_wallet, self.return_addr_remainder)\n+\n+        self.assert_balance_swept_completely(tx_from_wallet, wallet_balance_before_sweep)\n+\n+    def sweep_invalid_receiver_addresses(self):\n+        self.log.info(\"Testing sweep only with specified amount\")\n+        self.generate_initial_utxos([12, 9])\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-8, \"Must provide at least one address without a specified amount\" , self.wallet.sweep, [{self.return_addr_with_amount: 5}])\n+\n+        self.clean_up()\n+\n+    def sweep_invalid_amounts(self):\n+        self.log.info(\"Try sweeping more than balance\")\n+        self.generate_initial_utxos([7, 14])\n+        wallet_balance_before_sweep = self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+        expected_tx = self.wallet.sweep(receivers=[{self.return_addr_with_amount: 5}, self.return_addr_remainder], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\" , self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep + 1}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.return_addr_with_amount), self.wallet.sweep, [{self.return_addr_with_amount: 0.00000001}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee}, self.return_addr_remainder])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sweep, [{self.return_addr_with_amount: wallet_balance_before_sweep - fee - Decimal(0.00000010)}, self.return_addr_remainder])\n+\n+        self.clean_up()\n+\n+    def sweep_negative_effective_value(self):\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\", dust_wallet.sweep, receivers=[self.return_addr_remainder], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    def sweep_with_sendmax(self):\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 0.00000300)\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        sweep_tx_receipt = self.wallet.sweep(receivers=[self.return_addr_remainder], fee_rate=300, options={\"sendmax\": True})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791958764",
      "id" : 791958764,
      "in_reply_to_id" : 790143305,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII584vNFTs",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 130,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sweep.py",
      "position" : 130,
      "pull_request_review_id" : 862634775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791958764/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T17:30:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791958764",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977558"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks. I also removed it from send where it also wasn't used.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:52:15Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"conf_target\", request.params[1]);\n+                options.pushKV(\"estimate_mode\", request.params[2]);\n+            }\n+            if (options.exists(\"fee_rate\")) {\n+                if (!request.params[3].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"fee_rate\", request.params[3]);\n+            }\n+\n+            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n+            }\n+\n+            bool rbf = pwallet->m_signal_rbf;\n+            if (options.exists(\"replaceable\")) {\n+                rbf = options[\"replaceable\"].get_bool();\n+            }\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(NullUniValue, receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+            AvailableCoins(*pwallet, all_the_utxos, &coin_control, /* sweep 0-value utxos*/ 0);\n+\n+            const bool sendmax = options.exists(\"sendmax\") && options[\"sendmax\"].get_bool();\n+            CAmount total_input_value(0);\n+            for (const COutput& output : all_the_utxos) {\n+                CHECK_NONFATAL(output.nInputBytes > 0);\n+                if (sendmax && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                    continue;\n+                }\n+                CTxIn input(output.tx->GetHash(), output.i);\n+                rawTx.vin.push_back(input);\n+                total_input_value += output.tx->tx->vout[output.i].nValue; // The horrors. Why doesn't this just have an alias on COutput?\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (sendmax) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed(0);\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            CAmount remainder = effective_value - output_amounts_claimed;\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            bool add_to_wallet = true;\n+            if (options.exists(\"add_to_wallet\")) {\n+                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            }\n+\n+            // Make a blank psbt\n+            PartiallySignedTransaction psbtx(rawTx);\n+\n+            // First fill transaction with our data without signing,\n+            // so external signers are not asked sign more than once.\n+            bool complete;\n+            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+            // Other than the name suggests, this actually will sign the transaction if possible\n+            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n+            if (err != TransactionError::OK) {\n+                throw JSONRPCTransactionError(err);\n+            }\n+\n+            CMutableTransaction mtx;\n+            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : mtx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }\n+\n+\n+            UniValue result(UniValue::VOBJ);\n+\n+            if (psbt_opt_in || !complete || !add_to_wallet) {\n+                // Serialize the PSBT\n+                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+                ssTx << psbtx;\n+                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            }\n+\n+            if (complete) {\n+                std::string err_string;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977558",
      "id" : 791977558,
      "in_reply_to_id" : 790189815,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584vNJ5W",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1407,
      "original_position" : 256,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 862660702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977558/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T17:52:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977622"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977622"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed, thanks.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:52:20Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"conf_target\", request.params[1]);\n+                options.pushKV(\"estimate_mode\", request.params[2]);\n+            }\n+            if (options.exists(\"fee_rate\")) {\n+                if (!request.params[3].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"fee_rate\", request.params[3]);\n+            }\n+\n+            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n+            }\n+\n+            bool rbf = pwallet->m_signal_rbf;\n+            if (options.exists(\"replaceable\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977622",
      "id" : 791977622,
      "in_reply_to_id" : 791134867,
      "line" : 1301,
      "node_id" : "PRRC_kwDOABII584vNJ6W",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1301,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 225,
      "pull_request_review_id" : 862660788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977622/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T17:52:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977622",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977673"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added, thanks.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:52:24Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"conf_target\", request.params[1]);\n+                options.pushKV(\"estimate_mode\", request.params[2]);\n+            }\n+            if (options.exists(\"fee_rate\")) {\n+                if (!request.params[3].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+                }\n+            } else {\n+                options.pushKV(\"fee_rate\", request.params[3]);\n+            }\n+\n+            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n+            }\n+\n+            bool rbf = pwallet->m_signal_rbf;\n+            if (options.exists(\"replaceable\")) {\n+                rbf = options[\"replaceable\"].get_bool();\n+            }\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(NullUniValue, receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+            AvailableCoins(*pwallet, all_the_utxos, &coin_control, /* sweep 0-value utxos*/ 0);\n+\n+            const bool sendmax = options.exists(\"sendmax\") && options[\"sendmax\"].get_bool();\n+            CAmount total_input_value(0);\n+            for (const COutput& output : all_the_utxos) {\n+                CHECK_NONFATAL(output.nInputBytes > 0);\n+                if (sendmax && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                    continue;\n+                }\n+                CTxIn input(output.tx->GetHash(), output.i);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977673",
      "id" : 791977673,
      "in_reply_to_id" : 791135520,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584vNJ7J",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1312,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 862660865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977673/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T17:52:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977673",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977758"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Removed the newline. (I was copying the style of `send` which has one.)",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-25T17:52:30Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r791977758",
      "id" : 791977758,
      "in_reply_to_id" : 790144111,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584vNJ8e",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1166,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 862660968,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977758/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T18:12:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791977758",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r794424600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794424600"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> \"key-value\" is the prevalent way of describing this sort of datum.\r\n\r\nI had checked with various RPC commands, and I think it is correct. ",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-28T11:29:15Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r794424600",
      "id" : 794424600,
      "in_reply_to_id" : 790142798,
      "line" : 1188,
      "node_id" : "PRRC_kwDOABII584vWfUY",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1188,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 112,
      "pull_request_review_id" : 866027762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794424600/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-28T11:29:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794424600",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r794431354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794431354"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> This is consistent with how all other transaction creating RPCs permit setting the `fee_rate`.\r\n\r\nI checked with other RPCs where `\"fee_rate\", RPCArg::Type::AMOUNT,...` is used. It seems like the situation you are describing is true only for the `send` RPC (see https://github.com/bitcoin/bitcoin/blob/master/src/wallet/rpc/spend.cpp#L1050-L1062) and isn't a norm per se.\r\n\r\nOther RPCs that uses fee_rate but doesn't define it twice are:\r\n- sendtoaddress\r\n- sendmany\r\n- fundrawtransaction\r\n- bumpfee_helper, and,\r\n- walletcreatefundedpsbt\r\n\r\n",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-28T11:39:58Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r794431354",
      "id" : 794431354,
      "in_reply_to_id" : 790142312,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584vWg96",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1188,
      "original_position" : 37,
      "original_start_line" : 1184,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 866037257,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794431354/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-28T11:39:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794431354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r794441216"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794441216"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Regarding the error when conf_target and estimate_mode are passed in different ways, this is consistent with what send does.\r\n\r\nI checked the code, and it seems like you are right. I can also see that the `sweep` RPC is modeled after the `send` RPC. However, I am not sure if it is an optimal behavior. I can't understand why the user is compelled to input both of these options as either options or as arguments. Why not allow them to pass the first `conf_target` in one way and `estimate_mode` in another. Similar to what is done with `fee_rate`.",
      "commit_id" : "87e497f3a82307e61b92214e7298af0aa014ec73",
      "created_at" : "2022-01-28T11:55:30Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                    {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                          \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                          \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                    {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                    {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                    {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                    {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind.\"},\n+                },\n+                \"options\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweep\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweep\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n+                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r794441216",
      "id" : 794441216,
      "in_reply_to_id" : 790142638,
      "line" : 1254,
      "node_id" : "PRRC_kwDOABII584vWjYA",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1254,
      "original_position" : 86,
      "original_start_line" : 1235,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 178,
      "pull_request_review_id" : 866051255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794441216/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1252,
      "start_side" : "RIGHT",
      "updated_at" : "2022-01-28T11:55:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/794441216",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/85434418?v=4",
         "events_url" : "https://api.github.com/users/shaavan/events{/privacy}",
         "followers_url" : "https://api.github.com/users/shaavan/followers",
         "following_url" : "https://api.github.com/users/shaavan/following{/other_user}",
         "gists_url" : "https://api.github.com/users/shaavan/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/shaavan",
         "id" : 85434418,
         "login" : "shaavan",
         "node_id" : "MDQ6VXNlcjg1NDM0NDE4",
         "organizations_url" : "https://api.github.com/users/shaavan/orgs",
         "received_events_url" : "https://api.github.com/users/shaavan/received_events",
         "repos_url" : "https://api.github.com/users/shaavan/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/shaavan/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/shaavan/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/shaavan"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I have no objection to a dedicated `sweep` RPC call, but I don't agree with the premise that subtracting fee from output is only useful for sweeping a full wallet. See https://github.com/bitcoin/bitcoin/pull/24142#issuecomment-1024145620 ",
      "created_at" : "2022-01-28T12:01:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024148767",
      "id" : 1024148767,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849C0Uf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024148767/reactions"
      },
      "updated_at" : "2022-01-28T12:01:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024148767",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I have no objection to a dedicated `sweep` RPC call, but I don't agree with the premise that subtracting fee from output is only useful for sweeping a full wallet. See [#24142 (comment)](https://github.com/bitcoin/bitcoin/pull/24142#issuecomment-1024145620)\r\n\r\nEither approach seems fine to me, but I do think it is potentially more confusing to have two completely different RPCs for sending funds: \"send\" vs\" sweep\" than to have one sending option that means \"Send approximate amount. I don't care about exact amount of BTC received, and am happy if it's a little less or a little more to economize on fees and avoid change.\" Obviously you shouldn't use this option if you are trying to send an exact amount to someone, but it seems like it would be generally useful whenever you are sending money to one of your own wallets, or exchange accounts, or paying for any service that can be incrementally topped up.\r\n\r\nI know one of achow101's recent PR was adding more complexity to subtract from output implementation to try to do something to help sweeping, but I don't think the original (current?) semantics inherently had to add much complexity. It is true the code has been complex at different points but I think that was mostly a result of code shittiness and duplication, which have generally improved recently.",
      "created_at" : "2022-01-28T15:42:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024341246",
      "id" : 1024341246,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849DjT-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024341246/reactions"
      },
      "updated_at" : "2022-01-28T15:42:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024341246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Indeed I suspect that a `sweep` RPC will be useless if we decide to keep 'subtracting fee from output' functionality. In that case adding a sweep feature to the `send` RPC would make more sense. C-lightling has a special case amount `all` for that purpose.",
      "created_at" : "2022-01-28T16:19:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024373727",
      "id" : 1024373727,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849DrPf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024373727/reactions"
      },
      "updated_at" : "2022-01-28T16:20:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024373727",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK\r\n\r\nI have no objections to this RPC either, but something like `bitcoin-cli -named sendtoaddress address=\"....\" sweep=true` might be simpler for users instead of two commands to send funds.",
      "created_at" : "2022-01-28T16:59:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024420503",
      "id" : 1024420503,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849D2qX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024420503/reactions"
      },
      "updated_at" : "2022-01-28T16:59:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024420503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/94266259?v=4",
         "events_url" : "https://api.github.com/users/w0xlt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/w0xlt/followers",
         "following_url" : "https://api.github.com/users/w0xlt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/w0xlt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/w0xlt",
         "id" : 94266259,
         "login" : "w0xlt",
         "node_id" : "U_kgDOBZ5jkw",
         "organizations_url" : "https://api.github.com/users/w0xlt/orgs",
         "received_events_url" : "https://api.github.com/users/w0xlt/received_events",
         "repos_url" : "https://api.github.com/users/w0xlt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/w0xlt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/w0xlt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/w0xlt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I have no objection to a dedicated `sweep` RPC call, but I don't agree with the premise that subtracting fee from output is only useful for sweeping a full wallet. See [#24142 (comment)](https://github.com/bitcoin/bitcoin/pull/24142#issuecomment-1024145620)\r\n\r\nThat use case is what I call generalized sweep. Sweep can be viewed as spending all UTXOs in a given list without needing to specify the output amount. Whether that list is all the UTXOs in the wallet or a specific list of some UTXOs doesn't matter. So sweep can be extended to cover your use case by allowing for inputs to be specified.\r\n\r\n>  but it seems like it would be generally useful whenever you are sending money to one of your own wallets, or exchange accounts, or paying for any service that can be incrementally topped up.\r\n\r\nCan you describe why SFFO would be used in those cases? @Xekyo and I have had discussions with many people about SFFO use cases and even though the concept of \"send no more than X\" usually comes up, no one can express why that behavior would ever actually be useful. Just looking through many of the issues about SFFO show that its primary use case is to sweep an entire wallet, and sometimes spend just a preset list of coins without having to calculate the fee manually. Both of these cases can be covered by a sweep function without needing to maintain SFFO in coin selection logic.\r\n\r\n> I know one of achow101's recent PR was adding more complexity to subtract from output implementation to try to do something to help sweeping, but I don't think the original (current?) semantics inherently had to add much complexity. It is true the code has been complex at different points but I think that was mostly a result of code shittiness and duplication, which have generally improved recently.\r\n\r\nI find that SFFO makes it much harder to reason about our coin selection because we now use effective values for selection, but with SFFO, we don't actually want the effective values.",
      "created_at" : "2022-01-28T17:09:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024429070",
      "id" : 1024429070,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849D4wO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024429070/reactions"
      },
      "updated_at" : "2022-01-28T17:09:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024429070",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Another SFFO use case is when your recipient is legitimately taking on the cost of business. For example, it can be used when sending a loan.",
      "created_at" : "2022-01-29T08:32:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024866310",
      "id" : 1024866310,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849FjgG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024866310/reactions"
      },
      "updated_at" : "2022-01-29T08:32:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024866310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> > but it seems like it would be generally useful whenever you are sending money to one of your own wallets, or exchange accounts, or paying for any service that can be incrementally topped up.\r\n> \r\n> Can you describe why SFFO would be used in those cases? @Xekyo and I have had discussions with many people about SFFO use cases and even though the concept of \"send no more than X\" usually comes up, no one can express why that behavior would ever actually be useful.\r\n\r\nI think, mostly, it is useful *conceptually* as a way to simplify creating transactions. It's a way of expressing the *intention* behind a transaction, and letting the implementation take care of the details, instead of being having to think about what the transaction will look like, and choose between sweep and send APIs to create it.\r\n\r\nAlso the concept here is not exactly \"spend no more than X.\" If there are two amounts associated with transaction: X is amount spent by sender, Y is amount received by receiver, then option lets you choose between fixing X and letting Y vary, or fixing Y and letting X vary. If you have 12 BTC, and want to budget exactly 1 BTC per month to spend on a service, the option let you do that. And in general, it lets you just say what your intention is instead of having to think at a lower level.\r\n\r\nAdditionally, there is my main practical concern:\r\n\r\n- This is duplicating existing CreateTransaction(Internal) logic instead of just calling CreateTransaction with the right options. The claim is that this will be a code simplification, but the followup PR #24142 is +588/â148 lines. And this is while REMOVING features which I think we agree are useful: providing GUI support for sweeping, and being able to select coins to sweep. The new code and tests are going to grow and become even more complex after adding these features. \r\n\r\nMy medium level practical concern:\r\n\r\n- Deprecating subtract from output in #24142 presumably is going to break existing workflows, and there doesn't seem to be a good release notes or FAQ style item saying what that the problem is with subtract from output, why its removal is justified, and how to transition to the sweep API.\r\n\r\nAnd my mini practical concern:\r\n\r\n- This sweep API might be less safe than send APIs because it doesn't force you to specify amount you are trying to send. It's easier to fat-finger by accidentally sweeping the wrong wallet (or when manual coin selection is added) sweeping the wrong coin and spending an amount larger than you intended. Maybe this is not a very big concern. If it is a concern, it could also be addresed by adding a mandatory amount argument requiring you to specify total amount of the sweep or an override value like `\"unchecked\"` or `\"yolo\"`",
      "created_at" : "2022-01-29T14:16:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024920250",
      "id" : 1024920250,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849Fwq6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024920250/reactions"
      },
      "updated_at" : "2022-01-29T14:18:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024920250",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I find that SFFO makes it much harder to reason about our coin selection because we now use effective values for selection, but with SFFO, we don't actually want the effective values.\r\n\r\nCould you explain this more? There is a [`m_subtract_fee_outputs ? m_value : effective_value`](https://github.com/bitcoin/bitcoin/blob/5b4b8f76f3ae11064d4aa3ac157558e364751fd2/src/wallet/coinselection.cpp#L355-L358) line but that hardly seems terrible\r\n\r\nEDIT: I see there is a counterpart to this in `CreateTransactionInternal` where the option is used to [set](https://github.com/bitcoin/bitcoin/blob/5b4b8f76f3ae11064d4aa3ac157558e364751fd2/src/wallet/spend.cpp#L733-L735) [tx_noinput_size](https://github.com/bitcoin/bitcoin/blob/5b4b8f76f3ae11064d4aa3ac157558e364751fd2/src/wallet/spend.cpp#L741-L743). This seems pretty straightforward as well. Is this the extent of the problem or is there more under the surface?",
      "created_at" : "2022-01-29T14:46:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024925012",
      "id" : 1024925012,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849Fx1U",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024925012/reactions"
      },
      "updated_at" : "2022-01-29T14:58:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024925012",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This discussion is getting a little mixed between here and https://github.com/bitcoin/bitcoin/pull/24142#issuecomment-1024417067. I don't need _automatic_ coin selection for the use case I describe above. I do still need the feature to work for _manual_ coin selection. Having to use a separate \"sweep\" RPC for that seems a bit odd, especially when it needs to support most of the `send` kitchen sink, like using hardware wallets, specifying the fee rate, RBF, etc. And it still has to work in the GUI send screen, which touches much of the same CWallet code.",
      "created_at" : "2022-01-29T15:00:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1024927423",
      "id" : 1024927423,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849Fya_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024927423/reactions"
      },
      "updated_at" : "2022-01-29T15:00:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024927423",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> > I find that SFFO makes it much harder to reason about our coin selection because we now use effective values for selection, but with SFFO, we don't actually want the effective values.\r\n> \r\n> Could you explain this more? There is a [`m_subtract_fee_outputs ? m_value : effective_value`](https://github.com/bitcoin/bitcoin/blob/5b4b8f76f3ae11064d4aa3ac157558e364751fd2/src/wallet/coinselection.cpp#L355-L358) line but that hardly seems terrible\r\n> \r\n> EDIT: I see there is a counterpart to this in `CreateTransactionInternal` where the option is used to [set](https://github.com/bitcoin/bitcoin/blob/5b4b8f76f3ae11064d4aa3ac157558e364751fd2/src/wallet/spend.cpp#L733-L735) [tx_noinput_size](https://github.com/bitcoin/bitcoin/blob/5b4b8f76f3ae11064d4aa3ac157558e364751fd2/src/wallet/spend.cpp#L741-L743). This seems pretty straightforward as well. Is this the extent of the problem or is there more under the surface?\r\n\r\nIt makes the reasoning harder because the new coin selection code is almost entirely predicated on using effective values, particularly positive effective values. For BnB and SRD, we assume there are no negative ev inputs. For Knapsack and SRD, we assume we will make change and require a minimum change value. SFFO violates these assumptions, and that leads to bugs like #23026 (which happens to be a sweep use case).\r\n\r\n> and choose between sweep and send APIs to create it.\r\n> ...\r\n> This sweep API might be less safe than send APIs because it doesn't force you to specify amount you are trying to send. It's easier to fat-finger by accidentally sweeping the wrong wallet (or when manual coin selection is added) sweeping the wrong coin and spending an amount larger than you intended. Maybe this is not a very big concern. If it is a concern, it could also be addresed by adding a mandatory amount argument requiring you to specify total amount of the sweep or an override value like `\"unchecked\"` or `\"yolo\"`\r\n\r\nThere was some discussion about combining this with send where there would be some option for sweeping and some interpretation of magic values, but we felt that would end up being too clunky to use correctly so it was abandoned.\r\n\r\n> This is duplicating existing CreateTransaction(Internal) logic instead of just calling CreateTransaction with the right options. The claim is that this will be a code simplification, but the followup PR [Deprecate SubtractFeeFromOutputs #24142](https://github.com/bitcoin/bitcoin/pull/24142) is +588/â148 lines. \r\n\r\nThe followup only has more additions because it is adding `-deprecatedrpc=sffo`. It does not remove the behavior yet.\r\n\r\n> And this is while REMOVING features which I think we agree are useful: providing GUI support for sweeping, and being able to select coins to sweep.\r\n\r\nThere will be GUI support in the future.\r\n\r\n> The new code and tests are going to grow and become even more complex after adding these features.\r\n\r\nThis new code is unlikely to be expanded further given it's limited scope. However I agree there could be some refactors for deduplication between sweep and CreateTransactionInternal.\r\n\r\n> Deprecating subtract from output in [Deprecate SubtractFeeFromOutputs #24142](https://github.com/bitcoin/bitcoin/pull/24142) presumably is going to break existing workflows, and there doesn't seem to be a good release notes or FAQ style item saying what that the problem is with subtract from output, why its removal is justified, and how to transition to the sweep API.\r\n\r\nThe same could be said about every other time `-deprecatedrpc` has been used. Needing docs is not a reason to block a deprecation.\r\n",
      "created_at" : "2022-02-01T21:02:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1027283605",
      "id" : 1027283605,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849OxqV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1027283605/reactions"
      },
      "updated_at" : "2022-02-01T21:02:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1027283605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think, mostly, it is useful _conceptually_ as a way to simplify creating transactions. It's a way of expressing the _intention_ behind a transaction, and letting the implementation take care of the details, instead of being having to think about what the transaction will look like, and choose between sweep and send APIs to create it.\r\n\r\nAfter talking to some people in the last week and reading all comments on #24142 and here, I think I have a better understanding of how to distinguish the two domains of use cases between sweep and SFFO:\r\n\r\n- SFFO: Send to a recipient using a given budget deducting fees\r\n- Sweep: Send sum of inputs to recipient(s) deducting fees\r\n\r\nWe realize now, that SFFO is used more widely than we anticipated, and that the non-sweeping case is not covered by sweep. The problems and bugs occur when people use SFFO to specify the full wallet balance in order to arrive at a sweep functionality. Therefore, I do think that sweep is still useful, especially if we allow specifying an input list smaller than everything. We will work on that and GUI support.\r\n\r\n> * This is duplicating existing CreateTransaction(Internal) logic instead of just calling CreateTransaction with the right options. The claim is that this will be a code simplification, but the followup PR #24142 is +588/â148 lines. And this is while REMOVING features which I think we agree are useful: providing GUI support for sweeping, and being able to select coins to sweep. The new code and tests are going to grow and become even more complex after adding these features.\r\n\r\nWe looked into this, but found that we need to know the feerate to determine which inputs are eligible, need the inputs to be able to determine the receiver amounts, and when we have all the parameters to call `CreateTransaction(â¦)`, we already have used all of the duplicated code.",
      "created_at" : "2022-02-03T22:30:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1029462114",
      "id" : 1029462114,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849XFhi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029462114/reactions"
      },
      "updated_at" : "2022-02-03T22:32:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029462114",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Added the `inputs` option to sweep in 2664d3a.",
      "created_at" : "2022-02-04T00:42:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1029534293",
      "id" : 1029534293,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849XXJV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029534293/reactions"
      },
      "updated_at" : "2022-02-04T00:42:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029534293",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm still a bit worried about the amount of duplicated code here, also in the RPC parameter parsing.\r\n\r\nCan you add some test coverage for external signer use? The easiest way is probably to tweak `wallet_signer.py` such that the `send` example results in exactly the same coin selection as the new `sweep` example. In that case you can just duplicate the `hww.send` line and compare `res[hex]` between the two calls.\r\n\r\nIf you end up with two separate transactions because the RPC calls can't produce identical results, then it's useful to know the mechanism that test uses: it has one wallet with private keys and a watch-only clone. A PSBT is generated on the watch-only wallet. The private key enabled wallet is then used to sign it, with the result stored in the file system. Once the test node calls `mocks/signer.py` it reads the stored signed PSBT and returns it, thus faking a hardware wallet that actually signed something. This can of course be done for two separate PSBT's with some refactoring, but having an identical PSBT to sign is easier.",
      "created_at" : "2022-02-04T09:30:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1029800249",
      "id" : 1029800249,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849YYE5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029800249/reactions"
      },
      "updated_at" : "2022-02-04T09:30:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1029800249",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Renamed the proposed RPC `sweepwallet` to clarify that we are operating on the wallet's UTXO pool rather than a wallet-foreign private key as \"sweep\" may imply.\r\n\r\nRewrote the commit description.\r\n\r\n@Sjors: I will look into your feedback to reduce the code duplication and test external signer use.",
      "created_at" : "2022-02-04T21:54:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1030379808",
      "id" : 1030379808,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849alkg",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1030379808/reactions"
      },
      "updated_at" : "2022-02-04T21:54:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1030379808",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Deduplicated the parameter processing, still working on the test in `wallet_signer.py`.",
      "created_at" : "2022-02-08T21:18:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1033071628",
      "id" : 1033071628,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849k2wM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1033071628/reactions"
      },
      "updated_at" : "2022-02-08T21:18:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1033071628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Now with `wallet_signer.py` test.",
      "created_at" : "2022-02-08T21:43:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1033090522",
      "id" : 1033090522,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849k7Xa",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1033090522/reactions"
      },
      "updated_at" : "2022-02-08T21:43:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1033090522",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Now with Release Notes.",
      "created_at" : "2022-02-08T22:31:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1033128992",
      "id" : 1033128992,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849lEwg",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1033128992/reactions"
      },
      "updated_at" : "2022-02-08T22:31:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1033128992",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803092722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803092722"
         }
      },
      "author_association" : "MEMBER",
      "body" : "92b248498 nit, clang-format\r\n```diff\r\n-static void PreventOutdatedOptions(const UniValue& options) {\r\n+static void PreventOutdatedOptions(const UniValue& options)\r\n+{\r\n```\r\n74e3135 idem for `ParseFeeEstimationInstructions()`\r\n7ba3faa and for `FinishTransaction()`\r\n",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-09T21:13:46Z",
      "diff_hunk" : "@@ -50,6 +52,91 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options) {\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx) {\n+    bool add_to_wallet = options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true;\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex = EncodeHexTx(CTransaction(mtx));\n+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+        result.pushKV(\"txid\", tx->GetHash().GetHex());\n+        if (add_to_wallet && !psbt_opt_in) {\n+            pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+        } else {\n+            result.pushKV(\"hex\", hex);\n+        }\n+    }\n+    result.pushKV(\"complete\", complete);\n+\n+    return result;\n+}\n+\n+static void PreventOutdatedOptions(const UniValue& options) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803092722",
      "id" : 803092722,
      "line" : 119,
      "node_id" : "PRRC_kwDOABII584v3jjy",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 119,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 82,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803092722/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-09T22:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803092722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803096066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803096066"
         }
      },
      "author_association" : "MEMBER",
      "body" : "74e3135ba0721f62c2bc0cbb9bcab88a34003d67 if you retouch, we've been converging on this named arg format for clang-tidy verification\r\n```suggestion\r\n            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\r\n```\r\nb2b1d6b idem, line 1265, line 1290, etc.",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-09T21:18:31Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803096066",
      "id" : 803096066,
      "line" : 1162,
      "node_id" : "PRRC_kwDOABII584v3kYC",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1162,
      "original_position" : 210,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 210,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803096066/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-09T22:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803096066",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803113395"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803113395"
         }
      },
      "author_association" : "MEMBER",
      "body" : "7ba3faa4 minor style suggestions (initiialize localvar next to first use, const, braced initialization) if you retouch and are so inclined, these are already much improved\r\n\r\n<details><summary>diff</summary><p>\r\n\r\n```diff\r\n static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx) {\r\n-    bool add_to_wallet = options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true;\r\n-\r\n     // Make a blank psbt\r\n     PartiallySignedTransaction psbtx(rawTx);\r\n \r\n@@ -94,7 +92,9 @@ static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const\r\n \r\n     UniValue result(UniValue::VOBJ);\r\n \r\n-    const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\r\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\r\n+    const bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\r\n     if (psbt_opt_in || !complete || !add_to_wallet) {\r\n         // Serialize the PSBT\r\n         CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\r\n@@ -1231,7 +1231,7 @@ RPCHelpMan send()\r\n \r\n             CAmount fee;\r\n             int change_position;\r\n-            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\r\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\r\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\r\n             CCoinControl coin_control;\r\n```\r\n</p></details>\r\n",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-09T21:43:59Z",
      "diff_hunk" : "@@ -50,6 +52,91 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options) {\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803113395",
      "id" : 803113395,
      "line" : 76,
      "node_id" : "PRRC_kwDOABII584v3omz",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 76,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 39,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803113395/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-09T22:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803113395",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803134312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803134312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "b2b1d6b\r\n\r\n- I think you can add your release note directly to the file `doc/release-notes.md` in this section:\r\n\r\n```md\r\nNew RPCs\r\n--------\r\n```\r\n\r\n- s/without unspecified/without a specified/\r\n- add `(#24118)` to the end\r\n",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-09T22:15:22Z",
      "diff_hunk" : "@@ -0,0 +1,24 @@\n+Add `sweepwallet` RPC",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803134312",
      "id" : 803134312,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v3tto",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "doc/release-notes-24118.md",
      "position" : null,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803134312/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-11T10:35:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803134312",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803134829"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803134829"
         }
      },
      "author_association" : "MEMBER",
      "body" : "b2b1d6b nit, sort",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-09T22:16:10Z",
      "diff_hunk" : "@@ -7,11 +7,13 @@\n #include <policy/policy.h>\n #include <rpc/rawtransaction_util.h>\n #include <rpc/util.h>\n+#include <util/rbf.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803134829",
      "id" : 803134829,
      "line" : 10,
      "node_id" : "PRRC_kwDOABII584v3t1t",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 10,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 4,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803134829/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-09T22:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803134829",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803137411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803137411"
         }
      },
      "author_association" : "MEMBER",
      "body" : "b2b1d6b use a semi-colon here (\";\") or a new sentence\r\n```suggestion\r\n            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sweep destinations. Each address may only appear once.\\n\"\r\n```",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-09T22:20:03Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sweepwallet()\n+{\n+    return RPCHelpMan{\"sweepwallet\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweepwallet will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803137411",
      "id" : 803137411,
      "line" : 1188,
      "node_id" : "PRRC_kwDOABII584v3ueD",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1188,
      "original_position" : 244,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 244,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803137411/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-09T22:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803137411",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803138716"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803138716"
         }
      },
      "author_association" : "MEMBER",
      "body" : "b2b1d6b per the developer notes, snake case is used for new RPC arguments: `send_max`?  ",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-09T22:22:08Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sweepwallet()\n+{\n+    return RPCHelpMan{\"sweepwallet\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweepwallet will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with sendmax. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. Sendmax is incompatible with providing specific inputs.\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803138716",
      "id" : 803138716,
      "line" : 1222,
      "node_id" : "PRRC_kwDOABII584v3uyc",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1222,
      "original_position" : 278,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 278,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803138716/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-09T22:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803138716",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803150069"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803150069"
         }
      },
      "author_association" : "MEMBER",
      "body" : "b2b1d6b minor suggestions if you retouch and are so inclined\r\n\r\n<details><summary>diff</summary><p>\r\n\r\n```diff\r\n@@ -1353,17 +1353,11 @@ RPCHelpMan sweepwallet()\r\n             }\r\n \r\n             CCoinControl coin_control;\r\n-\r\n-            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\r\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\r\n \r\n             coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\r\n \r\n-            bool lock_unspents = false;\r\n-            if (options.exists(\"lock_unspents\")) {\r\n-                lock_unspents = options[\"lock_unspents\"].get_bool();\r\n-            }\r\n-\r\n-            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\r\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\r\n \r\n             FeeCalculation fee_calc_out;\r\n             CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\r\n@@ -1422,7 +1416,7 @@ RPCHelpMan sweepwallet()\r\n                 }\r\n             }\r\n \r\n-            CAmount output_amounts_claimed(0);\r\n+            CAmount output_amounts_claimed{0};\r\n             for (CTxOut out : rawTx.vout) {\r\n                 output_amounts_claimed += out.nValue;\r\n             }\r\n@@ -1431,12 +1425,12 @@ RPCHelpMan sweepwallet()\r\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\r\n             }\r\n \r\n-            CAmount remainder = effective_value - output_amounts_claimed;\r\n+            const CAmount remainder{effective_value - output_amounts_claimed};\r\n             if (remainder < 0) {\r\n                 throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\r\n             }\r\n \r\n-            CAmount per_output_without_amount = remainder / addresses_without_amount.size();\r\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\r\n \r\n             bool gave_remaining_to_first = false;\r\n             for (CTxOut& out : rawTx.vout) {\r\n@@ -1461,6 +1455,7 @@ RPCHelpMan sweepwallet()\r\n                 }\r\n             }\r\n \r\n+            const bool lock_unspents{options.exists(\"lock_unspents\") ? options[\"lock_unspents\"].get_bool() : false};\r\n             if (lock_unspents) {\r\n                 for (const CTxIn& txin : rawTx.vin) {\r\n                     pwallet->LockCoin(txin.prevout);\r\n```\r\n</p></details>\r\n",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-09T22:40:28Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sweepwallet()\n+{\n+    return RPCHelpMan{\"sweepwallet\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweepwallet will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with sendmax. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. Sendmax is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweepwallet\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweepwallet\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweepwallet\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweepwallet\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweepwallet\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n \n-            UniValue result(UniValue::VOBJ);\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool sendmax = options.exists(\"sendmax\") && options[\"sendmax\"].get_bool();\n+            if (options.exists(\"inputs\") && options.exists(\"sendmax\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine sendmax with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /* sweep 0-value utxos*/ 0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (sendmax && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (sendmax) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep, try using lower feerate.\");\n                 } else {\n-                    result.pushKV(\"hex\", hex);\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed(0);\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            CAmount remainder = effective_value - output_amounts_claimed;\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803150069",
      "id" : 803150069,
      "line" : 1399,
      "node_id" : "PRRC_kwDOABII584v3xj1",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1399,
      "original_position" : 480,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 480,
      "pull_request_review_id" : 878060109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803150069/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-09T22:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803150069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803205253"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803205253"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Okay, I'll take another look at that. Thank you.",
      "commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "created_at" : "2022-02-10T00:34:28Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r803205253",
      "id" : 803205253,
      "in_reply_to_id" : 790142312,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v3_CF",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1188,
      "original_position" : 37,
      "original_start_line" : 1184,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 878207785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803205253/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-10T00:34:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/803205253",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "â¢ Addressed @jonatack's comments\r\nâ¢ Added test for duplicate destinations\r\nâ¢ Added test for sweeping to multiple recipients sharing the remainder\r\nâ¢ Added `@cleanup` decorator to tests\r\nâ¢ Cleaned up extremely long lines in tests\r\n\r\nOpen questions: \r\nâ¢ Should this new RPC only allow one method (either options or positional args) to provide `fee_rate`, `feeconf_target` and `estimate_mode`?",
      "created_at" : "2022-02-10T22:25:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1035593556",
      "id" : 1035593556,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849uedU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1035593556/reactions"
      },
      "updated_at" : "2022-02-10T22:25:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1035593556",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804181749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804181749"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:28:16Z",
      "diff_hunk" : "@@ -7,11 +7,13 @@\n #include <policy/policy.h>\n #include <rpc/rawtransaction_util.h>\n #include <rpc/util.h>\n+#include <util/rbf.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804181749",
      "id" : 804181749,
      "in_reply_to_id" : 803134829,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v7tb1",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 10,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 879600000,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804181749/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:28:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804181749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804185121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185121"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think I got all these.",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:31:52Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sweepwallet()\n+{\n+    return RPCHelpMan{\"sweepwallet\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweepwallet will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with sendmax. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. Sendmax is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSweep all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sweepwallet\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sweepwallet\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Sweep all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweepwallet\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, sweep only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sweepwallet\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"sendmax\\\": true}'\\n\") +\n+        \"Sweep all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sweepwallet\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /* override_min_fee */ false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            bool lock_unspents = false;\n+            if (options.exists(\"lock_unspents\")) {\n+                lock_unspents = options[\"lock_unspents\"].get_bool();\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n \n-            UniValue result(UniValue::VOBJ);\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool sendmax = options.exists(\"sendmax\") && options[\"sendmax\"].get_bool();\n+            if (options.exists(\"inputs\") && options.exists(\"sendmax\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine sendmax with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /* sweep 0-value utxos*/ 0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (sendmax && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (sendmax) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep, try using lower feerate.\");\n                 } else {\n-                    result.pushKV(\"hex\", hex);\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for sweep. Try using lower feerate or excluding uneconomic UTXOs with 'sendmax' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed(0);\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            CAmount remainder = effective_value - output_amounts_claimed;\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804185121",
      "id" : 804185121,
      "in_reply_to_id" : 803150069,
      "line" : 1398,
      "node_id" : "PRRC_kwDOABII584v7uQh",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1398,
      "original_position" : 480,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 487,
      "pull_request_review_id" : 879603283,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185121/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:31:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185121",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804185666"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185666"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:32:24Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sweepwallet()\n+{\n+    return RPCHelpMan{\"sweepwallet\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweepwallet will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with sendmax. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"sendmax\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only sweep UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. Sendmax is incompatible with providing specific inputs.\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804185666",
      "id" : 804185666,
      "in_reply_to_id" : 803138716,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v7uZC",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1222,
      "original_position" : 278,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 879603799,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185666/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:32:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185666",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804185871"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185871"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, sounds much better.",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:32:35Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sweepwallet()\n+{\n+    return RPCHelpMan{\"sweepwallet\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweepwallet will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804185871",
      "id" : 804185871,
      "in_reply_to_id" : 803137411,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v7ucP",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1188,
      "original_position" : 244,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 879603951,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185871/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:32:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804185871",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804186159"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804186159"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Moved and amended as suggested",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:32:54Z",
      "diff_hunk" : "@@ -0,0 +1,24 @@\n+Add `sweepwallet` RPC",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804186159",
      "id" : 804186159,
      "in_reply_to_id" : 803134312,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v7ugv",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "doc/release-notes-24118.md",
      "position" : null,
      "pull_request_review_id" : 879604210,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804186159/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:32:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804186159",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804187419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804187419"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:34:14Z",
      "diff_hunk" : "@@ -50,6 +52,91 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options) {\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804187419",
      "id" : 804187419,
      "in_reply_to_id" : 803113395,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v7u0b",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 76,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 879605191,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804187419/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:34:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804187419",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804188483"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804188483"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Got em.",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:35:26Z",
      "diff_hunk" : "@@ -1060,101 +1159,248 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target*/ request.params[1], /*estimate_mode*/ request.params[2], /*fee_rate*/ request.params[3], options);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804188483",
      "id" : 804188483,
      "in_reply_to_id" : 803096066,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v7vFD",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 1162,
      "original_position" : 210,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 879606086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804188483/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:35:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804188483",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804189336"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804189336"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-10T22:36:31Z",
      "diff_hunk" : "@@ -50,6 +52,91 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options) {\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx) {\n+    bool add_to_wallet = options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true;\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex = EncodeHexTx(CTransaction(mtx));\n+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+        result.pushKV(\"txid\", tx->GetHash().GetHex());\n+        if (add_to_wallet && !psbt_opt_in) {\n+            pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+        } else {\n+            result.pushKV(\"hex\", hex);\n+        }\n+    }\n+    result.pushKV(\"complete\", complete);\n+\n+    return result;\n+}\n+\n+static void PreventOutdatedOptions(const UniValue& options) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804189336",
      "id" : 804189336,
      "in_reply_to_id" : 803092722,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584v7vSY",
      "original_commit_id" : "b2b1d6b54386627d9fb5170a6a265b0fbd904fc2",
      "original_line" : 119,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 879606945,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804189336/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-10T22:36:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804189336",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-02-10T22:47:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1035610384",
      "id" : 1035610384,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849uikQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1035610384/reactions"
      },
      "updated_at" : "2022-02-10T22:47:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1035610384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/13405205?v=4",
         "events_url" : "https://api.github.com/users/prayank23/events{/privacy}",
         "followers_url" : "https://api.github.com/users/prayank23/followers",
         "following_url" : "https://api.github.com/users/prayank23/following{/other_user}",
         "gists_url" : "https://api.github.com/users/prayank23/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/prayank23",
         "id" : 13405205,
         "login" : "prayank23",
         "node_id" : "MDQ6VXNlcjEzNDA1MjA1",
         "organizations_url" : "https://api.github.com/users/prayank23/orgs",
         "received_events_url" : "https://api.github.com/users/prayank23/received_events",
         "repos_url" : "https://api.github.com/users/prayank23/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/prayank23/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/prayank23"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Hate to nitpick the name, but \"sweepwallet\" to me sounds too easily confused with sweeping funds *into* the wallet.",
      "created_at" : "2022-02-11T03:49:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1035859509",
      "id" : 1035859509,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849vfY1",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1035859509/reactions"
      },
      "updated_at" : "2022-02-11T03:49:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1035859509",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804545946"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804545946"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure, but maybe `rpc_sweepwallet.py` would be the most coherent filename if the call is named \"sweepwallet\".",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-11T10:57:54Z",
      "diff_hunk" : "@@ -278,6 +278,8 @@\n     'wallet_create_tx.py --legacy-wallet',\n     'wallet_send.py --legacy-wallet',\n     'wallet_send.py --descriptors',\n+    'wallet_sweep.py --legacy-wallet',\n+    'wallet_sweep.py --descriptors',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804545946",
      "id" : 804545946,
      "line" : 282,
      "node_id" : "PRRC_kwDOABII584v9GWa",
      "original_commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "original_line" : 282,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/test_runner.py",
      "position" : 5,
      "pull_request_review_id" : 880031617,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804545946/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-11T11:28:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804545946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804560426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804560426"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I wonder if the release note isn't a bit long and whether the how-to info would be best documented elsewhere more permanently like in the sweepwallet help or in one of the doc/ files.",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-11T11:19:12Z",
      "diff_hunk" : "@@ -126,6 +126,30 @@ Updated RPCs\n New RPCs\n --------\n \n+- Add `sweepwallet` RPC\n+\n+  The `sweepwallet` RPC spends some given UTXOs' complete balance to one or more\n+  receivers without creating change.\n+\n+  By default, the `sweepwallet` RPC will empty the wallet completely leaving no\n+  UTXOs behind. Optionally, the `send_max` option allows skipping uneconomic UTXOs\n+  and therefore maximizing the received amount.\n+\n+  The `sweepwallet` RPC can process a combination of receiver addresses with and\n+  without amounts specified. The specified amounts are paid first, and the\n+  remainder split among the receivers with unspecified amounts. At least one\n+  address must be provided without a specified amount to receive the balance left\n+  after fees.\n+\n+  Instead of the complete UTXO pool, the call can be used to create a transaction\n+  from a specific UTXO set. We recommend using `sweepwallet` to empty wallets\n+  or to spend specific UTXOs in full.\n+\n+  The `sweepwallet` RPC therefore provides a less cumbersome way of spending\n+  specific UTXOs or emptying wallets than subtract fee from output/amount (SFFO).\n+  If the user wishes to specify a budget rather than a set of UTXOs to delimit a\n+  transaction, they should continue to use SFFO. (#24118)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804560426",
      "id" : 804560426,
      "line" : 151,
      "node_id" : "PRRC_kwDOABII584v9J4q",
      "original_commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "original_line" : 151,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "doc/release-notes.md",
      "position" : 26,
      "pull_request_review_id" : 880051548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804560426/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-11T11:19:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804560426",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Hate to nitpick the name, but \"sweepwallet\" to me sounds too easily confused with sweeping funds _into_ the wallet.\r\n\r\nI changed it from `sweep` after multiple people stated that they first thought it was a feature to sweep a private key into the wallet. I'm open to suggestions, if you have an idea for a better name.",
      "created_at" : "2022-02-11T17:49:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1036462094",
      "id" : 1036462094,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849xygO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1036462094/reactions"
      },
      "updated_at" : "2022-02-11T17:49:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1036462094",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804915694"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804915694"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: s/balance/value",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-11T18:43:15Z",
      "diff_hunk" : "@@ -126,6 +126,30 @@ Updated RPCs\n New RPCs\n --------\n \n+- Add `sweepwallet` RPC\n+\n+  The `sweepwallet` RPC spends some given UTXOs' complete balance to one or more",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r804915694",
      "id" : 804915694,
      "line" : 131,
      "node_id" : "PRRC_kwDOABII584v-gnu",
      "original_commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "original_line" : 131,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "doc/release-notes.md",
      "position" : 6,
      "pull_request_review_id" : 880551904,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804915694/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-11T18:43:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/804915694",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "idk, I guess if you don't mind ignoring the advanced use cases in naming, \"emptywallet\" might work.",
      "created_at" : "2022-02-11T18:45:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1036510984",
      "id" : 1036510984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII5849x-cI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1036510984/reactions"
      },
      "updated_at" : "2022-02-11T18:45:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1036510984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-02-14T12:21:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1039022742",
      "id" : 1039022742,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII58497jqW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1039022742/reactions"
      },
      "updated_at" : "2022-02-14T12:21:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1039022742",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "or maybe \"drainwallet\". \"emptywallet\" sounds a lot like empty wallet, i.e. it's not immediately clear that \"empty\" is a verb in this case",
      "created_at" : "2022-02-14T15:50:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1039247112",
      "id" : 1039247112,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII58498acI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1039247112/reactions"
      },
      "updated_at" : "2022-02-14T15:50:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1039247112",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/425166?v=4",
         "events_url" : "https://api.github.com/users/flack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/flack/followers",
         "following_url" : "https://api.github.com/users/flack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/flack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/flack",
         "id" : 425166,
         "login" : "flack",
         "node_id" : "MDQ6VXNlcjQyNTE2Ng==",
         "organizations_url" : "https://api.github.com/users/flack/orgs",
         "received_events_url" : "https://api.github.com/users/flack/received_events",
         "repos_url" : "https://api.github.com/users/flack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/flack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/flack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/flack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806111360"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806111360"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I see that some other wallet related calls do start with `rpc_â¦` as well, such as `rpc_rawtransaction.py`, `rpc_fundrawtransaction.py`, `rpc_signrawtransaction.py`, and `rpc_psbt.py`, but all the other send related calls are under `wallet_â¦`. I'm kinda thinking that it fits the pattern as it is currently. It should probably be `wallet_sweepwallet.py`, though.",
      "commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "created_at" : "2022-02-14T18:08:08Z",
      "diff_hunk" : "@@ -278,6 +278,8 @@\n     'wallet_create_tx.py --legacy-wallet',\n     'wallet_send.py --legacy-wallet',\n     'wallet_send.py --descriptors',\n+    'wallet_sweep.py --legacy-wallet',\n+    'wallet_sweep.py --descriptors',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806111360",
      "id" : 806111360,
      "in_reply_to_id" : 804545946,
      "line" : 282,
      "node_id" : "PRRC_kwDOABII584wDEiA",
      "original_commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "original_line" : 282,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/test_runner.py",
      "position" : 5,
      "pull_request_review_id" : 882010532,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806111360/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-14T18:08:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806111360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806245395"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245395"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Amended.",
      "commit_id" : "1051bade0b1b9f304d504c0a90c5b3c05334c340",
      "created_at" : "2022-02-14T21:16:36Z",
      "diff_hunk" : "@@ -126,6 +126,30 @@ Updated RPCs\n New RPCs\n --------\n \n+- Add `sweepwallet` RPC\n+\n+  The `sweepwallet` RPC spends some given UTXOs' complete balance to one or more",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806245395",
      "id" : 806245395,
      "in_reply_to_id" : 804915694,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wDlQT",
      "original_commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "original_line" : 131,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "doc/release-notes.md",
      "position" : null,
      "pull_request_review_id" : 882196594,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245395/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-14T21:16:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245395",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806245520"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245520"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I rewrote the release notes.",
      "commit_id" : "1051bade0b1b9f304d504c0a90c5b3c05334c340",
      "created_at" : "2022-02-14T21:16:46Z",
      "diff_hunk" : "@@ -126,6 +126,30 @@ Updated RPCs\n New RPCs\n --------\n \n+- Add `sweepwallet` RPC\n+\n+  The `sweepwallet` RPC spends some given UTXOs' complete balance to one or more\n+  receivers without creating change.\n+\n+  By default, the `sweepwallet` RPC will empty the wallet completely leaving no\n+  UTXOs behind. Optionally, the `send_max` option allows skipping uneconomic UTXOs\n+  and therefore maximizing the received amount.\n+\n+  The `sweepwallet` RPC can process a combination of receiver addresses with and\n+  without amounts specified. The specified amounts are paid first, and the\n+  remainder split among the receivers with unspecified amounts. At least one\n+  address must be provided without a specified amount to receive the balance left\n+  after fees.\n+\n+  Instead of the complete UTXO pool, the call can be used to create a transaction\n+  from a specific UTXO set. We recommend using `sweepwallet` to empty wallets\n+  or to spend specific UTXOs in full.\n+\n+  The `sweepwallet` RPC therefore provides a less cumbersome way of spending\n+  specific UTXOs or emptying wallets than subtract fee from output/amount (SFFO).\n+  If the user wishes to specify a budget rather than a set of UTXOs to delimit a\n+  transaction, they should continue to use SFFO. (#24118)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806245520",
      "id" : 806245520,
      "in_reply_to_id" : 804560426,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wDlSQ",
      "original_commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "original_line" : 151,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "doc/release-notes.md",
      "position" : null,
      "pull_request_review_id" : 882196757,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245520/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-14T21:16:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245520",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806245809"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245809"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Renamed to `wallet_sweepwallet.py`.",
      "commit_id" : "1051bade0b1b9f304d504c0a90c5b3c05334c340",
      "created_at" : "2022-02-14T21:17:14Z",
      "diff_hunk" : "@@ -278,6 +278,8 @@\n     'wallet_create_tx.py --legacy-wallet',\n     'wallet_send.py --legacy-wallet',\n     'wallet_send.py --descriptors',\n+    'wallet_sweep.py --legacy-wallet',\n+    'wallet_sweep.py --descriptors',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r806245809",
      "id" : 806245809,
      "in_reply_to_id" : 804545946,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wDlWx",
      "original_commit_id" : "27f8fb4c83e7178387afc86201cc14583fd943d2",
      "original_line" : 282,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/test_runner.py",
      "position" : null,
      "pull_request_review_id" : 882197184,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245809/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-14T21:17:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806245809",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Moved the release notes back to their own file to avoid merge conflict (I think I had misunderstood some feedback I got about release notes).",
      "created_at" : "2022-02-15T22:47:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1040874284",
      "id" : 1040874284,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII584-Cnss",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1040874284/reactions"
      },
      "updated_at" : "2022-02-15T22:47:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1040874284",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809377182"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809377182"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "After talking to a few people, my sentiment is that this is the expected behavior. In the minimal use case, the most important arguments are available as positional, making it easy to use. When people start using options, they may want to define everything as options, though, for consistency and readability.",
      "commit_id" : "5a663b2a676ed7ec24d5d4b1690d2639aeebab86",
      "created_at" : "2022-02-17T19:06:29Z",
      "diff_hunk" : "@@ -1159,6 +1160,267 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sweep()\n+{\n+    return RPCHelpMan{\"sweep\",\n+        \"\\nEXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend all confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sweep will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The destinations of the sweep, each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                {\n+                    {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                    {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809377182",
      "id" : 809377182,
      "in_reply_to_id" : 790142312,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wPh2e",
      "original_commit_id" : "669c52287ddc9e760de90b99f1085d9b2016d1aa",
      "original_line" : 1188,
      "original_position" : 37,
      "original_start_line" : 1184,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 886423867,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809377182/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-17T19:06:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809377182",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Renamed RPC to `sendall`, after discussion with other contributors. All review comments should have been addressed. Please let me know if I have missed something.",
      "created_at" : "2022-02-17T20:43:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1043411882",
      "id" : 1043411882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII584-MTOq",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1043411882/reactions"
      },
      "updated_at" : "2022-02-17T20:54:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1043411882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809483111"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809483111"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in 5a663b2a676ed7ec24d5d4b1690d2639aeebab86 \"Add sendall RPC nÃ©e sweep\"\r\n\r\nnit: The comment on this line is unnecessary.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-17T21:30:18Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809483111",
      "id" : 809483111,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wP7tn",
      "original_commit_id" : "5a663b2a676ed7ec24d5d4b1690d2639aeebab86",
      "original_line" : 1312,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 886575360,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809483111/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-17T21:42:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809483111",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809483926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809483926"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in 5a663b2a676ed7ec24d5d4b1690d2639aeebab86 \"Add sendall RPC nÃ©e sweep\"\r\n\r\nnit: the inline comment should have the parameter name\r\n\r\n```suggestion\r\n                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-17T21:31:24Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*spend 0-value utxos=*/0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809483926",
      "id" : 809483926,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wP76W",
      "original_commit_id" : "5a663b2a676ed7ec24d5d4b1690d2639aeebab86",
      "original_line" : 1331,
      "original_position" : 236,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 886575360,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809483926/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-17T21:42:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809483926",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809490334"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809490334"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 5a663b2a676ed7ec24d5d4b1690d2639aeebab86 \"Add sendall RPC nÃ©e sweep\"\r\n\r\nThis cleanup is no longer necessary with the `@cleanup` decorator.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-17T21:41:01Z",
      "diff_hunk" : "@@ -0,0 +1,291 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        return self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+    # Helper schema for success cases\n+    def test_sendall_success(self, sendall_args, remaining_balance = 0):\n+        sendall_tx_receipt = self.wallet.sendall(sendall_args)\n+        self.generate(self.nodes[0], 1)\n+        # wallet has remaining balance (usually empty)\n+        assert_equal(remaining_balance, self.wallet.getbalances()[\"mine\"][\"trusted\"])\n+\n+        assert_equal(sendall_tx_receipt[\"complete\"], True)\n+        return self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+    @cleanup\n+    def gen_and_clean(self):\n+        self.add_uxtos([15, 2, 4])\n+\n+    def test_cleanup(self):\n+        self.log.info(\"Test that cleanup wrapper empties wallet\")\n+        self.gen_and_clean()\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    # Actual tests\n+    @cleanup\n+    def sendall_two_utxos(self):\n+        self.log.info(\"Testing basic sendall case without specific amounts\")\n+        pre_sendall_balance = self.add_uxtos([10,11])\n+        tx_from_wallet = self.test_sendall_success(sendall_args = [self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx = tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance + tx_from_wallet[\"fee\"] } # fee is neg\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_split(self):\n+        self.log.info(\"Testing sendall where two recipients have unspecified amount\")\n+        pre_sendall_balance = self.add_uxtos([1, 2, 3, 15])\n+        tx_from_wallet = self.test_sendall_success([self.remainder_target, self.split_target])\n+\n+        half = (pre_sendall_balance + tx_from_wallet[\"fee\"]) / 2\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.split_target, \"value\": half },\n+                { \"address\": self.remainder_target, \"value\": half }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_and_spend(self):\n+        self.log.info(\"Testing sendall in combination with paying specified amount to recipient\")\n+        pre_sendall_balance = self.add_uxtos([8, 13])\n+        tx_from_wallet = self.test_sendall_success([{self.recipient: 5}, self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.recipient, \"value\": 5 },\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance - 5 + tx_from_wallet[\"fee\"] }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_invalid_receiver_addresses(self):\n+        self.log.info(\"Test having only receiver with specified amount, missing receiver with unspecified amount\")\n+        self.add_uxtos([12, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Must provide at least one address without a specified amount\" ,\n+                self.wallet.sendall,\n+                [{self.recipient: 5}]\n+            )\n+\n+    @cleanup\n+    def sendall_duplicate_receiver(self):\n+        self.log.info(\"Test duplicate destination\")\n+        self.add_uxtos([1, 8, 3, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Invalid parameter, duplicated address: {}\".format(self.remainder_target),\n+                self.wallet.sendall,\n+                [self.remainder_target, self.remainder_target]\n+            )\n+\n+    @cleanup\n+    def sendall_invalid_amounts(self):\n+        self.log.info(\"Test sending more than balance\")\n+        pre_sendall_balance = self.add_uxtos([7, 14])\n+\n+        expected_tx = self.wallet.sendall(receivers=[{self.recipient: 5}, self.remainder_target], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\", self.wallet.sendall,\n+                [ {self.recipient: pre_sendall_balance + 1}, self.remainder_target ])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance}, self.remainder_target])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.recipient),\n+                self.wallet.sendall, [{self.recipient: 0.00000001}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee - Decimal(0.00000010)}, self.remainder_target])\n+\n+    # @cleanup not needed because different wallet used\n+    def sendall_negative_effective_value(self):\n+        self.log.info(\"Test that sendall fails if all UTXOs have negative effective value\")\n+        # Use dedicated wallet for dust amounts and unload wallet at end\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for transaction.\"\n+                + \" Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\",\n+                dust_wallet.sendall, receivers=[self.remainder_target], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    @cleanup\n+    def sendall_with_send_max(self):\n+        self.log.info(\"Check that `send_max` option causes negative value UTXOs to be left behind\")\n+        self.add_uxtos([0.00000400, 0.00000300, 1])\n+\n+        # sendall with send_max\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], fee_rate=300, options={\"send_max\": True})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        self.assert_tx_has_outputs(tx_from_wallet, [{\"address\": self.remainder_target, \"value\": 1 + tx_from_wallet[\"fee\"]}])\n+        assert_equal(self.wallet.getbalances()[\"mine\"][\"trusted\"], Decimal(\"0.00000700\"))\n+\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+    @cleanup\n+    def sendall_specific_inputs(self):\n+        self.log.info(\"Test sendall with a subset of UTXO pool\")\n+        self.add_uxtos([17, 4])\n+        utxo = self.wallet.listunspent()[0]\n+\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], options={\"inputs\": [utxo]})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"txid\"], utxo[\"txid\"])\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"vout\"], utxo[\"vout\"])\n+        self.assert_tx_has_output(tx_from_wallet, self.remainder_target)\n+\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        # Clean up remaining UTXO\n+        self.wallet.sendall(receivers=[self.remainder_target])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809490334",
      "id" : 809490334,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wP9ee",
      "original_commit_id" : "5a663b2a676ed7ec24d5d4b1690d2639aeebab86",
      "original_line" : 220,
      "original_position" : 220,
      "original_start_line" : 217,
      "path" : "test/functional/wallet_sendall.py",
      "position" : null,
      "pull_request_review_id" : 886575360,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809490334/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-17T21:42:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809490334",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809535174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535174"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, removed",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-17T22:54:38Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809535174",
      "id" : 809535174,
      "in_reply_to_id" : 809483111,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wQIbG",
      "original_commit_id" : "5a663b2a676ed7ec24d5d4b1690d2639aeebab86",
      "original_line" : 1312,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 886649902,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535174/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-17T22:54:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535174",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809535260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535260"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, updated",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-17T22:54:49Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet); // Lock automatically released at end of function\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*spend 0-value utxos=*/0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809535260",
      "id" : 809535260,
      "in_reply_to_id" : 809483926,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wQIcc",
      "original_commit_id" : "5a663b2a676ed7ec24d5d4b1690d2639aeebab86",
      "original_line" : 1331,
      "original_position" : 236,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 886650001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535260/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-17T22:54:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535260",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809535455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535455"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Indeed. I removed the duplicate cleanup. Thanks.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-17T22:55:09Z",
      "diff_hunk" : "@@ -0,0 +1,291 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None ):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        return self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+    # Helper schema for success cases\n+    def test_sendall_success(self, sendall_args, remaining_balance = 0):\n+        sendall_tx_receipt = self.wallet.sendall(sendall_args)\n+        self.generate(self.nodes[0], 1)\n+        # wallet has remaining balance (usually empty)\n+        assert_equal(remaining_balance, self.wallet.getbalances()[\"mine\"][\"trusted\"])\n+\n+        assert_equal(sendall_tx_receipt[\"complete\"], True)\n+        return self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+    @cleanup\n+    def gen_and_clean(self):\n+        self.add_uxtos([15, 2, 4])\n+\n+    def test_cleanup(self):\n+        self.log.info(\"Test that cleanup wrapper empties wallet\")\n+        self.gen_and_clean()\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    # Actual tests\n+    @cleanup\n+    def sendall_two_utxos(self):\n+        self.log.info(\"Testing basic sendall case without specific amounts\")\n+        pre_sendall_balance = self.add_uxtos([10,11])\n+        tx_from_wallet = self.test_sendall_success(sendall_args = [self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx = tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance + tx_from_wallet[\"fee\"] } # fee is neg\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_split(self):\n+        self.log.info(\"Testing sendall where two recipients have unspecified amount\")\n+        pre_sendall_balance = self.add_uxtos([1, 2, 3, 15])\n+        tx_from_wallet = self.test_sendall_success([self.remainder_target, self.split_target])\n+\n+        half = (pre_sendall_balance + tx_from_wallet[\"fee\"]) / 2\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.split_target, \"value\": half },\n+                { \"address\": self.remainder_target, \"value\": half }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_and_spend(self):\n+        self.log.info(\"Testing sendall in combination with paying specified amount to recipient\")\n+        pre_sendall_balance = self.add_uxtos([8, 13])\n+        tx_from_wallet = self.test_sendall_success([{self.recipient: 5}, self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.recipient, \"value\": 5 },\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance - 5 + tx_from_wallet[\"fee\"] }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_invalid_receiver_addresses(self):\n+        self.log.info(\"Test having only receiver with specified amount, missing receiver with unspecified amount\")\n+        self.add_uxtos([12, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Must provide at least one address without a specified amount\" ,\n+                self.wallet.sendall,\n+                [{self.recipient: 5}]\n+            )\n+\n+    @cleanup\n+    def sendall_duplicate_receiver(self):\n+        self.log.info(\"Test duplicate destination\")\n+        self.add_uxtos([1, 8, 3, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Invalid parameter, duplicated address: {}\".format(self.remainder_target),\n+                self.wallet.sendall,\n+                [self.remainder_target, self.remainder_target]\n+            )\n+\n+    @cleanup\n+    def sendall_invalid_amounts(self):\n+        self.log.info(\"Test sending more than balance\")\n+        pre_sendall_balance = self.add_uxtos([7, 14])\n+\n+        expected_tx = self.wallet.sendall(receivers=[{self.recipient: 5}, self.remainder_target], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\", self.wallet.sendall,\n+                [ {self.recipient: pre_sendall_balance + 1}, self.remainder_target ])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance}, self.remainder_target])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.recipient),\n+                self.wallet.sendall, [{self.recipient: 0.00000001}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee - Decimal(0.00000010)}, self.remainder_target])\n+\n+    # @cleanup not needed because different wallet used\n+    def sendall_negative_effective_value(self):\n+        self.log.info(\"Test that sendall fails if all UTXOs have negative effective value\")\n+        # Use dedicated wallet for dust amounts and unload wallet at end\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for transaction.\"\n+                + \" Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\",\n+                dust_wallet.sendall, receivers=[self.remainder_target], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    @cleanup\n+    def sendall_with_send_max(self):\n+        self.log.info(\"Check that `send_max` option causes negative value UTXOs to be left behind\")\n+        self.add_uxtos([0.00000400, 0.00000300, 1])\n+\n+        # sendall with send_max\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], fee_rate=300, options={\"send_max\": True})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        self.assert_tx_has_outputs(tx_from_wallet, [{\"address\": self.remainder_target, \"value\": 1 + tx_from_wallet[\"fee\"]}])\n+        assert_equal(self.wallet.getbalances()[\"mine\"][\"trusted\"], Decimal(\"0.00000700\"))\n+\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+    @cleanup\n+    def sendall_specific_inputs(self):\n+        self.log.info(\"Test sendall with a subset of UTXO pool\")\n+        self.add_uxtos([17, 4])\n+        utxo = self.wallet.listunspent()[0]\n+\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], options={\"inputs\": [utxo]})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"txid\"], utxo[\"txid\"])\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"vout\"], utxo[\"vout\"])\n+        self.assert_tx_has_output(tx_from_wallet, self.remainder_target)\n+\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        # Clean up remaining UTXO\n+        self.wallet.sendall(receivers=[self.remainder_target])\n+        self.generate(self.nodes[0], 1)\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809535455",
      "id" : 809535455,
      "in_reply_to_id" : 809490334,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584wQIff",
      "original_commit_id" : "5a663b2a676ed7ec24d5d4b1690d2639aeebab86",
      "original_line" : 220,
      "original_position" : 220,
      "original_start_line" : 217,
      "path" : "test/functional/wallet_sendall.py",
      "position" : null,
      "pull_request_review_id" : 886650257,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535455/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-17T22:55:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809535455",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809797621"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809797621"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We can clean up the docs later, but I assume \"delimited via a budget\" refers to a scenario where a service pays a users an amount X and the user can decide what fee to pay?\r\n\r\nMaybe say:\r\n> Continue to use the \"subtract fee from output\" option in `send`, `sendtoaddress` or `sendmany` if the intention is to allocate a specific amount to a  recipient for which they incur the fee.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-18T09:01:35Z",
      "diff_hunk" : "@@ -0,0 +1,10 @@\n+New RPCs\n+--------\n+\n+- The `sendall` RPC spends given UTXOs to one or more receivers\n+  without creating change. By default, the `sendall` RPC will send\n+  everything in the wallet leaving no UTXOs behind. `sendall` is\n+  useful to empty wallets or to create a changeless payment from select\n+  UTXOs. Continue to use the \"subtract fee from output\" option to create\n+  transactions delimited via a budget (in contrast to a concrete set of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809797621",
      "id" : 809797621,
      "line" : 9,
      "node_id" : "PRRC_kwDOABII584wRIf1",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "doc/release-notes-24118.md",
      "position" : 9,
      "pull_request_review_id" : 886995922,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809797621/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-18T10:13:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809797621",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809802799"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809802799"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We use \"recipient(s)\" in most places (though receiver too). Both are valid, but \"recipient\" seems better:\r\nhttps://www.quora.com/What-is-the-difference-between-a-receiver-and-a-recipient",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-18T09:08:32Z",
      "diff_hunk" : "@@ -142,6 +142,10 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"send\", 1, \"conf_target\" },\n     { \"send\", 3, \"fee_rate\"},\n     { \"send\", 4, \"options\" },\n+    { \"sendall\", 0, \"receivers\" },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809802799",
      "id" : 809802799,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII584wRJwv",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 145,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 886995922,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809802799/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-18T10:13:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809802799",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809832478"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809832478"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c4d6cf5facf08cf4b1fba512ec30800f650a9c0b: maybe drop `positional_`",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-18T09:43:52Z",
      "diff_hunk" : "@@ -51,6 +51,28 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809832478",
      "id" : 809832478,
      "line" : 56,
      "node_id" : "PRRC_kwDOABII584wRRAe",
      "original_commit_id" : "c4d6cf5facf08cf4b1fba512ec30800f650a9c0b",
      "original_line" : 54,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 4,
      "pull_request_review_id" : 886995922,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809832478/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-18T10:13:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809832478",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809858573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809858573"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Some of the times when I run the test it raises \"Total value of UTXO pool too low to pay for transaction.\" and then during the handling it said \"No exception raised\" for this line.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-18T10:10:54Z",
      "diff_hunk" : "@@ -0,0 +1,286 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        return self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+    # Helper schema for success cases\n+    def test_sendall_success(self, sendall_args, remaining_balance = 0):\n+        sendall_tx_receipt = self.wallet.sendall(sendall_args)\n+        self.generate(self.nodes[0], 1)\n+        # wallet has remaining balance (usually empty)\n+        assert_equal(remaining_balance, self.wallet.getbalances()[\"mine\"][\"trusted\"])\n+\n+        assert_equal(sendall_tx_receipt[\"complete\"], True)\n+        return self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+    @cleanup\n+    def gen_and_clean(self):\n+        self.add_uxtos([15, 2, 4])\n+\n+    def test_cleanup(self):\n+        self.log.info(\"Test that cleanup wrapper empties wallet\")\n+        self.gen_and_clean()\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    # Actual tests\n+    @cleanup\n+    def sendall_two_utxos(self):\n+        self.log.info(\"Testing basic sendall case without specific amounts\")\n+        pre_sendall_balance = self.add_uxtos([10,11])\n+        tx_from_wallet = self.test_sendall_success(sendall_args = [self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx = tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance + tx_from_wallet[\"fee\"] } # fee is neg\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_split(self):\n+        self.log.info(\"Testing sendall where two recipients have unspecified amount\")\n+        pre_sendall_balance = self.add_uxtos([1, 2, 3, 15])\n+        tx_from_wallet = self.test_sendall_success([self.remainder_target, self.split_target])\n+\n+        half = (pre_sendall_balance + tx_from_wallet[\"fee\"]) / 2\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.split_target, \"value\": half },\n+                { \"address\": self.remainder_target, \"value\": half }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_and_spend(self):\n+        self.log.info(\"Testing sendall in combination with paying specified amount to recipient\")\n+        pre_sendall_balance = self.add_uxtos([8, 13])\n+        tx_from_wallet = self.test_sendall_success([{self.recipient: 5}, self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.recipient, \"value\": 5 },\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance - 5 + tx_from_wallet[\"fee\"] }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_invalid_receiver_addresses(self):\n+        self.log.info(\"Test having only receiver with specified amount, missing receiver with unspecified amount\")\n+        self.add_uxtos([12, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Must provide at least one address without a specified amount\" ,\n+                self.wallet.sendall,\n+                [{self.recipient: 5}]\n+            )\n+\n+    @cleanup\n+    def sendall_duplicate_receiver(self):\n+        self.log.info(\"Test duplicate destination\")\n+        self.add_uxtos([1, 8, 3, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Invalid parameter, duplicated address: {}\".format(self.remainder_target),\n+                self.wallet.sendall,\n+                [self.remainder_target, self.remainder_target]\n+            )\n+\n+    @cleanup\n+    def sendall_invalid_amounts(self):\n+        self.log.info(\"Test sending more than balance\")\n+        pre_sendall_balance = self.add_uxtos([7, 14])\n+\n+        expected_tx = self.wallet.sendall(receivers=[{self.recipient: 5}, self.remainder_target], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance + 1}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance}, self.remainder_target])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.recipient),\n+                self.wallet.sendall, [{self.recipient: 0.00000001}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee - Decimal(0.00000010)}, self.remainder_target])\n+\n+    # @cleanup not needed because different wallet used\n+    def sendall_negative_effective_value(self):\n+        self.log.info(\"Test that sendall fails if all UTXOs have negative effective value\")\n+        # Use dedicated wallet for dust amounts and unload wallet at end\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for transaction.\"\n+                + \" Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\",\n+                dust_wallet.sendall, receivers=[self.remainder_target], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    @cleanup\n+    def sendall_with_send_max(self):\n+        self.log.info(\"Check that `send_max` option causes negative value UTXOs to be left behind\")\n+        self.add_uxtos([0.00000400, 0.00000300, 1])\n+\n+        # sendall with send_max\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], fee_rate=300, options={\"send_max\": True})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        self.assert_tx_has_outputs(tx_from_wallet, [{\"address\": self.remainder_target, \"value\": 1 + tx_from_wallet[\"fee\"]}])\n+        assert_equal(self.wallet.getbalances()[\"mine\"][\"trusted\"], Decimal(\"0.00000700\"))\n+\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+    @cleanup\n+    def sendall_specific_inputs(self):\n+        self.log.info(\"Test sendall with a subset of UTXO pool\")\n+        self.add_uxtos([17, 4])\n+        utxo = self.wallet.listunspent()[0]\n+\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], options={\"inputs\": [utxo]})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"txid\"], utxo[\"txid\"])\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"vout\"], utxo[\"vout\"])\n+        self.assert_tx_has_output(tx_from_wallet, self.remainder_target)\n+\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    @cleanup\n+    def sendall_fails_on_missing_input(self):\n+        # fails because UTXO was previously spent, and wallet is empty\n+        self.log.info(\"Test sendall fails because specified UTXO is not available\")\n+        self.add_uxtos([16, 5])\n+        spent_utxo = self.wallet.listunspent()[0]\n+\n+        # fails on unconfirmed spent UTXO\n+        self.wallet.sendall(receivers=[self.remainder_target])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails on specific previously spent UTXO, while other UTXOs exist\n+        self.generate(self.nodes[0], 1)\n+        self.add_uxtos([19, 2])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails because UTXO is unknown, while other UTXOs exist\n+        foreign_utxo = self.def_wallet.listunspent()[0]\n+        assert_raises_rpc_error(-8, \"Input not found. UTXO ({}:{}) is not part of wallet.\".format(foreign_utxo[\"txid\"],\n+            foreign_utxo[\"vout\"]), self.wallet.sendall, receivers=[self.remainder_target],\n+            options={\"inputs\": [foreign_utxo]})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r809858573",
      "id" : 809858573,
      "line" : 241,
      "node_id" : "PRRC_kwDOABII584wRXYN",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 241,
      "original_position" : 241,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sendall.py",
      "position" : 241,
      "pull_request_review_id" : 886995922,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809858573/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-18T10:13:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/809858573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810114163"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810114163"
         }
      },
      "author_association" : "MEMBER",
      "body" : "General organization question: Did you consider putting some of this in a `CWallet` member function? A lot of it, like grabbing available coins and checking the effective values, locking unspents, etc. seem to be things that the wallet should take care of internally, rather than in the rpc handler code.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-18T15:40:08Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            const bool lock_unspents{options.exists(\"lock_unspents\") ? options[\"lock_unspents\"].get_bool() : false};\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810114163",
      "id" : 810114163,
      "line" : 1400,
      "node_id" : "PRRC_kwDOABII584wSVxz",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1400,
      "original_position" : 305,
      "original_start_line" : 1316,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 305,
      "pull_request_review_id" : 887441730,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810114163/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-18T15:57:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810114163",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810125831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810125831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Given that `AvailableCoins` filters much more than based on effective value, I'm wondering what the expected behavior *should* be for these types of UTXOs:\r\n\r\n- UTXOs that are not yet final or are immature coinbases \r\n- UTXOs for which the address has been marked as already used\r\n- outputs from replacement transactions\r\netc.\r\n\r\nMaybe it's fine that these are excluded, but just want to clarify that this behavior is what we want. Also leads me to wonder if the RPC should be returning a list of UTXOs that weren't included in the constructed transaction or something, but maybe that's overkill.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-18T15:53:32Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810125831",
      "id" : 810125831,
      "line" : 1331,
      "node_id" : "PRRC_kwDOABII584wSYoH",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1331,
      "original_position" : 236,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 236,
      "pull_request_review_id" : 887441730,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810125831/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-18T15:57:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810125831",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810204468"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810204468"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That seems like a good idea, but maybe too big a refactor for this PR?",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-18T17:28:39Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            const bool lock_unspents{options.exists(\"lock_unspents\") ? options[\"lock_unspents\"].get_bool() : false};\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810204468",
      "id" : 810204468,
      "in_reply_to_id" : 810114163,
      "line" : 1400,
      "node_id" : "PRRC_kwDOABII584wSr00",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1400,
      "original_position" : 305,
      "original_start_line" : 1316,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 305,
      "pull_request_review_id" : 887570234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810204468/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-18T17:28:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810204468",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810629932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810629932"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: slightly more concise\r\n```suggestion\r\n  without creating change. By default, the `sendall` RPC will spend\r\n  every UTXO in the wallet. `sendall` is\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-20T13:56:28Z",
      "diff_hunk" : "@@ -0,0 +1,10 @@\n+New RPCs\n+--------\n+\n+- The `sendall` RPC spends given UTXOs to one or more receivers\n+  without creating change. By default, the `sendall` RPC will send\n+  everything in the wallet leaving no UTXOs behind. `sendall` is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810629932",
      "id" : 810629932,
      "line" : 6,
      "node_id" : "PRRC_kwDOABII584wUTss",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 6,
      "original_position" : 6,
      "original_start_line" : 5,
      "path" : "doc/release-notes-24118.md",
      "position" : 6,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810629932/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 5,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810629932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810631375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810631375"
         }
      },
      "author_association" : "NONE",
      "body" : "I agree with Sjors' rephrasing - currently one could understand this to mean using SFFO with the `sendall` RPC. Slight iterative alteration which includes using the actual option name:\r\n\r\n> If the intention is to allocate a specific amount to a recipient for which the recipient incurs the fee, continue to use the `send`, `sendtoaddress` or `sendmany` methods with `subtractfeefromamount` option.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-20T14:07:04Z",
      "diff_hunk" : "@@ -0,0 +1,10 @@\n+New RPCs\n+--------\n+\n+- The `sendall` RPC spends given UTXOs to one or more receivers\n+  without creating change. By default, the `sendall` RPC will send\n+  everything in the wallet leaving no UTXOs behind. `sendall` is\n+  useful to empty wallets or to create a changeless payment from select\n+  UTXOs. Continue to use the \"subtract fee from output\" option to create\n+  transactions delimited via a budget (in contrast to a concrete set of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r810631375",
      "id" : 810631375,
      "in_reply_to_id" : 809797621,
      "line" : 9,
      "node_id" : "PRRC_kwDOABII584wUUDP",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "doc/release-notes-24118.md",
      "position" : 9,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810631375/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/810631375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r811673390"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/811673390"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is all newly added code?",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-22T08:11:33Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            const bool lock_unspents{options.exists(\"lock_unspents\") ? options[\"lock_unspents\"].get_bool() : false};\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r811673390",
      "id" : 811673390,
      "in_reply_to_id" : 810114163,
      "line" : 1400,
      "node_id" : "PRRC_kwDOABII584wYScu",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1400,
      "original_position" : 305,
      "original_start_line" : 1316,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 305,
      "pull_request_review_id" : 889418499,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/811673390/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-22T08:11:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/811673390",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r811711157"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/811711157"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops yes, this is not part of the refactoring commits.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-22T08:56:48Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            const bool lock_unspents{options.exists(\"lock_unspents\") ? options[\"lock_unspents\"].get_bool() : false};\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r811711157",
      "id" : 811711157,
      "in_reply_to_id" : 810114163,
      "line" : 1400,
      "node_id" : "PRRC_kwDOABII584wYbq1",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1400,
      "original_position" : 305,
      "original_start_line" : 1316,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 305,
      "pull_request_review_id" : 889470044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/811711157/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-22T08:56:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/811711157",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815754993"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815754993"
         }
      },
      "author_association" : "NONE",
      "body" : "nyfnit _(not-your-fault nit)_: would now be a good time to align the error messages and either have them all (preferred imo) or none report on the \"instead of\" like is done for `feeRate`/`fee_rate`? Might make more sense in a separate commit to not break the `--color-moved` heuristics.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T10:23:16Z",
      "diff_hunk" : "@@ -50,6 +53,93 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)\n+{\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)\n+{\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err{pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false)};\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\n+    bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex = EncodeHexTx(CTransaction(mtx));\n+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+        result.pushKV(\"txid\", tx->GetHash().GetHex());\n+        if (add_to_wallet && !psbt_opt_in) {\n+            pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+        } else {\n+            result.pushKV(\"hex\", hex);\n+        }\n+    }\n+    result.pushKV(\"complete\", complete);\n+\n+    return result;\n+}\n+\n+static void PreventOutdatedOptions(const UniValue& options)\n+{\n+    if (options.exists(\"feeRate\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n+    }\n+    if (options.exists(\"changeAddress\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n+    }\n+    if (options.exists(\"changePosition\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n+    }\n+    if (options.exists(\"includeWatching\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n+    }\n+    if (options.exists(\"lockUnspents\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n+    }\n+    if (options.exists(\"subtractFeeFromOutputs\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815754993",
      "id" : 815754993,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII584wn27x",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 140,
      "original_position" : 111,
      "original_start_line" : 123,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 111,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815754993/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 123,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815754993",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815762890"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815762890"
         }
      },
      "author_association" : "NONE",
      "body" : "I agree with Sjors, it would also make the hints on the call site align with the (shorter) parameter name.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T10:33:28Z",
      "diff_hunk" : "@@ -51,6 +51,28 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815762890",
      "id" : 815762890,
      "in_reply_to_id" : 809832478,
      "line" : 56,
      "node_id" : "PRRC_kwDOABII584wn43K",
      "original_commit_id" : "c4d6cf5facf08cf4b1fba512ec30800f650a9c0b",
      "original_line" : 54,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 4,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815762890/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815762890",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815767586"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815767586"
         }
      },
      "author_association" : "NONE",
      "body" : "Additional nit: I'm not sure `Parse` best captures the function behaviour. Since the function has side effects and I don't really see any parsing, I think a function name like `UpdateFeeEstimationInstructions` would better reflect that?",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T10:39:42Z",
      "diff_hunk" : "@@ -51,6 +51,28 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815767586",
      "id" : 815767586,
      "in_reply_to_id" : 809832478,
      "line" : 56,
      "node_id" : "PRRC_kwDOABII584wn6Ai",
      "original_commit_id" : "c4d6cf5facf08cf4b1fba512ec30800f650a9c0b",
      "original_line" : 54,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 4,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815767586/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815767586",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815803682"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815803682"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            bool rbf { options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf };\r\n```\r\n",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:30:25Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815803682",
      "id" : 815803682,
      "line" : 1171,
      "node_id" : "PRRC_kwDOABII584woC0i",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1171,
      "original_position" : 232,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 232,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815803682/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815803682",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815804228"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815804228"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            const UniValue& receivers { request.params[0] };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:31:14Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815804228",
      "id" : 815804228,
      "line" : 1274,
      "node_id" : "PRRC_kwDOABII584woC9E",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1274,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 338,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815804228/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815804228",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815804937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815804937"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n        std::string hex { EncodeHexTx(CTransaction(mtx)) };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:32:06Z",
      "diff_hunk" : "@@ -50,6 +53,93 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)\n+{\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)\n+{\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err{pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false)};\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\n+    bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex = EncodeHexTx(CTransaction(mtx));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815804937",
      "id" : 815804937,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII584woDIJ",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 107,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 78,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815804937/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815804937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815805628"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815805628"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            std::shared_ptr<CWallet> const pwallet { GetWalletForJSONRPCRequest(request) };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:32:53Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815805628",
      "id" : 815805628,
      "line" : 1264,
      "node_id" : "PRRC_kwDOABII584woDS8",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1264,
      "original_position" : 328,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 328,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815805628/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815805628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806023"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806023"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n                const UniValue& receiver { receivers[i] };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:33:17Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806023",
      "id" : 815806023,
      "line" : 1276,
      "node_id" : "PRRC_kwDOABII584woDZH",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1276,
      "original_position" : 340,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 340,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806023/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806023",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806298"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806298"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            CFeeRate fee_rate { GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out) };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:33:36Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806298",
      "id" : 815806298,
      "line" : 1300,
      "node_id" : "PRRC_kwDOABII584woDda",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1300,
      "original_position" : 373,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 373,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806298/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806298",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806599"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806599"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            CMutableTransaction rawTx { ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf) };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:33:54Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806599",
      "id" : 815806599,
      "line" : 1311,
      "node_id" : "PRRC_kwDOABII584woDiH",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1311,
      "original_position" : 386,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 386,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806599/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806599",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806892"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use list initialization?\r\n```suggestion\r\n                    const CWalletTx* tx { pwallet->GetWalletTx(input.prevout.hash) };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:34:12Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815806892",
      "id" : 815806892,
      "line" : 1324,
      "node_id" : "PRRC_kwDOABII584woDms",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1324,
      "original_position" : 399,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 399,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806892/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815806892",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815813825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815813825"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            TxSize tx_size { CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get()) };\r\n            CAmount fee_from_size { fee_rate.GetFee(tx_size.vsize) };\r\n            CAmount effective_value { total_input_value - fee_from_size };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:41:24Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815813825",
      "id" : 815813825,
      "line" : 1346,
      "node_id" : "PRRC_kwDOABII584woFTB",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1346,
      "original_position" : 422,
      "original_start_line" : 1344,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 422,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815813825/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1344,
      "start_side" : "RIGHT",
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815813825",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815814412"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815814412"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            const CAmount per_output_without_amount { remainder / addresses_without_amount.size() };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:42:00Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815814412",
      "id" : 815814412,
      "line" : 1370,
      "node_id" : "PRRC_kwDOABII584woFcM",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1370,
      "original_position" : 458,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 458,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815814412/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815814412",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815814668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815814668"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n            bool gave_remaining_to_first { false };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:42:17Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815814668",
      "id" : 815814668,
      "line" : 1372,
      "node_id" : "PRRC_kwDOABII584woFgM",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1372,
      "original_position" : 460,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 460,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815814668/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815814668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815816959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815816959"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: maybe use brace initialization?\r\n```suggestion\r\n                std::string addr { EncodeDestination(dest) };\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:45:30Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815816959",
      "id" : 815816959,
      "line" : 1376,
      "node_id" : "PRRC_kwDOABII584woGD_",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1376,
      "original_position" : 464,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 464,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815816959/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815816959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815822579"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815822579"
         }
      },
      "author_association" : "NONE",
      "body" : "Wording nit/suggestion:\r\n```suggestion\r\n        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. sendall respects the avoid_reuse wallet flag.\\n\",\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T11:53:52Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815822579",
      "id" : 815822579,
      "line" : 1189,
      "node_id" : "PRRC_kwDOABII584woHbz",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1189,
      "original_position" : 253,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 253,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815822579/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815822579",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815826629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815826629"
         }
      },
      "author_association" : "NONE",
      "body" : "Consistency nit\r\n```suggestion\r\n                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\r\n```",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T12:00:06Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815826629",
      "id" : 815826629,
      "line" : 1212,
      "node_id" : "PRRC_kwDOABII584woIbF",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1212,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 276,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815826629/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815826629",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815827002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815827002"
         }
      },
      "author_association" : "NONE",
      "body" : "Wording nit/suggestion:\r\n```suggestion\r\n                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\r\n```\r\n",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-02-28T12:00:42Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r815827002",
      "id" : 815827002,
      "line" : 1210,
      "node_id" : "PRRC_kwDOABII584woIg6",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1210,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 274,
      "pull_request_review_id" : 888039586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815827002/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-28T12:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/815827002",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@Sjors: Thanks for the thoughtful suggestions. I've adopted your suggestions for phrasing and discussed whether overloading the receivers/recipients array with a single string with some other developers. While I agree that it would ease the (probably) most likely use case of sweeping everything into a single address, some people didn't like the idea of allowing multiple types for one parameter.\r\n\r\n@glozow, @stickies-v: Thank you for the review, I'm working on answers to each of your comments.",
      "created_at" : "2022-03-09T20:51:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1063359957",
      "id" : 1063359957,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII584_YZXV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1063359957/reactions"
      },
      "updated_at" : "2022-03-09T20:51:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1063359957",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125413"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125413"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the suggestions. I'm changing the sentence to:\r\n\r\n> When creating a payment from a specific amount for which the recipient incurs the transaction fee, continue to use the   `subtractfeefromamount` option via the `send`, `sendtoaddress`, or `sendmany` RPCs.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-03-09T21:57:02Z",
      "diff_hunk" : "@@ -0,0 +1,10 @@\n+New RPCs\n+--------\n+\n+- The `sendall` RPC spends given UTXOs to one or more receivers\n+  without creating change. By default, the `sendall` RPC will send\n+  everything in the wallet leaving no UTXOs behind. `sendall` is\n+  useful to empty wallets or to create a changeless payment from select\n+  UTXOs. Continue to use the \"subtract fee from output\" option to create\n+  transactions delimited via a budget (in contrast to a concrete set of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125413",
      "id" : 823125413,
      "in_reply_to_id" : 809797621,
      "line" : 9,
      "node_id" : "PRRC_kwDOABII584xD-Wl",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "doc/release-notes-24118.md",
      "position" : 9,
      "pull_request_review_id" : 905034518,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125413/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-09T21:57:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125413",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125506"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Changing receiver to recipient everywhere.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-03-09T21:57:09Z",
      "diff_hunk" : "@@ -142,6 +142,10 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"send\", 1, \"conf_target\" },\n     { \"send\", 3, \"fee_rate\"},\n     { \"send\", 4, \"options\" },\n+    { \"sendall\", 0, \"receivers\" },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125506",
      "id" : 823125506,
      "in_reply_to_id" : 809802799,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII584xD-YC",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 145,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 905034634,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125506/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-09T21:57:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125506",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125611"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125611"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Dropping the `positional_` and renaming function to `InterpretFeeEstimationInstructions`",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-03-09T21:57:19Z",
      "diff_hunk" : "@@ -51,6 +51,28 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125611",
      "id" : 823125611,
      "in_reply_to_id" : 809832478,
      "line" : 56,
      "node_id" : "PRRC_kwDOABII584xD-Zr",
      "original_commit_id" : "c4d6cf5facf08cf4b1fba512ec30800f650a9c0b",
      "original_line" : 54,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 4,
      "pull_request_review_id" : 905034772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125611/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-09T21:57:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125611",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125712"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I have been able to reproduce this, but I haven't figured out what the issue is, yet.",
      "commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "created_at" : "2022-03-09T21:57:30Z",
      "diff_hunk" : "@@ -0,0 +1,286 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        return self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+    # Helper schema for success cases\n+    def test_sendall_success(self, sendall_args, remaining_balance = 0):\n+        sendall_tx_receipt = self.wallet.sendall(sendall_args)\n+        self.generate(self.nodes[0], 1)\n+        # wallet has remaining balance (usually empty)\n+        assert_equal(remaining_balance, self.wallet.getbalances()[\"mine\"][\"trusted\"])\n+\n+        assert_equal(sendall_tx_receipt[\"complete\"], True)\n+        return self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+    @cleanup\n+    def gen_and_clean(self):\n+        self.add_uxtos([15, 2, 4])\n+\n+    def test_cleanup(self):\n+        self.log.info(\"Test that cleanup wrapper empties wallet\")\n+        self.gen_and_clean()\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    # Actual tests\n+    @cleanup\n+    def sendall_two_utxos(self):\n+        self.log.info(\"Testing basic sendall case without specific amounts\")\n+        pre_sendall_balance = self.add_uxtos([10,11])\n+        tx_from_wallet = self.test_sendall_success(sendall_args = [self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx = tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance + tx_from_wallet[\"fee\"] } # fee is neg\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_split(self):\n+        self.log.info(\"Testing sendall where two recipients have unspecified amount\")\n+        pre_sendall_balance = self.add_uxtos([1, 2, 3, 15])\n+        tx_from_wallet = self.test_sendall_success([self.remainder_target, self.split_target])\n+\n+        half = (pre_sendall_balance + tx_from_wallet[\"fee\"]) / 2\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.split_target, \"value\": half },\n+                { \"address\": self.remainder_target, \"value\": half }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_and_spend(self):\n+        self.log.info(\"Testing sendall in combination with paying specified amount to recipient\")\n+        pre_sendall_balance = self.add_uxtos([8, 13])\n+        tx_from_wallet = self.test_sendall_success([{self.recipient: 5}, self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.recipient, \"value\": 5 },\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance - 5 + tx_from_wallet[\"fee\"] }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_invalid_receiver_addresses(self):\n+        self.log.info(\"Test having only receiver with specified amount, missing receiver with unspecified amount\")\n+        self.add_uxtos([12, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Must provide at least one address without a specified amount\" ,\n+                self.wallet.sendall,\n+                [{self.recipient: 5}]\n+            )\n+\n+    @cleanup\n+    def sendall_duplicate_receiver(self):\n+        self.log.info(\"Test duplicate destination\")\n+        self.add_uxtos([1, 8, 3, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Invalid parameter, duplicated address: {}\".format(self.remainder_target),\n+                self.wallet.sendall,\n+                [self.remainder_target, self.remainder_target]\n+            )\n+\n+    @cleanup\n+    def sendall_invalid_amounts(self):\n+        self.log.info(\"Test sending more than balance\")\n+        pre_sendall_balance = self.add_uxtos([7, 14])\n+\n+        expected_tx = self.wallet.sendall(receivers=[{self.recipient: 5}, self.remainder_target], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance + 1}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance}, self.remainder_target])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.recipient),\n+                self.wallet.sendall, [{self.recipient: 0.00000001}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee - Decimal(0.00000010)}, self.remainder_target])\n+\n+    # @cleanup not needed because different wallet used\n+    def sendall_negative_effective_value(self):\n+        self.log.info(\"Test that sendall fails if all UTXOs have negative effective value\")\n+        # Use dedicated wallet for dust amounts and unload wallet at end\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for transaction.\"\n+                + \" Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\",\n+                dust_wallet.sendall, receivers=[self.remainder_target], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    @cleanup\n+    def sendall_with_send_max(self):\n+        self.log.info(\"Check that `send_max` option causes negative value UTXOs to be left behind\")\n+        self.add_uxtos([0.00000400, 0.00000300, 1])\n+\n+        # sendall with send_max\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], fee_rate=300, options={\"send_max\": True})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        self.assert_tx_has_outputs(tx_from_wallet, [{\"address\": self.remainder_target, \"value\": 1 + tx_from_wallet[\"fee\"]}])\n+        assert_equal(self.wallet.getbalances()[\"mine\"][\"trusted\"], Decimal(\"0.00000700\"))\n+\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+    @cleanup\n+    def sendall_specific_inputs(self):\n+        self.log.info(\"Test sendall with a subset of UTXO pool\")\n+        self.add_uxtos([17, 4])\n+        utxo = self.wallet.listunspent()[0]\n+\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], options={\"inputs\": [utxo]})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"txid\"], utxo[\"txid\"])\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"vout\"], utxo[\"vout\"])\n+        self.assert_tx_has_output(tx_from_wallet, self.remainder_target)\n+\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    @cleanup\n+    def sendall_fails_on_missing_input(self):\n+        # fails because UTXO was previously spent, and wallet is empty\n+        self.log.info(\"Test sendall fails because specified UTXO is not available\")\n+        self.add_uxtos([16, 5])\n+        spent_utxo = self.wallet.listunspent()[0]\n+\n+        # fails on unconfirmed spent UTXO\n+        self.wallet.sendall(receivers=[self.remainder_target])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails on specific previously spent UTXO, while other UTXOs exist\n+        self.generate(self.nodes[0], 1)\n+        self.add_uxtos([19, 2])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails because UTXO is unknown, while other UTXOs exist\n+        foreign_utxo = self.def_wallet.listunspent()[0]\n+        assert_raises_rpc_error(-8, \"Input not found. UTXO ({}:{}) is not part of wallet.\".format(foreign_utxo[\"txid\"],\n+            foreign_utxo[\"vout\"]), self.wallet.sendall, receivers=[self.remainder_target],\n+            options={\"inputs\": [foreign_utxo]})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r823125712",
      "id" : 823125712,
      "in_reply_to_id" : 809858573,
      "line" : 241,
      "node_id" : "PRRC_kwDOABII584xD-bQ",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 241,
      "original_position" : 241,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sendall.py",
      "position" : 241,
      "pull_request_review_id" : 905034919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125712/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-09T21:57:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/823125712",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Sorry if this is confusing, but I've started responding to comments, but haven't finished making all the code changes and rebasing yet (gotta switch devices and didn't want to lose what I've already written).",
      "created_at" : "2022-03-09T22:00:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1063415497",
      "id" : 1063415497,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII584_Ym7J",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1063415497/reactions"
      },
      "updated_at" : "2022-03-09T22:00:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1063415497",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824911936"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824911936"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This RPC will only operate on confirmed spendable UTXOs. It also respects the wallet-wide `avoid_reuse` configuration.\r\n\r\n> * UTXOs that are not yet final or are immature coinbases\r\n\r\nI would expect them to get ignored since they're not spendable at this time.\r\n\r\n> * UTXOs for which the address has been marked as already used\r\n\r\nIf address reuse has been disabled, it should ignore funds on previously used addresses, if it only permits spending all of the funds on one address at once, it should either use all or none, and if it's not restricted, it should just spend either all or the economically viable UTXOs as determined by the options on this RPC.\r\n\r\n> * outputs from replacement transactions\r\n\r\nWe don't spend unconfirmed UTXOs in this call.",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:09:45Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824911936",
      "id" : 824911936,
      "in_reply_to_id" : 810125831,
      "line" : 1332,
      "node_id" : "PRRC_kwDOABII584xKyhA",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1332,
      "original_position" : 236,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 407,
      "pull_request_review_id" : 907499206,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824911936/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:09:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824911936",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824912019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824912019"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Adopted your suggestion.",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:09:51Z",
      "diff_hunk" : "@@ -0,0 +1,10 @@\n+New RPCs\n+--------\n+\n+- The `sendall` RPC spends given UTXOs to one or more receivers\n+  without creating change. By default, the `sendall` RPC will send\n+  everything in the wallet leaving no UTXOs behind. `sendall` is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824912019",
      "id" : 824912019,
      "in_reply_to_id" : 810629932,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKyiT",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 6,
      "original_position" : 6,
      "original_start_line" : 5,
      "path" : "doc/release-notes-24118.md",
      "position" : null,
      "pull_request_review_id" : 907499316,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824912019/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-11T17:09:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824912019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824912927"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824912927"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I will look into this",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:00Z",
      "diff_hunk" : "@@ -50,6 +53,93 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)\n+{\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)\n+{\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err{pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false)};\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\n+    bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex = EncodeHexTx(CTransaction(mtx));\n+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+        result.pushKV(\"txid\", tx->GetHash().GetHex());\n+        if (add_to_wallet && !psbt_opt_in) {\n+            pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+        } else {\n+            result.pushKV(\"hex\", hex);\n+        }\n+    }\n+    result.pushKV(\"complete\", complete);\n+\n+    return result;\n+}\n+\n+static void PreventOutdatedOptions(const UniValue& options)\n+{\n+    if (options.exists(\"feeRate\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n+    }\n+    if (options.exists(\"changeAddress\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n+    }\n+    if (options.exists(\"changePosition\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n+    }\n+    if (options.exists(\"includeWatching\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n+    }\n+    if (options.exists(\"lockUnspents\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n+    }\n+    if (options.exists(\"subtractFeeFromOutputs\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824912927",
      "id" : 824912927,
      "in_reply_to_id" : 815754993,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII584xKywf",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 140,
      "original_position" : 111,
      "original_start_line" : 123,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 111,
      "pull_request_review_id" : 907500533,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824912927/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 123,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-11T17:11:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824912927",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913029"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913029"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:10Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913029",
      "id" : 824913029,
      "in_reply_to_id" : 815803682,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKyyF",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1171,
      "original_position" : 232,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907500689,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913029/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913029",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913135"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913135"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:19Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913135",
      "id" : 824913135,
      "in_reply_to_id" : 815804228,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKyzv",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1274,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907500845,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913135/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913135",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913172"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913172"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:22Z",
      "diff_hunk" : "@@ -50,6 +53,93 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)\n+{\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)\n+{\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err{pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false)};\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\n+    bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex = EncodeHexTx(CTransaction(mtx));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913172",
      "id" : 824913172,
      "in_reply_to_id" : 815804937,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy0U",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 107,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907500919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913172/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913172",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913209"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913209"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:26Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913209",
      "id" : 824913209,
      "in_reply_to_id" : 815805628,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy05",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1264,
      "original_position" : 328,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907500974,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913209/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913285"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913285"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:32Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913285",
      "id" : 824913285,
      "in_reply_to_id" : 815806298,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy2F",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1300,
      "original_position" : 373,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501076,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913285/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913285",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913328"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913328"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:35Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913328",
      "id" : 824913328,
      "in_reply_to_id" : 815806599,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy2w",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1311,
      "original_position" : 386,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501139,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913328/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913328",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913358"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913358"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:39Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913358",
      "id" : 824913358,
      "in_reply_to_id" : 815806892,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy3O",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1324,
      "original_position" : 399,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501186,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913358/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913358",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913436"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913436"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:43Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913436",
      "id" : 824913436,
      "in_reply_to_id" : 815813825,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy4c",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1346,
      "original_position" : 422,
      "original_start_line" : 1344,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913436/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-11T17:11:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913436",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913507"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:48Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913507",
      "id" : 824913507,
      "in_reply_to_id" : 815814412,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy5j",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1370,
      "original_position" : 458,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913576"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913576"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:53Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913576",
      "id" : 824913576,
      "in_reply_to_id" : 815816959,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy6o",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1376,
      "original_position" : 464,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501477,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913576/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913576",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913624"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913624"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Amended",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:11:57Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913624",
      "id" : 824913624,
      "in_reply_to_id" : 815822579,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy7Y",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1189,
      "original_position" : 253,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501559,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913624/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:11:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913624",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913716"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913716"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:12:04Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913716",
      "id" : 824913716,
      "in_reply_to_id" : 815826629,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy80",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1212,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501694,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913716/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:12:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913716",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913772"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913772"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's better, thanks",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:12:08Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824913772",
      "id" : 824913772,
      "in_reply_to_id" : 815827002,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKy9s",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1210,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907501765,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913772/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:12:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824913772",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824914562"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914562"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That sounds like a good idea. Especially getting subsets of a wallet's UTXO pool does seem like a good candidate. I'll consult with my wallet expert on this matter.",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:13:16Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            const bool lock_unspents{options.exists(\"lock_unspents\") ? options[\"lock_unspents\"].get_bool() : false};\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824914562",
      "id" : 824914562,
      "in_reply_to_id" : 810114163,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKzKC",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1401,
      "original_position" : 305,
      "original_start_line" : 1316,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907502989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914562/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-11T17:13:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914562",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824914745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914745"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:13:31Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824914745",
      "id" : 824914745,
      "in_reply_to_id" : 815806023,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKzM5",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1276,
      "original_position" : 340,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907503266,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914745/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:13:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824914817"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914817"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:13:36Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824914817",
      "id" : 824914817,
      "in_reply_to_id" : 815814668,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xKzOB",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1372,
      "original_position" : 460,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907503354,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914817/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:13:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824914817",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Addressed most comments by Sjors, Gloria and stickies-v.\r\n\r\nStill looking into/open for feedback on:\r\n- @sjors's suggestion of overloading recipients parameter to take a single string in the case of a single recipient instead of an array\r\n- The inconsistent bug @Sjors noticed in the  `sendall_fails_on_missing_input` test\r\n- @glozow's suggestion of moving parts of the UTXO filtering into CWallet\r\n- @stickies-v's suggestion to align the error messages\r\n\r\nI've also added another testcase that was authored by @ishaanam.\r\n",
      "created_at" : "2022-03-11T17:20:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1065320790",
      "id" : 1065320790,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII584_f4FW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1065320790/reactions"
      },
      "updated_at" : "2022-03-11T17:21:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1065320790",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824944505"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824944505"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This one actually doesn't like being a brace initialization:\r\n\r\n```\r\nwallet/rpc/spend.cpp: In lambda function:\r\nwallet/rpc/spend.cpp:1371:63: warning: narrowing conversion of â(((long unsigned int)((long int)remainder)) / addresses_without_amount.std::set<std::__cxx11::basic_string<char> >::size())â from âlong unsigned intâ to âCAmountâ {aka âlong intâ} inside { } [-Wnarrowing]\r\n             const CAmount per_output_without_amount{remainder / addresses_without_amount.size()};\r\n                                                     ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n```",
      "commit_id" : "f4352c6735e5863ac5f848fde7df016e630743c0",
      "created_at" : "2022-03-11T17:53:22Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r824944505",
      "id" : 824944505,
      "in_reply_to_id" : 815814412,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xK6d5",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1370,
      "original_position" : 458,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907544932,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824944505/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T17:53:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/824944505",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825010506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825010506"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed by casting the size to `(long)` explicitly.",
      "commit_id" : "93f37c00dda68db8c1acd9f66b00ffc11ddb6a35",
      "created_at" : "2022-03-11T19:27:53Z",
      "diff_hunk" : "@@ -1060,101 +1162,244 @@ RPCHelpMan send()\n             if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n-            if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n-                if (!request.params[1].isNull() || !request.params[2].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"conf_target\", request.params[1]);\n-                options.pushKV(\"estimate_mode\", request.params[2]);\n-            }\n-            if (options.exists(\"fee_rate\")) {\n-                if (!request.params[3].isNull()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n-                }\n-            } else {\n-                options.pushKV(\"fee_rate\", request.params[3]);\n-            }\n-            if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n-            }\n-            if (options.exists(\"feeRate\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n-            }\n-            if (options.exists(\"changeAddress\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n-            }\n-            if (options.exists(\"changePosition\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n-            }\n-            if (options.exists(\"includeWatching\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n-            }\n-            if (options.exists(\"lockUnspents\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n-            }\n-            if (options.exists(\"subtractFeeFromOutputs\")) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n-            }\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n \n-            const bool psbt_opt_in = options.exists(\"psbt\") && options[\"psbt\"].get_bool();\n \n             CAmount fee;\n             int change_position;\n-            bool rbf = pwallet->m_signal_rbf;\n-            if (options.exists(\"replaceable\")) {\n-                rbf = options[\"replaceable\"].get_bool();\n-            }\n+            bool rbf = options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf;\n             CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], request.params[0], options[\"locktime\"], rbf);\n             CCoinControl coin_control;\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825010506",
      "id" : 825010506,
      "in_reply_to_id" : 815814412,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xLKlK",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1370,
      "original_position" : 458,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 907639675,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825010506/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-11T19:27:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825010506",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825825139"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825825139"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 5c0a1b330294d40112af79af19414b913d0dce8c \"Add sendall RPC nÃ©e sweep\"\r\n\r\n```suggestion\r\n        res = hww.sendall(recipients=[{dest:0.5}, hww.getrawchangeaddress()],options={\"add_to_wallet\": False})\r\n```",
      "commit_id" : "93f37c00dda68db8c1acd9f66b00ffc11ddb6a35",
      "created_at" : "2022-03-14T11:01:19Z",
      "diff_hunk" : "@@ -192,6 +192,12 @@ def test_valid_signer(self):\n         assert(res[\"complete\"])\n         assert_equal(res[\"hex\"], mock_tx)\n \n+        self.log.info('Test sendall using hww1')\n+\n+        res = hww.sendall(receivers=[{dest:0.5}, hww.getrawchangeaddress()],options={\"add_to_wallet\": False})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825825139",
      "id" : 825825139,
      "line" : 197,
      "node_id" : "PRRC_kwDOABII584xORdz",
      "original_commit_id" : "5c0a1b330294d40112af79af19414b913d0dce8c",
      "original_line" : 197,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/wallet_signer.py",
      "position" : 6,
      "pull_request_review_id" : 908614636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825825139/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T11:01:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825825139",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825843949"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825843949"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 5c0a1b330294d40112af79af19414b913d0dce8c \"Add sendall RPC nÃ©e sweep\"\r\n\r\n```suggestion\r\n    def add_utxos(self, amounts):\r\n```",
      "commit_id" : "93f37c00dda68db8c1acd9f66b00ffc11ddb6a35",
      "created_at" : "2022-03-14T11:24:43Z",
      "diff_hunk" : "@@ -0,0 +1,286 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825843949",
      "id" : 825843949,
      "line" : 53,
      "node_id" : "PRRC_kwDOABII584xOWDt",
      "original_commit_id" : "5c0a1b330294d40112af79af19414b913d0dce8c",
      "original_line" : 53,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sendall.py",
      "position" : 53,
      "pull_request_review_id" : 908640286,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825843949/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T11:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825843949",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825859044"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825859044"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The issue is that `foreign_utxo` might be the change output for a transaction that funded the test wallet. Because the transaction has something belonging to the test wallet, the test wallet knows the transaction and does not detect it to be foreign. I will add a suggestion at the relevant line to fix this issue.",
      "commit_id" : "93f37c00dda68db8c1acd9f66b00ffc11ddb6a35",
      "created_at" : "2022-03-14T11:44:12Z",
      "diff_hunk" : "@@ -0,0 +1,286 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        return self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+    # Helper schema for success cases\n+    def test_sendall_success(self, sendall_args, remaining_balance = 0):\n+        sendall_tx_receipt = self.wallet.sendall(sendall_args)\n+        self.generate(self.nodes[0], 1)\n+        # wallet has remaining balance (usually empty)\n+        assert_equal(remaining_balance, self.wallet.getbalances()[\"mine\"][\"trusted\"])\n+\n+        assert_equal(sendall_tx_receipt[\"complete\"], True)\n+        return self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+    @cleanup\n+    def gen_and_clean(self):\n+        self.add_uxtos([15, 2, 4])\n+\n+    def test_cleanup(self):\n+        self.log.info(\"Test that cleanup wrapper empties wallet\")\n+        self.gen_and_clean()\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    # Actual tests\n+    @cleanup\n+    def sendall_two_utxos(self):\n+        self.log.info(\"Testing basic sendall case without specific amounts\")\n+        pre_sendall_balance = self.add_uxtos([10,11])\n+        tx_from_wallet = self.test_sendall_success(sendall_args = [self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx = tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance + tx_from_wallet[\"fee\"] } # fee is neg\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_split(self):\n+        self.log.info(\"Testing sendall where two recipients have unspecified amount\")\n+        pre_sendall_balance = self.add_uxtos([1, 2, 3, 15])\n+        tx_from_wallet = self.test_sendall_success([self.remainder_target, self.split_target])\n+\n+        half = (pre_sendall_balance + tx_from_wallet[\"fee\"]) / 2\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.split_target, \"value\": half },\n+                { \"address\": self.remainder_target, \"value\": half }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_and_spend(self):\n+        self.log.info(\"Testing sendall in combination with paying specified amount to recipient\")\n+        pre_sendall_balance = self.add_uxtos([8, 13])\n+        tx_from_wallet = self.test_sendall_success([{self.recipient: 5}, self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.recipient, \"value\": 5 },\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance - 5 + tx_from_wallet[\"fee\"] }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_invalid_receiver_addresses(self):\n+        self.log.info(\"Test having only receiver with specified amount, missing receiver with unspecified amount\")\n+        self.add_uxtos([12, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Must provide at least one address without a specified amount\" ,\n+                self.wallet.sendall,\n+                [{self.recipient: 5}]\n+            )\n+\n+    @cleanup\n+    def sendall_duplicate_receiver(self):\n+        self.log.info(\"Test duplicate destination\")\n+        self.add_uxtos([1, 8, 3, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Invalid parameter, duplicated address: {}\".format(self.remainder_target),\n+                self.wallet.sendall,\n+                [self.remainder_target, self.remainder_target]\n+            )\n+\n+    @cleanup\n+    def sendall_invalid_amounts(self):\n+        self.log.info(\"Test sending more than balance\")\n+        pre_sendall_balance = self.add_uxtos([7, 14])\n+\n+        expected_tx = self.wallet.sendall(receivers=[{self.recipient: 5}, self.remainder_target], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance + 1}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance}, self.remainder_target])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.recipient),\n+                self.wallet.sendall, [{self.recipient: 0.00000001}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee - Decimal(0.00000010)}, self.remainder_target])\n+\n+    # @cleanup not needed because different wallet used\n+    def sendall_negative_effective_value(self):\n+        self.log.info(\"Test that sendall fails if all UTXOs have negative effective value\")\n+        # Use dedicated wallet for dust amounts and unload wallet at end\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for transaction.\"\n+                + \" Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\",\n+                dust_wallet.sendall, receivers=[self.remainder_target], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    @cleanup\n+    def sendall_with_send_max(self):\n+        self.log.info(\"Check that `send_max` option causes negative value UTXOs to be left behind\")\n+        self.add_uxtos([0.00000400, 0.00000300, 1])\n+\n+        # sendall with send_max\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], fee_rate=300, options={\"send_max\": True})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        self.assert_tx_has_outputs(tx_from_wallet, [{\"address\": self.remainder_target, \"value\": 1 + tx_from_wallet[\"fee\"]}])\n+        assert_equal(self.wallet.getbalances()[\"mine\"][\"trusted\"], Decimal(\"0.00000700\"))\n+\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+    @cleanup\n+    def sendall_specific_inputs(self):\n+        self.log.info(\"Test sendall with a subset of UTXO pool\")\n+        self.add_uxtos([17, 4])\n+        utxo = self.wallet.listunspent()[0]\n+\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], options={\"inputs\": [utxo]})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"txid\"], utxo[\"txid\"])\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"vout\"], utxo[\"vout\"])\n+        self.assert_tx_has_output(tx_from_wallet, self.remainder_target)\n+\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    @cleanup\n+    def sendall_fails_on_missing_input(self):\n+        # fails because UTXO was previously spent, and wallet is empty\n+        self.log.info(\"Test sendall fails because specified UTXO is not available\")\n+        self.add_uxtos([16, 5])\n+        spent_utxo = self.wallet.listunspent()[0]\n+\n+        # fails on unconfirmed spent UTXO\n+        self.wallet.sendall(receivers=[self.remainder_target])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails on specific previously spent UTXO, while other UTXOs exist\n+        self.generate(self.nodes[0], 1)\n+        self.add_uxtos([19, 2])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails because UTXO is unknown, while other UTXOs exist\n+        foreign_utxo = self.def_wallet.listunspent()[0]\n+        assert_raises_rpc_error(-8, \"Input not found. UTXO ({}:{}) is not part of wallet.\".format(foreign_utxo[\"txid\"],\n+            foreign_utxo[\"vout\"]), self.wallet.sendall, receivers=[self.remainder_target],\n+            options={\"inputs\": [foreign_utxo]})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825859044",
      "id" : 825859044,
      "in_reply_to_id" : 809858573,
      "line" : 241,
      "node_id" : "PRRC_kwDOABII584xOZvk",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 241,
      "original_position" : 241,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sendall.py",
      "position" : 241,
      "pull_request_review_id" : 908660947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825859044/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T11:44:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825859044",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825864503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825864503"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We may accidentally allow an external UTXO here if the transaction had both outputs that belonged to us, and outputs that did not. So we should check that the specified output itself actually belongs to this wallet.\r\n\r\n```suggestion\r\n                    if (!tx || pwallet->IsMine(tx->tx->vout[input.prevout.n]) != ISMINE_SPENDABLE | (coin_control.fAllowWatchOnly ? ISMINE_WATCHONLY : 0)) {\r\n```\r\n\r\n(Did not test it, but something similar to that should work. The output needs to be in the wallet, and we should also respect `coin_control.fAllowWatchonly`)\r\n\r\nFixes https://github.com/bitcoin/bitcoin/pull/24118/commits/5c0a1b330294d40112af79af19414b913d0dce8c#r809858573",
      "commit_id" : "93f37c00dda68db8c1acd9f66b00ffc11ddb6a35",
      "created_at" : "2022-03-14T11:51:11Z",
      "diff_hunk" : "@@ -1168,6 +1181,230 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx{pwallet->GetWalletTx(input.prevout.hash)};\n+                    if (!tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r825864503",
      "id" : 825864503,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII584xObE3",
      "original_commit_id" : "5c0a1b330294d40112af79af19414b913d0dce8c",
      "original_line" : 1326,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 240,
      "pull_request_review_id" : 908668374,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825864503/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T11:51:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/825864503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021533"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021533"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, fixed working from achow101's suggestion",
      "commit_id" : "76196e5e8f9d7aa8835997598a743d27d1564952",
      "created_at" : "2022-03-14T14:39:07Z",
      "diff_hunk" : "@@ -0,0 +1,286 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):\n+        for a in amounts:\n+            self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), a)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        return self.wallet.getbalances()[\"mine\"][\"trusted\"]\n+\n+    # Helper schema for success cases\n+    def test_sendall_success(self, sendall_args, remaining_balance = 0):\n+        sendall_tx_receipt = self.wallet.sendall(sendall_args)\n+        self.generate(self.nodes[0], 1)\n+        # wallet has remaining balance (usually empty)\n+        assert_equal(remaining_balance, self.wallet.getbalances()[\"mine\"][\"trusted\"])\n+\n+        assert_equal(sendall_tx_receipt[\"complete\"], True)\n+        return self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+    @cleanup\n+    def gen_and_clean(self):\n+        self.add_uxtos([15, 2, 4])\n+\n+    def test_cleanup(self):\n+        self.log.info(\"Test that cleanup wrapper empties wallet\")\n+        self.gen_and_clean()\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    # Actual tests\n+    @cleanup\n+    def sendall_two_utxos(self):\n+        self.log.info(\"Testing basic sendall case without specific amounts\")\n+        pre_sendall_balance = self.add_uxtos([10,11])\n+        tx_from_wallet = self.test_sendall_success(sendall_args = [self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx = tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance + tx_from_wallet[\"fee\"] } # fee is neg\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_split(self):\n+        self.log.info(\"Testing sendall where two recipients have unspecified amount\")\n+        pre_sendall_balance = self.add_uxtos([1, 2, 3, 15])\n+        tx_from_wallet = self.test_sendall_success([self.remainder_target, self.split_target])\n+\n+        half = (pre_sendall_balance + tx_from_wallet[\"fee\"]) / 2\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.split_target, \"value\": half },\n+                { \"address\": self.remainder_target, \"value\": half }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_and_spend(self):\n+        self.log.info(\"Testing sendall in combination with paying specified amount to recipient\")\n+        pre_sendall_balance = self.add_uxtos([8, 13])\n+        tx_from_wallet = self.test_sendall_success([{self.recipient: 5}, self.remainder_target])\n+\n+        self.assert_tx_has_outputs(tx_from_wallet,\n+            expected_outputs = [\n+                { \"address\": self.recipient, \"value\": 5 },\n+                { \"address\": self.remainder_target, \"value\": pre_sendall_balance - 5 + tx_from_wallet[\"fee\"] }\n+            ]\n+        )\n+        self.assert_balance_swept_completely(tx_from_wallet, pre_sendall_balance)\n+\n+    @cleanup\n+    def sendall_invalid_receiver_addresses(self):\n+        self.log.info(\"Test having only receiver with specified amount, missing receiver with unspecified amount\")\n+        self.add_uxtos([12, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Must provide at least one address without a specified amount\" ,\n+                self.wallet.sendall,\n+                [{self.recipient: 5}]\n+            )\n+\n+    @cleanup\n+    def sendall_duplicate_receiver(self):\n+        self.log.info(\"Test duplicate destination\")\n+        self.add_uxtos([1, 8, 3, 9])\n+\n+        assert_raises_rpc_error(\n+                -8,\n+                \"Invalid parameter, duplicated address: {}\".format(self.remainder_target),\n+                self.wallet.sendall,\n+                [self.remainder_target, self.remainder_target]\n+            )\n+\n+    @cleanup\n+    def sendall_invalid_amounts(self):\n+        self.log.info(\"Test sending more than balance\")\n+        pre_sendall_balance = self.add_uxtos([7, 14])\n+\n+        expected_tx = self.wallet.sendall(receivers=[{self.recipient: 5}, self.remainder_target], options={\"add_to_wallet\": False})\n+        tx = self.wallet.decoderawtransaction(expected_tx['hex'])\n+        fee = 21 - sum([o[\"value\"] for o in tx[\"vout\"]])\n+\n+        assert_raises_rpc_error(-8, \"Assigned more value to outputs than available funds.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance + 1}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Insufficient funds for fees after creating specified outputs.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance}, self.remainder_target])\n+        assert_raises_rpc_error(-8, \"Specified output amount to {} is below dust threshold\".format(self.recipient),\n+                self.wallet.sendall, [{self.recipient: 0.00000001}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee}, self.remainder_target])\n+        assert_raises_rpc_error(-6, \"Dynamically assigned remainder results in dust output.\", self.wallet.sendall,\n+                [{self.recipient: pre_sendall_balance - fee - Decimal(0.00000010)}, self.remainder_target])\n+\n+    # @cleanup not needed because different wallet used\n+    def sendall_negative_effective_value(self):\n+        self.log.info(\"Test that sendall fails if all UTXOs have negative effective value\")\n+        # Use dedicated wallet for dust amounts and unload wallet at end\n+        self.nodes[0].createwallet(\"dustwallet\")\n+        dust_wallet = self.nodes[0].get_wallet_rpc(\"dustwallet\")\n+\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000400)\n+        self.def_wallet.sendtoaddress(dust_wallet.getnewaddress(), 0.00000300)\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(dust_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+        assert_raises_rpc_error(-6, \"Total value of UTXO pool too low to pay for transaction.\"\n+                + \" Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\",\n+                dust_wallet.sendall, receivers=[self.remainder_target], fee_rate=300)\n+\n+        dust_wallet.unloadwallet()\n+\n+    @cleanup\n+    def sendall_with_send_max(self):\n+        self.log.info(\"Check that `send_max` option causes negative value UTXOs to be left behind\")\n+        self.add_uxtos([0.00000400, 0.00000300, 1])\n+\n+        # sendall with send_max\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], fee_rate=300, options={\"send_max\": True})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        self.assert_tx_has_outputs(tx_from_wallet, [{\"address\": self.remainder_target, \"value\": 1 + tx_from_wallet[\"fee\"]}])\n+        assert_equal(self.wallet.getbalances()[\"mine\"][\"trusted\"], Decimal(\"0.00000700\"))\n+\n+        self.def_wallet.sendtoaddress(self.wallet.getnewaddress(), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+    @cleanup\n+    def sendall_specific_inputs(self):\n+        self.log.info(\"Test sendall with a subset of UTXO pool\")\n+        self.add_uxtos([17, 4])\n+        utxo = self.wallet.listunspent()[0]\n+\n+        sendall_tx_receipt = self.wallet.sendall(receivers=[self.remainder_target], options={\"inputs\": [utxo]})\n+        tx_from_wallet = self.wallet.gettransaction(txid = sendall_tx_receipt[\"txid\"], verbose = True)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vin\"]), 1)\n+        assert_equal(len(tx_from_wallet[\"decoded\"][\"vout\"]), 1)\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"txid\"], utxo[\"txid\"])\n+        assert_equal(tx_from_wallet[\"decoded\"][\"vin\"][0][\"vout\"], utxo[\"vout\"])\n+        self.assert_tx_has_output(tx_from_wallet, self.remainder_target)\n+\n+        self.generate(self.nodes[0], 1)\n+        assert_greater_than(self.wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+\n+    @cleanup\n+    def sendall_fails_on_missing_input(self):\n+        # fails because UTXO was previously spent, and wallet is empty\n+        self.log.info(\"Test sendall fails because specified UTXO is not available\")\n+        self.add_uxtos([16, 5])\n+        spent_utxo = self.wallet.listunspent()[0]\n+\n+        # fails on unconfirmed spent UTXO\n+        self.wallet.sendall(receivers=[self.remainder_target])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails on specific previously spent UTXO, while other UTXOs exist\n+        self.generate(self.nodes[0], 1)\n+        self.add_uxtos([19, 2])\n+        assert_raises_rpc_error(-8,\n+                \"Input not available. UTXO ({}:{}) was already spent.\".format(spent_utxo[\"txid\"], spent_utxo[\"vout\"]),\n+                self.wallet.sendall, receivers=[self.remainder_target], options={\"inputs\": [spent_utxo]})\n+\n+        # fails because UTXO is unknown, while other UTXOs exist\n+        foreign_utxo = self.def_wallet.listunspent()[0]\n+        assert_raises_rpc_error(-8, \"Input not found. UTXO ({}:{}) is not part of wallet.\".format(foreign_utxo[\"txid\"],\n+            foreign_utxo[\"vout\"]), self.wallet.sendall, receivers=[self.remainder_target],\n+            options={\"inputs\": [foreign_utxo]})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021533",
      "id" : 826021533,
      "in_reply_to_id" : 809858573,
      "line" : 241,
      "node_id" : "PRRC_kwDOABII584xPBad",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 241,
      "original_position" : 241,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sendall.py",
      "position" : 241,
      "pull_request_review_id" : 908896032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021533/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T14:39:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021533",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021647"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Amended all the error messages to fully explain the issue as in the `fee_rate`. Added the change as a separate commit.",
      "commit_id" : "76196e5e8f9d7aa8835997598a743d27d1564952",
      "created_at" : "2022-03-14T14:39:12Z",
      "diff_hunk" : "@@ -50,6 +53,93 @@ static void ParseRecipients(const UniValue& address_amounts, const UniValue& sub\n     }\n }\n \n+static void ParseFeeEstimationInstructions(const UniValue& positional_conf_target, const UniValue& positional_estimate_mode, const UniValue& positional_fee_rate, UniValue& options)\n+{\n+    if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n+        if (!positional_conf_target.isNull() || !positional_estimate_mode.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass conf_target and estimate_mode either as arguments or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"conf_target\", positional_conf_target);\n+        options.pushKV(\"estimate_mode\", positional_estimate_mode);\n+    }\n+    if (options.exists(\"fee_rate\")) {\n+        if (!positional_fee_rate.isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Pass the fee_rate either as an argument, or in the options object, but not both\");\n+        }\n+    } else {\n+        options.pushKV(\"fee_rate\", positional_fee_rate);\n+    }\n+    if (!options[\"conf_target\"].isNull() && (options[\"estimate_mode\"].isNull() || (options[\"estimate_mode\"].get_str() == \"unset\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Specify estimate_mode\");\n+    }\n+}\n+\n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)\n+{\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err{pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false)};\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\n+    bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex = EncodeHexTx(CTransaction(mtx));\n+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+        result.pushKV(\"txid\", tx->GetHash().GetHex());\n+        if (add_to_wallet && !psbt_opt_in) {\n+            pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+        } else {\n+            result.pushKV(\"hex\", hex);\n+        }\n+    }\n+    result.pushKV(\"complete\", complete);\n+\n+    return result;\n+}\n+\n+static void PreventOutdatedOptions(const UniValue& options)\n+{\n+    if (options.exists(\"feeRate\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use fee_rate (\" + CURRENCY_ATOM + \"/vB) instead of feeRate\");\n+    }\n+    if (options.exists(\"changeAddress\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_address\");\n+    }\n+    if (options.exists(\"changePosition\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use change_position\");\n+    }\n+    if (options.exists(\"includeWatching\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use include_watching\");\n+    }\n+    if (options.exists(\"lockUnspents\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use lock_unspents\");\n+    }\n+    if (options.exists(\"subtractFeeFromOutputs\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Use subtract_fee_from_outputs\");\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021647",
      "id" : 826021647,
      "in_reply_to_id" : 815754993,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xPBcP",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 141,
      "original_position" : 111,
      "original_start_line" : 123,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 908896192,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021647/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-14T14:39:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021647",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021747"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021747"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed, thank you",
      "commit_id" : "76196e5e8f9d7aa8835997598a743d27d1564952",
      "created_at" : "2022-03-14T14:39:18Z",
      "diff_hunk" : "@@ -192,6 +192,12 @@ def test_valid_signer(self):\n         assert(res[\"complete\"])\n         assert_equal(res[\"hex\"], mock_tx)\n \n+        self.log.info('Test sendall using hww1')\n+\n+        res = hww.sendall(receivers=[{dest:0.5}, hww.getrawchangeaddress()],options={\"add_to_wallet\": False})",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021747",
      "id" : 826021747,
      "in_reply_to_id" : 825825139,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xPBdz",
      "original_commit_id" : "5c0a1b330294d40112af79af19414b913d0dce8c",
      "original_line" : 197,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/wallet_signer.py",
      "position" : null,
      "pull_request_review_id" : 908896334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021747/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T14:39:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021747",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021858"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed everywhere, thanks",
      "commit_id" : "76196e5e8f9d7aa8835997598a743d27d1564952",
      "created_at" : "2022-03-14T14:39:23Z",
      "diff_hunk" : "@@ -0,0 +1,286 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the sendall RPC command.\"\"\"\n+\n+from decimal import Decimal, getcontext\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_raises_rpc_error,\n+)\n+\n+# Decorator to reset activewallet to zero utxos\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            if 0 < self.wallet.getbalances()[\"mine\"][\"trusted\"]:\n+                self.wallet.sendall([self.remainder_target])\n+            assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+    return wrapper\n+\n+class SendallTest(BitcoinTestFramework):\n+    # Setup and helpers\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        getcontext().prec=10\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def assert_balance_swept_completely(self, tx, balance):\n+        output_sum = sum([o[\"value\"] for o in tx[\"decoded\"][\"vout\"]])\n+        assert_equal(output_sum, balance + tx[\"fee\"])\n+        assert_equal(0, self.wallet.getbalances()[\"mine\"][\"trusted\"]) # wallet is empty\n+\n+    def assert_tx_has_output(self, tx, addr, value=None):\n+        for output in tx[\"decoded\"][\"vout\"]:\n+            if addr == output[\"scriptPubKey\"][\"address\"] and value is None or value == output[\"value\"]:\n+                return\n+        raise AssertionError(\"Output to {} not present or wrong amount\".format(addr))\n+\n+    def assert_tx_has_outputs(self, tx, expected_outputs):\n+        assert_equal(len(expected_outputs), len(tx[\"decoded\"][\"vout\"]))\n+        for eo in expected_outputs:\n+            self.assert_tx_has_output(tx, eo[\"address\"], eo[\"value\"])\n+\n+    def add_uxtos(self, amounts):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021858",
      "id" : 826021858,
      "in_reply_to_id" : 825843949,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xPBfi",
      "original_commit_id" : "5c0a1b330294d40112af79af19414b913d0dce8c",
      "original_line" : 53,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "test/functional/wallet_sendall.py",
      "position" : null,
      "pull_request_review_id" : 908896483,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021858/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T14:39:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021858",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021946"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021946"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks! I've used \r\n`if (!tx || pwallet->IsMine(tx->tx->vout[input.prevout.n]) != (coin_control.fAllowWatchOnly ? ISMINE_ALL : ISMINE_SPENDABLE))`",
      "commit_id" : "76196e5e8f9d7aa8835997598a743d27d1564952",
      "created_at" : "2022-03-14T14:39:29Z",
      "diff_hunk" : "@@ -1168,6 +1181,230 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx{pwallet->GetWalletTx(input.prevout.hash)};\n+                    if (!tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r826021946",
      "id" : 826021946,
      "in_reply_to_id" : 825864503,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xPBg6",
      "original_commit_id" : "5c0a1b330294d40112af79af19414b913d0dce8c",
      "original_line" : 1326,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 908896632,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021946/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-14T14:39:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/826021946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Addressed review comments from @achow101, fixed the bug that @Sjors discovered, enacted the suggestion of @stickies-v to update the remaining error messages for outdated options to be more helpful.\r\n\r\nStill open for comments on:\r\n- @sjors's suggestion of overloading recipients parameter to take a single string in the case of a single recipient instead of an array\r\n- @glozow's suggestion of moving parts of the UTXO filtering into CWallet",
      "created_at" : "2022-03-14T14:41:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1066884958",
      "id" : 1066884958,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII584_l19e",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1066884958/reactions"
      },
      "updated_at" : "2022-03-16T01:32:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1066884958",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Added a second test provided by @ishaanam. Thanks!",
      "created_at" : "2022-03-16T01:29:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1068632419",
      "id" : 1068632419,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII584_sglj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1068632419/reactions"
      },
      "updated_at" : "2022-03-16T01:29:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1068632419",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r828048955"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828048955"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In the first help example, use [...] instead of {..} for a valid json array.",
      "commit_id" : "e71b03a3c814aa6c0dcbf76bf1abb78e7d33b82d",
      "created_at" : "2022-03-16T14:04:46Z",
      "diff_hunk" : "@@ -1235,6 +1248,230 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r828048955",
      "id" : 828048955,
      "line" : 1311,
      "node_id" : "PRRC_kwDOABII584xWwY7",
      "original_commit_id" : "cab7a4bf86dbce605de9cd6ab1388158a79a5937",
      "original_line" : 1311,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 158,
      "pull_request_review_id" : 911687175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828048955/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-16T14:20:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828048955",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r828059316"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828059316"
         }
      },
      "author_association" : "NONE",
      "body" : "That works for me, although I don't think \"from a specific amount\" is grammatically correct, I think that should be \"of a specific amount\".",
      "commit_id" : "e71b03a3c814aa6c0dcbf76bf1abb78e7d33b82d",
      "created_at" : "2022-03-16T14:14:11Z",
      "diff_hunk" : "@@ -0,0 +1,10 @@\n+New RPCs\n+--------\n+\n+- The `sendall` RPC spends given UTXOs to one or more receivers\n+  without creating change. By default, the `sendall` RPC will send\n+  everything in the wallet leaving no UTXOs behind. `sendall` is\n+  useful to empty wallets or to create a changeless payment from select\n+  UTXOs. Continue to use the \"subtract fee from output\" option to create\n+  transactions delimited via a budget (in contrast to a concrete set of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r828059316",
      "id" : 828059316,
      "in_reply_to_id" : 809797621,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xWy60",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "doc/release-notes-24118.md",
      "position" : null,
      "pull_request_review_id" : 911702154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828059316/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-16T14:14:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828059316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69010457?v=4",
         "events_url" : "https://api.github.com/users/stickies-v/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stickies-v/followers",
         "following_url" : "https://api.github.com/users/stickies-v/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stickies-v/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stickies-v",
         "id" : 69010457,
         "login" : "stickies-v",
         "node_id" : "MDQ6VXNlcjY5MDEwNDU3",
         "organizations_url" : "https://api.github.com/users/stickies-v/orgs",
         "received_events_url" : "https://api.github.com/users/stickies-v/received_events",
         "repos_url" : "https://api.github.com/users/stickies-v/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stickies-v/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stickies-v/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stickies-v"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r828204508"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828204508"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thank you, fixed",
      "commit_id" : "08be21737e1b38a8171ca216c18a7bbf94511c49",
      "created_at" : "2022-03-16T16:17:03Z",
      "diff_hunk" : "@@ -1235,6 +1248,230 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r828204508",
      "id" : 828204508,
      "in_reply_to_id" : 828048955,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xXWXc",
      "original_commit_id" : "cab7a4bf86dbce605de9cd6ab1388158a79a5937",
      "original_line" : 1311,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 911921606,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828204508/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-16T16:17:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828204508",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 08be21737e1b38a8171ca216c18a7bbf94511c49",
      "created_at" : "2022-03-23T19:18:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1076730403",
      "id" : 1076730403,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585ALZoj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1076730403/reactions"
      },
      "updated_at" : "2022-03-23T19:18:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1076730403",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needs rebase?",
      "created_at" : "2022-03-25T08:51:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1078793283",
      "id" : 1078793283,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585ATRRD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1078793283/reactions"
      },
      "updated_at" : "2022-03-25T08:51:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1078793283",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Needs rebase?\r\n\r\nYes, there's a silent merge conflict.",
      "created_at" : "2022-03-25T14:49:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1079101011",
      "id" : 1079101011,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585AUcZT",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1079101011/reactions"
      },
      "updated_at" : "2022-03-25T14:49:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1079101011",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased to master due to silent merge conflict.",
      "created_at" : "2022-03-25T15:45:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1079155870",
      "id" : 1079155870,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585AUpye",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1079155870/reactions"
      },
      "updated_at" : "2022-03-25T15:45:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1079155870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r835408565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835408565"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think some things like unspent locking could be refactored further, but the bulk of this PR is new code rather than copied from somewhere else. There isn't much here that I think can be reused elsewhere.\r\n\r\nw.r.t getting a subset of the UTXO pool, it doesn't make sense for this to be part of `AvailableCoins` as that function is used for more than transaction creation. Not all situations where ti is used have access to information such as feerates.",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-25T16:01:51Z",
      "diff_hunk" : "@@ -1168,6 +1181,229 @@ RPCHelpMan send()\n     };\n }\n \n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the wallet flag for avoid_reuse.\\n\",\n+        {\n+            {\"receivers\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some receivers can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns a serialized transaction which will not be added to the wallet or broadcast\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='{\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"}' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"receivers='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // receivers\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            ParseFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue receiver_key_value_pairs(UniValue::VARR);\n+            const UniValue& receivers = request.params[0];\n+            for (unsigned int i = 0; i < receivers.size(); ++i) {\n+                const UniValue& receiver = receivers[i];\n+                if (receiver.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(receiver.get_str(), 0);\n+                    receiver_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(receiver.get_str());\n+                } else {\n+                    receiver_key_value_pairs.push_back(receiver);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n+            }\n+\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n+\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate = GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out);\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n+            }\n+\n+            CMutableTransaction rawTx = ConstructTransaction(options[\"inputs\"], receiver_key_value_pairs, options[\"locktime\"], rbf);\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx = pwallet->GetWalletTx(input.prevout.hash);\n+                    if (!tx) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.nInputBytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.nInputBytes) > output.tx->tx->vout[output.i].nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.tx->GetHash(), output.i, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.tx->tx->vout[output.i].nValue;\n+                }\n+            }\n+\n+            // estimate final size of tx\n+            TxSize tx_size = CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get());\n+            CAmount fee_from_size = fee_rate.GetFee(tx_size.vsize);\n+            CAmount effective_value = total_input_value - fee_from_size;\n+\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n+            }\n+\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }\n+\n+            const CAmount per_output_without_amount = remainder / addresses_without_amount.size();\n+\n+            bool gave_remaining_to_first = false;\n+            for (CTxOut& out : rawTx.vout) {\n+                CTxDestination dest;\n+                ExtractDestination(out.scriptPubKey, dest);\n+                std::string addr = EncodeDestination(dest);\n+                if (addresses_without_amount.count(addr) > 0) {\n+                    out.nValue = per_output_without_amount;\n+                    if (!gave_remaining_to_first) {\n+                        out.nValue += remainder % addresses_without_amount.size();\n+                        gave_remaining_to_first = true;\n+                    }\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Dynamically generated output amount is dust\n+                        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Dynamically assigned remainder results in dust output.\");\n+                    }\n+                } else {\n+                    if (IsDust(out, pwallet->chain().relayDustFee())) {\n+                        // Specified output amount is dust\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Specified output amount to %s is below dust threshold.\", addr));\n+                    }\n+                }\n+            }\n+\n+            const bool lock_unspents{options.exists(\"lock_unspents\") ? options[\"lock_unspents\"].get_bool() : false};\n+            if (lock_unspents) {\n+                for (const CTxIn& txin : rawTx.vin) {\n+                    pwallet->LockCoin(txin.prevout);\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r835408565",
      "id" : 835408565,
      "in_reply_to_id" : 810114163,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xy1K1",
      "original_commit_id" : "9bda5234bc41b7477b0224930177c6dfcd8cb9fc",
      "original_line" : 1468,
      "original_position" : 305,
      "original_start_line" : 1316,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 921849137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835408565/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-25T16:05:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835408565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK 78aab643af1c1afbaf82e1269b55a617f7fda6f6\r\n\r\nChanges since last were just the rebase to resolving the silent merge conflict with renaming variables.",
      "created_at" : "2022-03-25T16:11:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1079179455",
      "id" : 1079179455,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585AUvi_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1079179455/reactions"
      },
      "updated_at" : "2022-03-25T16:11:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1079179455",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sjors @stickies-v @glozow re-review this?",
      "created_at" : "2022-03-28T14:28:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1080727453",
      "id" : 1080727453,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585Aaped",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 2,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1080727453/reactions"
      },
      "updated_at" : "2022-03-28T14:28:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1080727453",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836667051"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836667051"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in 35ed094e4b0e0554e609709f6ca1f7d17096882c since you're touching\r\n```suggestion\r\nstatic void ParseRecipients(const UniValue& address_amounts, const UniValue& subtract_fee_outputs, std::vector<CRecipient>& recipients)\r\n```",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-28T17:18:55Z",
      "diff_hunk" : "@@ -21,7 +21,8 @@\n \n \n namespace wallet {\n-static void ParseRecipients(const UniValue& address_amounts, const UniValue& subtract_fee_outputs, std::vector<CRecipient> &recipients) {\n+static void ParseRecipients(const UniValue& address_amounts, const UniValue& subtract_fee_outputs, std::vector<CRecipient> &recipients)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836667051",
      "id" : 836667051,
      "line" : 26,
      "node_id" : "PRRC_kwDOABII584x3oar",
      "original_commit_id" : "35ed094e4b0e0554e609709f6ca1f7d17096882c",
      "original_line" : 24,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 5,
      "pull_request_review_id" : 923487940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836667051/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-28T18:34:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836667051",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836678721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836678721"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in 902793c7772e5bdd5aae5b0d20a32c02a1a6dc7c (for clang-tidy, see https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#coding-style-c-named-arguments)\r\n\r\n```suggestion\r\n            pwallet->CommitTransaction(tx, {}, /*orderForm=*/ {});\r\n```\r\n\r\n",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-28T17:32:59Z",
      "diff_hunk" : "@@ -74,6 +74,50 @@ static void InterpretFeeEstimationInstructions(const UniValue& conf_target, cons\n     }\n }\n \n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)\n+{\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err{pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false)};\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\n+    bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex{EncodeHexTx(CTransaction(mtx))};\n+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+        result.pushKV(\"txid\", tx->GetHash().GetHex());\n+        if (add_to_wallet && !psbt_opt_in) {\n+            pwallet->CommitTransaction(tx, {}, {} /* orderForm */);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836678721",
      "id" : 836678721,
      "line" : 112,
      "node_id" : "PRRC_kwDOABII584x3rRB",
      "original_commit_id" : "902793c7772e5bdd5aae5b0d20a32c02a1a6dc7c",
      "original_line" : 111,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 38,
      "pull_request_review_id" : 923487940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836678721/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-28T18:34:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836678721",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836701319"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836701319"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in 3813ba1b196f8dd89de1f8b959c179dd28c05d4e: would prefer to not have default values",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-28T17:57:09Z",
      "diff_hunk" : "@@ -449,31 +450,43 @@ RPCHelpMan settxfee()\n \n \n // Only includes key documentation where the key is snake_case in all RPC methods. MixedCase keys can be added later.\n-static std::vector<RPCArg> FundTxDoc()\n+static std::vector<RPCArg> FundTxDoc(bool solving_data = true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836701319",
      "id" : 836701319,
      "line" : 453,
      "node_id" : "PRRC_kwDOABII584x3wyH",
      "original_commit_id" : "3813ba1b196f8dd89de1f8b959c179dd28c05d4e",
      "original_line" : 453,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 26,
      "pull_request_review_id" : 923487940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836701319/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-28T18:34:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836701319",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836712508"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836712508"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in 3813ba1b196f8dd89de1f8b959c179dd28c05d4e\r\n\r\n```suggestion\r\n            const TxSize tx_size{CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get())};\r\n            const CAmount fee_from_size{fee_rate.GetFee(tx_size.vsize)};\r\n            const CAmount effective_value{total_input_value - fee_from_size};\r\n```",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-28T18:11:40Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx{pwallet->GetWalletTx(input.prevout.hash)};\n+                    if (!tx || pwallet->IsMine(tx->tx->vout[input.prevout.n]) != (coin_control.fAllowWatchOnly ? ISMINE_ALL : ISMINE_SPENDABLE)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.input_bytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.input_bytes) > output.txout.nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.outpoint.hash, output.outpoint.n, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.txout.nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size{CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get())};\n+            CAmount fee_from_size{fee_rate.GetFee(tx_size.vsize)};\n+            CAmount effective_value{total_input_value - fee_from_size};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836712508",
      "id" : 836712508,
      "line" : 1414,
      "node_id" : "PRRC_kwDOABII584x3zg8",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1414,
      "original_position" : 423,
      "original_start_line" : 1412,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 423,
      "pull_request_review_id" : 923487940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836712508/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1412,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-28T18:34:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836712508",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836713923"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836713923"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in 3813ba1b196f8dd89de1f8b959c179dd28c05d4e\r\n```suggestion\r\n            const bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\r\n```",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-28T18:12:47Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836713923",
      "id" : 836713923,
      "line" : 1384,
      "node_id" : "PRRC_kwDOABII584x3z3D",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1384,
      "original_position" : 392,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 392,
      "pull_request_review_id" : 923487940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836713923/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-28T18:34:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836713923",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836720064"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836720064"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What makes one of these `RPC_INVALID_PARAMETER` and the other `RPC_WALLET_INSUFFICIENT_FUNDS` ?",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-28T18:19:40Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx{pwallet->GetWalletTx(input.prevout.hash)};\n+                    if (!tx || pwallet->IsMine(tx->tx->vout[input.prevout.n]) != (coin_control.fAllowWatchOnly ? ISMINE_ALL : ISMINE_SPENDABLE)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.input_bytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.input_bytes) > output.txout.nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.outpoint.hash, output.outpoint.n, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.txout.nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size{CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get())};\n+            CAmount fee_from_size{fee_rate.GetFee(tx_size.vsize)};\n+            CAmount effective_value{total_input_value - fee_from_size};\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836720064",
      "id" : 836720064,
      "line" : 1436,
      "node_id" : "PRRC_kwDOABII584x31XA",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1436,
      "original_position" : 457,
      "original_start_line" : 1429,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 457,
      "pull_request_review_id" : 923487940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836720064/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1429,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-28T18:34:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836720064",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836729505"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836729505"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do you need to `pwallet->BlockUntilSyncedToCurrentChain();` here?",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-28T18:31:52Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r836729505",
      "id" : 836729505,
      "line" : 1334,
      "node_id" : "PRRC_kwDOABII584x33qh",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1334,
      "original_position" : 331,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 331,
      "pull_request_review_id" : 923487940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836729505/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-28T18:34:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/836729505",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837085217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837085217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Generally I'd prefer to keep code logic and constants (defaults) separate. Otherwise changing the constant (default) requires changing the code logic. So this should be `bool a{option.exists() ? option.bool() : option_default};`",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-29T06:05:30Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837085217",
      "id" : 837085217,
      "in_reply_to_id" : 836713923,
      "line" : 1384,
      "node_id" : "PRRC_kwDOABII584x5Ogh",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1384,
      "original_position" : 392,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 392,
      "pull_request_review_id" : 924068600,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837085217/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-29T06:08:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837085217",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837658298"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837658298"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes! Thanks.",
      "commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "created_at" : "2022-03-29T16:08:34Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837658298",
      "id" : 837658298,
      "in_reply_to_id" : 836729505,
      "line" : 1334,
      "node_id" : "PRRC_kwDOABII584x7aa6",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1334,
      "original_position" : 331,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 331,
      "pull_request_review_id" : 924883369,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837658298/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-29T16:08:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837658298",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837889960"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837889960"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Using this default value in this instance replicates the previous behavior.",
      "commit_id" : "bb84b7145b31dbfdcb4cf0b9b6e612a57e573993",
      "created_at" : "2022-03-29T20:37:42Z",
      "diff_hunk" : "@@ -449,31 +450,43 @@ RPCHelpMan settxfee()\n \n \n // Only includes key documentation where the key is snake_case in all RPC methods. MixedCase keys can be added later.\n-static std::vector<RPCArg> FundTxDoc()\n+static std::vector<RPCArg> FundTxDoc(bool solving_data = true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837889960",
      "id" : 837889960,
      "in_reply_to_id" : 836701319,
      "line" : 453,
      "node_id" : "PRRC_kwDOABII584x8S-o",
      "original_commit_id" : "3813ba1b196f8dd89de1f8b959c179dd28c05d4e",
      "original_line" : 453,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : 122,
      "pull_request_review_id" : 925208558,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837889960/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-29T20:37:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837889960",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837890861"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837890861"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Changed this line to match @MarcoFalke's suggestion.",
      "commit_id" : "bb84b7145b31dbfdcb4cf0b9b6e612a57e573993",
      "created_at" : "2022-03-29T20:39:00Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837890861",
      "id" : 837890861,
      "in_reply_to_id" : 836713923,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584x8TMt",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1384,
      "original_position" : 392,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 925209791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837890861/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-29T20:39:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837890861",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837891323"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837891323"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Changed to `RPC_WALLET_INSUFFICIENT_FUNDS`",
      "commit_id" : "bb84b7145b31dbfdcb4cf0b9b6e612a57e573993",
      "created_at" : "2022-03-29T20:39:39Z",
      "diff_hunk" : "@@ -1179,49 +1243,231 @@ RPCHelpMan send()\n             SetOptionsInputWeights(options[\"inputs\"], options);\n             FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n-            bool add_to_wallet = true;\n-            if (options.exists(\"add_to_wallet\")) {\n-                add_to_wallet = options[\"add_to_wallet\"].get_bool();\n+            return FinishTransaction(pwallet, options, rawTx);\n+        }\n+    };\n+}\n+\n+RPCHelpMan sendall()\n+{\n+    return RPCHelpMan{\"sendall\",\n+        \"EXPERIMENTAL warning: this call may be changed in future releases.\\n\"\n+        \"\\nSpend the value of all (or specific) confirmed UTXOs in the wallet to one or more recipients.\\n\"\n+        \"Unconfirmed inbound UTXOs and locked UTXOs will not be spent. Sendall will respect the avoid_reuse wallet flag.\\n\"\n+        \"If your wallet contains many small inputs, either because it received tiny payments or as a result of accumulating change, consider using `send_max` to exclude inputs that are worth less than the fees needed to spend them.\\n\",\n+        {\n+            {\"recipients\", RPCArg::Type::ARR, RPCArg::Optional::NO, \"The sendall destinations. Each address may only appear once.\\n\"\n+                \"Optionally some recipients can be specified with an amount to perform payments, but at least one address must appear without a specified amount.\\n\",\n+                {\n+                    {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"A bitcoin address which receives an equal share of the unspecified amount.\"},\n+                    {\"\", RPCArg::Type::OBJ_USER_KEYS, RPCArg::Optional::OMITTED, \"\",\n+                        {\n+                            {\"address\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\"},\n+                        },\n+                    },\n+                },\n+            },\n+            {\"conf_target\", RPCArg::Type::NUM, RPCArg::DefaultHint{\"wallet -txconfirmtarget\"}, \"Confirmation target in blocks\"},\n+            {\"estimate_mode\", RPCArg::Type::STR, RPCArg::Default{\"unset\"}, std::string() + \"The fee estimate mode, must be one of (case insensitive):\\n\"\n+                        \"       \\\"\" + FeeModes(\"\\\"\\n\\\"\") + \"\\\"\"},\n+            {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+            {\n+                \"options\", RPCArg::Type::OBJ, RPCArg::Optional::OMITTED_NAMED_ARG, \"\",\n+                Cat<std::vector<RPCArg>>(\n+                    {\n+                        {\"add_to_wallet\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"When false, returns the serialized transaction without broadcasting or adding it to the wallet\"},\n+                        {\"fee_rate\", RPCArg::Type::AMOUNT, RPCArg::DefaultHint{\"not set, fall back to wallet fee estimation\"}, \"Specify a fee rate in \" + CURRENCY_ATOM + \"/vB.\"},\n+                        {\"include_watching\", RPCArg::Type::BOOL, RPCArg::DefaultHint{\"true for watch-only wallets, otherwise false\"}, \"Also select inputs which are watch-only.\\n\"\n+                                              \"Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,\\n\"\n+                                              \"e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.\"},\n+                        {\"inputs\", RPCArg::Type::ARR, RPCArg::Default{UniValue::VARR}, \"Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max. A JSON array of JSON objects\",\n+                            {\n+                                {\"txid\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The transaction id\"},\n+                                {\"vout\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The output number\"},\n+                                {\"sequence\", RPCArg::Type::NUM, RPCArg::Optional::NO, \"The sequence number\"},\n+                            },\n+                        },\n+                        {\"locktime\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Raw locktime. Non-0 value also locktime-activates inputs\"},\n+                        {\"lock_unspents\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Lock selected unspent outputs\"},\n+                        {\"psbt\", RPCArg::Type::BOOL,  RPCArg::DefaultHint{\"automatic\"}, \"Always return a PSBT, implies add_to_wallet=false.\"},\n+                        {\"send_max\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.\"},\n+                    },\n+                    FundTxDoc()\n+                ),\n+                \"options\"\n+            },\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+                {\n+                    {RPCResult::Type::BOOL, \"complete\", \"If the transaction has a complete set of signatures\"},\n+                    {RPCResult::Type::STR_HEX, \"txid\", /*optional=*/true, \"The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.\"},\n+                    {RPCResult::Type::STR_HEX, \"hex\", /*optional=*/true, \"If add_to_wallet is false, the hex-encoded raw transaction with signature(s)\"},\n+                    {RPCResult::Type::STR, \"psbt\", /*optional=*/true, \"If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction\"}\n+                }\n+        },\n+        RPCExamples{\"\"\n+        \"\\nSpend all UTXOs from the wallet with a fee rate of 1Â \" + CURRENCY_ATOM + \"/vB using named arguments\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.1 \" + CURRENCY_ATOM + \"/vB using positional arguments\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" 1.1\\n\") +\n+        \"Spend all UTXOs split into equal amounts to two addresses with a fee rate of 1.5 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\", \\\"\" + EXAMPLE_ADDRESS[1] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 1.5}'\\n\") +\n+        \"Leave dust UTXOs in wallet, spend only UTXOs with positive effective value with a fee rate of 10 \" + CURRENCY_ATOM + \"/vB using the options argument\\n\"\n+        + HelpExampleCli(\"sendall\", \"'[\\\"\" + EXAMPLE_ADDRESS[0] + \"\\\"]' null \\\"unset\\\" null '{\\\"fee_rate\\\": 10, \\\"send_max\\\": true}'\\n\") +\n+        \"Spend all UTXOs with a fee rate of 1.3 \" + CURRENCY_ATOM + \"/vB using named arguments and sending a 0.25 \" + CURRENCY_UNIT + \" to another recipient\\n\"\n+        + HelpExampleCli(\"-named sendall\", \"recipients='[{\\\"\" + EXAMPLE_ADDRESS[1] + \"\\\": 0.25}, \\\"\"+ EXAMPLE_ADDRESS[0] + \"\\\"]' fee_rate=1.3\\n\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            RPCTypeCheck(request.params, {\n+                UniValue::VARR, // recipients\n+                UniValue::VNUM, // conf_target\n+                UniValue::VSTR, // estimate_mode\n+                UniValueType(), // fee_rate, will be checked by AmountFromValue() in SetFeeEstimateMode()\n+                UniValue::VOBJ, // options\n+                }, true\n+            );\n+\n+            std::shared_ptr<CWallet> const pwallet{GetWalletForJSONRPCRequest(request)};\n+            if (!pwallet) return NullUniValue;\n+\n+            UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n+            InterpretFeeEstimationInstructions(/*conf_target=*/request.params[1], /*estimate_mode=*/request.params[2], /*fee_rate=*/request.params[3], options);\n+            PreventOutdatedOptions(options);\n+\n+\n+            std::set<std::string> addresses_without_amount;\n+            UniValue recipient_key_value_pairs(UniValue::VARR);\n+            const UniValue& recipients{request.params[0]};\n+            for (unsigned int i = 0; i < recipients.size(); ++i) {\n+                const UniValue& recipient{recipients[i]};\n+                if (recipient.isStr()) {\n+                    UniValue rkvp(UniValue::VOBJ);\n+                    rkvp.pushKV(recipient.get_str(), 0);\n+                    recipient_key_value_pairs.push_back(rkvp);\n+                    addresses_without_amount.insert(recipient.get_str());\n+                } else {\n+                    recipient_key_value_pairs.push_back(recipient);\n+                }\n+            }\n+\n+            if (addresses_without_amount.size() == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Must provide at least one address without a specified amount\");\n             }\n \n-            // Make a blank psbt\n-            PartiallySignedTransaction psbtx(rawTx);\n+            CCoinControl coin_control;\n+\n+            SetFeeEstimateMode(*pwallet, coin_control, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], /*override_min_fee=*/false);\n \n-            // First fill transaction with our data without signing,\n-            // so external signers are not asked sign more than once.\n-            bool complete;\n-            pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n-            const TransactionError err = pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false);\n-            if (err != TransactionError::OK) {\n-                throw JSONRPCTransactionError(err);\n+            coin_control.fAllowWatchOnly = ParseIncludeWatchonly(options[\"include_watching\"], *pwallet);\n+\n+            const bool rbf{options.exists(\"replaceable\") ? options[\"replaceable\"].get_bool() : pwallet->m_signal_rbf};\n+\n+            FeeCalculation fee_calc_out;\n+            CFeeRate fee_rate{GetMinimumFeeRate(*pwallet, coin_control, &fee_calc_out)};\n+            // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n+            // provided one\n+            if (coin_control.m_feerate && fee_rate > *coin_control.m_feerate) {\n+               throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\", coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), fee_rate.ToString(FeeEstimateMode::SAT_VB)));\n+            }\n+            if (fee_calc_out.reason == FeeReason::FALLBACK && !pwallet->m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n             }\n \n-            CMutableTransaction mtx;\n-            complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+            CMutableTransaction rawTx{ConstructTransaction(options[\"inputs\"], recipient_key_value_pairs, options[\"locktime\"], rbf)};\n+            LOCK(pwallet->cs_wallet);\n+            std::vector<COutput> all_the_utxos;\n+\n+            CAmount total_input_value(0);\n+            bool send_max{options.exists(\"send_max\") && options[\"send_max\"].get_bool()};\n+            if (options.exists(\"inputs\") && options.exists(\"send_max\")) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot combine send_max with specific inputs.\");\n+            } else if (options.exists(\"inputs\")) {\n+                for (const CTxIn& input : rawTx.vin) {\n+                    if (pwallet->IsSpent(input.prevout.hash, input.prevout.n)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not available. UTXO (%s:%d) was already spent.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    const CWalletTx* tx{pwallet->GetWalletTx(input.prevout.hash)};\n+                    if (!tx || pwallet->IsMine(tx->tx->vout[input.prevout.n]) != (coin_control.fAllowWatchOnly ? ISMINE_ALL : ISMINE_SPENDABLE)) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input not found. UTXO (%s:%d) is not part of wallet.\", input.prevout.hash.ToString(), input.prevout.n));\n+                    }\n+                    total_input_value += tx->tx->vout[input.prevout.n].nValue;\n+                }\n+            } else {\n+                AvailableCoins(*pwallet, all_the_utxos, &coin_control, /*nMinimumAmount=*/0);\n+                for (const COutput& output : all_the_utxos) {\n+                    CHECK_NONFATAL(output.input_bytes > 0);\n+                    if (send_max && fee_rate.GetFee(output.input_bytes) > output.txout.nValue) {\n+                        continue;\n+                    }\n+                    CTxIn input(output.outpoint.hash, output.outpoint.n, CScript(), rbf ? MAX_BIP125_RBF_SEQUENCE : CTxIn::SEQUENCE_FINAL);\n+                    rawTx.vin.push_back(input);\n+                    total_input_value += output.txout.nValue;\n+                }\n+            }\n \n-            UniValue result(UniValue::VOBJ);\n+            // estimate final size of tx\n+            TxSize tx_size{CalculateMaximumSignedTxSize(CTransaction(rawTx), pwallet.get())};\n+            CAmount fee_from_size{fee_rate.GetFee(tx_size.vsize)};\n+            CAmount effective_value{total_input_value - fee_from_size};\n \n-            if (psbt_opt_in || !complete || !add_to_wallet) {\n-                // Serialize the PSBT\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << psbtx;\n-                result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+            if (effective_value <= 0) {\n+                if (send_max) {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction, try using lower feerate.\");\n+                } else {\n+                    throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Total value of UTXO pool too low to pay for transaction. Try using lower feerate or excluding uneconomic UTXOs with 'send_max' option.\");\n+                }\n             }\n \n-            if (complete) {\n-                std::string err_string;\n-                std::string hex = EncodeHexTx(CTransaction(mtx));\n-                CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-                result.pushKV(\"txid\", tx->GetHash().GetHex());\n-                if (add_to_wallet && !psbt_opt_in) {\n-                    pwallet->CommitTransaction(tx, {}, {} /* orderForm */);\n+            CAmount output_amounts_claimed{0};\n+            for (CTxOut out : rawTx.vout) {\n+                output_amounts_claimed += out.nValue;\n+            }\n+\n+            if (output_amounts_claimed > total_input_value) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Assigned more value to outputs than available funds.\");\n+            }\n+\n+            const CAmount remainder{effective_value - output_amounts_claimed};\n+            if (remainder < 0) {\n+                throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds for fees after creating specified outputs.\");\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837891323",
      "id" : 837891323,
      "in_reply_to_id" : 836720064,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584x8TT7",
      "original_commit_id" : "78aab643af1c1afbaf82e1269b55a617f7fda6f6",
      "original_line" : 1439,
      "original_position" : 457,
      "original_start_line" : 1429,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 925211190,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837891323/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2022-03-29T20:39:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837891323",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Addressed all of the comments by @glozow and @MarcoFalke",
      "created_at" : "2022-03-29T20:40:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1082352676",
      "id" : 1082352676,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585Ag2Qk",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1082352676/reactions"
      },
      "updated_at" : "2022-03-29T20:40:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1082352676",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837893121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837893121"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "bb84b7145b31dbfdcb4cf0b9b6e612a57e573993",
      "created_at" : "2022-03-29T20:41:09Z",
      "diff_hunk" : "@@ -21,7 +21,8 @@\n \n \n namespace wallet {\n-static void ParseRecipients(const UniValue& address_amounts, const UniValue& subtract_fee_outputs, std::vector<CRecipient> &recipients) {\n+static void ParseRecipients(const UniValue& address_amounts, const UniValue& subtract_fee_outputs, std::vector<CRecipient> &recipients)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837893121",
      "id" : 837893121,
      "in_reply_to_id" : 836667051,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584x8TwB",
      "original_commit_id" : "35ed094e4b0e0554e609709f6ca1f7d17096882c",
      "original_line" : 24,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 925212978,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837893121/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-29T20:41:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837893121",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837893255"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837893255"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "bb84b7145b31dbfdcb4cf0b9b6e612a57e573993",
      "created_at" : "2022-03-29T20:41:16Z",
      "diff_hunk" : "@@ -74,6 +74,50 @@ static void InterpretFeeEstimationInstructions(const UniValue& conf_target, cons\n     }\n }\n \n+static UniValue FinishTransaction(const std::shared_ptr<CWallet> pwallet, const UniValue& options, const CMutableTransaction& rawTx)\n+{\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx(rawTx);\n+\n+    // First fill transaction with our data without signing,\n+    // so external signers are not asked sign more than once.\n+    bool complete;\n+    pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, false, true);\n+    const TransactionError err{pwallet->FillPSBT(psbtx, complete, SIGHASH_DEFAULT, true, false)};\n+    if (err != TransactionError::OK) {\n+        throw JSONRPCTransactionError(err);\n+    }\n+\n+    CMutableTransaction mtx;\n+    complete = FinalizeAndExtractPSBT(psbtx, mtx);\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    const bool psbt_opt_in{options.exists(\"psbt\") && options[\"psbt\"].get_bool()};\n+    bool add_to_wallet{options.exists(\"add_to_wallet\") ? options[\"add_to_wallet\"].get_bool() : true};\n+    if (psbt_opt_in || !complete || !add_to_wallet) {\n+        // Serialize the PSBT\n+        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+        ssTx << psbtx;\n+        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+    }\n+\n+    if (complete) {\n+        std::string hex{EncodeHexTx(CTransaction(mtx))};\n+        CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+        result.pushKV(\"txid\", tx->GetHash().GetHex());\n+        if (add_to_wallet && !psbt_opt_in) {\n+            pwallet->CommitTransaction(tx, {}, {} /* orderForm */);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#discussion_r837893255",
      "id" : 837893255,
      "in_reply_to_id" : 836678721,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584x8TyH",
      "original_commit_id" : "902793c7772e5bdd5aae5b0d20a32c02a1a6dc7c",
      "original_line" : 111,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/wallet/rpc/spend.cpp",
      "position" : null,
      "pull_request_review_id" : 925213091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24118",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837893255/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-29T20:41:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/837893255",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK bb84b7145b31dbfdcb4cf0b9b6e612a57e573993",
      "created_at" : "2022-03-29T22:02:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1082414588",
      "id" : 1082414588,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585AhFX8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1082414588/reactions"
      },
      "updated_at" : "2022-03-29T22:02:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1082414588",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This had 3 ACKs and I checked the range-diff. Did not review myself.",
      "created_at" : "2022-03-30T13:04:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1083115561",
      "id" : 1083115561,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585Ajwgp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1083115561/reactions"
      },
      "updated_at" : "2022-03-30T13:04:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1083115561",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Sorry I didn't get around to reviewing this. I'll see if I can test it later.\r\n\r\nThis remains on my wish list (for a future PR):\r\n\r\n> a new RPC call that returns a concise list of outpoints with their amount, like so:\r\n> \r\n> ```\r\n> 16a9...97f:7 0.000100\r\n> 34fe...e8d:0 0.00200\r\n> ```\r\n> \r\n> We could even use transaction short ids, if there's no duplicate in any given wallet (return the full id if there is).",
      "created_at" : "2022-03-30T13:22:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1083134500",
      "id" : 1083134500,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585Aj1Ik",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1083134500/reactions"
      },
      "updated_at" : "2022-03-30T13:22:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1083134500",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Probably wouldn't hurt to also return metadata like `depth` etc..",
      "created_at" : "2022-03-30T13:54:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24118#issuecomment-1083170336",
      "id" : 1083170336,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24118",
      "node_id" : "IC_kwDOABII585Aj94g",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1083170336/reactions"
      },
      "updated_at" : "2022-03-30T13:54:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1083170336",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   }
]
