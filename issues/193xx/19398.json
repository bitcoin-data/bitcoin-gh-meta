{
   "active_lock_reason" : null,
   "assignee" : null,
   "assignees" : [],
   "author_association" : "MEMBER",
   "body" : "The application layer is any data that is transmitted within P2P message payloads, and the processing of that data. Examples are tx inventory, addr gossiping, ping/pong processing.\r\n\r\n`CNode` currently contains many data and function members that are concerned with the application layer. These should be moved into net processing, so that `CNode` is only concerned with the network layer (sending/receiving bytes, keeping statistics, eviction logic, etc).\r\n\r\nOne blocker to moving these is that the existing peer data structure that exists in net processing is `CNodeState`, which is guarded by cs_main. Moving all application layer data into `CNodeState` would expand where we need to take and hold cs_main locks. Instead, we should create a new data structure in net processing called `PeerState` which doesn't require a cs_main lock, and move the application layer data there.\r\n\r\nhttps://github.com/jnewbery/bitcoin/tree/2020-06-cnode-comments is a move/comment only branch that re-orders the `CNode` data members into logical groups and adds comments for each member, including TODOs for members that should be moved to net processing. The branch isn't intended for merging, but is a guide for what I think needs to change in `CNode`.\r\n\r\nhttps://github.com/jnewbery/bitcoin/tree/2020-06-cs-main-split is a branch that implements `PeerState` and starts moving application layer data into that structure. I intend to peel off commits from that branch into separate PRs. That branch also starts moving data that doesn't require the cs_main lock from `CNodeState` into `PeerState`. Longer term, I believe almost all `CNodeState` data can be moved into `PeerState`, greatly reducing the scope that cs_main locks are held in net processing.\r\n\r\nAny help reviewing or implementing these changes would be very much appreciated!\r\n\r\n<details><summary><code>CNode</code> with comments. See TODO comments.</summary>\r\n\r\n```c++\r\n/** Information about a peer */\r\nclass CNode\r\n{\r\n    friend class CConnman;\r\n    friend struct ConnmanTestMsg;\r\n\r\npublic:\r\n    /** A semaphore limits the number of outbound and manual peers. This\r\n     *  CNode holds the grant until the connection is closed, at which point\r\n     *  it's released to allow another connection. */\r\n    CSemaphoreGrant grantOutbound;\r\n    /** Reference count to prevent the CNode from being deleted while there\r\n     *  are still references to it being held.\r\n     *  TODO: replace with std::shared_ptr */\r\n    std::atomic<int> nRefCount{0};\r\n\r\n    /** Socket mutex */\r\n    RecursiveMutex cs_hSocket;\r\n    /** Socket */\r\n    SOCKET hSocket GUARDED_BY(cs_hSocket);\r\n\r\n    /** Send buffer mutex */\r\n    RecursiveMutex cs_vSend;\r\n    /** Send buffer */\r\n    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\r\n    /** Total size of all vSendMsg entries */\r\n    size_t nSendSize{0};\r\n    /** Offset inside the first vSendMsg already sent */\r\n    size_t nSendOffset{0};\r\n    /** Total bytes sent to this peer */\r\n    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\r\n    /** Whether the send buffer is full and we should pause sending\r\n     *  data to this peer. */\r\n    std::atomic_bool fPauseSend{false};\r\n\r\n    /** Send processing mutex. Ensures that we don't enter SendMessages()\r\n     *  for this peer on multiple threads */\r\n    RecursiveMutex cs_sendProcessing;\r\n\r\n    /** Receive buffer mutex */\r\n    RecursiveMutex cs_vProcessMsg;\r\n    /** Buffer of deserialized net messages */\r\n    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\r\n    /** Total size of receive buffer mutex */\r\n    size_t nProcessQueueSize{0} GUARDED_BY(cs_vProcessMsg);\r\n    /** Whether the receive buffer is full and we should pause receiving\r\n     *  data from this peer. */\r\n    std::atomic_bool fPauseRecv{false};\r\n\r\n    /** Receive buffer statistics mutex */\r\n    RecursiveMutex cs_vRecv;\r\n    /** Total bytes received from this peer */\r\n    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\r\n\r\n    /** Address of this peer */\r\n    const CAddress addr;\r\n    /** Bind address of our side of the connection */\r\n    const CAddress addrBind;\r\n    /** Mutex guarding the cleanSubVer field.\r\n     *  TODO: replace with atomic */\r\n    RecursiveMutex cs_SubVer;\r\n    /** Sanitized string of the user agent byte array we read from the wire.\r\n     *  This cleaned string can safely be logged or displayed.  */\r\n    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\r\n    /** Unusued in actual processing, only present for backward compatibility at RPC/QT level */\r\n    bool m_legacyWhitelisted{false};\r\n\r\n    /** If this peer is being used as a short lived feeler. */\r\n    bool fFeeler{false}; \r\n    /** If this peer is being used to fetch addresses and then disconnect */\r\n    bool fOneShot{false};\r\n    /** If this peer is a manual connection added by command-line argument or RPC */\r\n    bool m_manual_connection{false};\r\n    /** If the connection with this peer was initiated by the peer */\r\n    const bool fInbound;\r\n\r\n    /** If the version-verack handshake has successfully completed. */\r\n    std::atomic_bool fSuccessfullyConnected{false};\r\n    /** Setting fDisconnect to true will cause the node to be disconnected the\r\n    / * next time DisconnectNodes() runs */\r\n    std::atomic_bool fDisconnect{false};\r\n\r\n    /** If this peer is a light client (doesn't serve blocks).\r\n     *  TODO: move this application layer data to net processing. */\r\n    bool fClient{false};\r\n    /** If this peer is 'limited' (can only serve recent blocks).\r\n     *  TODO: move this application layer data to net processing. */\r\n    bool m_limited_node{false};\r\n\r\n    /** Whether this peer is preferred for eviction */\r\n    bool m_prefer_evict{false};\r\n    /** The time of the last message sent to this peer. Used in inactivity checks */\r\n    std::atomic<int64_t> nLastSend{0};\r\n    /** The time of the last message received from this peer. Used in inactivity checks */\r\n    std::atomic<int64_t> nLastRecv{0};\r\n    /** Which netgroup this peer is in. Used in eviction logic */\r\n    const uint64_t nKeyedNetGroup;\r\n    /** Last time we accepted a block from this peer. Used in eviction logic */\r\n    std::atomic<int64_t> nLastBlockTime{0};\r\n    /** Last time we accepted a transaction from this peer. Used in eviction logic */\r\n    std::atomic<int64_t> nLastTXTime{0};\r\n    /** Best measured round-trip time for this peer. Used in eviction logic */\r\n    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\r\n\r\n    /** The time that the connection with this node was established. Used in eviction logic */\r\n    const int64_t nTimeConnected;\r\n    /** The difference between the peer's clock and our own. Only used in logging */\r\n    std::atomic<int64_t> nTimeOffset{0};\r\n\r\n    /** The P2P version announced by the peer in its version message.\r\n     *  TODO: this is only used in the application layer. Move to net processing */\r\n    std::atomic<int> nRecvVersion{INIT_PROTO_VERSION};\r\n    /** The P2P version announced by the peer in its version message.\r\n     *  TODO: This seems to largely a duplicate of nRecvVersion. Remove. */\r\n    std::atomic<int> nVersion{0};\r\n    /** The supported services announced by the peer in its version message.\r\n     *  TODO: Move this application layer data to net processing. */\r\n    std::atomic<ServiceFlags> nServices{NODE_NONE};\r\n\r\n    /** Addresses to send to this peer.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::vector<CAddress> vAddrToSend;\r\n    /** Probabilistic filter of addresses that this peer already knows.\r\n     *  TODO: move this application layer data to net processing. */\r\n    const std::unique_ptr<CRollingBloomFilter> m_addr_known;\r\n    /** Whether a GETADDR request is pending from this node.\r\n     *  TODO: move this application layer data to net processing. */\r\n    bool fGetAddr{false};\r\n    /** Timestamp after which we should send the next addr message to this peer.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\r\n    /** Timestamp after which we should advertise our local address to this peer.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\r\n    /** If we've sent an initial ADDR message to this peer.\r\n     *  TODO: move this application layer data to net processing. */\r\n    bool fSentAddr{false};\r\n\r\n    /** Address relay mutex.\r\n     *  TODO: move this application layer data to net processing. */\r\n    RecursiveMutex cs_inventory;\r\n    /** List of block ids we still have announce.\r\n    / * There is no final sorting before sending, as they are always sent immediately\r\n    / * and in the order requested.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::vector<uint256> vInventoryBlockToSend GUARDED_BY(cs_inventory);\r\n    /** List of block hashes to relay in headers messages.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);\r\n    /** When the peer requests this block, we send an inv that\r\n      * triggers the peer to send a getblocks to fetch the next batch of\r\n      * inventory. Only used for peers that don't do headers-first syncing.\r\n      *  TODO: move this application layer data to net processing. */\r\n    uint256 hashContinue;\r\n    /** This peer's height, as announced in its version message.\r\n      *  TODO: move this application layer data to net processing. */\r\n    std::atomic<int> nStartingHeight{-1};\r\n\r\n    struct TxRelay {\r\n        /** bloom filter mutex */\r\n        mutable RecursiveMutex cs_filter;\r\n        /** We use fRelayTxes for two purposes -\r\n         *  a) it allows us to not relay tx invs before receiving the peer's version message\r\n         *  b) the peer may tell us in its version message that we should not relay tx invs\r\n         *     unless it loads a bloom filter. */\r\n        bool fRelayTxes GUARDED_BY(cs_filter){false};\r\n        /** BIP 31 bloom filter */\r\n        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\r\n\r\n        /** Transaction relay mutex */\r\n        mutable RecursiveMutex cs_tx_inventory;\r\n        /** Probabilistic filter of txids that the peer already knows */\r\n        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\r\n        /** Set of transaction ids we still have to announce.\r\n         * They are sorted by the mempool before relay, so the order is not important. */\r\n        std::set<uint256> setInventoryTxToSend;\r\n        /** Timestamp after which we should send the next transaction INV message to this peer */\r\n        std::chrono::microseconds nNextInvSend{0};\r\n\r\n        /** If the peer has a pending BIP 35 MEMPOOL request to us */\r\n        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\r\n        /** Last time a MEMPOOL request was serviced. */\r\n        std::atomic<std::chrono::seconds> m_last_mempool_req{std::chrono::seconds{0}};\r\n\r\n        /** Feefilter mutex */\r\n        RecursiveMutex cs_feeFilter;\r\n        /** Minimum fee rate with which to filter inv's to this node */\r\n        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\r\n        /** Last feefilter value we sent to the peer */\r\n        CAmount lastSentFeeFilter{0};\r\n        /** Timestamp after which we should send the next FEEFILTER message to this peer */\r\n        int64_t nextSendTimeFeeFilter{0};\r\n    };\r\n\r\n    /** Transaction relay data for this peer. If m_tx_relay == nullptr then we don't\r\n     *  relay transactions with this peer.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::unique_ptr<TxRelay> m_tx_relay;\r\n\r\n    /** List of inv items requested by this peer in a getdata message.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::deque<CInv> vRecvGetData;\r\n\r\n    /** The pong reply we're expecting, or 0 if no pong expected.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::atomic<uint64_t> nPingNonceSent{0};\r\n    /** Time (in usec) the last ping was sent, or 0 if no ping was ever sent.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::atomic<int64_t> nPingUsecStart{0};\r\n    /** Last measured ping round-trip time.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::atomic<int64_t> nPingUsecTime{0};\r\n    /** Whether a ping request is pending to this peer.\r\n     *  TODO: move this application layer data to net processing. */\r\n    std::atomic<bool> fPingQueued{false};\r\n\r\n    /** Orphan transactions to reconsider after the parent was accepted.\r\n     *  TODO: move this application layer data to a global in net processing. */\r\n    std::set<uint256> orphan_work_set;\r\n\r\nprivate:\r\n    /** Unique numeric identifier for this node */\r\n    const NodeId id;\r\n    /** Node name mutex\r\n     *  TODO: replace with atomic */\r\n    mutable RecursiveMutex cs_addrName;\r\n    /** Node name */\r\n    std::string addrName GUARDED_BY(cs_addrName);\r\n    /** This node's permission flags. */\r\n    NetPermissionFlags m_permissionFlags{ PF_NONE };\r\n    /** addrLocal mutex\r\n     *  TODO: replace with atomic */\r\n    mutable RecursiveMutex cs_addrLocal;\r\n    /** Our address, as reported by the peer */\r\n    CService addrLocal GUARDED_BY(cs_addrLocal);\r\n\r\n    /** Random nonce sent in our VERSION message to detect connecting to ourselves.\r\n     *  TODO: move this application layer data to net processing */\r\n    const uint64_t nLocalHostNonce;\r\n    /** Services offered to this peer.\r\n     *\r\n     * This is supplied by the parent CConnman during peer connection\r\n     * (CConnman::ConnectNode()) from its attribute of the same name.\r\n     *\r\n     * This is const because there is no protocol defined for renegotiating\r\n     * services initially offered to a peer. The set of local services we\r\n     * offer should not change after initialization.\r\n     *\r\n     * An interesting example of this is NODE_NETWORK and initial block\r\n     * download: a node which starts up from scratch doesn't have any blocks\r\n     * to serve, but still advertises NODE_NETWORK because it will eventually\r\n     * fulfill this role after IBD completes. P2P code is written in such a\r\n     * way that it can gracefully handle peers who don't make good on their\r\n     * service advertisements.\r\n     *\r\n     * TODO: move this application layer data to net processing. */\r\n    const ServiceFlags nLocalServices;\r\n    /** Our starting height that we advertised to this node in our VERSION message.\r\n     * TODO: this value is not used after sending the version message. We can remove this field. */\r\n    const int nMyStartingHeight;\r\n    /** The version that we advertised to the peer in our VERSION message.\r\n     *  TODO: move this application layer data to net processing */\r\n    int nSendVersion{0};\r\n\r\n    /** Deserializer for messages received over the network. This is a derived\r\n     * class of TransportDeserializer based on the P2P version used with this\r\n     * peer. */\r\n    std::unique_ptr<TransportDeserializer> m_deserializer;\r\n    /** Serializer for messages sent over the network. This is a derived\r\n     * class of TransportDeserializer based on the P2P version used with this\r\n     * peer. */\r\n    std::unique_ptr<TransportSerializer> m_serializer;\r\n\r\n    /** Temporary buffer used by the SocketHandler thread for received messages,\r\n     *  before they're pushed onto the vProcessMsg buffer. */\r\n    std::list<CNetMessage> vRecvMsg;\r\n\r\n    /** Statistics of bytes sent to this peer, broken out by message type */\r\n    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\r\n    /** Statistics of bytes received from this peer, broken out by message type */\r\n    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\r\n\r\npublic:\r\n    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn,\r\n          const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn,\r\n          const CAddress &addrBindIn, const std::string &addrNameIn = \"\",\r\n          bool fInboundIn = false, bool block_relay_only = false);\r\n    ~CNode();\r\n    CNode(const CNode&) = delete;\r\n    CNode& operator=(const CNode&) = delete;\r\n\r\n    NodeId GetId() const {\r\n        return id;\r\n    }\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    uint64_t GetLocalNonce() const {return nLocalHostNonce;}\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    int GetMyStartingHeight() const {return nMyStartingHeight;}\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    ServiceFlags GetLocalServices() const { return nLocalServices; }\r\n\r\n    /** TODO: move these application layer functions to net processing */\r\n    void SetRecvVersion(int nVersionIn) { nRecvVersion = nVersionIn; }\r\n    int GetRecvVersion() const { return nRecvVersion; }\r\n    void SetSendVersion(int nVersionIn);\r\n    int GetSendVersion() const;\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    bool IsAddrRelayPeer() const { return m_addr_known != nullptr; }\r\n\r\n    /** TODO: Replace with std::shared_ptr refcounts */\r\n    int GetRefCount() const\r\n    {\r\n        assert(nRefCount >= 0);\r\n        return nRefCount;\r\n    }\r\n\r\n    CNode* AddRef()\r\n    {\r\n        nRefCount++;\r\n        return this;\r\n    }\r\n\r\n    void Release()\r\n    {\r\n        nRefCount--;\r\n    }\r\n\r\n    bool ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete);\r\n\r\n    CService GetAddrLocal() const;\r\n    //! May not be called more than once\r\n    void SetAddrLocal(const CService& addrLocalIn);\r\n\r\n    std::string GetAddrName() const;\r\n    //! Sets the addrName only if it was not previously set\r\n    void MaybeSetAddrName(const std::string& addrNameIn);\r\n\r\n    bool HasPermission(NetPermissionFlags permission) const {\r\n        return NetPermissions::HasFlag(m_permissionFlags, permission);\r\n    }\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    void AddAddressKnown(const CAddress& _addr)\r\n    {\r\n        assert(m_addr_known);\r\n        m_addr_known->insert(_addr.GetKey());\r\n    }\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\r\n    {\r\n        // Known checking here is only to save space from duplicates.\r\n        // SendMessages will filter it again for knowns that were added\r\n        // after addresses were pushed.\r\n        assert(m_addr_known);\r\n        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey())) {\r\n            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\r\n                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\r\n            } else {\r\n                vAddrToSend.push_back(_addr);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    void AddInventoryKnown(const CInv& inv)\r\n    {\r\n        if (m_tx_relay != nullptr) {\r\n            LOCK(m_tx_relay->cs_tx_inventory);\r\n            m_tx_relay->filterInventoryKnown.insert(inv.hash);\r\n        }\r\n    }\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    void PushTxInventory(const uint256& hash)\r\n    {\r\n        if (m_tx_relay == nullptr) return;\r\n        LOCK(m_tx_relay->cs_tx_inventory);\r\n        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\r\n            m_tx_relay->setInventoryTxToSend.insert(hash);\r\n        }\r\n    }\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    void PushBlockInventory(const uint256& hash)\r\n    {\r\n        LOCK(cs_inventory);\r\n        vInventoryBlockToSend.push_back(hash);\r\n    }\r\n\r\n    /** TODO: move this application layer function to net processing */\r\n    void PushBlockHash(const uint256 &hash)\r\n    {\r\n        LOCK(cs_inventory);\r\n        vBlockHashesToAnnounce.push_back(hash);\r\n    }\r\n\r\n    void CloseSocketDisconnect();\r\n\r\n    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\r\n};\r\n```\r\n</details>",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 1,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19398/comments",
   "created_at" : "2020-06-27T17:58:34Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19398/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/19398",
   "id" : 646725848,
   "labels" : [
      {
         "color" : "E6F6D6",
         "default" : false,
         "description" : null,
         "id" : 135961,
         "name" : "Refactoring",
         "node_id" : "MDU6TGFiZWwxMzU5NjE=",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19398/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDU6SXNzdWU2NDY3MjU4NDg=",
   "number" : 19398,
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "title" : "Move remaining application layer data to net processing",
   "updated_at" : "2020-06-27T18:05:17Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19398",
   "user" : {
      "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
      "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
      "followers_url" : "https://api.github.com/users/jnewbery/followers",
      "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/jnewbery",
      "id" : 1063656,
      "login" : "jnewbery",
      "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
      "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
      "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
      "repos_url" : "https://api.github.com/users/jnewbery/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/jnewbery"
   }
}
