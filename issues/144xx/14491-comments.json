[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For the same reason as pointed out in the other PR, you can't do this; you're going to mark payments to individual multisig pubkeys as incoming payments.\r\n\r\nYou'll need a way to restrict this to P2PK, P2WPKH, and P2SH/P2WSH wrapped versions of those.\r\n\r\nEDIT: I realize that when it's about private keys, the same effect applies too, and there it can't be avoided. Perhaps this stuff is just to scary, and we should wait until there's a way to actually specify what to treat as ours explicitly...",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T06:11:05Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327",
      "id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQwODMyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 164997487,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nif (data.exists(\"scriptPubKey\") && data.exists(\"descriptor\")) {\r\n    // throw error because these should be exclusive?\r\n}\r\n```\r\nand add test.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T10:32:07Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727",
      "id" : 225484727,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NDcyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 536,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T10:41:39Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379",
      "id" : 225487379,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzM3OQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 444,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 213,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T10:41:50Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418",
      "id" : 225487418,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzQxOA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 446,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T10:42:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555",
      "id" : 225487555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzU1NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 450,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`;",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T10:42:48Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698",
      "id" : 225487698,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzY5OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 491,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T10:43:16Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854",
      "id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzg1NA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 362,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `ProcessImportDescriptor`.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T10:43:40Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947",
      "id" : 225487947,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzk0Nw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 539,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, extra `-` :sweat_smile:",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T11:10:21Z",
      "diff_hunk" : "@@ -0,0 +1,6 @@\n+Low-level RPC changes\n+----------------------",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251",
      "id" : 225495251,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ5NTI1MQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 2,
      "path" : "doc/release-notes-14454.md",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit space after `if`.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T11:51:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588",
      "id" : 225505588,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUwNTU4OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 431,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Restricting it from multisig(to avoid being tricked as you mention) would make this even more confusing to a user. \r\n\r\nUnfortunate. ",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T13:10:52Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603",
      "id" : 225531603,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUzMTYwMw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165149268,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mentioned on IRC, but what if we just never import public keys at all, and only either A) add the scriptPubKey as watch only or B) import the private key. If we have the private key then IMO it's less scary, because it's still \"ours\" and we can access the funds",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T18:21:27Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495",
      "id" : 225654495,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY1NDQ5NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165301641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're right; the same concern doesn't exist for private keys as you're obviously able to spend those coins anyway.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T18:40:24Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278",
      "id" : 225662278,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2MjI3OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165309946,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225665843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225665843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would not importing the pubkeys affect the wallet's ability to construct PSBT inputs?",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T18:50:50Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225665843",
      "id" : 225665843,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2NTg0Mw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165314304,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225665843",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225666972"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225666972"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Only for things that have PKH/WPKH construction in them (GetPubKey is needed for those, which finds a pubkey based on pubkeyhash).\r\n\r\n@MeshCollider To be clear, we do have to import the pubkey for those; otherwise the result is not solvable.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T18:54:12Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225666972",
      "id" : 225666972,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2Njk3Mg==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165315744,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225666972",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225736677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225736677"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I said more tests were coming Ã°ÂÂÂ",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-10-16T23:08:21Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225736677",
      "id" : 225736677,
      "in_reply_to_id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTczNjY3Nw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 362,
      "pull_request_review_id" : 165403464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225736677",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "After discussion with sipa, closing for now, will come back to this after #14454 is merged",
      "created_at" : "2018-10-16T23:48:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-430440099",
      "id" : 430440099,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzMDQ0MDA5OQ==",
      "updated_at" : "2018-10-16T23:48:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/430440099",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Since #14454 has been merged, this can be reopened?",
      "created_at" : "2018-11-01T19:13:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435153258",
      "id" : 435153258,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1MzI1OA==",
      "updated_at" : "2018-11-01T19:13:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435153258",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I believe a simpler approach is possible on top of #14565.",
      "created_at" : "2018-11-01T19:20:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435155301",
      "id" : 435155301,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1NTMwMQ==",
      "updated_at" : "2018-11-01T19:20:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435155301",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yep I'll reopen this when rebased on 14565",
      "created_at" : "2018-11-01T19:24:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435156556",
      "id" : 435156556,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1NjU1Ng==",
      "updated_at" : "2018-11-01T19:24:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435156556",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on https://github.com/bitcoin/bitcoin/pull/14565\r\n\r\nStill planning on adding more tests + release notes, please don't nitpick the lack of tests yet",
      "created_at" : "2018-11-03T00:23:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435544886",
      "id" : 435544886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTU0NDg4Ng==",
      "updated_at" : "2018-11-03T02:02:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435544886",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors thanks for the feedback :) \r\n\r\n> If I use watchonly: true, then getaddressinfo doesn't show a descriptor and it says solvable: false, which seems wrong (the latter also happens without cherry-pick).\r\n\r\nIt should only watch for the scriptPubKey and import no other information, watch-only is a different requirement than being solvable without private keys.\r\n\r\n>  the origin info in the descriptor seems both wrong and incomplete: \"desc\": \"wpkh([224885f8]026...)\", where 224885f8 is not the master fingerprint I used, and derivation info is missing. \r\n\r\nYou're right, good point. I'll take a look at andrews PR\r\n\r\n> I didn't use the watchonly while importing a descriptor with an xpub, should that be allowed? Or should watchonly argument not be allowed when using a descriptor?\r\n\r\nI think it should be allowed, because of the above reason. Using an xpub without watch only allows it to be solvable without being spendable",
      "created_at" : "2018-11-05T23:33:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436075791",
      "id" : 436075791,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjA3NTc5MQ==",
      "updated_at" : "2018-11-05T23:33:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436075791",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MeshCollider @Sjors I was imagining that \"watchonly\" would be implicit when using descriptors (`addr()` and `raw()` would be watchonly; anything else would result in a solvable result).\r\n\r\nThe reason for \"watchonly\" is so that users need to be explicit about the fact they _don't_ want solvability (generally, you should always want solvability, but if you can't, you can tell importmulti that it's fine without).",
      "created_at" : "2018-11-05T23:39:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436077191",
      "id" : 436077191,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjA3NzE5MQ==",
      "updated_at" : "2018-11-05T23:39:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436077191",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa I like your suggestion. In that case we should disallow usage of the `watchonly` param when combined with a descriptor.\r\n\r\nRegarding getting origin information from the descriptors, @achow101  just rebased #14021 on top of this PR. It's a non trivial change. Perhaps for this PR it's best to not store origin information. Just make sure that if you do `walletcreatefundedpsbt` with bip32 flag set to true, then the result doesn't crash `decodepsbt`.",
      "created_at" : "2018-11-06T08:56:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436177401",
      "id" : 436177401,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjE3NzQwMQ==",
      "updated_at" : "2018-11-06T08:56:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436177401",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I don't see the problem if you want to add a ranged descriptor as watch only to import all the scriptPubKeys but not retain any more info than that?",
      "created_at" : "2018-11-06T10:02:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436197110",
      "id" : 436197110,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjE5NzExMA==",
      "updated_at" : "2018-11-06T10:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436197110",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "IIUC you would indicate that in the descriptor by wrapping the result in `addr(...)`. Mandating that removes ambiguity from how a descriptor ends up in a wallet.",
      "created_at" : "2018-11-06T10:15:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436201303",
      "id" : 436201303,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjIwMTMwMw==",
      "updated_at" : "2018-11-06T10:15:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436201303",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors It was my understanding that `addr(...)` cannot contain another type of descriptor or key (e.g. a ranged BIP32 key), only the base58/bech32 encoded address formats. If I'm wrong then I'm happy to change this PR, @sipa could weigh in here",
      "created_at" : "2018-11-06T11:19:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436218992",
      "id" : 436218992,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjIxODk5Mg==",
      "updated_at" : "2018-11-06T11:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436218992",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "xpub byte prefix mismatch results in very generic error; would be nice to give something more meaningful ",
      "created_at" : "2018-11-07T18:15:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436723660",
      "id" : 436723660,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjcyMzY2MA==",
      "updated_at" : "2018-11-07T18:15:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436723660",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#15032](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15032.html) (Nit fixes for PR 14565 by MeshCollider)\n* [#14918](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14918.html) (RPCHelpMan: Check default values are given at compile-time by MarcoFalke)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-11-08T21:28:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-437162334",
      "id" : 437162334,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNzE2MjMzNA==",
      "updated_at" : "2019-02-06T21:38:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/437162334",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r232172774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232172774"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could use `std::any_of`? :-)",
      "commit_id" : "ed21a15e835b7eec1fb909c9095e6078a6541b5c",
      "created_at" : "2018-11-09T08:28:57Z",
      "diff_hunk" : "@@ -804,233 +805,351 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> script_pub_keys;\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            data.used_keys.emplace(pubkey.GetID());\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the full script imported\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::WITNESS_V0);\n+        break;\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the full script imported\n+        break;\n+    }\n+    default:\n+        return \"nonstandard script\";\n+    }\n+    return \"\";\n+}\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, const UniValue& data, bool& watch_only)\n+{\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n+    import_data.script_pub_keys.emplace(script);\n \n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n         }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n         }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+        }\n+        import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (import_data.pubkeys.count(id)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n+        }\n+        import_data.privkeys.emplace(id, key);\n+    }\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Warn about inconsistencies between watch_only and provided keys/scripts\n+    UniValue warnings(UniValue::VARR);\n+    bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+    if (watch_only && have_solving_data) {\n+        warnings.push_back(\"redeemscript, witnessscript, keys, and pubkeys are ignored when watchonly is set.\");\n+    }\n+    if (!watch_only && !have_solving_data) {\n+        warnings.push_back(\"Assuming watchonly as no redeemscript, witnessscript, keys, or pubkeys are provided.\");\n+        watch_only = true;\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+    }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+    // Verify and process input data\n+    if (!watch_only) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.require_keys) {\n+                if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Ignoring information in keys, pubkeys, redeemscript, and witnessscript:: \" + error);\n+            import_data = ImportData();\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript \" + strRedeemScript + \" as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript \" + witness_script_hex + \" as this is not a P2WSH script.\");\n+            for (const auto& privkey : import_data.privkeys) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r232172774",
      "id" : 232172774,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjE3Mjc3NA==",
      "original_commit_id" : "ed21a15e835b7eec1fb909c9095e6078a6541b5c",
      "original_position" : 345,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 345,
      "pull_request_review_id" : 173311534,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-09T08:28:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232172774",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "~~Can you rebase this on most recent #14565 ? It has a few logic fixes.~~ discussing what I think are bugs\r\n\r\nIn addition, you can not ignore the `watch_only` field for descriptor import. `watch_only` needs to be set to true if the descriptor deals with public keys only: https://github.com/bitcoin/bitcoin/pull/14565/files#diff-522490d83dce5375d423b23886e4125eR1019 (this code is from the refreshed dependent PR)",
      "created_at" : "2018-11-09T17:06:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-437426180",
      "id" : 437426180,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNzQyNjE4MA==",
      "updated_at" : "2018-11-09T17:25:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/437426180",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-11-13T17:40:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-438366545",
      "id" : 438366545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzODM2NjU0NQ==",
      "updated_at" : "2018-11-13T17:40:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/438366545",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Now might be a good to time to rebase it, because testing this might reveal anything we've missed in the overhaul PR #14565.",
      "created_at" : "2018-12-12T09:34:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-446522157",
      "id" : 446522157,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NjUyMjE1Nw==",
      "updated_at" : "2018-12-12T09:34:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446522157",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've rebased this but haven't tested, it was a bit of a messy rebase and still a couple of things to address such as adding the warnings to the descriptor import function, plus more tests. I'll hopefully finish those things off in the next couple of days too.",
      "created_at" : "2018-12-13T01:03:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-446803700",
      "id" : 446803700,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NjgwMzcwMA==",
      "updated_at" : "2018-12-13T01:03:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446803700",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "By \"haven't tested\" you mean \"haven't compiled\" right? :-)\r\n\r\nIt looks like a tricky rebase. E.g. your code is referring to `import_data.pubkeys` and `import_data.privkeys`, the latter has been renamed to `import_data.used_keys`, but the former doesn't exist anymore.\r\n\r\nThe `ProcessImport` function is now duplicated.",
      "created_at" : "2018-12-13T09:24:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-446898912",
      "id" : 446898912,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Njg5ODkxMg==",
      "updated_at" : "2018-12-13T09:24:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446898912",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've now finished rebasing, lightly tested, added some warnings, and added a couple more tests. \r\n\r\nThere is one thing that still needs addressing, which is that a descriptor which provides a private key should import that private key. Currently it only Expands() the descriptor and imports the public keys. The implementation of that is likely going to require some discussion so I will open a future PR for that, and leave it as a TODO for now.",
      "created_at" : "2018-12-14T07:32:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-447240211",
      "id" : 447240211,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NzI0MDIxMQ==",
      "updated_at" : "2018-12-19T03:10:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447240211",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r241992959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241992959"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This variable is unused in this function",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-12-16T19:35:03Z",
      "diff_hunk" : "@@ -923,203 +924,291 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n-            privkey_map.emplace(id, key);\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n         }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Internal addresses should not have a label\n+    // TODO: add warnings if private keys don't correspond to watch-only\n+    return warnings;\n+}\n+\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r241992959",
      "id" : 241992959,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTk5Mjk1OQ==",
      "original_commit_id" : "85b235cf9b029fa706b9373ef0f75811678da1f3",
      "original_position" : 281,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 185400604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241992959",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. I've had a quick skim of the code. A couple of high-level questions:\r\n\r\n- have you considered implementing this as a separate `importdescriptor` RPC method? There are enough modal arguments (eg redeemscript/witnessscript/pubkeys/watchonly(?) should only be used when importing addresses/scripts, range should only be used when importing descriptors) that it seems like this makes sense as a separate method.\r\n- should it ever be necessary to add a `keys` argument for importing private keys with a descriptor? Can't you just include the private keys directly in the descriptor?",
      "created_at" : "2018-12-20T20:19:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-449123454",
      "id" : 449123454,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0OTEyMzQ1NA==",
      "updated_at" : "2018-12-20T20:19:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449123454",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery IIRC a unique RPC would likely be reserved for when wallet actually has descriptor records and can have a clean API break.",
      "created_at" : "2018-12-20T20:22:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-449124103",
      "id" : 449124103,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0OTEyNDEwMw==",
      "updated_at" : "2018-12-20T20:22:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449124103",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "+1 for including private keys directly in the descriptor rather than a separate keys argument",
      "created_at" : "2018-12-21T13:24:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-449387508",
      "id" : 449387508,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0OTM4NzUwOA==",
      "updated_at" : "2018-12-21T13:24:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449387508",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery @Sjors as mentioned above\r\n\r\n>There is one thing that still needs addressing, which is that a descriptor which provides a private key should import that private key. Currently it only Expands() the descriptor and imports the public keys. The implementation of that is likely going to require some discussion so I will open a future PR for that, and leave it as a TODO for now.\r\n\r\nSo right now, the \"keys\" field is the only way to import a private key. That is because the descriptor code doesn't currently support deriving specific private keys, Expand() only provides public keys and scripts. I have the code for importing private keys too ready, so let's discuss that issue there when I open a PR. EDIT: #15024",
      "created_at" : "2018-12-21T21:16:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-449500333",
      "id" : 449500333,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0OTUwMDMzMw==",
      "updated_at" : "2018-12-21T22:32:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449500333",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-12-24T11:21:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-449721608",
      "id" : 449721608,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0OTcyMTYwOA==",
      "updated_at" : "2018-12-24T11:21:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449721608",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244194544"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244194544"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/specify the watchonly flag/specify the watchonly flag to suppress this warning/",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-12-27T17:29:09Z",
      "diff_hunk" : "@@ -1108,14 +1117,25 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         }\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID id = pubkey.GetID();\n+\n         // Check if this private key corresponds to a public key from the descriptor\n         if (!pubkey_map.count(id)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n         }\n-        privkey_map.emplace(id, key);\n     }\n \n-    // TODO: add warnings if private keys don't correspond to watch-only\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244194544",
      "id" : 244194544,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDE5NDU0NA==",
      "original_commit_id" : "5330527724c9af9e79eafc6c5fc9df62e7695161",
      "original_position" : 52,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 303,
      "pull_request_review_id" : 188139748,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244194544",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244194592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244194592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/do not specify the watchonly flag/do not specify the watchonly flag to suppress this warning/",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-12-27T17:29:28Z",
      "diff_hunk" : "@@ -1108,14 +1117,25 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         }\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID id = pubkey.GetID();\n+\n         // Check if this private key corresponds to a public key from the descriptor\n         if (!pubkey_map.count(id)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n         }\n-        privkey_map.emplace(id, key);\n     }\n \n-    // TODO: add warnings if private keys don't correspond to watch-only\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244194592",
      "id" : 244194592,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDE5NDU5Mg==",
      "original_commit_id" : "5330527724c9af9e79eafc6c5fc9df62e7695161",
      "original_position" : 55,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 306,
      "pull_request_review_id" : 188139748,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244194592",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244195403"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244195403"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This error message is misleading: An `end` range suffices.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-12-27T17:34:55Z",
      "diff_hunk" : "@@ -629,7 +629,30 @@ def run_test(self):\n                               True)\n         self.test_address(address,\n                           solvable=True,\n-                          ismine=True)\n+                          ismine=True,\n+                          label=\"Descriptor import test\")\n+\n+        # Test ranged descriptor fails if range is not specified\n+        xpriv = \"tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg\"\n+        addresses = [\"2N7yv4p8G8yEaPddJxY41kPihnWvs39qCMf\", \"2MsHxyb2JS3pAySeNUsJ7mNnurtpeenDzLA\"] # hdkeypath=m/0'/0'/0' and 1'\n+        desc = \"sh(wpkh(\" + xpriv + \"/0'/0'/*'\" + \"))\"\n+        self.log.info(\"Ranged descriptor import should fail without a specified range\")\n+        self.test_importmulti({\"desc\": desc,\n+                               \"timestamp\": \"now\"},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Descriptor is ranged, please specify the range')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244195403",
      "id" : 244195403,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDE5NTQwMw==",
      "original_commit_id" : "d2fe87244d64c5cfadf108c570bd50ca8139e239",
      "original_position" : 17,
      "path" : "test/functional/wallet_importmulti.py",
      "position" : 36,
      "pull_request_review_id" : 188139748,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244195403",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244196991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244196991"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Try to import an invalid descriptor as well as one without a range.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2018-12-27T17:45:18Z",
      "diff_hunk" : "@@ -629,7 +629,30 @@ def run_test(self):\n                               True)\n         self.test_address(address,\n                           solvable=True,\n-                          ismine=True)\n+                          ismine=True,\n+                          label=\"Descriptor import test\")\n+\n+        # Test ranged descriptor fails if range is not specified\n+        xpriv = \"tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg\"\n+        addresses = [\"2N7yv4p8G8yEaPddJxY41kPihnWvs39qCMf\", \"2MsHxyb2JS3pAySeNUsJ7mNnurtpeenDzLA\"] # hdkeypath=m/0'/0'/0' and 1'\n+        desc = \"sh(wpkh(\" + xpriv + \"/0'/0'/*'\" + \"))\"\n+        self.log.info(\"Ranged descriptor import should fail without a specified range\")\n+        self.test_importmulti({\"desc\": desc,\n+                               \"timestamp\": \"now\"},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Descriptor is ranged, please specify the range')\n+\n+        # Test importing of a ranged descriptor without keys\n+        self.log.info(\"Should import the ranged descriptor with specified range as solvable\")\n+        self.test_importmulti({\"desc\": desc,\n+                               \"timestamp\": \"now\",\n+                               \"range\": {\"end\": 1}},\n+                              True,\n+                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+        for address in addresses:\n+            self.test_address(address,\n+                              solvable=True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244196991",
      "id" : 244196991,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDE5Njk5MQ==",
      "original_commit_id" : "d2fe87244d64c5cfadf108c570bd50ca8139e239",
      "original_position" : 28,
      "path" : "test/functional/wallet_importmulti.py",
      "position" : null,
      "pull_request_review_id" : 188139748,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244196991",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244971795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244971795"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@instagibbs I'd argue that specifying an `end` counts as specifying the range, considering the helptext for the rpc",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-03T11:24:48Z",
      "diff_hunk" : "@@ -629,7 +629,30 @@ def run_test(self):\n                               True)\n         self.test_address(address,\n                           solvable=True,\n-                          ismine=True)\n+                          ismine=True,\n+                          label=\"Descriptor import test\")\n+\n+        # Test ranged descriptor fails if range is not specified\n+        xpriv = \"tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg\"\n+        addresses = [\"2N7yv4p8G8yEaPddJxY41kPihnWvs39qCMf\", \"2MsHxyb2JS3pAySeNUsJ7mNnurtpeenDzLA\"] # hdkeypath=m/0'/0'/0' and 1'\n+        desc = \"sh(wpkh(\" + xpriv + \"/0'/0'/*'\" + \"))\"\n+        self.log.info(\"Ranged descriptor import should fail without a specified range\")\n+        self.test_importmulti({\"desc\": desc,\n+                               \"timestamp\": \"now\"},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Descriptor is ranged, please specify the range')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244971795",
      "id" : 244971795,
      "in_reply_to_id" : 244195403,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDk3MTc5NQ==",
      "original_commit_id" : "d2fe87244d64c5cfadf108c570bd50ca8139e239",
      "original_position" : 17,
      "path" : "test/functional/wallet_importmulti.py",
      "position" : 36,
      "pull_request_review_id" : 188975860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244971795",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r245677784"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/245677784"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This could use a test.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-07T14:50:31Z",
      "diff_hunk" : "@@ -1108,14 +1117,25 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         }\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID id = pubkey.GetID();\n+\n         // Check if this private key corresponds to a public key from the descriptor\n         if (!pubkey_map.count(id)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+            warnings.push_back(\"Ignoring irrelevant private key.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r245677784",
      "id" : 245677784,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NTY3Nzc4NA==",
      "original_commit_id" : "5330527724c9af9e79eafc6c5fc9df62e7695161",
      "original_position" : 40,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 288,
      "pull_request_review_id" : 189838451,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/245677784",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r245677951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/245677951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also, this and the related warning could use a test.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-07T14:50:59Z",
      "diff_hunk" : "@@ -1108,14 +1117,25 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         }\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID id = pubkey.GetID();\n+\n         // Check if this private key corresponds to a public key from the descriptor\n         if (!pubkey_map.count(id)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n         }\n-        privkey_map.emplace(id, key);\n     }\n \n-    // TODO: add warnings if private keys don't correspond to watch-only\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r245677951",
      "id" : 245677951,
      "in_reply_to_id" : 244194544,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NTY3Nzk1MQ==",
      "original_commit_id" : "5330527724c9af9e79eafc6c5fc9df62e7695161",
      "original_position" : 52,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 303,
      "pull_request_review_id" : 189838451,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/245677951",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r245678614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/245678614"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Still coming?",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-07T14:52:57Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r245678614",
      "id" : 245678614,
      "in_reply_to_id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NTY3ODYxNA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 362,
      "pull_request_review_id" : 189838451,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/245678614",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MeshCollider - I know you're travelling so no rush on an answer to this, but do you have thoughts about my questions in IRC:\r\n\r\n```\r\n15:40 < jnewbery> meshcollider: what's the eventual plan for private keys in importmulti with descriptors? After #15024, there are two ways of importing the privkeys: either in the descriptor itself or with the keys argument. Would it be better to only allow importing privkeys from the descriptor itself?\r\n15:42 < jnewbery> If you agree, then I think it makes sense to flip the ordering of the PRs (ie reduce 15024 to just commit https://github.com/bitcoin/bitcoin/pull/15024/commits/8a270b9582d82991766172430d508a1a7358e80d and merge that first, and then have 14491 following it)\r\n```",
      "created_at" : "2019-01-09T22:25:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-452892414",
      "id" : 452892414,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1Mjg5MjQxNA==",
      "updated_at" : "2019-01-09T22:25:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/452892414",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Would it be better to only allow importing privkeys from the descriptor itself?\r\n\r\n@jnewbery you mean deprecate `keys` in `importmulti` or error if `keys` and `desc` are used? ",
      "created_at" : "2019-01-09T22:32:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-452894386",
      "id" : 452894386,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1Mjg5NDM4Ng==",
      "updated_at" : "2019-01-09T22:32:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/452894386",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> you mean deprecate keys in importmulti or error if keys and desc are used?\r\n\r\nWe can't deprecate `keys` in `importmulti`. That field is still required if importing a script not using a descriptor. My suggestion would be to error if `desc` and `keys` are provided in the same import object (in the same way that this PR errors if both `desc` and `scriptPubKey` are provided).\r\n\r\nBut perhaps I don't have full context, and importing with a descriptor and private keys provided separately is important functionality. Looking forward to hearing meshcollider's input.",
      "created_at" : "2019-01-09T22:54:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-452900217",
      "id" : 452900217,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1MjkwMDIxNw==",
      "updated_at" : "2019-01-09T22:54:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/452900217",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery I think it's reasonable to have a shared fully-public descriptor that all participants know, and each has their own private key stored separately. It may be inconvenient to first need a utility to combine the public descriptor with private keys before importing.",
      "created_at" : "2019-01-09T23:32:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-452909497",
      "id" : 452909497,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1MjkwOTQ5Nw==",
      "updated_at" : "2019-01-09T23:32:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/452909497",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Agree with sipa, I don't see a reason for limiting one way or the other just for the sake of limitation, this flexibility seems potentially useful unless there's a case against it",
      "created_at" : "2019-01-10T10:41:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-453050808",
      "id" : 453050808,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1MzA1MDgwOA==",
      "updated_at" : "2019-01-10T10:41:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/453050808",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247184235"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/247184235"
         }
      },
      "author_association" : "MEMBER",
      "body" : "misindentation. I think the changes to the `warnings` and `result` handling here are an unintentional reversion of the changes from #14565: https://github.com/bitcoin/bitcoin/pull/14565/files#diff-522490d83dce5375d423b23886e4125eR1122.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-11T16:53:08Z",
      "diff_hunk" : "@@ -1100,27 +1198,36 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n         }\n-        if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n-            if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+\n+        for (const CScript& script : script_pub_keys) {\n+            if (!have_solving_data || !::IsMine(*pwallet, script)) { // Always call AddWatchOnly for non-solvable watch-only, so that watch timestamp gets updated\n+                if (!pwallet->AddWatchOnly(script, timestamp)) {\n+                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+                }\n+            }\n+            CTxDestination dest;\n+            ExtractDestination(script, dest);\n+            if (!internal) {\n+                assert(IsValidDestination(dest));\n+                pwallet->SetAddressBook(dest, label, \"receive\");\n             }\n-        }\n-        if (!internal) {\n-            assert(IsValidDestination(dest));\n-            pwallet->SetAddressBook(dest, label, \"receive\");\n         }\n \n+        UniValue result = UniValue(UniValue::VOBJ);\n         result.pushKV(\"success\", UniValue(true));\n-    } catch (const UniValue& e) {\n-        result.pushKV(\"success\", UniValue(false));\n-        result.pushKV(\"error\", e);\n-    } catch (...) {\n-        result.pushKV(\"success\", UniValue(false));\n-\n-        result.pushKV(\"error\", JSONRPCError(RPC_MISC_ERROR, \"Missing required fields\"));\n-    }\n-    if (warnings.size()) result.pushKV(\"warnings\", warnings);\n-    return result;\n+         if (warnings.size()) result.pushKV(\"warnings\", warnings);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247184235",
      "id" : 247184235,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NzE4NDIzNQ==",
      "original_commit_id" : "63b669bf4d9c6effa5465ed2e843fb7d61e5a2da",
      "original_position" : 422,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 191751385,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/247184235",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247184778"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/247184778"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Descriptors will still be a relatively new concept for most users. Is it possible to link to the documentation here: https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md?",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-11T16:54:43Z",
      "diff_hunk" : "@@ -0,0 +1,4 @@\n+Descriptor import support\n+---------------------\n+\n+The `importmulti` RPC now supports importing of addresses from descriptors. A \"desc\" parameter can be provided instead of the \"scriptPubKey\" in a request, as well as an optional range for ranged descriptors to specify the start and end of the range to import.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247184778",
      "id" : 247184778,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NzE4NDc3OA==",
      "original_commit_id" : "63b669bf4d9c6effa5465ed2e843fb7d61e5a2da",
      "original_position" : 4,
      "path" : "doc/release-notes-14491.md",
      "position" : null,
      "pull_request_review_id" : 191751385,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/247184778",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247192015"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/247192015"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this is correct, as it will cause import of all involved public keys as watch-only (even for example the public keys that are part of a multisig).",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-11T17:17:47Z",
      "diff_hunk" : "@@ -923,154 +924,251 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247192015",
      "id" : 247192015,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NzE5MjAxNQ==",
      "original_commit_id" : "63b669bf4d9c6effa5465ed2e843fb7d61e5a2da",
      "original_position" : 252,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 275,
      "pull_request_review_id" : 191761299,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/247192015",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've had a go at rearranging the commits for this PR in a branch here: https://github.com/jnewbery/bitcoin/tree/pr14491.rearrange. It splits up the code move and new functionality, so with `-w` and `--color-moved=zebra` for the move commits, it should be a lot easier to review (review hints are in the commit log). I've also made a very minor change that undoes the reversion here: https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247184235.\r\n\r\nI think splitting up the commits in this way makes the PR much easier to review. @MeshCollider - feel free to grab that branch if you agree.",
      "created_at" : "2019-01-11T22:10:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-453673095",
      "id" : 453673095,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1MzY3MzA5NQ==",
      "updated_at" : "2019-01-11T22:10:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/453673095",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery thanks, that is indeed way more readable. For those looking on Github, you can use `?w=1`. So that just leaves my request for more tests.\r\n\r\nI'm quite happy with how short the meat of this change in https://github.com/bitcoin/bitcoin/commit/e7c45d7eb425fbe8c7b9f92d21d10c99145d3771 is.",
      "created_at" : "2019-01-15T12:39:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-454378499",
      "id" : 454378499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NDM3ODQ5OQ==",
      "updated_at" : "2019-01-15T12:39:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/454378499",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery Thanks! I've grabbed your branch, and I'll address the few other comments shortly",
      "created_at" : "2019-01-16T09:56:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-454719824",
      "id" : 454719824,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NDcxOTgyNA==",
      "updated_at" : "2019-01-16T09:56:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/454719824",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "`wallet_importmulti.py` fails when rebased on master due to test refactor.\r\n\r\nI've rebased my branch on master and fixed the test here: https://github.com/jnewbery/bitcoin/commit/087ba0734ee24438b2f495367c71fb257bb5b760",
      "created_at" : "2019-01-16T15:29:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-454820724",
      "id" : 454820724,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NDgyMDcyNA==",
      "updated_at" : "2019-01-16T15:29:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/454820724",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r249164864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249164864"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I could imagine this being an annoying failure mode if you try to import a ranged descriptor where the range is over something you've already imported. The error message doesn't give any indication of which script_pub_key caused the import to fail.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-18T19:46:34Z",
      "diff_hunk" : "@@ -923,154 +924,256 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n             privkey_map.emplace(id, key);\n         }\n+    }\n+\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n+\n+    return warnings;\n+}\n \n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    UniValue warnings(UniValue::VARR);\n+    UniValue result(UniValue::VOBJ);\n+\n+    try {\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         // Internal addresses should not have a label\n         if (internal && data.exists(\"label\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n+        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n-        // Verify and process input data\n-        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n-        if (have_solving_data) {\n-            // Match up data in import_data with the scriptPubKey in script.\n-            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n-\n-            // Verify whether the watchonly option corresponds to the availability of private keys.\n-            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n-            if (!watchOnly && !spendable) {\n-                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n-            }\n-            if (watchOnly && spendable) {\n-                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n-            }\n-\n-            // Check that all required keys for solvability are provided.\n-            if (error.empty()) {\n-                for (const auto& require_key : import_data.used_keys) {\n-                    if (!require_key.second) continue; // Not a required key\n-                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n-                        error = \"some required keys are missing\";\n-                    }\n-                }\n-            }\n-\n-            if (!error.empty()) {\n-                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n-                import_data = ImportData();\n-                pubkey_map.clear();\n-                privkey_map.clear();\n-                have_solving_data = false;\n-            } else {\n-                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n-                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n-                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n-                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    if (import_data.used_keys.count(oldit->first) == 0) {\n-                        warnings.push_back(\"Ignoring irrelevant private key.\");\n-                        privkey_map.erase(oldit);\n-                    }\n-                }\n-                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    auto key_data_it = import_data.used_keys.find(oldit->first);\n-                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n-                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n-                        pubkey_map.erase(oldit);\n-                    }\n-                }\n-            }\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        std::map<CKeyID, CKey> privkey_map;\n+        std::set<CScript> script_pub_keys;\n+        bool have_solving_data;\n+\n+        if (data.exists(\"scriptPubKey\") && data.exists(\"desc\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Both a descriptor and a scriptPubKey should not be provided.\");\n+        } else if (data.exists(\"scriptPubKey\")) {\n+            warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+        } else if (data.exists(\"desc\")) {\n+            warnings = ProcessImportDescriptor(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");\n         }\n \n         // Check whether we have any work to do\n-        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        for (const CScript& script : script_pub_keys) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r249164864",
      "id" : 249164864,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTE2NDg2NA==",
      "original_commit_id" : "087ba0734ee24438b2f495367c71fb257bb5b760",
      "original_position" : 380,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 399,
      "pull_request_review_id" : 194255568,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249164864",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250388156"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250388156"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[wallet] Refactor ProcessImport()\" (34a7ce3d5cf3651e117502ab742087e966cd6ef2)\r\n\r\nIt's confusing that these `script` and `dest` variables still declared here at a top level, when their actual usages after this error-checking block are now gone. Would suggest dropping `script` variable and calling `script_pub_keys.emplace(GetScriptForDestination(...))` directly, and just declaring `dest` variables as needed where they are used. It's not good to have these generically named variables with 150 line scopes that just get shadowed later and never used.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-23T21:56:47Z",
      "diff_hunk" : "@@ -942,9 +955,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n         const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n         const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250388156",
      "id" : 250388156,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDM4ODE1Ng==",
      "original_commit_id" : "34a7ce3d5cf3651e117502ab742087e966cd6ef2",
      "original_position" : 29,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 195764069,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250388156",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250393053"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250393053"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[wallet] Allow descriptor imports with importmulti\" (a0e341061463a25917d9faf4099219e71f982564)\r\n\r\nCould also trigger an error if a range is specified for a non-descriptor import.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-23T22:12:24Z",
      "diff_hunk" : "@@ -1062,6 +1063,83 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250393053",
      "id" : 250393053,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDM5MzA1Mw==",
      "original_commit_id" : "a0e341061463a25917d9faf4099219e71f982564",
      "original_position" : 28,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 213,
      "pull_request_review_id" : 195764069,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250393053",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250393989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250393989"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[wallet] Allow descriptor imports with importmulti\" (a0e341061463a25917d9faf4099219e71f982564)\r\n\r\nCould error check for `0 <= start <= end`",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-23T22:15:36Z",
      "diff_hunk" : "@@ -1062,6 +1063,83 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+        }\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n+        }\n+        range_end = range[\"end\"].get_int64();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250393989",
      "id" : 250393989,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDM5Mzk4OQ==",
      "original_commit_id" : "a0e341061463a25917d9faf4099219e71f982564",
      "original_position" : 38,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 241,
      "pull_request_review_id" : 195764069,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250393989",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250397357"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250397357"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[wallet] Allow descriptor imports with importmulti\" (a0e341061463a25917d9faf4099219e71f982564)\r\n\r\nIt seems like all these warnings should be errors. I think the only reason for having warnings and supporting these nonsensical rpc calls was to provide backwards compatibility, which shouldn't be a concern here.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-23T22:26:37Z",
      "diff_hunk" : "@@ -1108,14 +1117,25 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         }\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID id = pubkey.GetID();\n+\n         // Check if this private key corresponds to a public key from the descriptor\n         if (!pubkey_map.count(id)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+            warnings.push_back(\"Ignoring irrelevant private key.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250397357",
      "id" : 250397357,
      "in_reply_to_id" : 245677784,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDM5NzM1Nw==",
      "original_commit_id" : "5330527724c9af9e79eafc6c5fc9df62e7695161",
      "original_position" : 40,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 288,
      "pull_request_review_id" : 195764069,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250397357",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250398876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250398876"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247192015\r\n\r\nIn commit \"[wallet] Allow descriptor imports with importmulti\" (a0e341061463a25917d9faf4099219e71f982564)\r\n\r\n> I don't think this is correct, as it will cause import of all involved public keys as watch-only (even for example the public keys that are part of a multisig).\r\n\r\nIs this issue still unresolved? In earlier discusion https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327, it seemed to be. Either way it would be helpful to have a short comment here saying what effect adding these to pubkey_map has on solvability or wallet balances or whatever.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-23T22:31:46Z",
      "diff_hunk" : "@@ -923,154 +924,251 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250398876",
      "id" : 250398876,
      "in_reply_to_id" : 247192015,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDM5ODg3Ng==",
      "original_commit_id" : "63b669bf4d9c6effa5465ed2e843fb7d61e5a2da",
      "original_position" : 252,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 275,
      "pull_request_review_id" : 195764069,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250398876",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250399809"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250399809"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[wallet] Allow descriptor imports with importmulti\" (a0e341061463a25917d9faf4099219e71f982564)\r\n\r\n> // This does not take into account threshold multisigs which could be spendable without all keys\r\n\r\nWhat does this mean? Is this something that needs to be documented for the user? Something that needs to be fixed later? Comment should be made more clear.\r\n",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-23T22:35:06Z",
      "diff_hunk" : "@@ -1062,6 +1063,83 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+        }\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n+        }\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n+        }\n+    }\n+\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250399809",
      "id" : 250399809,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDM5OTgwOQ==",
      "original_commit_id" : "a0e341061463a25917d9faf4099219e71f982564",
      "original_position" : 77,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 195764069,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250399809",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250820734"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250820734"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@ryanofsky `script` is used below, in the `RecurseImportData` call. I have reduced the scope of `dest` though.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-24T23:44:46Z",
      "diff_hunk" : "@@ -942,9 +955,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n         const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n         const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n         // Generate the script and destination for the scriptPubKey provided\n         CScript script;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250820734",
      "id" : 250820734,
      "in_reply_to_id" : 250388156,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDgyMDczNA==",
      "original_commit_id" : "34a7ce3d5cf3651e117502ab742087e966cd6ef2",
      "original_position" : 29,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 196304244,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250820734",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250820770"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250820770"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-24T23:44:56Z",
      "diff_hunk" : "@@ -923,154 +924,256 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n             privkey_map.emplace(id, key);\n         }\n+    }\n+\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n+\n+    return warnings;\n+}\n \n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    UniValue warnings(UniValue::VARR);\n+    UniValue result(UniValue::VOBJ);\n+\n+    try {\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         // Internal addresses should not have a label\n         if (internal && data.exists(\"label\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n+        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n-        // Verify and process input data\n-        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n-        if (have_solving_data) {\n-            // Match up data in import_data with the scriptPubKey in script.\n-            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n-\n-            // Verify whether the watchonly option corresponds to the availability of private keys.\n-            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n-            if (!watchOnly && !spendable) {\n-                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n-            }\n-            if (watchOnly && spendable) {\n-                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n-            }\n-\n-            // Check that all required keys for solvability are provided.\n-            if (error.empty()) {\n-                for (const auto& require_key : import_data.used_keys) {\n-                    if (!require_key.second) continue; // Not a required key\n-                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n-                        error = \"some required keys are missing\";\n-                    }\n-                }\n-            }\n-\n-            if (!error.empty()) {\n-                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n-                import_data = ImportData();\n-                pubkey_map.clear();\n-                privkey_map.clear();\n-                have_solving_data = false;\n-            } else {\n-                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n-                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n-                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n-                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    if (import_data.used_keys.count(oldit->first) == 0) {\n-                        warnings.push_back(\"Ignoring irrelevant private key.\");\n-                        privkey_map.erase(oldit);\n-                    }\n-                }\n-                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    auto key_data_it = import_data.used_keys.find(oldit->first);\n-                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n-                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n-                        pubkey_map.erase(oldit);\n-                    }\n-                }\n-            }\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        std::map<CKeyID, CKey> privkey_map;\n+        std::set<CScript> script_pub_keys;\n+        bool have_solving_data;\n+\n+        if (data.exists(\"scriptPubKey\") && data.exists(\"desc\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Both a descriptor and a scriptPubKey should not be provided.\");\n+        } else if (data.exists(\"scriptPubKey\")) {\n+            warnings = ProcessImportLegacy(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+        } else if (data.exists(\"desc\")) {\n+            warnings = ProcessImportDescriptor(import_data, pubkey_map, privkey_map, script_pub_keys, have_solving_data, data);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");\n         }\n \n         // Check whether we have any work to do\n-        if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        for (const CScript& script : script_pub_keys) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250820770",
      "id" : 250820770,
      "in_reply_to_id" : 249164864,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDgyMDc3MA==",
      "original_commit_id" : "087ba0734ee24438b2f495367c71fb257bb5b760",
      "original_position" : 380,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 399,
      "pull_request_review_id" : 196304302,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250820770",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250821601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250821601"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-24T23:49:08Z",
      "diff_hunk" : "@@ -1062,6 +1063,83 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+        }\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n+        }\n+        range_end = range[\"end\"].get_int64();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250821601",
      "id" : 250821601,
      "in_reply_to_id" : 250393989,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDgyMTYwMQ==",
      "original_commit_id" : "a0e341061463a25917d9faf4099219e71f982564",
      "original_position" : 38,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 241,
      "pull_request_review_id" : 196305347,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250821601",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250821619"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250821619"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-24T23:49:14Z",
      "diff_hunk" : "@@ -1062,6 +1063,83 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250821619",
      "id" : 250821619,
      "in_reply_to_id" : 250393053,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDgyMTYxOQ==",
      "original_commit_id" : "a0e341061463a25917d9faf4099219e71f982564",
      "original_position" : 28,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 213,
      "pull_request_review_id" : 196305375,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250821619",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250822431"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250822431"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-24T23:53:27Z",
      "diff_hunk" : "@@ -923,154 +924,251 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r250822431",
      "id" : 250822431,
      "in_reply_to_id" : 247192015,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDgyMjQzMQ==",
      "original_commit_id" : "63b669bf4d9c6effa5465ed2e843fb7d61e5a2da",
      "original_position" : 252,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 275,
      "pull_request_review_id" : 196306365,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250822431",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I think you've now changed it to never importing public keys.\r\n\r\nIf I import \"pkh(036f1aef8329e88a8e7dca56a4e8f908697555478b26709f7513eba54db4acea21)\", and subsequently call `getaddressinfo 1H2JaLY37d3PeqGgMV6yDStzHqenoRcCYF`, it says \"solvable: False\". All information for solvability is available, however.\r\n",
      "created_at" : "2019-01-25T01:17:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-457420341",
      "id" : 457420341,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NzQyMDM0MQ==",
      "updated_at" : "2019-01-25T01:24:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457420341",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The following tests reproduces what @sipa found:\r\n\r\n```python\r\n        # Test importing of a P2PKH address via descriptor\r\n        key = get_key(self.nodes[0])\r\n        self.log.info(\"Should import a p2pkh address from descriptor\")\r\n        self.test_importmulti({\"desc\": \"pkh(\" + key.pubkey + \")\",\r\n                               \"timestamp\": \"now\",\r\n                               \"label\": \"Descriptor import test\"},\r\n                              True,\r\n                              warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\r\n        test_address(self.nodes[1],\r\n                     key.p2pkh_addr,\r\n                     solvable=True,\r\n                     ismine=False,\r\n                     label=\"Descriptor import test\")\r\n```",
      "created_at" : "2019-01-25T11:23:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-457542647",
      "id" : 457542647,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NzU0MjY0Nw==",
      "updated_at" : "2019-01-25T11:23:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457542647",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "More IRC discussion: http://www.erisian.com.au/bitcoin-core-dev/log-2019-01-24.html#l-742\r\n\r\nBeyond the immediate bug that's been found, I'm confused about the pubkey issues being discussed:\r\nhttps://github.com/bitcoin/bitcoin/pull/14491#discussion_r247192015, https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327. Just at a really high level it's not clear to me if there is:\r\n\r\n1. One clearly correct solution to implement in this PR.\r\n2. One solution to implement in this PR that is clearly better than alternatives, but with known limitations that can be addressed later.\r\n3. Disagreement about multiple solutions with different tradeoffs.\r\n\r\n@sipa / @MeshCollider if you could clarify whether the situation is (1), (2), or (3), it would help the discussion make more sense...",
      "created_at" : "2019-01-25T14:38:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-457592612",
      "id" : 457592612,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NzU5MjYxMg==",
      "updated_at" : "2019-01-25T14:38:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457592612",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ryanofsky I suspect this is subjective, but this is my view:\r\n\r\n* Due to the inherent quirks in the current IsMine logic, we can't guarantee that *just* the exact scriptPubKey implied by the provided descriptor will match. If that was possible, it would be the obvious solution - but it's a choice we make by implementing this as a layer on top of the existing IsMine logic.\r\n* A strong requirement in my view is that all the things that are imported are \"policy compatible\" with the descriptor. By that I mean that all scriptPubKeys made watched by importing a descriptor must be spendable by the same group of keys that can spend the sPK corresponding to the descriptor. If this is violated, you risk accepting a payment to something you can't spend.\r\n* A weaker requirement is that whenever all information for solvability is present in the descriptor, the output is considered solvable.\r\n\r\nI believe the above is all possible with the current IsMine logic, so I think it's the most obvious solution. It requires only importing the public keys which occur inside P2PKH/P2WPKH, but not those inside multisig.",
      "created_at" : "2019-01-25T17:58:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-457661534",
      "id" : 457661534,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NzY2MTUzNA==",
      "updated_at" : "2019-01-25T17:58:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457661534",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MeshCollider See #15263, that should make it easier.",
      "created_at" : "2019-01-25T18:38:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-457676056",
      "id" : 457676056,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NzY3NjA1Ng==",
      "updated_at" : "2019-01-25T18:38:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457676056",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Tested a bit and works as expected (limited tests).\r\nA nitpick would be why the range is a JSON object rather then an array with two items.",
      "created_at" : "2019-01-29T21:03:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-458705799",
      "id" : 458705799,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1ODcwNTc5OQ==",
      "updated_at" : "2019-01-29T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/458705799",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jonasschnelli I had the array initially, but the RPCHelpMan doesn't support that kind of help output so I just changed it",
      "created_at" : "2019-01-29T23:57:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-458755954",
      "id" : 458755954,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1ODc1NTk1NA==",
      "updated_at" : "2019-01-29T23:57:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/458755954",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252137642"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252137642"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: `const auto` for consistency",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-30T07:11:14Z",
      "diff_hunk" : "@@ -923,154 +924,263 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    if (data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for a non-descriptor import\");\n+    }\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    if (!isScript) {\n+        CTxDestination dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        CTxDestination dest;\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252137642",
      "id" : 252137642,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MjEzNzY0Mg==",
      "original_commit_id" : "02f1a89a609269899d78cbba30f0b6be05b5b615",
      "original_position" : 268,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 197929612,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252137642",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252138433"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252138433"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this line deserves to be 3 lines\r\n```C++\r\nbool spendable = std::all_of(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), [&](const std::pair<CKeyID, CPubKey>& used_key) {\r\n   return privkey_map.count(used_key.first) > 0;\r\n});\r\n```\r\nI would even argue it could do with 4\r\n```C++\r\nbool spendable = std::all_of(out_keys.pubkeys.begin(), out_keys.pubkeys.end(),\r\n   [&](const std::pair<CKeyID, CPubKey>& used_key) {\r\n      return privkey_map.count(used_key.first) > 0;\r\n   });\r\n```",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-30T07:15:03Z",
      "diff_hunk" : "@@ -923,154 +924,263 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    if (data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for a non-descriptor import\");\n+    }\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    if (!isScript) {\n+        CTxDestination dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        CTxDestination dest;\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!out_keys.pubkeys.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n             privkey_map.emplace(id, key);\n         }\n+    }\n \n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys.\n+    // Thus, threshold multisigs without all keys will be considered not spendable here, even if they are,\n+    // perhaps triggering a false warning message. This is consistent with the current wallet IsMine check.\n+    bool spendable = std::all_of(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252138433",
      "id" : 252138433,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MjEzODQzMw==",
      "original_commit_id" : "02f1a89a609269899d78cbba30f0b6be05b5b615",
      "original_position" : 293,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 197929612,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252138433",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252138889"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252138889"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could just do\r\n```C++\r\n= data.exists(\"internal\") && data[\"internal\"].get_bool()\r\n```",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-30T07:17:30Z",
      "diff_hunk" : "@@ -923,154 +924,263 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    if (data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for a non-descriptor import\");\n+    }\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    if (!isScript) {\n+        CTxDestination dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        CTxDestination dest;\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!out_keys.pubkeys.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n             privkey_map.emplace(id, key);\n         }\n+    }\n \n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys.\n+    // Thus, threshold multisigs without all keys will be considered not spendable here, even if they are,\n+    // perhaps triggering a false warning message. This is consistent with the current wallet IsMine check.\n+    bool spendable = std::all_of(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n+\n+    return warnings;\n+}\n+\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    UniValue warnings(UniValue::VARR);\n+    UniValue result(UniValue::VOBJ);\n+\n+    try {\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252138889",
      "id" : 252138889,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MjEzODg4OQ==",
      "original_commit_id" : "02f1a89a609269899d78cbba30f0b6be05b5b615",
      "original_position" : 310,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 318,
      "pull_request_review_id" : 197929612,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252138889",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252139232"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252139232"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This sentence looks weird. `\"Descriptors and scriptPubKeys cannot be used at the same time.\"` maybe?",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-01-30T07:19:15Z",
      "diff_hunk" : "@@ -923,154 +924,263 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    if (data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for a non-descriptor import\");\n+    }\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    if (!isScript) {\n+        CTxDestination dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        CTxDestination dest;\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!out_keys.pubkeys.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n             privkey_map.emplace(id, key);\n         }\n+    }\n \n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys.\n+    // Thus, threshold multisigs without all keys will be considered not spendable here, even if they are,\n+    // perhaps triggering a false warning message. This is consistent with the current wallet IsMine check.\n+    bool spendable = std::all_of(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n+\n+    return warnings;\n+}\n+\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    UniValue warnings(UniValue::VARR);\n+    UniValue result(UniValue::VOBJ);\n+\n+    try {\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         // Internal addresses should not have a label\n         if (internal && data.exists(\"label\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n         }\n+        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n \n-        // Verify and process input data\n-        bool have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n-        if (have_solving_data) {\n-            // Match up data in import_data with the scriptPubKey in script.\n-            auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n-\n-            // Verify whether the watchonly option corresponds to the availability of private keys.\n-            bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n-            if (!watchOnly && !spendable) {\n-                warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n-            }\n-            if (watchOnly && spendable) {\n-                warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n-            }\n-\n-            // Check that all required keys for solvability are provided.\n-            if (error.empty()) {\n-                for (const auto& require_key : import_data.used_keys) {\n-                    if (!require_key.second) continue; // Not a required key\n-                    if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n-                        error = \"some required keys are missing\";\n-                    }\n-                }\n-            }\n-\n-            if (!error.empty()) {\n-                warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n-                import_data = ImportData();\n-                pubkey_map.clear();\n-                privkey_map.clear();\n-                have_solving_data = false;\n-            } else {\n-                // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n-                if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n-                if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n-                for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    if (import_data.used_keys.count(oldit->first) == 0) {\n-                        warnings.push_back(\"Ignoring irrelevant private key.\");\n-                        privkey_map.erase(oldit);\n-                    }\n-                }\n-                for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n-                    auto oldit = it++;\n-                    auto key_data_it = import_data.used_keys.find(oldit->first);\n-                    if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n-                        warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n-                        pubkey_map.erase(oldit);\n-                    }\n-                }\n-            }\n+        ImportData import_data;\n+        std::map<CKeyID, CPubKey> pubkey_map;\n+        std::map<CKeyID, CKey> privkey_map;\n+        std::set<CScript> script_pub_keys;\n+        bool have_solving_data;\n+\n+        if (data.exists(\"scriptPubKey\") && data.exists(\"desc\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Both a descriptor and a scriptPubKey should not be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r252139232",
      "id" : 252139232,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MjEzOTIzMg==",
      "original_commit_id" : "02f1a89a609269899d78cbba30f0b6be05b5b615",
      "original_position" : 375,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 356,
      "pull_request_review_id" : 197929612,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T06:43:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/252139232",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I took a stab at rebasing this, but it was absolute hell :-) Maybe @achow101 has more luck...",
      "created_at" : "2019-02-02T20:51:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-459998190",
      "id" : 459998190,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1OTk5ODE5MA==",
      "updated_at" : "2019-02-02T20:51:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/459998190",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "https://github.com/achow101/bitcoin/tree/rebase-14491 is a rebase of this which handles the merge conflicts caused by #15235. It does not account for #15263 (even though that is in it's history).",
      "created_at" : "2019-02-03T03:53:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-460020798",
      "id" : 460020798,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ2MDAyMDc5OA==",
      "updated_at" : "2019-02-03T03:53:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/460020798",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've rebased and squashed as well as added some more tests for descriptor imports and fixed the public key issue now #15263 has gone in",
      "created_at" : "2019-02-05T06:44:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-460530914",
      "id" : 460530914,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ2MDUzMDkxNA==",
      "updated_at" : "2019-02-05T06:44:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/460530914",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253794196"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253794196"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: add (TODO to add) `expandRange` method to Descriptor instance",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T09:50:35Z",
      "diff_hunk" : "@@ -1103,6 +1108,91 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+        }\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n+        }\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n+        }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253794196",
      "id" : 253794196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1Mzc5NDE5Ng==",
      "original_commit_id" : "9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
      "original_position" : 74,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 264,
      "pull_request_review_id" : 199985648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T09:59:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253794196",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253804289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253804289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@Sjors this TODO is addressed in #15024 :)",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T10:20:40Z",
      "diff_hunk" : "@@ -1103,6 +1108,91 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+        }\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n+        }\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n+        }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253804289",
      "id" : 253804289,
      "in_reply_to_id" : 253794196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MzgwNDI4OQ==",
      "original_commit_id" : "9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
      "original_position" : 74,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 264,
      "pull_request_review_id" : 199998482,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T10:20:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253804289",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T15:25:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-460679053",
      "id" : 460679053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ2MDY3OTA1Mw==",
      "updated_at" : "2019-02-05T15:25:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/460679053",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253976779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253976779"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/14491#discussion_r245677784\r\n\r\nThese comments don't appear to be resolved, but I think that's ok.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T17:54:53Z",
      "diff_hunk" : "@@ -1108,14 +1117,25 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         }\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID id = pubkey.GetID();\n+\n         // Check if this private key corresponds to a public key from the descriptor\n         if (!pubkey_map.count(id)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+            warnings.push_back(\"Ignoring irrelevant private key.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253976779",
      "id" : 253976779,
      "in_reply_to_id" : 245677784,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1Mzk3Njc3OQ==",
      "original_commit_id" : "5330527724c9af9e79eafc6c5fc9df62e7695161",
      "original_position" : 40,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 288,
      "pull_request_review_id" : 200217334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T22:16:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253976779",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253985234"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253985234"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[wallet] Allow descriptor imports with importmulti\" (9f48053d8f9a1feacc96d7e2a00c8a3a67576948)\r\n\r\nIt would be really nice to move this duplicated watchonly checking code out of `ProcessLegacy` and `ProcessImportDescriptor` either up into `ProcessImport` or down to into a common helper function. The watchonly checks are weird enough to deal with once, much less twice in two functions with slightly different variable names and comments.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T18:17:05Z",
      "diff_hunk" : "@@ -1103,6 +1108,91 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     return warnings;\n }\n \n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+        }\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n+        }\n+        range_end = range[\"end\"].get_int64();\n+        if (range_end < range_start || range_start < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid descriptor range specified\");\n+        }\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (const auto& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n+        }\n+    }\n+\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys.\n+    // Thus, threshold multisigs without all keys will be considered not spendable here, even if they are,\n+    // perhaps triggering a false warning message. This is consistent with the current wallet IsMine check.\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r253985234",
      "id" : 253985234,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1Mzk4NTIzNA==",
      "original_commit_id" : "9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
      "original_position" : 108,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 298,
      "pull_request_review_id" : 200217334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T22:16:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253985234",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254008101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254008101"
         }
      },
      "author_association" : "MEMBER",
      "body" : "looks like it came: https://github.com/bitcoin/bitcoin/pull/14491/commits/fbb5e935eaf17d603ec62e1a704a174235540b71#diff-3dfbfa462305488434b8d8da81f99de7R613",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T19:17:08Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254008101",
      "id" : 254008101,
      "in_reply_to_id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NDAwODEwMQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 362,
      "pull_request_review_id" : 200255739,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T19:17:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254008101",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254019674"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254019674"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/14491#discussion_r244194544\r\n\r\n> s/specify the watchonly flag/specify the watchonly flag to suppress this warning/\r\n\r\nNote: implementing this suggestion would make the warning text vary between `ProcessImportLegacy` and `ProcessImportDescriptor`.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T19:47:06Z",
      "diff_hunk" : "@@ -1108,14 +1117,25 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n         }\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID id = pubkey.GetID();\n+\n         // Check if this private key corresponds to a public key from the descriptor\n         if (!pubkey_map.count(id)) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n         }\n-        privkey_map.emplace(id, key);\n     }\n \n-    // TODO: add warnings if private keys don't correspond to watch-only\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254019674",
      "id" : 254019674,
      "in_reply_to_id" : 244194544,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NDAxOTY3NA==",
      "original_commit_id" : "5330527724c9af9e79eafc6c5fc9df62e7695161",
      "original_position" : 52,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 303,
      "pull_request_review_id" : 200217334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T22:16:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254019674",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254028414"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254028414"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[wallet] Allow descriptor imports with importmulti\" (9f48053d8f9a1feacc96d7e2a00c8a3a67576948)\r\n\r\nNote: Changes here more are directly related to previous commit \"[wallet] Refactor ProcessImport()\" (a1b25e12a5f57048a4639964d57c0b46eb84cd4e) than this one.",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T20:12:26Z",
      "diff_hunk" : "@@ -984,11 +985,14 @@ static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CP\n     const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n     const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n+    if (data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for a non-descriptor import\");\n+    }\n+\n     // Generate the script and destination for the scriptPubKey provided\n     CScript script;\n-    CTxDestination dest;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254028414",
      "id" : 254028414,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NDAyODQxNA==",
      "original_commit_id" : "9f48053d8f9a1feacc96d7e2a00c8a3a67576948",
      "original_position" : 18,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 200217334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T22:16:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254028414",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254063220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254063220"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/14491#discussion_r247192015\r\n\r\nFor future reference, this was fixed by removing `out.pubkeys.emplace` in #15263.\r\n\r\nI think it would be helpful to have a comment here noting that this imports the public keys which occur inside P2PKH and P2WPKH descriptors, but not those inside multisig descriptors. It would also be great to include or link to sipa's rationale for this in https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-457661534",
      "commit_id" : "b985e9c850ea682eced7021faf6c7c835066c61b",
      "created_at" : "2019-02-05T21:57:26Z",
      "diff_hunk" : "@@ -923,154 +924,251 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r254063220",
      "id" : 254063220,
      "in_reply_to_id" : 247192015,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NDA2MzIyMA==",
      "original_commit_id" : "63b669bf4d9c6effa5465ed2e843fb7d61e5a2da",
      "original_position" : 252,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 275,
      "pull_request_review_id" : 200217334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2019-02-05T22:16:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/254063220",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   }
]
