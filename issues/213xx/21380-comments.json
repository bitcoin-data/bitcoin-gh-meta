[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "~Because of the refactoring this will conflict heavily with other changes to versionbits. I've rebased #21377 on top of this and there's a height based variant at #21392.~ I think it should be possible to adapt to cover the rest of #19573, but haven't tried. It would require some refactoring of the bip8 code in order to be able to catch bugs in the MUST_SIGNAL handling, but maybe that's worthwhile anyway.\r\n\r\nParticularly interested in additional checks that could be added, or better ways of converting fuzz data into interesting chains to test. I've just hardcoded the intervals at 10 minutes, ~and currently the BIP9 timeouts will precisely match some block's time, which could be missing edge cases?~ So far it seems pretty reasonable though.",
      "created_at" : "2021-03-07T12:46:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792273605",
      "id" : 792273605,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjI3MzYwNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T11:30:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792273605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.",
      "created_at" : "2021-03-07T17:25:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792316498",
      "id" : 792316498,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjMxNjQ5OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-17T13:45:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792316498",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Particularly interested in additional checks that could be added\r\n\r\nMaybe some simple reorg testing, e.g. just invalidateblock around various thresholds to ensure we return to the previous state, then add a new block with a different timestamp to ensure we either advance or don't advance to the next state as is appropriate?",
      "created_at" : "2021-03-07T17:42:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792321707",
      "id" : 792321707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjMyMTcwNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-07T17:42:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792321707",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/61096?v=4",
         "events_url" : "https://api.github.com/users/harding/events{/privacy}",
         "followers_url" : "https://api.github.com/users/harding/followers",
         "following_url" : "https://api.github.com/users/harding/following{/other_user}",
         "gists_url" : "https://api.github.com/users/harding/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/harding",
         "id" : 61096,
         "login" : "harding",
         "node_id" : "MDQ6VXNlcjYxMDk2",
         "organizations_url" : "https://api.github.com/users/harding/orgs",
         "received_events_url" : "https://api.github.com/users/harding/received_events",
         "repos_url" : "https://api.github.com/users/harding/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/harding/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/harding/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/harding"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Strong Concept ACK\r\n\r\nVery excited to see the versionbits implementation more thoroughly fuzzed :)\r\n\r\nThanks!",
      "created_at" : "2021-03-07T18:34:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792330157",
      "id" : 792330157,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjMzMDE1Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-07T18:34:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792330157",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Maybe some simple reorg testing, e.g. just invalidateblock around various thresholds to ensure we return to the previous state, then add a new block with a different timestamp to ensure we either advance or don't advance to the next state as is appropriate?\r\n\r\nThat would make sense if versionbits knew about tips or cached blocks based on height, but it caches based on block hash and just relies on being able to query ancestors of whatever `CBlockIndex*` is passed in. Neither the fuzz tester nor the existing unit test set up the scenario sufficiently for invalidateblock to work.",
      "created_at" : "2021-03-07T23:26:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792373952",
      "id" : 792373952,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjM3Mzk1Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-07T23:26:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792373952",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code Review ACK 9c08af24e77980673efa30b5101451c3c8b20b1b\r\n\r\nThe cleanups to versionbits handling are nice. Skimmed over the fuzzer part, but did run it. It did catch a possible corner case in #21392.",
      "created_at" : "2021-03-09T04:23:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-793365701",
      "id" : 793365701,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MzM2NTcwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-09T04:23:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/793365701",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 9c08af24e77980673efa30b5101451c3c8b20b1b\r\n\r\nI managed to run the fuzzer (on linux), but haven't studied it in much detail. We should probably improve it in followups, so the PR's that build on top of the refactoring commits here can continue without rebase headaches.",
      "created_at" : "2021-03-09T12:21:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-793807435",
      "id" : 793807435,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MzgwNzQzNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-09T12:21:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/793807435",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I am not sure if it is good to hide validation code refactoring in a \"Add fuzzing harness\" pull",
      "created_at" : "2021-03-12T09:29:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-797361955",
      "id" : 797361955,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5NzM2MTk1NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-12T09:29:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/797361955",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I am not sure if it is good to hide validation code refactoring in a \"Add fuzzing harness\" pull\r\n\r\nIt's not mean to be hidden; the commits aren't subtle, it's called out in the description, and the labels are all there... The reason it's a single PR is that (I don't think) the fuzzer works without the refactoring, and without the fuzzer, there's not a lot of other tests to ensure the refactoring is correct...",
      "created_at" : "2021-03-12T21:40:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-797771240",
      "id" : 797771240,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5Nzc3MTI0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-12T21:40:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/797771240",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Maybe the title could be changed to \"Refactor versionbits to add fuzzing harness\" or so?",
      "created_at" : "2021-03-13T07:44:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-797884708",
      "id" : 797884708,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5Nzg4NDcwOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-13T07:44:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/797884708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.\r\n\r\nCan we remove `nRuleChangeActivationThreshold` from `Params` now that it's only used in the `WarningBitsConditionChecker`?",
      "created_at" : "2021-03-15T12:43:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799388832",
      "id" : 799388832,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTM4ODgzMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-15T12:43:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799388832",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nðµï¸ @sipa has been requested to review this pull request as specified in the REVIEWERS file.",
      "created_at" : "2021-03-15T16:49:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799573869",
      "id" : 799573869,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTU3Mzg2OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-15T16:49:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799573869",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-03-15T18:54:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799670259",
      "id" : 799670259,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTY3MDI1OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-15T18:54:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799670259",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Can we remove `nRuleChangeActivationThreshold` from `Params` now that it's only used in the `WarningBitsConditionChecker`?\r\n\r\nIt's still chain specific, so it could be moved from Consensus::Params to ChainParams (and renamed), but not removed entirely I think.",
      "created_at" : "2021-03-16T03:31:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799917074",
      "id" : 799917074,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTkxNzA3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T03:31:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799917074",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> The reason it's a single PR is that (I don't think) the fuzzer works without the refactoring, [...]\r\n\r\nThis turns out not to be the case. I'm having a go at changing the approach to fuzzing approach, and if that works out will probably split the refactoring out of this PR.\r\n",
      "created_at" : "2021-03-16T05:23:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799959690",
      "id" : 799959690,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTk1OTY5MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T05:23:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799959690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased and updated to only add the fuzzing harness and not do any refactoring.\r\n\r\nThis also changes the approach used for fuzzing to only sanity check one period's worth of blocks, rather than every period -- relying instead on different fuzz inputs to check different periods. Seems to be no less thorough, and much faster for fuzzing. Also might be a bit easier to understand.",
      "created_at" : "2021-03-16T11:31:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-800181058",
      "id" : 800181058,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMDE4MTA1OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T11:32:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/800181058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595099275"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595099275"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would you consider adding a few line breaks to these function declarations?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T11:55:40Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595099275",
      "id" : 595099275,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA5OTI3NQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595099275",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595102829"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595102829"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n} // namespace\r\n\r\nFUZZ_TARGET(versionbits)\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:00:15Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595102829",
      "id" : 595102829,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwMjgyOQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 105,
      "original_position" : 110,
      "original_start_line" : 103,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595102829",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595103941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595103941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    constexpr int period{32};\r\n    constexpr int threshold{29};\r\n\r\n    static_assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:01:55Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595103941",
      "id" : 595103941,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwMzk0MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : 114,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595103941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595104935"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595104935"
         }
      },
      "author_association" : "MEMBER",
      "body" : "style-nit: (add new line and clang-format to avoid excessive long lines)\r\n\r\n```suggestion\r\n    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\r\n    : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:03:30Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595104935",
      "id" : 595104935,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNDkzNQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595104935",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595105060"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595105060"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also consider s/period/PERIOD/ and s/threshold/THRESHOLD/",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:03:43Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595105060",
      "id" : 595105060,
      "in_reply_to_id" : 595103941,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNTA2MA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : 114,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595105060",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106496"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106496"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason not to make `blocks` a `std::vector<std::unique_ptr<CBlockIndex>>`, and let the default destructor take care of this for you?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:06:11Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106496",
      "id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNjQ5Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106496",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106608"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    std::vector<CBlockIndex*> m_blocks;\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:06:23Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106608",
      "id" : 595106608,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNjYwOA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106617"
         }
      },
      "author_association" : "MEMBER",
      "body" : "style-nit: Can be shorter\r\n\r\n```suggestion\r\nFUZZ_TARGET(versionbits)\r\n```\r\n",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:06:24Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106617",
      "id" : 595106617,
      "line" : 105,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNjYxNw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 105,
      "original_position" : 110,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 105,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595108166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595108166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "shouldn't this be a static assert? (With the constexpr symbols all uppercase)\r\n\r\nOr is the goal to have the fuzz engine pick the period length?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:08:46Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595108166",
      "id" : 595108166,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwODE2Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595108166",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109347"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe move this up next to the `n_blocks` declaration, make those constants `constexpr` and make this a static_assert.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:10:39Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109347",
      "id" : 595109347,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwOTM0Nw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 132,
      "original_position" : 132,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109600"
         }
      },
      "author_association" : "MEMBER",
      "body" : "would it be possible to use params.genesis.nTime instead of the copied value?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:11:03Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109600",
      "id" : 595109600,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwOTYwMA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 128,
      "original_position" : 128,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109600",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110128"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110128"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mind doing a clang-format, so that all files in `src/test/fuzz` are \"clean\"?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:11:53Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110128",
      "id" : 595110128,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExMDEyOA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 125,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110128",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110558"
         }
      },
      "author_association" : "MEMBER",
      "body" : "static_assert (with same comment from above)",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:12:34Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110558",
      "id" : 595110558,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExMDU1OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 132,
      "original_position" : 132,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595111407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595111407"
         }
      },
      "author_association" : "MEMBER",
      "body" : "would it be possible to use params.consensus.nPowTargetSpacing instead of the hardcoded value?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:13:42Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595111407",
      "id" : 595111407,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExMTQwNw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 146,
      "original_position" : 146,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595111407",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595114366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595114366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could replace with \r\n```suggestion\r\n    while (fuzzed_data_provider.ConsumeBool()) {\r\n```\r\n\r\nor mention that the provider is used up after this call and should not be accessed again?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T12:17:43Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595114366",
      "id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExNDM2Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595114366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595146970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595146970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        if (blocks.size() > 2 * n_blocks) break;\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:02:36Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't go too crazy with how many blocks we mine\n+        if (blocks.size() > 2*n_blocks) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595146970",
      "id" : 595146970,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE0Njk3MA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 206,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595146970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595147323"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595147323"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/n_blocks/max_blocks/",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:03:09Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595147323",
      "id" : 595147323,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE0NzMyMw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 120,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595147323",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595148151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595148151"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Wanted to leave it open for the threshold could be picked by the fuzzer at least. Changing the period makes the test take longer, so not sure how much sense it makes to fuzz that.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:04:19Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595148151",
      "id" : 595148151,
      "in_reply_to_id" : 595108166,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE0ODE1MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613215547,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595148151",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595151368"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595151368"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Move this declaration down to where it's used first.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:08:28Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595151368",
      "id" : 595151368,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE1MTM2OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 195,
      "original_position" : 195,
      "original_start_line" : 194,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595151368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595160435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595160435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Neither of these are used.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:19:55Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595160435",
      "id" : 595160435,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE2MDQzNQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 17,
      "original_position" : 17,
      "original_start_line" : 16,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595160435",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595161446"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595161446"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Couldn't the subsequent `ConsumeBool()` fail if this is the last byte in the data provider?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:21:12Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595161446",
      "id" : 595161446,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE2MTQ0Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 613233132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595161446",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595172488"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595172488"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Seemed easier to do it this way than to have to manually extract the raw pointers everywhere",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:34:11Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595172488",
      "id" : 595172488,
      "in_reply_to_id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE3MjQ4OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613247624,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595172488",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595173844"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595173844"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm deliberately getting the mask beforehand so that adding bytes at the end of the fuzz data just adds blocks and doesn't change what gets interpreted as a mask and what gets interpreted as a bool",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T13:35:46Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595173844",
      "id" : 595173844,
      "in_reply_to_id" : 595151368,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE3Mzg0NA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 195,
      "original_position" : 195,
      "original_start_line" : 194,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613249467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595173844",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595197898"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595197898"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you'd only need to change the `tip()` and `mine_block()` member functions:\r\n\r\n```diff\r\ndiff --git a/src/test/fuzz/versionbits.cpp b/src/test/fuzz/versionbits.cpp\r\nindex ded18d8602..1613f65586 100644\r\n--- a/src/test/fuzz/versionbits.cpp\r\n+++ b/src/test/fuzz/versionbits.cpp\r\n@@ -13,6 +13,7 @@\r\n #include <test/fuzz/util.h>\r\n \r\n #include <cstdint>\r\n+#include <memory>\r\n #include <optional>\r\n #include <string>\r\n #include <vector>\r\n@@ -60,7 +61,7 @@ public:\r\n class Blocks\r\n {\r\n private:\r\n-    std::vector<CBlockIndex*> blocks;\r\n+    std::vector<std::unique_ptr<CBlockIndex>> blocks;\r\n     const uint32_t m_start_time;\r\n     const int32_t m_signal;\r\n     const int32_t m_no_signal;\r\n@@ -68,19 +69,11 @@ private:\r\n public:\r\n     Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\r\n \r\n-    ~Blocks()\r\n-    {\r\n-        for (auto& v : blocks) {\r\n-            delete v;\r\n-        }\r\n-        blocks.clear();\r\n-    }\r\n-\r\n     size_t size() const { return blocks.size(); }\r\n \r\n     CBlockIndex* tip() const\r\n     {\r\n-        return blocks.empty() ? nullptr : blocks.back();\r\n+        return blocks.empty() ? nullptr : blocks.back().get();\r\n     }\r\n \r\n     CBlockIndex* mine_block(bool signal)\r\n@@ -90,14 +83,14 @@ public:\r\n         header.nTime = m_start_time + blocks.size() * 600;\r\n         header.nBits = 0x1d00ffff;\r\n \r\n-        CBlockIndex* current_block = new CBlockIndex{header};\r\n+        auto current_block = std::make_unique<CBlockIndex>(header);\r\n         current_block->pprev = tip();\r\n         current_block->nHeight = blocks.size();\r\n         current_block->BuildSkip();\r\n \r\n-        blocks.push_back(current_block);\r\n+        blocks.push_back(std::move(current_block));\r\n \r\n-        return current_block;\r\n+        return tip();\r\n     }\r\n };\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T14:02:17Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595197898",
      "id" : 595197898,
      "in_reply_to_id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE5Nzg5OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613281570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595197898",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595213695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595213695"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added the comment",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T14:19:27Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595213695",
      "id" : 595213695,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTIxMzY5NQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 613302546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595213695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Bunches of nits addressed.\r\n\r\n> This fuzz test is based on times, so I presume it will change again once activation is changed to be based on block heights?\r\n\r\nMy theory is having a fuzz test should make it easier to be confident a switch to heights isn't introducing new edge cases with bogus behaviour.",
      "created_at" : "2021-03-16T14:23:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-800302418",
      "id" : 800302418,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMDMwMjQxOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T14:23:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/800302418",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595279670"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595279670"
         }
      },
      "author_association" : "MEMBER",
      "body" : "ah! Makes sense. Thanks.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T15:26:20Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595279670",
      "id" : 595279670,
      "in_reply_to_id" : 595151368,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTI3OTY3MA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 195,
      "original_position" : 195,
      "original_start_line" : 194,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613391060,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595279670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595376481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595376481"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FuzzedDataProvider itself doesn't fail if the last byte was consumed. It will simply return constant values. In the case of bool, `false`. So using `ConsumeBool()` would be identical to `remaining_bytes`, with the difference that the fuzz input is one more byte large (to encode the consumed bool) per iteration. Also, `ConsumeBool` would leave open the possibility to use the data provider afterwards without invalidating the inputs.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T17:11:32Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595376481",
      "id" : 595376481,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTM3NjQ4MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 613515128,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595376481",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "concept ACK ",
      "created_at" : "2021-03-16T20:25:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-800579714",
      "id" : 800579714,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMDU3OTcxNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T20:25:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/800579714",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595598929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595598929"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, I think you're right -- was using `delete` prior to having made the `Blocks` class so there would have been more duplication then.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-16T23:03:40Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595598929",
      "id" : 595598929,
      "in_reply_to_id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTU5ODkyOQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613794808,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595598929",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595655261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595655261"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-17T01:46:48Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595655261",
      "id" : 595655261,
      "in_reply_to_id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTY1NTI2MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613856816,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595655261",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595844551"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595844551"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Much better. I was going to have to look up what those funny `new` and `delete` keywords meant.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-17T09:26:00Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595844551",
      "id" : 595844551,
      "in_reply_to_id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTg0NDU1MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 614082830,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595844551",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595868851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595868851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, thanks Marco. I agree that this would be better as ConsumeBool (and then we could move the `signalling_mask` declaration down to where it's used).",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-17T09:57:42Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595868851",
      "id" : 595868851,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTg2ODg1MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 614113568,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595868851",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code review ACK cf81c6533fe26a64bb8c5a5baf5be21367f7eee5",
      "created_at" : "2021-03-17T10:04:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-800956696",
      "id" : 800956696,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMDk1NjY5Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-17T10:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/800956696",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597328399"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597328399"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: you don't technically need `virtual` if you're already specifying `override`.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T00:25:49Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597328399",
      "id" : 597328399,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzMyODM5OQ==",
      "original_commit_id" : "cf81c6533fe26a64bb8c5a5baf5be21367f7eee5",
      "original_line" : 42,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 615974247,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597328399",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597331653"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597331653"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@JeremyRubin on #21377 wrote:\r\n\r\n> @MarcoFalke's comment is a slight misunderstanding I believe of how the fuzzer simulates time; I recall AJ saying (somewhere) that block times are steady interval in the fuzzing so that it doesn't matter (can't find that comment now tho). Is that correct?\r\n\r\nThe fuzzer picks the mtp parameters for the deployment by first picking a random block (`start_block` or `end_block`), figuring out the timestamp that block will have (same formula as `Blocks::mine_block` use for `nTime`), and then randomly bumps one or the other by half the interval, just to check it's not relying on exact equality.\r\n\r\n(So switching fuzzing from mtp to height should just be a matter of using `start_block` and `end_block` directly)\r\n\r\nThe steady interval means there's no direct testing of what happens if blocks happen to come really quickly or really slowly, however if the fuzzer picks two blocks in the same period for start/timeout, that should pretty much simulate the same behaviour.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T00:36:16Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // these could be changed to be fuzzed inputs if desired\n+    const int period = 32;\n+    const int threshold = 29;\n+    const size_t max_periods = 16;\n+\n+    static_assert(0 < threshold && threshold < period, \"must be able to not signal!\");\n+    const size_t max_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597331653",
      "id" : 597331653,
      "line" : 153,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzMzMTY1Mw==",
      "original_commit_id" : "cf81c6533fe26a64bb8c5a5baf5be21367f7eee5",
      "original_line" : 153,
      "original_position" : 153,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 153,
      "pull_request_review_id" : 615977885,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597331653",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597340647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597340647"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nitnit: s/is fully consumed/may be fully consumed/",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T01:05:44Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // these could be changed to be fuzzed inputs if desired\n+    const int period = 32;\n+    const int threshold = 29;\n+    const size_t max_periods = 16;\n+\n+    static_assert(0 < threshold && threshold < period, \"must be able to not signal!\");\n+    const size_t max_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't go too crazy with how many blocks we mine\n+        if (blocks.size() > 2 * max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider is fully consumed at this point and should not be used further",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597340647",
      "id" : 597340647,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzM0MDY0Nw==",
      "original_commit_id" : "cf81c6533fe26a64bb8c5a5baf5be21367f7eee5",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 615974247,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597340647",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Changed to only calculate the start/end blocks if they're going to be used",
      "created_at" : "2021-03-19T01:19:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-802438301",
      "id" : 802438301,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMjQzODMwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-19T01:19:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/802438301",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597346657"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597346657"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason to not do that already (at least for the threshold)? It seems like an easy way of increasing potential edge cases.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T01:25:16Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // these could be changed to be fuzzed inputs if desired",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597346657",
      "id" : 597346657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzM0NjY1Nw==",
      "original_commit_id" : "afa4e12c57e8cdeec29503e26738863814aede3a",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 615974247,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597346657",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597387047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597387047"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Tried the `while (ConsumeBool()) { signal = ConsumeBool(); } mask = ConsumeIntegral();` alternative and it seems like the current approach gets more coverage more quickly (1896 cov 6382 ft after 20s and 1898 cov 7041 ft after ~3m; vs 1893 cov 6111 ft after 20s and 1895 cov 6960 ft after ~3m), so am leaving this as-is.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T03:41:59Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597387047",
      "id" : 597387047,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzM4NzA0Nw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 616039512,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597387047",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597409540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597409540"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "And most of the codebase doesn't specify virtual with override, so changed to do likewise",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T05:06:18Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597409540",
      "id" : 597409540,
      "in_reply_to_id" : 597328399,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQwOTU0MA==",
      "original_commit_id" : "cf81c6533fe26a64bb8c5a5baf5be21367f7eee5",
      "original_line" : 42,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 616064489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597409540",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597409638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597409638"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Donedone(done...)",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T05:06:41Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // these could be changed to be fuzzed inputs if desired\n+    const int period = 32;\n+    const int threshold = 29;\n+    const size_t max_periods = 16;\n+\n+    static_assert(0 < threshold && threshold < period, \"must be able to not signal!\");\n+    const size_t max_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't go too crazy with how many blocks we mine\n+        if (blocks.size() > 2 * max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider is fully consumed at this point and should not be used further",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597409638",
      "id" : 597409638,
      "in_reply_to_id" : 597340647,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQwOTYzOA==",
      "original_commit_id" : "cf81c6533fe26a64bb8c5a5baf5be21367f7eee5",
      "original_line" : 208,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 616064617,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:06:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597409638",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597409759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597409759"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, no reason not to. Doing it with the period slows things down unfortunately.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T05:07:06Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // these could be changed to be fuzzed inputs if desired",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597409759",
      "id" : 597409759,
      "in_reply_to_id" : 597346657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQwOTc1OQ==",
      "original_commit_id" : "afa4e12c57e8cdeec29503e26738863814aede3a",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 616064760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T05:07:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597409759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK 1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T05:17:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-802564196",
      "id" : 802564196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMjU2NDE5Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-19T05:17:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/802564196",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597476634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597476634"
         }
      },
      "author_association" : "MEMBER",
      "body" : "would be nice to not initialize const members, so that review is easier and the compiler can warn about missing initialization.\r\n```suggestion\r\n    const int m_bit;\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T08:09:15Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597476634",
      "id" : 597476634,
      "line" : 32,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQ3NjYzNA==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 32,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 32,
      "pull_request_review_id" : 616145551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597476634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597476866"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597476866"
         }
      },
      "author_association" : "MEMBER",
      "body" : "clang-format ;)\r\n\r\n```suggestion\r\n        if (blocks.size() + period * 2 > max_blocks) break;\r\n```",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T08:09:40Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    const uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't risk exceeding max_blocks or times may wrap around\n+        if (blocks.size() + period*2 > max_blocks) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597476866",
      "id" : 597476866,
      "line" : 206,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQ3Njg2Ng==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 206,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 206,
      "pull_request_review_id" : 616145551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597476866",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597495025"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597495025"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would be nice to not use globals in tests, unless necessary.\r\n\r\n```diff\r\n-\r\n-void initialize()\r\n-{\r\n-    SelectParams(CBaseChainParams::MAIN);\r\n-}\r\n } // namespace\r\n \r\n constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\r\n \r\n-FUZZ_TARGET_INIT(versionbits, initialize)\r\n+FUZZ_TARGET(versionbits)\r\n {\r\n-    const CChainParams& params = Params();\r\n+    const auto chainparams = CreateChainParams(ArgsManager{} , CBaseChainParams::MAIN);\r\n+    const CChainParams& params = *chainparams;\r\n",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T08:41:48Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597495025",
      "id" : 597495025,
      "line" : 99,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQ5NTAyNQ==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 99,
      "original_position" : 99,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 99,
      "pull_request_review_id" : 616145551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597495025",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597496093"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597496093"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Namespace can cover the whole file",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T08:43:38Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597496093",
      "id" : 597496093,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQ5NjA5Mw==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 101,
      "pull_request_review_id" : 616145551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597496093",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597507214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597507214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is a slightly confusing constant name. `MAX_START_TIME` would be more precise. It could also be in the unnamed namespace.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T09:00:51Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597507214",
      "id" : 597507214,
      "line" : 103,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzUwNzIxNA==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 103,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 103,
      "pull_request_review_id" : 616184798,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:20:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597507214",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597512660"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597512660"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I am trying to reproduce with `FUZZ=versionbits ./src/test/fuzz/fuzz -use_value_profile=1 -entropic=1 -max_total_time=10`.\r\nLooks like I am exhausting line coverage after 10 seconds with `ConsumeBool()`:\r\n\r\n```\r\n#68347\tDONE   cov: 653 ft: 3266 corp: 557/16057b lim: 122 exec/s: 6213 rss: 46Mb\r\n```\r\n\r\n\r\nWhereas remaining_bytes gives lower line coverage after 10 seconds:\r\n\r\n```\r\n#58568\tDONE   cov: 650 ft: 3262 corp: 530/14599b lim: 128 exec/s: 5324 rss: 46Mb\r\n```\r\n\r\n(Edit: Lower line coverage is probably expected, since `remaining_bytes` won't be called)\r\n\r\nIn either case, this seems premature optimization. A time-scale of 10 seconds is nothing compared to the CPU time that is going to be spent on this in our fuzz farms. I think the primary thing to optimize is to write tests in a way they are easy to understand and hard to get wrong when modified/written. For example, in another test (commit fa42da2d5424c0aeccfae4b49fde2bea330b63dc) a fully consumed buffer has already bitten me.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T09:09:05Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597512660",
      "id" : 597512660,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzUxMjY2MA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 616145551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:13:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597512660",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597518755"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597518755"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't understand the factor of 2 here (or lower down in `if (blocks.size() + period*2 > max_blocks)`. What is it needed for?\r\n",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T09:18:54Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597518755",
      "id" : 597518755,
      "line" : 118,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzUxODc1NQ==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 118,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 118,
      "pull_request_review_id" : 616184798,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:20:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597518755",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597537592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597537592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "style-nit: Can be const. Also any downside to assert the genesis block is always DEFINED (unless the non-BIP9 compliant special cases never active/always active)\r\n\r\n```diff\r\n-    int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);\r\n+    const int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);\r\n     assert(exp_since <= prev_next_height);\r\n \r\n+    if (prev == nullptr && !always_active_test && !never_active_test) {\r\n+        assert(exp_state == ThresholdState::DEFINED);\r\n+    }\r\n+\r\n",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T09:47:51Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    const uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't risk exceeding max_blocks or times may wrap around\n+        if (blocks.size() + period*2 > max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider may be fully consumed at this point and should not be used further\n+\n+    // now we mine the final period and check that everything looks sane\n+\n+    // count the number of signalling blocks\n+    int blocks_sig = 0;\n+\n+    // get the info for the first block of the period\n+    CBlockIndex* prev = blocks.tip();\n+    const int exp_since = checker.GetStateSinceHeightFor(prev);\n+    const ThresholdState exp_state = checker.GetStateFor(prev);\n+    BIP9Stats last_stats = checker.GetStateStatisticsFor(prev);\n+\n+    int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597537592",
      "id" : 597537592,
      "line" : 221,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzUzNzU5Mg==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 221,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 221,
      "pull_request_review_id" : 616224314,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T09:47:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597537592",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597553324"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597553324"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`max_blocks` is the max number of blocks \"mined\"; there shouldn't be any point mining more than `period*max_period` worth -- things should just be stuck in ACTIVE/FAILED from that point on, but this lets some extra amount be checked just in case.\r\n\r\nIf `blocks.size() + period*2 > max_blocks` then an additional round of the loop and then the final period combined would end up mining more than `max_blocks` in total.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T10:12:12Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597553324",
      "id" : 597553324,
      "in_reply_to_id" : 597518755,
      "line" : 118,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzU1MzMyNA==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 118,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 118,
      "pull_request_review_id" : 616244514,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T10:12:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597553324",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597555132"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597555132"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`never_active_test` also starts in DEFINED with bip9 (though it wouldn't wth bip8)\r\n\r\nIf `prev == nullptr` then `prev_net_height == 0` and therefore `exp_since <= 0` (from the above code) and at the end there's `assert(exp_since > 0 || exp_state == ThresholdState::DEFINED)` so this case should be already covered.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T10:15:07Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    const uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't risk exceeding max_blocks or times may wrap around\n+        if (blocks.size() + period*2 > max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider may be fully consumed at this point and should not be used further\n+\n+    // now we mine the final period and check that everything looks sane\n+\n+    // count the number of signalling blocks\n+    int blocks_sig = 0;\n+\n+    // get the info for the first block of the period\n+    CBlockIndex* prev = blocks.tip();\n+    const int exp_since = checker.GetStateSinceHeightFor(prev);\n+    const ThresholdState exp_state = checker.GetStateFor(prev);\n+    BIP9Stats last_stats = checker.GetStateStatisticsFor(prev);\n+\n+    int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597555132",
      "id" : 597555132,
      "in_reply_to_id" : 597537592,
      "line" : 221,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzU1NTEzMg==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 221,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 221,
      "pull_request_review_id" : 616246933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T10:15:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597555132",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597557529"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597557529"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, thanks.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T10:18:45Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    const uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't risk exceeding max_blocks or times may wrap around\n+        if (blocks.size() + period*2 > max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider may be fully consumed at this point and should not be used further\n+\n+    // now we mine the final period and check that everything looks sane\n+\n+    // count the number of signalling blocks\n+    int blocks_sig = 0;\n+\n+    // get the info for the first block of the period\n+    CBlockIndex* prev = blocks.tip();\n+    const int exp_since = checker.GetStateSinceHeightFor(prev);\n+    const ThresholdState exp_state = checker.GetStateFor(prev);\n+    BIP9Stats last_stats = checker.GetStateStatisticsFor(prev);\n+\n+    int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597557529",
      "id" : 597557529,
      "in_reply_to_id" : 597537592,
      "line" : 221,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzU1NzUyOQ==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 221,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 221,
      "pull_request_review_id" : 616249943,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T10:18:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597557529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597559803"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597559803"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason to only allow two different nVersion per test input? On the real network there is more noise. The following diff compiled for me, but feel free to ignore:\r\n\r\n```diff\r\ndiff --git a/src/test/fuzz/versionbits.cpp b/src/test/fuzz/versionbits.cpp\r\nindex a898e2782d..1724bde3dc 100644\r\n--- a/src/test/fuzz/versionbits.cpp\r\n+++ b/src/test/fuzz/versionbits.cpp\r\n@@ -64,11 +64,11 @@ private:\r\n     std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\r\n     const uint32_t m_start_time;\r\n     const uint32_t m_interval;\r\n-    const int32_t m_signal;\r\n-    const int32_t m_no_signal;\r\n+    const std::vector<int32_t> m_signal;\r\n+    const std::vector<int32_t> m_no_signal;\r\n \r\n public:\r\n-    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\r\n+    Blocks(uint32_t start_time, uint32_t interval, std::vector<int32_t> signal, std::vector<int32_t> no_signal)\r\n         : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\r\n \r\n     size_t size() const { return m_blocks.size(); }\r\n@@ -81,7 +81,7 @@ public:\r\n     CBlockIndex* mine_block(bool signal)\r\n     {\r\n         CBlockHeader header;\r\n-        header.nVersion = signal ? m_signal : m_no_signal;\r\n+        header.nVersion = signal ? m_signal.at(m_blocks.size() % m_signal.size()) : m_no_signal.at(m_blocks.size() % m_no_signal.size());\r\n         header.nTime = m_start_time + m_blocks.size() * m_interval;\r\n         header.nBits = 0x1d00ffff;\r\n \r\n@@ -126,10 +126,6 @@ FUZZ_TARGET_INIT(versionbits, initialize)\r\n \r\n     const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\r\n \r\n-    // what values for version will we use to signal / not signal?\r\n-    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\r\n-    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\r\n-\r\n     // select deployment parameters: bit, start time, timeout\r\n     const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\r\n \r\n@@ -168,16 +164,25 @@ FUZZ_TARGET_INIT(versionbits, initialize)\r\n \r\n     TestConditionChecker checker(start_time, timeout, period, threshold, bit);\r\n \r\n-    // Early exit if the versions don't signal sensibly for the deployment\r\n-    if (!checker.Condition(ver_signal)) return;\r\n-    if (checker.Condition(ver_nosignal)) return;\r\n-    if (ver_nosignal < 0) return;\r\n-\r\n-    // TOP_BITS should ensure version will be positive\r\n-    assert(ver_signal > 0);\r\n+    // what values for version will we use to signal / not signal?\r\n+    std::vector<int32_t> vver_signal;\r\n+    std::vector<int32_t> vver_nosignal;\r\n+    while (vver_signal.size() < 5) {\r\n+        const auto ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\r\n+        if (!checker.Condition(ver_signal)) return;\r\n+        // TOP_BITS should ensure version will be positive\r\n+        assert(ver_signal > 0);\r\n+        vver_signal.push_back(ver_signal);\r\n+    }\r\n+    while (vver_nosignal.size() < 5) {\r\n+        const auto ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\r\n+        if (ver_nosignal < 0) return;\r\n+        if (checker.Condition(ver_nosignal)) return;\r\n+        vver_nosignal.push_back(ver_nosignal);\r\n+    }\r\n \r\n     // Now that we have chosen time and versions, setup to mine blocks\r\n-    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\r\n+    Blocks blocks(block_start_time, interval, vver_signal, vver_nosignal);\r\n \r\n     /* Strategy:\r\n      *  * we will mine a final period worth of blocks, with\r\n",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T10:22:20Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597559803",
      "id" : 597559803,
      "line" : 84,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzU1OTgwMw==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 84,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 84,
      "pull_request_review_id" : 616253018,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T10:22:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597559803",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597565791"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597565791"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Could `assert(ver_signal > VERSIONBITS_LAST_OLD_BLOCK_VERSION);`?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T10:31:41Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597565791",
      "id" : 597565791,
      "line" : 178,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzU2NTc5MQ==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 178,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 178,
      "pull_request_review_id" : 616260800,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T10:31:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597565791",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597598744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597598744"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Oh, I like that!\r\n\r\nI don't think it's much benefit for now though -- without some refactoring, I think it's only checking how the `Condition()` function defined in the fuzzer behaves, not the one that's actually used for consensus.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T11:16:07Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597598744",
      "id" : 597598744,
      "in_reply_to_id" : 597559803,
      "line" : 84,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzU5ODc0NA==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 84,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 84,
      "pull_request_review_id" : 616294291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T11:16:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597598744",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597612911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597612911"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, good point. The first thing I did when reviewing was to change the Condition function to something else. And the test still passed, turns out this is expected. Can be revisited later.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T11:42:11Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597612911",
      "id" : 597612911,
      "in_reply_to_id" : 597559803,
      "line" : 84,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzYxMjkxMQ==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 84,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 84,
      "pull_request_review_id" : 616312379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T11:42:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597612911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597613758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597613758"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, got it. So `max_periods` is the max number of periods in the versionbits parameters and `max_blocks` is the max number of blocks in the test.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T11:43:50Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+} // namespace\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597613758",
      "id" : 597613758,
      "in_reply_to_id" : 597518755,
      "line" : 118,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzYxMzc1OA==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 118,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 118,
      "pull_request_review_id" : 616313521,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T11:43:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597613758",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK 1639c3b76c",
      "created_at" : "2021-03-19T11:44:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-802774729",
      "id" : 802774729,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMjc3NDcyOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-19T11:44:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/802774729",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ajtowns Let me know if you want this merged or address the comments and wait for re-ACKs",
      "created_at" : "2021-03-19T11:56:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-802781291",
      "id" : 802781291,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMjc4MTI5MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-19T11:56:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/802781291",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597720395"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597720395"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Well, you're getting about 150x the exec/s I am, so getting thorough coverage in 10s when it takes me 2m makes sense. I don't follow why your \"cov\" figures are 650 rather than the 1900 or so I get though?",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T14:25:39Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597720395",
      "id" : 597720395,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzcyMDM5NQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 616457712,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T14:25:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597720395",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@MarcoFalke merge and followup sounds good to me",
      "created_at" : "2021-03-19T14:26:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-802871811",
      "id" : 802871811,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMjg3MTgxMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-19T14:26:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/802871811",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597866398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597866398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"cov\" and \"ft\" depend on the instrumentation (version of libFuzzer, sanitizers, run time flags, ...), they are not considered a \"stable interface\".\r\n\r\nEven if it took 2 minutes to saturate line coverage, I'd still consider it more than acceptable. We have many targets that are ground with hundreds of CPU hours and still aren't close to being saturated in line coverage.",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T17:43:19Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597866398",
      "id" : 597866398,
      "in_reply_to_id" : 595114366,
      "line" : 198,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2NjM5OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 198,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 198,
      "pull_request_review_id" : 616652853,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T17:43:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597866398",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597949585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597949585"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm curious why you decided to right shift the version message instead of matching how `VersionBitsConditionChecker` left shifts the bit to compare to the block's version. \r\n\r\nAlso why the `version` param here is an `int64_t` when `CBlockHeader.nVersion` is `int32_t`. \r\n\r\nI don't think (?) any of these cause problems, but I think we want the test checker to match the version bits checker as closely as possible? ",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-19T20:13:56Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r597949585",
      "id" : 597949585,
      "line" : 54,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzk0OTU4NQ==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 54,
      "original_position" : 54,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 54,
      "pull_request_review_id" : 616761037,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-19T20:13:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/597949585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r598201322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/598201322"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't think there's any good reason for either of those changes.\r\n",
      "commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "created_at" : "2021-03-21T00:51:19Z",
      "diff_hunk" : "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r598201322",
      "id" : 598201322,
      "in_reply_to_id" : 597949585,
      "line" : 54,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODIwMTMyMg==",
      "original_commit_id" : "1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "original_line" : 54,
      "original_position" : 54,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 54,
      "pull_request_review_id" : 616973050,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-21T00:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/598201322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Followup in #21489 ; the \"use more than just two versions\" idea is still waiting for a consensus refactor so that it does something useful.",
      "created_at" : "2021-03-21T01:31:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-803496629",
      "id" : 803496629,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMzQ5NjYyOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-21T01:31:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/803496629",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   }
]
