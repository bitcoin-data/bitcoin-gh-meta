[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16400](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16400.html) (refactor: Rewrite AcceptToMemoryPoolWorker() using smaller parts by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-07-18T23:28:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-513031077",
      "id" : 513031077,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMzAzMTA3Nw==",
      "updated_at" : "2019-09-06T14:42:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/513031077",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Please rebase so this only contains the single commit for this PR.",
      "created_at" : "2019-07-22T21:34:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-513963835",
      "id" : 513963835,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMzk2MzgzNQ==",
      "updated_at" : "2019-07-22T21:34:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/513963835",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased. Now just one commit + master.",
      "created_at" : "2019-07-23T20:08:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-514364535",
      "id" : 514364535,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNDM2NDUzNQ==",
      "updated_at" : "2019-07-23T20:08:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/514364535",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased after #16471. Also, @sdaftuar noted that I (a) misunderstood the meaning of setConflicts so the description in the comment was wrong in a few ways, and also we were allowing an RBF transaction to get in via the carve-out even when it shouldn't be allowed to (ie when it has more than one mempool ancestor). Sadly, after talking through it it doesn't seem like we'll be able to get away with no extra calls to CalculateMemPoolAncestors, but at least its a bit easier to reason about now (IMO).",
      "created_at" : "2019-07-29T18:36:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-516111698",
      "id" : 516111698,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjExMTY5OA==",
      "updated_at" : "2019-07-29T18:36:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516111698",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308384647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308384647"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can we just use `GetMemPoolParents(conflict)` and grab the hashes from there, instead of iterating all the inputs?",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-29T18:53:41Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308384647",
      "id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4NDY0Nw==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308384647",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308385882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308385882"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Similarly, if you hadn't cleared out setAncestors() a few lines up, I think you could skip having to walk all the inputs again here.  Perhaps save that and then compare setAncestors to the mempool parents of conflictTx?",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-29T18:56:11Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308385882",
      "id" : 308385882,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4NTg4Mg==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308385882",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308387438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308387438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think a comment would be helpful here to explain exactly what we're doing:\r\n * No need to bump ancestor sizes/limits (since those are only tested on the transaction itself and are unaffected by the presence of conflicting transactions)\r\n * Descendant size / count are bumped by conflict tx size and 1, to account for the removal of that transaction from all the ancestors of the new transaction. Since we require that the new transaction not introduce any new mempool-ancestors (compared with the conflict tx), this is sufficient to enforce our existing package limits.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-29T18:59:40Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }\n+                if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants + 1,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308387438",
      "id" : 308387438,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4NzQzOA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 54,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308387438",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388243"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Another comment would be helpful here, to explain that if we failed to RBF due to the package limit, we'll give it one more try using the carve-out rules.  So we use the same ancestor limits that the carve-out provision requires, but bump the descendant limits to account for the to-be-removed transaction.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-29T19:01:39Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }\n+                if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants + 1,\n+                        nLimitDescendantSize + conflict->GetTxSize(), dummy_err_string)) {\n+                    if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388243",
      "id" : 308388243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4ODI0Mw==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 56,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388243",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It looks like you're not clearing setAncestors before this call.  I think that's actually fine, but maybe better practice to clear it out to avoid confusion?",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-29T19:02:07Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }\n+                if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants + 1,\n+                        nLimitDescendantSize + conflict->GetTxSize(), dummy_err_string)) {\n+                    if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n+                            !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 2,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388398",
      "id" : 308388398,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4ODM5OA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 57,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388398",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This whole section could probably use a clearer comment that lays out the problem we have with evaluating package limits in the presence of RBF transactions, to help future readers of this code.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-29T19:03:30Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388970",
      "id" : 308388970,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4ODk3MA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 25,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388970",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308860203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308860203"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, GetMemPoolParents just returns the parents set, which isn't actually filled until the very last step in addUnchecked.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-30T17:57:57Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308860203",
      "id" : 308860203,
      "in_reply_to_id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2MDIwMw==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268566504,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308860203",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308861464"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308861464"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, but doesn't CalculateMemPoolAncestors return early if we hit a limit? I didn't want to start introducing some \"if we return early, X is initialized, but Y is not\" kind of invariants in CalculateMemPoolAncestors. If you think its worth it, though...",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-30T18:00:39Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308861464",
      "id" : 308861464,
      "in_reply_to_id" : 308385882,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2MTQ2NA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268568786,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308861464",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308864741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308864741"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh right, never mind.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-30T18:06:18Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308864741",
      "id" : 308864741,
      "in_reply_to_id" : 308385882,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2NDc0MQ==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268571888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308864741",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308866818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308866818"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The conflict tx is already in the mempool, so shouldnât that work fine?",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-30T18:11:02Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308866818",
      "id" : 308866818,
      "in_reply_to_id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2NjgxOA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268574451,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308866818",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rewrote the comment at the top of the new block to now be a Mega Comment (tm). Hopefully its sufficient, though I can break it up and move it to corresponding code if you really want @sdaftuar, I just didn't bother cause its easy to rewrite without.",
      "created_at" : "2019-07-30T18:46:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-516545624",
      "id" : 516545624,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjU0NTYyNA==",
      "updated_at" : "2019-07-30T18:46:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516545624",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, though I'd prefer if this was solved for all mempool txs and not only for a special case of lightning txs.",
      "created_at" : "2019-07-30T21:06:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-516595758",
      "id" : 516595758,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjU5NTc1OA==",
      "updated_at" : "2019-07-30T21:06:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516595758",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r309431618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309431618"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Oh right, was looking at the wrong line and thought you meant the new entry. Will fix.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-07-31T21:05:25Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r309431618",
      "id" : 309431618,
      "in_reply_to_id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwOTQzMTYxOA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 269282594,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309431618",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@MarcoFalke This isn't *completely* targeted only at lightning/carve-out/contract applications, though it obviously ensures that carve-out transactions are a supported use-case. Mostly trying to implement this in the general case is Hard (tm), but this does work for any only-directly-conflicts-with-1-transaction tx.",
      "created_at" : "2019-07-31T21:07:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-517021531",
      "id" : 517021531,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNzAyMTUzMQ==",
      "updated_at" : "2019-07-31T21:07:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/517021531",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166682"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166682"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Rather than doing this test after the initial CalculateMemPoolAncestors(), would it make sense to work out if the limits can be relaxed first, and then start calling CalculateMemPoolAncestors? ie\r\n\r\n```c++\r\nint bump_desc = 0;\r\nint bump_desc_size = 0;\r\nif (setConflicts.size() == 1) {\r\n auto conflict = *setIterConflicting.begin();\r\n if (tx_only_uses_unconfirmed_inputs_from_conflicting_tx) {\r\n  bump_desc = 1;\r\n  bump_desc_size = conflict->GetTxSize();\r\n }\r\n}\r\nif (!CalculateMemPoolAncestors(..,nLimitDescendents+bump_desc, nLimitDescendantSize+bump_desc_size,..) {\r\n std::string dummy_err;\r\n if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT || !CalculateMemPoolAncestors(..+bump_desc,..+bump_desc_size)) {\r\n  Invalid();\r\n }\r\n}\r\n```\r\n",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-15T03:53:03Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166682",
      "id" : 314166682,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNDE2NjY4Mg==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 9,
      "path" : "src/validation.cpp",
      "position" : 49,
      "pull_request_review_id" : 275251295,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166682",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166985"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166985"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I wonder if extensive comments like this wouldn't be better as an informative BIP? Also it's probably a lost cause, but wrapping the comments at 80 columns or less rather than ~120 would be nice :)",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-15T03:55:28Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166985",
      "id" : 314166985,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNDE2Njk4NQ==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 26,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 275251686,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166985",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315229807"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315229807"
         }
      },
      "author_association" : "MEMBER",
      "body" : "too many commas :) `s/very realistic, either/very realistic either/`",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T14:07:52Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315229807",
      "id" : 315229807,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTIyOTgwNw==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 30,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315229807",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315235160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315235160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "for readers of the comments, this has (attempted) to be addressed",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T14:18:12Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315235160",
      "id" : 315235160,
      "in_reply_to_id" : 308388970,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTIzNTE2MA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 25,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315235160",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315237028"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315237028"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> the subset of RBF transactions which we allow despite conflicts\r\n\r\nAren't RBF transactions conflicting by definition?",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T14:21:40Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315237028",
      "id" : 315237028,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTIzNzAyOA==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 35,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315237028",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315240852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315240852"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This check appears to be identical to https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L733\r\n\r\nwhich would at least be good to point out, or how it's different, if it's not the same. I could see the other check being relaxed in the future but this kept in place.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T14:28:58Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case (as the ancestor limits should be the same for both our new\n+                // transaction and any conflicts, though you shouldn't be able to violate these given the\n+                // no-new-unconfirmed-inputs check), with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction (as these are recalculated by assuming the new\n+                // transaction being added is a new dependant, with no removals, of each parents' existing\n+                // dependant set).\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                    conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                        if (pool.exists(new_input.prevout.hash)) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315240852",
      "id" : 315240852,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTI0MDg1Mg==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 61,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315240852",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315241877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315241877"
         }
      },
      "author_association" : "MEMBER",
      "body" : "you should probably label the thing you're calling `carve-out` for those not reading git history.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T14:30:46Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315241877",
      "id" : 315241877,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTI0MTg3Nw==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 32,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315241877",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315243438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315243438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Having real trouble parsing this last paragraph.\r\n\r\nLots of different things being referenced, \"above\", \"below\", \"corresponding\", unsure exactly what it's referring to.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T14:33:36Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315243438",
      "id" : 315243438,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTI0MzQzOA==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315243438",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428075"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah, indeed, nice call, done.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T21:52:11Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428075",
      "id" : 315428075,
      "in_reply_to_id" : 314166682,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQyODA3NQ==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 9,
      "path" : "src/validation.cpp",
      "position" : 49,
      "pull_request_review_id" : 276835021,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428075",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428337"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428337"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "80 chars is....very antiquated. I dunno anyone who is left coding on a 80x60 terminal :p.\r\n\r\nStill, I don't think this deserves a BIP if only cause we hopefully can extend it further in the future.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T21:53:01Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428337",
      "id" : 315428337,
      "in_reply_to_id" : 314166985,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQyODMzNw==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 26,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276835333,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428337",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315437310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315437310"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this a bit more readable given the changes made for https://github.com/bitcoin/bitcoin/pull/16421#pullrequestreview-275251295 ?",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-19T22:23:30Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315437310",
      "id" : 315437310,
      "in_reply_to_id" : 315243438,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQzNzMxMA==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276846287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315437310",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472937"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`setIterConflicting.size()` could theoretically be zero if the conflicting hash from `setConflicts` isn't in the mempool somehow. That shouldn't be possible because we've held a lock on `cs_main` and `pool.cs` since we populated `setConflicts`, so this assertion should be correct.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-20T01:19:31Z",
      "diff_hunk" : "@@ -609,17 +609,66 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies (checked first).\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472937",
      "id" : 315472937,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQ3MjkzNw==",
      "original_commit_id" : "8b1884f38bb7b4cd893ff13a2a86c1e975966711",
      "original_position" : 35,
      "path" : "src/validation.cpp",
      "position" : 40,
      "pull_request_review_id" : 276888919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472937",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472953"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"Contracting\" with a t? :)\r\n",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-20T01:19:37Z",
      "diff_hunk" : "@@ -609,17 +609,66 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies (checked first).\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            std::set<uint256> conflict_existing_mempool_inputs;\n+            for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+            }\n+\n+            bool meets_rbf_conflict_limit = true;\n+            for (const CTxIn& new_input: tx.vin) {\n+                if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                    if (pool.exists(new_input.prevout.hash)) {\n+                        meets_rbf_conflict_limit = false;\n+                    }\n+                }\n+            }\n+\n+            if (meets_rbf_conflict_limit) {\n+                nLimitDescendants += 1;\n+                nLimitDescendantSize += conflict->GetTxSize();\n+            }\n+        }\n+\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n+            // Contracing/payment channels CPFP carve-out:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472953",
      "id" : 315472953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQ3Mjk1Mw==",
      "original_commit_id" : "8b1884f38bb7b4cd893ff13a2a86c1e975966711",
      "original_position" : 63,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276888919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472953",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315497691"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315497691"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No one ever warned me I'd need to know how to spell to write code :(",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-20T03:57:20Z",
      "diff_hunk" : "@@ -609,17 +609,66 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies (checked first).\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            std::set<uint256> conflict_existing_mempool_inputs;\n+            for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+            }\n+\n+            bool meets_rbf_conflict_limit = true;\n+            for (const CTxIn& new_input: tx.vin) {\n+                if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                    if (pool.exists(new_input.prevout.hash)) {\n+                        meets_rbf_conflict_limit = false;\n+                    }\n+                }\n+            }\n+\n+            if (meets_rbf_conflict_limit) {\n+                nLimitDescendants += 1;\n+                nLimitDescendantSize += conflict->GetTxSize();\n+            }\n+        }\n+\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n+            // Contracing/payment channels CPFP carve-out:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315497691",
      "id" : 315497691,
      "in_reply_to_id" : 315472953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQ5NzY5MQ==",
      "original_commit_id" : "8b1884f38bb7b4cd893ff13a2a86c1e975966711",
      "original_position" : 63,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276920137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315497691",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315847891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315847891"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Indeed! Good call. I removes the entire block of code wholesale, but added extra comments to ensure if the BIP 125 rules are relaxed we know to re-add the checks here.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-20T18:47:24Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case (as the ancestor limits should be the same for both our new\n+                // transaction and any conflicts, though you shouldn't be able to violate these given the\n+                // no-new-unconfirmed-inputs check), with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction (as these are recalculated by assuming the new\n+                // transaction being added is a new dependant, with no removals, of each parents' existing\n+                // dependant set).\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                    conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                        if (pool.exists(new_input.prevout.hash)) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315847891",
      "id" : 315847891,
      "in_reply_to_id" : 315240852,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTg0Nzg5MQ==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 61,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 277368804,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315847891",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r319618828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319618828"
         }
      },
      "author_association" : "MEMBER",
      "body" : "named args would make this more obvious what's going on without a comment",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-08-30T17:58:09Z",
      "diff_hunk" : "@@ -33,7 +33,7 @@ def chain_transaction(self, node, parent_txids, vouts, value, fee, num_outputs):\n         outputs = {}\n         for i in range(num_outputs):\n             outputs[node.getnewaddress()] = send_value\n-        rawtx = node.createrawtransaction(inputs, outputs)\n+        rawtx = node.createrawtransaction(inputs, outputs, 0, True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r319618828",
      "id" : 319618828,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTYxODgyOA==",
      "original_commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "original_position" : 5,
      "path" : "test/functional/mempool_package_onemore.py",
      "position" : 5,
      "pull_request_review_id" : 282172509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319618828",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK b9dc087c99d327aaa194de31282fedde864b7740 ; changes since last ack are comments and dropping the \"no new ancestors\" check for this carve out; code review, checked compiled and tests pass.\r\n\r\nDropping the checks seems correct -- the original behaviour when conflicting with one tx should have been:\r\n\r\n```\r\nif (!has_new_ancestors && desc > LimitDesc+1) Invalid();\r\nif (has_new_ancestors && desc > LimitDesc) Invalid();\r\nif (has_new_ancestors) Invalid();\r\n```\r\n\r\nand it should now be `if (desc > LimitDesc+1 || has_new_ancestors) Invalid();` which looks correct to me. And there's comments to document the dependency between the two bits of code, to help avoid introducing bugs in future.",
      "created_at" : "2019-09-02T04:27:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-526996994",
      "id" : 526996994,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjk5Njk5NA==",
      "updated_at" : "2019-09-02T04:27:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526996994",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320427716"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320427716"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/dependant/descendant/g\r\ns/parents'/parent's/",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-09-03T18:57:33Z",
      "diff_hunk" : "@@ -609,17 +609,53 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+            // amended, we may need to move that check to here instead of removing it wholesale.\n+            //\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320427716",
      "id" : 320427716,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDQyNzcxNg==",
      "original_commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "original_position" : 35,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 283196547,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320427716",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320838962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320838962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe we can make this `conflict->GetSizeWithDescendants()` and still respect our mempool limits.\r\n\r\nWithout the size of the descendants, it's possible that an attempt to RBF a single transaction could fail if there are descendants of that transaction in the mempool, due to the mempool limits (even though those child transactions would be replaced as well).  By accounting for the size of those transactions, we should be able to accommodate any RBF attempt that conflicts with a single transaction and introduces no new mempool ancestors.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-09-04T15:52:57Z",
      "diff_hunk" : "@@ -609,17 +609,53 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+            // amended, we may need to move that check to here instead of removing it wholesale.\n+            //\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            nLimitDescendants += 1;\n+            nLimitDescendantSize += conflict->GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320838962",
      "id" : 320838962,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDgzODk2Mg==",
      "original_commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 283196547,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320838962",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320911079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320911079"
         }
      },
      "author_association" : "MEMBER",
      "body" : "note the comment above would have to change too https://github.com/bitcoin/bitcoin/pull/16421/files#diff-24efdb00bfbe56b140fb006b562cc70bR641",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-09-04T18:32:18Z",
      "diff_hunk" : "@@ -609,17 +609,53 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+            // amended, we may need to move that check to here instead of removing it wholesale.\n+            //\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            nLimitDescendants += 1;\n+            nLimitDescendantSize += conflict->GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320911079",
      "id" : 320911079,
      "in_reply_to_id" : 320838962,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDkxMTA3OQ==",
      "original_commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 283812889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320911079",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320944986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320944986"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done! good idea.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-09-04T19:53:27Z",
      "diff_hunk" : "@@ -609,17 +609,53 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+            // amended, we may need to move that check to here instead of removing it wholesale.\n+            //\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            nLimitDescendants += 1;\n+            nLimitDescendantSize += conflict->GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r320944986",
      "id" : 320944986,
      "in_reply_to_id" : 320838962,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDk0NDk4Ng==",
      "original_commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 283856570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-04T19:53:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320944986",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Tweaked the increment to use GetSizeWithDescendants() instead and updated the comment (with some slight readability tweaks @instagibbs may appreciate).",
      "created_at" : "2019-09-04T19:54:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-528059466",
      "id" : 528059466,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODA1OTQ2Ng==",
      "updated_at" : "2019-09-04T19:54:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528059466",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK https://github.com/bitcoin/bitcoin/pull/16421/commits/5ce822efbe45513ce3517c1ca731ac6d6a0c3b54\r\n\r\ncomment clarification and `GetSizeWithDescendants` change only.",
      "created_at" : "2019-09-04T19:58:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-528060551",
      "id" : 528060551,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODA2MDU1MQ==",
      "updated_at" : "2019-09-04T19:58:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528060551",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r321038978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321038978"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can't we actually cope with merging packages this way too though? If you've got a tx that has parents A, B, C; and that conflicts with tx's X (parent A) and Y (parent B), then beforehand you had:\r\n\r\n```\r\n..., A, X, [children X]\r\n..., B, Y, [children Y]\r\n```\r\n\r\n(maybe some tx's were descendants of both X and Y, but it's worse if there weren't any like that) and afterwards you have:\r\n\r\n```\r\n..., A, tx\r\n..., B, tx\r\n```\r\n\r\nYou don't have C in the mempool because that would fail the \"replacement-adds-unconfirmed\" test later.\r\n\r\nSo you know tx's ancestor checks pass, because they're actually worked out; you know A,B's ancestor checks pass because they don't change, tx's descendant check is trivial, and you know A,B and all their parent's descendant checks passed, because they did so when X and Y were there -- as far as sizes go, if they were all at their limit, then the max size for tx is the minimum of the descendant sizes of each tx that was replaced.\r\n\r\nSo I think you could replace the `setConflicts.size() == 1` test with:\r\n\r\n```\r\nif (!setConflicts.empty()) {\r\n    auto conflict = setIterConflicting.begin();\r\n    assert(conflict != setIterConflicting.end());\r\n    uint64_t bump = (*conflict)->GetSizeWithDescendants();\r\n    while(++conflict != setIterConflicting.end()) {\r\n        bump = std::min(bump, (*conflict)->GetSizeWithDescendants());\r\n    }\r\n    nLimitDescendants += 1;\r\n    nLimitDescendantSize += bump;\r\n}\r\n```\r\n\r\nMaybe I'm missing something though?",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-09-05T01:15:03Z",
      "diff_hunk" : "@@ -609,17 +609,53 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+            // amended, we may need to move that check to here instead of removing it wholesale.\n+            //\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            nLimitDescendants += 1;\n+            nLimitDescendantSize += conflict->GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r321038978",
      "id" : 321038978,
      "in_reply_to_id" : 320838962,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTAzODk3OA==",
      "original_commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 283975283,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-05T01:15:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321038978",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK 5ce822efbe45513ce3517c1ca731ac6d6a0c3b54 ; GetSizeWithDescendants is only change and makes sense",
      "created_at" : "2019-09-05T01:16:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-528154120",
      "id" : 528154120,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODE1NDEyMA==",
      "updated_at" : "2019-09-05T01:16:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528154120",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r321404523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321404523"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I agree there's lots we can do in the future to improve things (not actually 100% sure on this one, these things are complicated...) lets try to land this as-is first, though, cause I do really want it for 0.19 still.",
      "commit_id" : "5ce822efbe45513ce3517c1ca731ac6d6a0c3b54",
      "created_at" : "2019-09-05T18:01:38Z",
      "diff_hunk" : "@@ -609,17 +609,53 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies. Note that the \"no new mempool dependencies\"\n+            // check is accomplished later, so we don't bother doing anything about it here, but if BIP 125 is\n+            // amended, we may need to move that check to here instead of removing it wholesale.\n+            //\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            nLimitDescendants += 1;\n+            nLimitDescendantSize += conflict->GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r321404523",
      "id" : 321404523,
      "in_reply_to_id" : 320838962,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTQwNDUyMw==",
      "original_commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 284441492,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-09-05T18:01:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321404523",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code review ACK 5ce822efbe45513ce3517c1ca731ac6d6a0c3b54. I haven't thought hard about the effect on potential DoS issues this policy change may have.",
      "created_at" : "2019-09-06T18:25:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-528963361",
      "id" : 528963361,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODk2MzM2MQ==",
      "updated_at" : "2019-09-06T18:25:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528963361",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "post-merge utACK",
      "created_at" : "2019-09-09T19:53:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-529638952",
      "id" : 529638952,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyOTYzODk1Mg==",
      "updated_at" : "2019-09-09T19:53:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529638952",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   }
]
