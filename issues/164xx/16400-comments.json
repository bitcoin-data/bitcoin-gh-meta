[
   {
      "author_association" : "MEMBER",
      "body" : "The motivation behind this refactor is to allow implementation of a package relay system (#14895).  A simple implementation that I have in mind, which requires no additional p2p protocol changes, is shown at #16401.",
      "created_at" : "2019-07-16T20:18:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-511969315",
      "id" : 511969315,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMTk2OTMxNQ==",
      "updated_at" : "2019-07-16T20:26:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/511969315",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16658](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16658.html) (validation: Rename CheckInputs to CheckInputScripts by jnewbery)\n* [#13525](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13525.html) (policy: Report reason inputs are nonstandard from AreInputsStandard by Empact)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-07-16T22:33:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-512027229",
      "id" : 512027229,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMjAyNzIyOQ==",
      "updated_at" : "2019-09-16T21:01:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/512027229",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304359601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304359601"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure why this is set to `0` as default, as opposed to the actual `DEFAULT_*` values. I understand that setting the defaults here is very verbose and not needed, so why not make it `const`, so that the compiler enforces that this is set in the constructor?\r\n\r\n```suggestion\r\n    const size_t nLimitDescendantSize;\r\n```",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T11:50:16Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};\n+\n+        const uint256& hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n+        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+        }\n+\n+        if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+        }\n+        return true;\n+    }\n+\n+private:\n+    CTxMemPool& pool;\n+    CCoinsViewCache view;\n+    CCoinsViewMemPool viewMemPool;\n+    CCoinsView dummy;\n+\n+    // The package limits in effect at the time of invocation.\n+    size_t nLimitAncestors{0};\n+    size_t nLimitAncestorSize{0};\n+    size_t nLimitDescendants{0};\n+    size_t nLimitDescendantSize{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304359601",
      "id" : 304359601,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM1OTYwMQ==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 125,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304359601",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304360866"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304360866"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you explain the difference between `pool` and `this->pool`? Looks like passing in the pool as a function parameter is redundant and confusing. Might want to drop it?\r\n\r\nAlso, I'd slightly prefer to call the member `m_tx_pool` or something. We already use `mempool` for the global and `pool` for things passed as parameters.\r\n\r\n```suggestion\r\n    bool AcceptSingleTransaction(const CChainParams& chainparams,\r\n```",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T11:53:59Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304360866",
      "id" : 304360866,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM2MDg2Ng==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 41,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304360866",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304361906"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304361906"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks like all the remaining args can be passed as a `ATMPArgs`. Any reason not to do this?\r\n\r\n```suggestion\r\n            ATMPArgs& args);\r\n```",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T11:56:50Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304361906",
      "id" : 304361906,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM2MTkwNg==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 46,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304361906",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304362289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304362289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could better document which arguments are going in and which are going out by setting everything that goes in to `const`?\r\n\r\n```suggestion\r\n        const bool test_accept;\r\n```",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T11:57:57Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304362289",
      "id" : 304362289,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM2MjI4OQ==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 60,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304362289",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304363188"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304363188"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why are some of the settings parsed in the constructor and saved as a member and others are not?\r\n\r\nCould do the same here.\r\n\r\n```suggestion\r\n        CAmount mempoolRejectFee = pool.GetMinFee(m_max_pool_size).GetFee(package_size);\r\n```",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T12:00:21Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};\n+\n+        const uint256& hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304363188",
      "id" : 304363188,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM2MzE4OA==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 104,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304363188",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304366523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304366523"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Given that the local name and the name of the member are identical, does it really make sense to alias it? Looks like you already changed every line in this function due to whitespace fixups, so might as well prefix what we need with `ws.` or `args.` in line. No strong opinion, though.\r\nIf you decide to keep the current approach, I think you can make review easier by not duplicating all the types (use `auto&`, which should keep the type and constness as is.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T12:09:33Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};\n+\n+        const uint256& hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n+        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+        }\n+\n+        if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+        }\n+        return true;\n+    }\n+\n+private:\n+    CTxMemPool& pool;\n+    CCoinsViewCache view;\n+    CCoinsViewMemPool viewMemPool;\n+    CCoinsView dummy;\n+\n+    // The package limits in effect at the time of invocation.\n+    size_t nLimitAncestors{0};\n+    size_t nLimitAncestorSize{0};\n+    size_t nLimitDescendants{0};\n+    size_t nLimitDescendantSize{0};\n+};\n+\n+bool MemPoolAccept::PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws)\n {\n     const CTransaction& tx = *ptx;\n-    const uint256 hash = tx.GetHash();\n-    AssertLockHeld(cs_main);\n-    LOCK(pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n+    const uint256& hash = ws.hash;\n+\n+    // Copy/alias what we need out of args\n+    CValidationState &state = args.state;\n+    bool* pfMissingInputs = args.pfMissingInputs;\n+    const int64_t nAcceptTime = args.nAcceptTime;\n+    const bool bypass_limits = args.bypass_limits;\n+    const CAmount& nAbsurdFee = args.nAbsurdFee;\n+    std::vector<COutPoint>& coins_to_uncache = args.coins_to_uncache;\n+\n+    // Alias what we need out of ws\n+    std::set<uint256>& setConflicts = ws.setConflicts;\n+    CTxMemPool::setEntries& allConflicting = ws.allConflicting;\n+    CTxMemPool::setEntries& setAncestors = ws.setAncestors;\n+    std::unique_ptr<CTxMemPoolEntry>& entry = ws.entry;\n+    bool& fReplacementTransaction = ws.fReplacementTransaction;\n+    CAmount& nModifiedFees = ws.nModifiedFees;\n+    CAmount& nConflictingFees = ws.nConflictingFees;\n+    size_t& nConflictingSize = ws.nConflictingSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304366523",
      "id" : 304366523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM2NjUyMw==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 152,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304366523",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304370428"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304370428"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason this is not stored in the workspace at this point? Maybe as a unique ptr or something, like the `entry`?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T12:20:22Z",
      "diff_hunk" : "@@ -503,322 +617,367 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n-        view.SetBackend(viewMemPool);\n+    LockPoints lp;\n+    CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+    view.SetBackend(viewMemPool);\n \n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // XXX: this comment is wrong/confusing, since we do retain a lock on the mempool\n+    // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n+    view.SetBackend(dummy);\n \n-        // Only accept BIP68 sequence locked transactions that can be mined in the next\n-        // block; we don't want our mempool filled up with transactions that can't\n-        // be mined yet.\n-        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-        // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+    // Only accept BIP68 sequence locked transactions that can be mined in the next\n+    // block; we don't want our mempool filled up with transactions that can't\n+    // be mined yet.\n+    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+    // CoinsViewCache instead of create its own\n+    if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n-        CAmount nFees = 0;\n-        if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n-            return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n-        }\n+    CAmount nFees = 0;\n+    if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n+        return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n+    }\n \n-        // Check for non-standard pay-to-script-hash in inputs\n-        if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+    // Check for non-standard pay-to-script-hash in inputs\n+    if (fRequireStandard && !AreInputsStandard(tx, view))\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        // Check for non-standard witness in P2WSH\n-        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+    // Check for non-standard witness in P2WSH\n+    if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n-        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+    int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n-        // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-        CAmount nModifiedFees = nFees;\n-        pool.ApplyDelta(hash, nModifiedFees);\n+    // nModifiedFees includes any fee deltas from PrioritiseTransaction\n+    nModifiedFees = nFees;\n+    pool.ApplyDelta(hash, nModifiedFees);\n \n-        // Keep track of transactions that spend a coinbase, which we re-scan\n-        // during reorgs to ensure COINBASE_MATURITY is still met.\n-        bool fSpendsCoinbase = false;\n-        for (const CTxIn &txin : tx.vin) {\n-            const Coin &coin = view.AccessCoin(txin.prevout);\n-            if (coin.IsCoinBase()) {\n-                fSpendsCoinbase = true;\n-                break;\n-            }\n+    // Keep track of transactions that spend a coinbase, which we re-scan\n+    // during reorgs to ensure COINBASE_MATURITY is still met.\n+    bool fSpendsCoinbase = false;\n+    for (const CTxIn &txin : tx.vin) {\n+        const Coin &coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsCoinBase()) {\n+            fSpendsCoinbase = true;\n+            break;\n         }\n+    }\n \n-        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n-                              fSpendsCoinbase, nSigOpsCost, lp);\n-        unsigned int nSize = entry.GetTxSize();\n+    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+            fSpendsCoinbase, nSigOpsCost, lp));\n+    unsigned int nSize = entry->GetTxSize();\n \n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n-        if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n-        }\n-\n-        // No transactions are allowed below minRelayTxFee except from disconnected blocks\n-        if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n-        }\n+    // No transactions are allowed below minRelayTxFee except from disconnected\n+    // blocks\n+    if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n-        if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n+    if (nAbsurdFee && nFees > nAbsurdFee)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n-        // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-        std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n-        }\n+    // Calculate in-mempool ancestors, up to a limit.\n+    std::string errString;\n+    if (!pool.CalculateMemPoolAncestors(*entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+    }\n \n-        // A transaction that spends outputs that would be replaced by it is invalid. Now\n-        // that we have the set of all ancestors we can detect this\n-        // pathological case by making sure setConflicts and setAncestors don't\n-        // intersect.\n-        for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    // A transaction that spends outputs that would be replaced by it is invalid. Now\n+    // that we have the set of all ancestors we can detect this\n+    // pathological case by making sure setConflicts and setAncestors don't\n+    // intersect.\n+    for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    {\n+        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        if (setConflicts.count(hashAncestor))\n         {\n-            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n-            if (setConflicts.count(hashAncestor))\n-            {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n-            }\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+                    strprintf(\"%s spends conflicting transaction %s\",\n+                        hash.ToString(),\n+                        hashAncestor.ToString()));\n         }\n+    }\n \n-        // Check if it's economically rational to mine this transaction rather\n-        // than the ones it replaces.\n-        CAmount nConflictingFees = 0;\n-        size_t nConflictingSize = 0;\n-        uint64_t nConflictingCount = 0;\n-        CTxMemPool::setEntries allConflicting;\n-\n-        // If we don't hold the lock allConflicting might be incomplete; the\n-        // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n-        // mempool consistency for us.\n-        const bool fReplacementTransaction = setConflicts.size();\n-        if (fReplacementTransaction)\n-        {\n-            CFeeRate newFeeRate(nModifiedFees, nSize);\n-            std::set<uint256> setConflictsParents;\n-            const int maxDescendantsToVisit = 100;\n-            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n-            for (const auto& mi : setIterConflicting) {\n-                // Don't allow the replacement to reduce the feerate of the\n-                // mempool.\n-                //\n-                // We usually don't want to accept replacements with lower\n-                // feerates than what they replaced as that would lower the\n-                // feerate of the next block. Requiring that the feerate always\n-                // be increased is also an easy-to-reason about way to prevent\n-                // DoS attacks via replacements.\n-                //\n-                // We only consider the feerates of transactions being directly\n-                // replaced, not their indirect descendants. While that does\n-                // mean high feerate children are ignored when deciding whether\n-                // or not to replace, we do require the replacement to pay more\n-                // overall fees too, mitigating most cases.\n-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-                if (newFeeRate <= oldFeeRate)\n-                {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                                  hash.ToString(),\n-                                  newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()));\n-                }\n-\n-                for (const CTxIn &txin : mi->GetTx().vin)\n-                {\n-                    setConflictsParents.insert(txin.prevout.hash);\n-                }\n+    // Check if it's economically rational to mine this transaction rather\n+    // than the ones it replaces.\n+    nConflictingFees = 0;\n+    nConflictingSize = 0;\n+    uint64_t nConflictingCount = 0;\n \n-                nConflictingCount += mi->GetCountWithDescendants();\n-            }\n-            // This potentially overestimates the number of actual descendants\n-            // but we just want to be conservative to avoid doing too much\n-            // work.\n-            if (nConflictingCount <= maxDescendantsToVisit) {\n-                // If not too many to replace, then calculate the set of\n-                // transactions that would have to be evicted\n-                for (CTxMemPool::txiter it : setIterConflicting) {\n-                    pool.CalculateDescendants(it, allConflicting);\n-                }\n-                for (CTxMemPool::txiter it : allConflicting) {\n-                    nConflictingFees += it->GetModifiedFee();\n-                    nConflictingSize += it->GetTxSize();\n-                }\n-            } else {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n-                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+    // If we don't hold the lock allConflicting might be incomplete; the\n+    // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n+    // mempool consistency for us.\n+    fReplacementTransaction = setConflicts.size();\n+    if (fReplacementTransaction)\n+    {\n+        CFeeRate newFeeRate(nModifiedFees, nSize);\n+        std::set<uint256> setConflictsParents;\n+        const int maxDescendantsToVisit = 100;\n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n+        for (const auto& mi : setIterConflicting) {\n+            // Don't allow the replacement to reduce the feerate of the\n+            // mempool.\n+            //\n+            // We usually don't want to accept replacements with lower\n+            // feerates than what they replaced as that would lower the\n+            // feerate of the next block. Requiring that the feerate always\n+            // be increased is also an easy-to-reason about way to prevent\n+            // DoS attacks via replacements.\n+            //\n+            // We only consider the feerates of transactions being directly\n+            // replaced, not their indirect descendants. While that does\n+            // mean high feerate children are ignored when deciding whether\n+            // or not to replace, we do require the replacement to pay more\n+            // overall fees too, mitigating most cases.\n+            CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n-                            nConflictingCount,\n-                            maxDescendantsToVisit));\n+                            newFeeRate.ToString(),\n+                            oldFeeRate.ToString()));\n             }\n \n-            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            for (const CTxIn &txin : mi->GetTx().vin)\n             {\n-                // We don't want to accept replacements that require low\n-                // feerate junk to be mined first. Ideally we'd keep track of\n-                // the ancestor feerates and make the decision based on that,\n-                // but for now requiring all new inputs to be confirmed works.\n-                if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n-                {\n-                    // Rather than check the UTXO set - potentially expensive -\n-                    // it's cheaper to just check if the new input refers to a\n-                    // tx that's in the mempool.\n-                    if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n-                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j));\n-                    }\n-                }\n+                setConflictsParents.insert(txin.prevout.hash);\n             }\n \n-            // The replacement must pay greater fees than the transactions it\n-            // replaces - if we did the bandwidth used by those conflicting\n-            // transactions would not be paid for.\n-            if (nModifiedFees < nConflictingFees)\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+            nConflictingCount += mi->GetCountWithDescendants();\n+        }\n+        // This potentially overestimates the number of actual descendants\n+        // but we just want to be conservative to avoid doing too much\n+        // work.\n+        if (nConflictingCount <= maxDescendantsToVisit) {\n+            // If not too many to replace, then calculate the set of\n+            // transactions that would have to be evicted\n+            for (CTxMemPool::txiter it : setIterConflicting) {\n+                pool.CalculateDescendants(it, allConflicting);\n             }\n-\n-            // Finally in addition to paying more fees than the conflicts the\n-            // new transaction must pay for its own bandwidth.\n-            CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                              hash.ToString(),\n-                              FormatMoney(nDeltaFees),\n-                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+            for (CTxMemPool::txiter it : allConflicting) {\n+                nConflictingFees += it->GetModifiedFee();\n+                nConflictingSize += it->GetTxSize();\n             }\n+        } else {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n+                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                        hash.ToString(),\n+                        nConflictingCount,\n+                        maxDescendantsToVisit));\n         }\n \n-        constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n-\n-        // Check against previous transactions\n-        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        PrecomputedTransactionData txdata(tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304370428",
      "id" : 304370428,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM3MDQyOA==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 556,
      "path" : "src/validation.cpp",
      "position" : 594,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304370428",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304371351"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304371351"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd prefer not to initialize the memory, so that valgrind and other memory tools can warn about logic errors in the code.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T12:22:35Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304371351",
      "id" : 304371351,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM3MTM1MQ==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 75,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304371351",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304372367"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304372367"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure what you are trying to say with the `XXX:`. I feel like the documentation \"typo\" can be fixed in a separate commit or pull request.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T12:25:27Z",
      "diff_hunk" : "@@ -503,322 +617,367 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n-        view.SetBackend(viewMemPool);\n+    LockPoints lp;\n+    CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+    view.SetBackend(viewMemPool);\n \n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // XXX: this comment is wrong/confusing, since we do retain a lock on the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304372367",
      "id" : 304372367,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDM3MjM2Nw==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 232,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 262973496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304372367",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304452075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304452075"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Passing the mempool into AcceptSingleTransaction was just a mistake, removing.\r\n\r\nI'll add a commit that fixes all the variable naming to conform to the style guide.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T14:57:12Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304452075",
      "id" : 304452075,
      "in_reply_to_id" : 304360866,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ1MjA3NQ==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 41,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263111632,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304452075",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304452211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304452211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sounds good, thanks!",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T14:57:27Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};\n+\n+        const uint256& hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n+        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+        }\n+\n+        if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+        }\n+        return true;\n+    }\n+\n+private:\n+    CTxMemPool& pool;\n+    CCoinsViewCache view;\n+    CCoinsViewMemPool viewMemPool;\n+    CCoinsView dummy;\n+\n+    // The package limits in effect at the time of invocation.\n+    size_t nLimitAncestors{0};\n+    size_t nLimitAncestorSize{0};\n+    size_t nLimitDescendants{0};\n+    size_t nLimitDescendantSize{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304452211",
      "id" : 304452211,
      "in_reply_to_id" : 304359601,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ1MjIxMQ==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 125,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263112312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304452211",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304462008"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304462008"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sounds good.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T15:07:02Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304462008",
      "id" : 304462008,
      "in_reply_to_id" : 304362289,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ2MjAwOA==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 60,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263120731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304462008",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304462743"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304462743"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agreed - looks better that way.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T15:07:46Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304462743",
      "id" : 304462743,
      "in_reply_to_id" : 304361906,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ2Mjc0Mw==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 46,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263120731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304462743",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304468562"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304468562"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not convinced that removing default initialization is a win, but I'm also indifferent, so I'll take your preference.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T15:18:36Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304468562",
      "id" : 304468562,
      "in_reply_to_id" : 304371351,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ2ODU2Mg==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 75,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263120731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304468562",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304470126"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304470126"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The reason is that I end up needing to access the package size limits directly when adding `AcceptMultipleTransactions()` in #16401, whereas I didn't need local copies of the reject fee.  So my main motivation behind not saving these as members is to avoid cluttering the state, which was already complex to untangle.\r\n\r\nI don't feel strongly about this though; I just wanted to make it as easy as possible for reviewers and future code maintainers to be able to understand what data is required by each function.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T15:21:40Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};\n+\n+        const uint256& hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304470126",
      "id" : 304470126,
      "in_reply_to_id" : 304363188,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ3MDEyNg==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 104,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263120731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304470126",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304472162"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304472162"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I did think it was going to be easier for review if I didn't end up changing all the variables out at the same time.  I think my preferred approach would be to fix the variable names in MemPoolAccept, Workspace, and ATMPArgs to conform to the style guide, but then continue to use these aliases so that we're not also changing all the variables in each of these functions.\r\n\r\nOne benefit of the aliases is that it makes it easier to tell what variables we're not using as well.  I could also achieve that by changing the functions so that we pass in less data, such as by directly passing in only those members of the Workspace and Args structs that each function needs.  Perhaps that is a better approach?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T15:25:21Z",
      "diff_hunk" : "@@ -417,21 +418,135 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool) {\n+        nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n+        nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+    }\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n+     *                                coins cache, but were added as a result of validating the tx\n+     *                                for mempool acceptance. This allows the caller to optionally\n+     *                                remove the cache additions if the associated transaction ends\n+     *                                up being rejected by the mempool.\n+     */\n+    bool AcceptSingleTransaction(const CChainParams& chainparams, CTxMemPool& pool,\n+            CValidationState& state, const CTransactionRef& ptx,\n+            bool* pfMissingInputs, int64_t nAcceptTime,\n+            std::list<CTransactionRef>* plTxnReplaced, bool bypass_limits,\n+            const CAmount& nAbsurdFee,\n+            std::vector<COutPoint>& coins_to_uncache, bool test_accept);\n+\n+private:\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        bool test_accept;\n+    };\n+\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : hash(ptx->GetHash()) {}\n+        std::set<uint256> setConflicts;\n+        CTxMemPool::setEntries allConflicting;\n+        CTxMemPool::setEntries setAncestors;\n+        std::unique_ptr<CTxMemPoolEntry> entry;\n+\n+        bool fReplacementTransaction{false};\n+        CAmount nModifiedFees{0};\n+        CAmount nConflictingFees{0};\n+        size_t nConflictingSize{0};\n+\n+        const uint256& hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n+        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+        }\n+\n+        if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+        }\n+        return true;\n+    }\n+\n+private:\n+    CTxMemPool& pool;\n+    CCoinsViewCache view;\n+    CCoinsViewMemPool viewMemPool;\n+    CCoinsView dummy;\n+\n+    // The package limits in effect at the time of invocation.\n+    size_t nLimitAncestors{0};\n+    size_t nLimitAncestorSize{0};\n+    size_t nLimitDescendants{0};\n+    size_t nLimitDescendantSize{0};\n+};\n+\n+bool MemPoolAccept::PreChecks(ATMPArgs& args, const CTransactionRef& ptx, Workspace& ws)\n {\n     const CTransaction& tx = *ptx;\n-    const uint256 hash = tx.GetHash();\n-    AssertLockHeld(cs_main);\n-    LOCK(pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n+    const uint256& hash = ws.hash;\n+\n+    // Copy/alias what we need out of args\n+    CValidationState &state = args.state;\n+    bool* pfMissingInputs = args.pfMissingInputs;\n+    const int64_t nAcceptTime = args.nAcceptTime;\n+    const bool bypass_limits = args.bypass_limits;\n+    const CAmount& nAbsurdFee = args.nAbsurdFee;\n+    std::vector<COutPoint>& coins_to_uncache = args.coins_to_uncache;\n+\n+    // Alias what we need out of ws\n+    std::set<uint256>& setConflicts = ws.setConflicts;\n+    CTxMemPool::setEntries& allConflicting = ws.allConflicting;\n+    CTxMemPool::setEntries& setAncestors = ws.setAncestors;\n+    std::unique_ptr<CTxMemPoolEntry>& entry = ws.entry;\n+    bool& fReplacementTransaction = ws.fReplacementTransaction;\n+    CAmount& nModifiedFees = ws.nModifiedFees;\n+    CAmount& nConflictingFees = ws.nConflictingFees;\n+    size_t& nConflictingSize = ws.nConflictingSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304472162",
      "id" : 304472162,
      "in_reply_to_id" : 304366523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ3MjE2Mg==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 152,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263120731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304472162",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304472518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304472518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah I just wanted to call attention to it being wrong; given that we do keep a lock on the mempool throughout testing for acceptance, I wonder if we should just scrap the whole idea of using the dummy at all?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T15:26:02Z",
      "diff_hunk" : "@@ -503,322 +617,367 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n-        view.SetBackend(viewMemPool);\n+    LockPoints lp;\n+    CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+    view.SetBackend(viewMemPool);\n \n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // XXX: this comment is wrong/confusing, since we do retain a lock on the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304472518",
      "id" : 304472518,
      "in_reply_to_id" : 304372367,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ3MjUxOA==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 232,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263120731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304472518",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304473078"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304473078"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I had a version of this code where it was a unique_ptr, but thought this was an easy way to avoid a heap allocation that we don't really need.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T15:27:12Z",
      "diff_hunk" : "@@ -503,322 +617,367 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n-        view.SetBackend(viewMemPool);\n+    LockPoints lp;\n+    CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+    view.SetBackend(viewMemPool);\n \n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // XXX: this comment is wrong/confusing, since we do retain a lock on the mempool\n+    // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n+    view.SetBackend(dummy);\n \n-        // Only accept BIP68 sequence locked transactions that can be mined in the next\n-        // block; we don't want our mempool filled up with transactions that can't\n-        // be mined yet.\n-        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-        // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+    // Only accept BIP68 sequence locked transactions that can be mined in the next\n+    // block; we don't want our mempool filled up with transactions that can't\n+    // be mined yet.\n+    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+    // CoinsViewCache instead of create its own\n+    if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n-        CAmount nFees = 0;\n-        if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n-            return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n-        }\n+    CAmount nFees = 0;\n+    if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n+        return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n+    }\n \n-        // Check for non-standard pay-to-script-hash in inputs\n-        if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+    // Check for non-standard pay-to-script-hash in inputs\n+    if (fRequireStandard && !AreInputsStandard(tx, view))\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        // Check for non-standard witness in P2WSH\n-        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+    // Check for non-standard witness in P2WSH\n+    if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n-        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+    int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n-        // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-        CAmount nModifiedFees = nFees;\n-        pool.ApplyDelta(hash, nModifiedFees);\n+    // nModifiedFees includes any fee deltas from PrioritiseTransaction\n+    nModifiedFees = nFees;\n+    pool.ApplyDelta(hash, nModifiedFees);\n \n-        // Keep track of transactions that spend a coinbase, which we re-scan\n-        // during reorgs to ensure COINBASE_MATURITY is still met.\n-        bool fSpendsCoinbase = false;\n-        for (const CTxIn &txin : tx.vin) {\n-            const Coin &coin = view.AccessCoin(txin.prevout);\n-            if (coin.IsCoinBase()) {\n-                fSpendsCoinbase = true;\n-                break;\n-            }\n+    // Keep track of transactions that spend a coinbase, which we re-scan\n+    // during reorgs to ensure COINBASE_MATURITY is still met.\n+    bool fSpendsCoinbase = false;\n+    for (const CTxIn &txin : tx.vin) {\n+        const Coin &coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsCoinBase()) {\n+            fSpendsCoinbase = true;\n+            break;\n         }\n+    }\n \n-        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n-                              fSpendsCoinbase, nSigOpsCost, lp);\n-        unsigned int nSize = entry.GetTxSize();\n+    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+            fSpendsCoinbase, nSigOpsCost, lp));\n+    unsigned int nSize = entry->GetTxSize();\n \n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n-        if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n-        }\n-\n-        // No transactions are allowed below minRelayTxFee except from disconnected blocks\n-        if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n-        }\n+    // No transactions are allowed below minRelayTxFee except from disconnected\n+    // blocks\n+    if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n-        if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n+    if (nAbsurdFee && nFees > nAbsurdFee)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n-        // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-        std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n-        }\n+    // Calculate in-mempool ancestors, up to a limit.\n+    std::string errString;\n+    if (!pool.CalculateMemPoolAncestors(*entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+    }\n \n-        // A transaction that spends outputs that would be replaced by it is invalid. Now\n-        // that we have the set of all ancestors we can detect this\n-        // pathological case by making sure setConflicts and setAncestors don't\n-        // intersect.\n-        for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    // A transaction that spends outputs that would be replaced by it is invalid. Now\n+    // that we have the set of all ancestors we can detect this\n+    // pathological case by making sure setConflicts and setAncestors don't\n+    // intersect.\n+    for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    {\n+        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        if (setConflicts.count(hashAncestor))\n         {\n-            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n-            if (setConflicts.count(hashAncestor))\n-            {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n-            }\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+                    strprintf(\"%s spends conflicting transaction %s\",\n+                        hash.ToString(),\n+                        hashAncestor.ToString()));\n         }\n+    }\n \n-        // Check if it's economically rational to mine this transaction rather\n-        // than the ones it replaces.\n-        CAmount nConflictingFees = 0;\n-        size_t nConflictingSize = 0;\n-        uint64_t nConflictingCount = 0;\n-        CTxMemPool::setEntries allConflicting;\n-\n-        // If we don't hold the lock allConflicting might be incomplete; the\n-        // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n-        // mempool consistency for us.\n-        const bool fReplacementTransaction = setConflicts.size();\n-        if (fReplacementTransaction)\n-        {\n-            CFeeRate newFeeRate(nModifiedFees, nSize);\n-            std::set<uint256> setConflictsParents;\n-            const int maxDescendantsToVisit = 100;\n-            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n-            for (const auto& mi : setIterConflicting) {\n-                // Don't allow the replacement to reduce the feerate of the\n-                // mempool.\n-                //\n-                // We usually don't want to accept replacements with lower\n-                // feerates than what they replaced as that would lower the\n-                // feerate of the next block. Requiring that the feerate always\n-                // be increased is also an easy-to-reason about way to prevent\n-                // DoS attacks via replacements.\n-                //\n-                // We only consider the feerates of transactions being directly\n-                // replaced, not their indirect descendants. While that does\n-                // mean high feerate children are ignored when deciding whether\n-                // or not to replace, we do require the replacement to pay more\n-                // overall fees too, mitigating most cases.\n-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-                if (newFeeRate <= oldFeeRate)\n-                {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                                  hash.ToString(),\n-                                  newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()));\n-                }\n-\n-                for (const CTxIn &txin : mi->GetTx().vin)\n-                {\n-                    setConflictsParents.insert(txin.prevout.hash);\n-                }\n+    // Check if it's economically rational to mine this transaction rather\n+    // than the ones it replaces.\n+    nConflictingFees = 0;\n+    nConflictingSize = 0;\n+    uint64_t nConflictingCount = 0;\n \n-                nConflictingCount += mi->GetCountWithDescendants();\n-            }\n-            // This potentially overestimates the number of actual descendants\n-            // but we just want to be conservative to avoid doing too much\n-            // work.\n-            if (nConflictingCount <= maxDescendantsToVisit) {\n-                // If not too many to replace, then calculate the set of\n-                // transactions that would have to be evicted\n-                for (CTxMemPool::txiter it : setIterConflicting) {\n-                    pool.CalculateDescendants(it, allConflicting);\n-                }\n-                for (CTxMemPool::txiter it : allConflicting) {\n-                    nConflictingFees += it->GetModifiedFee();\n-                    nConflictingSize += it->GetTxSize();\n-                }\n-            } else {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n-                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+    // If we don't hold the lock allConflicting might be incomplete; the\n+    // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n+    // mempool consistency for us.\n+    fReplacementTransaction = setConflicts.size();\n+    if (fReplacementTransaction)\n+    {\n+        CFeeRate newFeeRate(nModifiedFees, nSize);\n+        std::set<uint256> setConflictsParents;\n+        const int maxDescendantsToVisit = 100;\n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n+        for (const auto& mi : setIterConflicting) {\n+            // Don't allow the replacement to reduce the feerate of the\n+            // mempool.\n+            //\n+            // We usually don't want to accept replacements with lower\n+            // feerates than what they replaced as that would lower the\n+            // feerate of the next block. Requiring that the feerate always\n+            // be increased is also an easy-to-reason about way to prevent\n+            // DoS attacks via replacements.\n+            //\n+            // We only consider the feerates of transactions being directly\n+            // replaced, not their indirect descendants. While that does\n+            // mean high feerate children are ignored when deciding whether\n+            // or not to replace, we do require the replacement to pay more\n+            // overall fees too, mitigating most cases.\n+            CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n-                            nConflictingCount,\n-                            maxDescendantsToVisit));\n+                            newFeeRate.ToString(),\n+                            oldFeeRate.ToString()));\n             }\n \n-            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            for (const CTxIn &txin : mi->GetTx().vin)\n             {\n-                // We don't want to accept replacements that require low\n-                // feerate junk to be mined first. Ideally we'd keep track of\n-                // the ancestor feerates and make the decision based on that,\n-                // but for now requiring all new inputs to be confirmed works.\n-                if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n-                {\n-                    // Rather than check the UTXO set - potentially expensive -\n-                    // it's cheaper to just check if the new input refers to a\n-                    // tx that's in the mempool.\n-                    if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n-                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j));\n-                    }\n-                }\n+                setConflictsParents.insert(txin.prevout.hash);\n             }\n \n-            // The replacement must pay greater fees than the transactions it\n-            // replaces - if we did the bandwidth used by those conflicting\n-            // transactions would not be paid for.\n-            if (nModifiedFees < nConflictingFees)\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+            nConflictingCount += mi->GetCountWithDescendants();\n+        }\n+        // This potentially overestimates the number of actual descendants\n+        // but we just want to be conservative to avoid doing too much\n+        // work.\n+        if (nConflictingCount <= maxDescendantsToVisit) {\n+            // If not too many to replace, then calculate the set of\n+            // transactions that would have to be evicted\n+            for (CTxMemPool::txiter it : setIterConflicting) {\n+                pool.CalculateDescendants(it, allConflicting);\n             }\n-\n-            // Finally in addition to paying more fees than the conflicts the\n-            // new transaction must pay for its own bandwidth.\n-            CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                              hash.ToString(),\n-                              FormatMoney(nDeltaFees),\n-                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+            for (CTxMemPool::txiter it : allConflicting) {\n+                nConflictingFees += it->GetModifiedFee();\n+                nConflictingSize += it->GetTxSize();\n             }\n+        } else {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n+                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                        hash.ToString(),\n+                        nConflictingCount,\n+                        maxDescendantsToVisit));\n         }\n \n-        constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n-\n-        // Check against previous transactions\n-        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        PrecomputedTransactionData txdata(tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304473078",
      "id" : 304473078,
      "in_reply_to_id" : 304370428,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDQ3MzA3OA==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 556,
      "path" : "src/validation.cpp",
      "position" : 594,
      "pull_request_review_id" : 263120731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304473078",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304563740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304563740"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could move this doc to `ATMPArgs::coins_to_uncache`?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-17T17:51:53Z",
      "diff_hunk" : "@@ -417,21 +418,129 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : pool(mempool), view(&dummy), viewMemPool(pcoinsTip.get(), pool),\n+        nLimitAncestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        nLimitAncestorSize(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        nLimitDescendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        nLimitDescendantSize(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& chainparams;\n+        CValidationState &state;\n+        bool* pfMissingInputs;\n+        const int64_t nAcceptTime;\n+        std::list<CTransactionRef>* plTxnReplaced;\n+        const bool bypass_limits;\n+        const CAmount& nAbsurdFee;\n+        std::vector<COutPoint>& coins_to_uncache;\n+        const bool test_accept;\n+    };\n+\n+    /**\n+     * Single transaction acceptance\n+     *\n+     * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304563740",
      "id" : 304563740,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDU2Mzc0MA==",
      "original_commit_id" : "52e932e68c29260e02bb5236171a99bc66bc87e7",
      "original_position" : 48,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263218127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304563740",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I went ahead and squashed the commits up to the variable rename, unsquashed version is here: [16400.1](https://github.com/sdaftuar/bitcoin/commits/16400.1)",
      "created_at" : "2019-07-17T19:08:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-512528705",
      "id" : 512528705,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMjUyODcwNQ==",
      "updated_at" : "2019-07-17T19:08:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/512528705",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304918462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304918462"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Cleaned this up by changing the comment to give a reason why we might actually want to still use a dummy here, thanks @MarcoFalke ",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-18T13:32:58Z",
      "diff_hunk" : "@@ -503,322 +617,367 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n-        view.SetBackend(viewMemPool);\n+    LockPoints lp;\n+    CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+    view.SetBackend(viewMemPool);\n \n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // XXX: this comment is wrong/confusing, since we do retain a lock on the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r304918462",
      "id" : 304918462,
      "in_reply_to_id" : 304372367,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNDkxODQ2Mg==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 232,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 263656584,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/304918462",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Re-running travis",
      "created_at" : "2019-07-23T19:41:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-514354930",
      "id" : 514354930,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNDM1NDkzMA==",
      "updated_at" : "2019-07-23T19:41:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/514354930",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Minor side-note: It looks like this conflicts with some other pulls such as assumeutxo and other work happening on the mempool. Potentially a lot of the conflicts come from whitespace changes, so maybe those could be deferred until later or not done at all?",
      "created_at" : "2019-07-23T20:22:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-514369196",
      "id" : 514369196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNDM2OTE5Ng==",
      "updated_at" : "2019-07-23T20:22:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/514369196",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306638080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306638080"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Doesn't seem necessary?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T05:59:18Z",
      "diff_hunk" : "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <validation.h>\n+#include <memory>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306638080",
      "id" : 306638080,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjYzODA4MA==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 4,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 265805023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306638080",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306638949"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306638949"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Seems like `m_coins_to_uncache` could just be a member var of `MemPoolAccept` directly; with either a `UncacheCoins()` method invoked by the caller on failure, or having a `~MemPoolAccept()` destructor that automatically uncaches, with `AcceptSingleTransaction` calling `m_coins_to_uncache.clear()` before returning true to avoid uncaching things that should remain cached.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T06:03:30Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306638949",
      "id" : 306638949,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjYzODk0OQ==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 48,
      "path" : "src/validation.cpp",
      "position" : 46,
      "pull_request_review_id" : 265805023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306638949",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306640022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306640022"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could emphasise that this is per-transaction workspace, as opposed to `m_view`, `m_viewmempool` and `m_dummy`",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T06:07:52Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args);\n+\n+private:\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306640022",
      "id" : 306640022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjY0MDAyMg==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 58,
      "path" : "src/validation.cpp",
      "position" : 56,
      "pull_request_review_id" : 265805023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306640022",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306640269"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306640269"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should have `EXCLUSIVE_LOCKS_REQUIRED(cs_main)`",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T06:08:47Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306640269",
      "id" : 306640269,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjY0MDI2OQ==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 265805023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306640269",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306640536"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306640536"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Probably should have `namespace { class MemPoolAccept { }; };` so these methods get internal linkage, to match the \"static\" they used to have.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T06:09:52Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306640536",
      "id" : 306640536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjY0MDUzNg==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 22,
      "path" : "src/validation.cpp",
      "position" : 16,
      "pull_request_review_id" : 265805023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306640536",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306641375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306641375"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could set `const CTransaction& m_tx = *ptx` in Workspace, to save passing `ptx` around as an argument. Once you get to AcceptMultipleTransactions, I think this would let you just iterate over `tx_workspaces` instead of having to simultaneously iterate over `tx_list` and `tx_workspaces` which would make that code a bit simpler.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T06:13:34Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args);\n+\n+private:\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306641375",
      "id" : 306641375,
      "in_reply_to_id" : 306640022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjY0MTM3NQ==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 58,
      "path" : "src/validation.cpp",
      "position" : 56,
      "pull_request_review_id" : 265805023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306641375",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306641758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306641758"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think you could make it even easier by having `const ATMPArgs m_args` as a member of MemPoolAccept, and not passing it around at all. That doesn't work for `m_bypass_limits` in AcceptMultipleTransactions, but you're basically manually checking the limits there anyway, so maybe could do `false` for all of them; otherwise could use `Workspace` for per-tx logic.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T06:15:14Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306641758",
      "id" : 306641758,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjY0MTc1OA==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 33,
      "path" : "src/validation.cpp",
      "position" : 31,
      "pull_request_review_id" : 265805023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306641758",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306823205"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306823205"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I have no idea now why I thought I needed it, gone.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T13:56:18Z",
      "diff_hunk" : "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <validation.h>\n+#include <memory>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306823205",
      "id" : 306823205,
      "in_reply_to_id" : 306638080,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjgyMzIwNQ==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 4,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 266037407,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306823205",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306823270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306823270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sounds good.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T13:56:25Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306823270",
      "id" : 306823270,
      "in_reply_to_id" : 306640536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjgyMzI3MA==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 22,
      "path" : "src/validation.cpp",
      "position" : 16,
      "pull_request_review_id" : 266037407,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306823270",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306833790"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306833790"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's one place in PreChecks() where we need ptx, but we can cache that in Workspace at least. Done.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T14:15:17Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args);\n+\n+private:\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306833790",
      "id" : 306833790,
      "in_reply_to_id" : 306640022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjgzMzc5MA==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 58,
      "path" : "src/validation.cpp",
      "position" : 56,
      "pull_request_review_id" : 266037407,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306833790",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306833880"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306833880"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T14:15:28Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306833880",
      "id" : 306833880,
      "in_reply_to_id" : 306640269,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjgzMzg4MA==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 266037407,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306833880",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306843163"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306843163"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think I'm going to leave this as-is for the moment.  I do think that holistically, we can think about doing one of two things with this refactor:\r\n\r\n(a) go all in for storing state in the class and not pass around data between member functions\r\n(b) dump this class and pass state around explicitly instead\r\n\r\nI did something weird in this PR where I started to introduce a class (mostly to function as a namespace, I guess!), but I mostly clung to the historical style of passing everything around anyway (except for the mempool/coinsview related things, and the chain limits).  So this is probably a pretty weird state to leave things, and I'm happy to dive down either direction so that the design is more cohesive, but I'd like feedback on which way to go.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T14:31:26Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306843163",
      "id" : 306843163,
      "in_reply_to_id" : 306641758,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjg0MzE2Mw==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 33,
      "path" : "src/validation.cpp",
      "position" : 31,
      "pull_request_review_id" : 266037407,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306843163",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306844481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306844481"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure it makes sense to mix ATMP logic at this layer with managing the utxo cache -- I think that's better handled by callers in the long run, even we're just doing something very simple now.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-24T14:33:37Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r306844481",
      "id" : 306844481,
      "in_reply_to_id" : 306638949,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNjg0NDQ4MQ==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 48,
      "path" : "src/validation.cpp",
      "position" : 46,
      "pull_request_review_id" : 266037407,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/306844481",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r307075556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/307075556"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm, I was thinking of it more as \"ATMP logic messes up the cache when it decides it can't accept, so cleaning up that mess should also be part of ATMP logic\". But having it be done in ATMPWithTime is still part of ATMP in my book, so either way works.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-25T00:41:50Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r307075556",
      "id" : 307075556,
      "in_reply_to_id" : 306638949,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNzA3NTU1Ng==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 48,
      "path" : "src/validation.cpp",
      "position" : 46,
      "pull_request_review_id" : 266352206,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/307075556",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r307080579"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/307080579"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I guess I think either way is fine, but my preference is to keep the class for namespacing (so it's clear the private methods are only called from the public ones), and to keep the number of explicit params to the functions pretty small -- pulling the stuff you actually need from the Args/Workspace structs like you do looks good to me.\r\n\r\nMaybe it might make sense to only pass things as args if they aren't known got MemPoolAccept's constructor or can be deallocated before the end -- like txdata -- or are per-transaction -- like Workspace?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-07-25T01:12:42Z",
      "diff_hunk" : "@@ -422,21 +423,128 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+class MemPoolAccept\n+{\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r307080579",
      "id" : 307080579,
      "in_reply_to_id" : 306641758,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwNzA4MDU3OQ==",
      "original_commit_id" : "a372e03e8921a7cd423f997375f8ae075be4eec4",
      "original_position" : 33,
      "path" : "src/validation.cpp",
      "position" : 31,
      "pull_request_review_id" : 266358231,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/307080579",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-07-29T18:54:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-516117958",
      "id" : 516117958,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjExNzk1OA==",
      "updated_at" : "2019-07-29T18:54:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516117958",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2019-07-31T14:20:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-516869950",
      "id" : 516869950,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjg2OTk1MA==",
      "updated_at" : "2019-07-31T14:20:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516869950",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r311672077"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/311672077"
         }
      },
      "author_association" : "MEMBER",
      "body" : "note to other reviewers. This says \"package\", but in the current code this is a single tx (the one that is added)",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-08-07T17:24:41Z",
      "diff_hunk" : "@@ -423,21 +423,132 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+namespace {\n+\n+class MemPoolAccept\n {\n-    const CTransaction& tx = *ptx;\n-    const uint256 hash = tx.GetHash();\n-    AssertLockHeld(cs_main);\n-    LOCK(pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+private:\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n+        std::set<uint256> m_conflicts;\n+        CTxMemPool::setEntries m_all_conflicting;\n+        CTxMemPool::setEntries m_ancestors;\n+        std::unique_ptr<CTxMemPoolEntry> m_entry;\n+\n+        bool m_replacement_transaction;\n+        CAmount m_modified_fees;\n+        CAmount m_conflicting_fees;\n+        size_t m_conflicting_size;\n+\n+        const CTransactionRef& m_ptx;\n+        const uint256& m_hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r311672077",
      "id" : 311672077,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxMTY3MjA3Nw==",
      "original_commit_id" : "0840a1d2e2270c06342710c4ebfaac1c41652dab",
      "original_position" : 93,
      "path" : "src/validation.cpp",
      "position" : 93,
      "pull_request_review_id" : 272114026,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/311672077",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r311676031"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/311676031"
         }
      },
      "author_association" : "MEMBER",
      "body" : "doc-nit: Should this say that this method fully initializes the `ws`? Or is this only a coincidence not worth to mention?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-08-07T17:33:34Z",
      "diff_hunk" : "@@ -423,21 +423,132 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+namespace {\n+\n+class MemPoolAccept\n {\n-    const CTransaction& tx = *ptx;\n-    const uint256 hash = tx.GetHash();\n-    AssertLockHeld(cs_main);\n-    LOCK(pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+private:\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n+        std::set<uint256> m_conflicts;\n+        CTxMemPool::setEntries m_all_conflicting;\n+        CTxMemPool::setEntries m_ancestors;\n+        std::unique_ptr<CTxMemPoolEntry> m_entry;\n+\n+        bool m_replacement_transaction;\n+        CAmount m_modified_fees;\n+        CAmount m_conflicting_fees;\n+        size_t m_conflicting_size;\n+\n+        const CTransactionRef& m_ptx;\n+        const uint256& m_hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r311676031",
      "id" : 311676031,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxMTY3NjAzMQ==",
      "original_commit_id" : "0840a1d2e2270c06342710c4ebfaac1c41652dab",
      "original_position" : 75,
      "path" : "src/validation.cpp",
      "position" : 75,
      "pull_request_review_id" : 272114026,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/311676031",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 0840a1d2e2270c06342710c4ebfaac1c41652dab (read diff with --ignore-all-space)\r\n\r\nI like that this splits up the massivley large ATMP into logical chunks\r\n(not only functional separate checks, but also structural into args and\r\nworkspace). With the added documentation, the code is probably easier to\r\nunderstand now.\r\n\r\n<details><summary>Show signature and timestamp</summary>\r\n\r\nSignature:\r\n\r\n```\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA512\r\n\r\nACK 0840a1d2e2270c06342710c4ebfaac1c41652dab (read diff with --ignore-all-space)\r\n\r\nI like that this splits up the massivley large ATMP into logical chunks\r\n(not only functional separate checks, but also structural into args and\r\nworkspace). With the added documentation, the code is probably easier to\r\nunderstand now.\r\n-----BEGIN PGP SIGNATURE-----\r\n\r\niQGzBAEBCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\r\npUg9Qgv/euaSC1DAapYXrYcl9nrFF04qsMeVtv3lJ8hupHNjRXHpTFZoLE2uUO3T\r\n+kf5rugC1UuImZsVOy4odQ0+rVIrnLhrI7DqECzQ+P7OX4+JN/Wf6dfciHzznGsX\r\nh+lrDEDgs0MuCEgsoQAIgQe39IDsexNQyE5i6+dEZtbqhhiuT+hoJAH8Hj3TKQib\r\n60Sn7yBpdOSgYnZM1TTELCYSL4lDzXIFH5lW3ojj2oYF+1AnAqjRU8EydUH0wGRX\r\nsK1PtCdI8dXhTXChHYnku24e0cR1VCHMjPmLXXxtqp9xm0qVtDMH7coSgOdY9SRx\r\nOO++RjA+8oag5YmCxZRVcvkZ7m/XlwRshGJDbKCSKy2vuW++MNJmTzkxUkZPUl7s\r\nBSrBP04DYMyhEtZHfcMV3oLbb8HZ/a9RJTbBlpQubEsvBT5SbcPdFMhMv7Ok6M6C\r\nSSQm56IF2bz/Ky6F1F1h1EVnVNpF1SXkXNHfnn5JfZoPVlbvvNk5k+iS7pVqxtOI\r\n5TNLNS1L\r\n=ZwOV\r\n-----END PGP SIGNATURE-----\r\n```\r\n\r\n[Timestamp of file with hash `e1313ca99cc4b41a7b44fb90863a0d30e70235c91504a644337a0c8a77443411  -`](https://opentimestamps.org/info/?004f70656e54696d657374616d7073000050726f6f6600bf89e2e884e892940108e1313ca99cc4b41a7b44fb90863a0d30e70235c91504a644337a0c8a77443411f010a15c9c0dcaeb257c50050d3601dedf5308fff0101dbe01be571f0ed83bc31f2e61ff0afc08f1045d4b1243f008286216ed747051ef0083dfe30d2ef90c8e232268747470733a2f2f6274632e63616c656e6461722e636174616c6c6178792e636f6dfff010393198f0009ff6c907f02d62523a535808f1045d4b1243f008c36ab10af774fce80083dfe30d2ef90c8e2e2d68747470733a2f2f616c6963652e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267f0105cedc66d870942b1f50bbd2c4517b2fe08f1045d4b1242f008acc1024b76df69880083dfe30d2ef90c8e2c2b68747470733a2f2f626f622e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267)\r\n\r\n</details>\r\n",
      "created_at" : "2019-08-07T18:03:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-519207091",
      "id" : 519207091,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxOTIwNzA5MQ==",
      "updated_at" : "2019-08-07T18:03:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/519207091",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "utACK 0840a1d2e2270c06342710c4ebfaac1c41652dab.",
      "created_at" : "2019-08-14T20:11:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-521399819",
      "id" : 521399819,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyMTM5OTgxOQ==",
      "updated_at" : "2019-08-14T20:11:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/521399819",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r314198443"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314198443"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Seems a bit weird to have `m_entry` as a `unique_ptr`, but not have `txdata` in there as well just to avoid it being on the heap. I think making `txdata` a `unique_ptr` in Workspace would simplify #16401 a bit too.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-08-15T07:18:57Z",
      "diff_hunk" : "@@ -503,322 +617,367 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n-        view.SetBackend(viewMemPool);\n+    LockPoints lp;\n+    CCoinsViewMemPool viewMemPool(pcoinsTip.get(), pool);\n+    view.SetBackend(viewMemPool);\n \n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (pcoinsTip.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // XXX: this comment is wrong/confusing, since we do retain a lock on the mempool\n+    // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n+    view.SetBackend(dummy);\n \n-        // Only accept BIP68 sequence locked transactions that can be mined in the next\n-        // block; we don't want our mempool filled up with transactions that can't\n-        // be mined yet.\n-        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-        // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+    // Only accept BIP68 sequence locked transactions that can be mined in the next\n+    // block; we don't want our mempool filled up with transactions that can't\n+    // be mined yet.\n+    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+    // CoinsViewCache instead of create its own\n+    if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n-        CAmount nFees = 0;\n-        if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n-            return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n-        }\n+    CAmount nFees = 0;\n+    if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n+        return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n+    }\n \n-        // Check for non-standard pay-to-script-hash in inputs\n-        if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+    // Check for non-standard pay-to-script-hash in inputs\n+    if (fRequireStandard && !AreInputsStandard(tx, view))\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        // Check for non-standard witness in P2WSH\n-        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+    // Check for non-standard witness in P2WSH\n+    if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n-        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+    int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n-        // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-        CAmount nModifiedFees = nFees;\n-        pool.ApplyDelta(hash, nModifiedFees);\n+    // nModifiedFees includes any fee deltas from PrioritiseTransaction\n+    nModifiedFees = nFees;\n+    pool.ApplyDelta(hash, nModifiedFees);\n \n-        // Keep track of transactions that spend a coinbase, which we re-scan\n-        // during reorgs to ensure COINBASE_MATURITY is still met.\n-        bool fSpendsCoinbase = false;\n-        for (const CTxIn &txin : tx.vin) {\n-            const Coin &coin = view.AccessCoin(txin.prevout);\n-            if (coin.IsCoinBase()) {\n-                fSpendsCoinbase = true;\n-                break;\n-            }\n+    // Keep track of transactions that spend a coinbase, which we re-scan\n+    // during reorgs to ensure COINBASE_MATURITY is still met.\n+    bool fSpendsCoinbase = false;\n+    for (const CTxIn &txin : tx.vin) {\n+        const Coin &coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsCoinBase()) {\n+            fSpendsCoinbase = true;\n+            break;\n         }\n+    }\n \n-        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n-                              fSpendsCoinbase, nSigOpsCost, lp);\n-        unsigned int nSize = entry.GetTxSize();\n+    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+            fSpendsCoinbase, nSigOpsCost, lp));\n+    unsigned int nSize = entry->GetTxSize();\n \n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n-        if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n-        }\n-\n-        // No transactions are allowed below minRelayTxFee except from disconnected blocks\n-        if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n-        }\n+    // No transactions are allowed below minRelayTxFee except from disconnected\n+    // blocks\n+    if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n-        if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n+    if (nAbsurdFee && nFees > nAbsurdFee)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n-        // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-        std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n-        }\n+    // Calculate in-mempool ancestors, up to a limit.\n+    std::string errString;\n+    if (!pool.CalculateMemPoolAncestors(*entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n+        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+    }\n \n-        // A transaction that spends outputs that would be replaced by it is invalid. Now\n-        // that we have the set of all ancestors we can detect this\n-        // pathological case by making sure setConflicts and setAncestors don't\n-        // intersect.\n-        for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    // A transaction that spends outputs that would be replaced by it is invalid. Now\n+    // that we have the set of all ancestors we can detect this\n+    // pathological case by making sure setConflicts and setAncestors don't\n+    // intersect.\n+    for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    {\n+        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        if (setConflicts.count(hashAncestor))\n         {\n-            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n-            if (setConflicts.count(hashAncestor))\n-            {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n-            }\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+                    strprintf(\"%s spends conflicting transaction %s\",\n+                        hash.ToString(),\n+                        hashAncestor.ToString()));\n         }\n+    }\n \n-        // Check if it's economically rational to mine this transaction rather\n-        // than the ones it replaces.\n-        CAmount nConflictingFees = 0;\n-        size_t nConflictingSize = 0;\n-        uint64_t nConflictingCount = 0;\n-        CTxMemPool::setEntries allConflicting;\n-\n-        // If we don't hold the lock allConflicting might be incomplete; the\n-        // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n-        // mempool consistency for us.\n-        const bool fReplacementTransaction = setConflicts.size();\n-        if (fReplacementTransaction)\n-        {\n-            CFeeRate newFeeRate(nModifiedFees, nSize);\n-            std::set<uint256> setConflictsParents;\n-            const int maxDescendantsToVisit = 100;\n-            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n-            for (const auto& mi : setIterConflicting) {\n-                // Don't allow the replacement to reduce the feerate of the\n-                // mempool.\n-                //\n-                // We usually don't want to accept replacements with lower\n-                // feerates than what they replaced as that would lower the\n-                // feerate of the next block. Requiring that the feerate always\n-                // be increased is also an easy-to-reason about way to prevent\n-                // DoS attacks via replacements.\n-                //\n-                // We only consider the feerates of transactions being directly\n-                // replaced, not their indirect descendants. While that does\n-                // mean high feerate children are ignored when deciding whether\n-                // or not to replace, we do require the replacement to pay more\n-                // overall fees too, mitigating most cases.\n-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-                if (newFeeRate <= oldFeeRate)\n-                {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                                  hash.ToString(),\n-                                  newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()));\n-                }\n-\n-                for (const CTxIn &txin : mi->GetTx().vin)\n-                {\n-                    setConflictsParents.insert(txin.prevout.hash);\n-                }\n+    // Check if it's economically rational to mine this transaction rather\n+    // than the ones it replaces.\n+    nConflictingFees = 0;\n+    nConflictingSize = 0;\n+    uint64_t nConflictingCount = 0;\n \n-                nConflictingCount += mi->GetCountWithDescendants();\n-            }\n-            // This potentially overestimates the number of actual descendants\n-            // but we just want to be conservative to avoid doing too much\n-            // work.\n-            if (nConflictingCount <= maxDescendantsToVisit) {\n-                // If not too many to replace, then calculate the set of\n-                // transactions that would have to be evicted\n-                for (CTxMemPool::txiter it : setIterConflicting) {\n-                    pool.CalculateDescendants(it, allConflicting);\n-                }\n-                for (CTxMemPool::txiter it : allConflicting) {\n-                    nConflictingFees += it->GetModifiedFee();\n-                    nConflictingSize += it->GetTxSize();\n-                }\n-            } else {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n-                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+    // If we don't hold the lock allConflicting might be incomplete; the\n+    // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n+    // mempool consistency for us.\n+    fReplacementTransaction = setConflicts.size();\n+    if (fReplacementTransaction)\n+    {\n+        CFeeRate newFeeRate(nModifiedFees, nSize);\n+        std::set<uint256> setConflictsParents;\n+        const int maxDescendantsToVisit = 100;\n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n+        for (const auto& mi : setIterConflicting) {\n+            // Don't allow the replacement to reduce the feerate of the\n+            // mempool.\n+            //\n+            // We usually don't want to accept replacements with lower\n+            // feerates than what they replaced as that would lower the\n+            // feerate of the next block. Requiring that the feerate always\n+            // be increased is also an easy-to-reason about way to prevent\n+            // DoS attacks via replacements.\n+            //\n+            // We only consider the feerates of transactions being directly\n+            // replaced, not their indirect descendants. While that does\n+            // mean high feerate children are ignored when deciding whether\n+            // or not to replace, we do require the replacement to pay more\n+            // overall fees too, mitigating most cases.\n+            CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n-                            nConflictingCount,\n-                            maxDescendantsToVisit));\n+                            newFeeRate.ToString(),\n+                            oldFeeRate.ToString()));\n             }\n \n-            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            for (const CTxIn &txin : mi->GetTx().vin)\n             {\n-                // We don't want to accept replacements that require low\n-                // feerate junk to be mined first. Ideally we'd keep track of\n-                // the ancestor feerates and make the decision based on that,\n-                // but for now requiring all new inputs to be confirmed works.\n-                if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n-                {\n-                    // Rather than check the UTXO set - potentially expensive -\n-                    // it's cheaper to just check if the new input refers to a\n-                    // tx that's in the mempool.\n-                    if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n-                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j));\n-                    }\n-                }\n+                setConflictsParents.insert(txin.prevout.hash);\n             }\n \n-            // The replacement must pay greater fees than the transactions it\n-            // replaces - if we did the bandwidth used by those conflicting\n-            // transactions would not be paid for.\n-            if (nModifiedFees < nConflictingFees)\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+            nConflictingCount += mi->GetCountWithDescendants();\n+        }\n+        // This potentially overestimates the number of actual descendants\n+        // but we just want to be conservative to avoid doing too much\n+        // work.\n+        if (nConflictingCount <= maxDescendantsToVisit) {\n+            // If not too many to replace, then calculate the set of\n+            // transactions that would have to be evicted\n+            for (CTxMemPool::txiter it : setIterConflicting) {\n+                pool.CalculateDescendants(it, allConflicting);\n             }\n-\n-            // Finally in addition to paying more fees than the conflicts the\n-            // new transaction must pay for its own bandwidth.\n-            CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                              hash.ToString(),\n-                              FormatMoney(nDeltaFees),\n-                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+            for (CTxMemPool::txiter it : allConflicting) {\n+                nConflictingFees += it->GetModifiedFee();\n+                nConflictingSize += it->GetTxSize();\n             }\n+        } else {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n+                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                        hash.ToString(),\n+                        nConflictingCount,\n+                        maxDescendantsToVisit));\n         }\n \n-        constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n-\n-        // Check against previous transactions\n-        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        PrecomputedTransactionData txdata(tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r314198443",
      "id" : 314198443,
      "in_reply_to_id" : 304370428,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNDE5ODQ0Mw==",
      "original_commit_id" : "a109ce24d719d709b4f2d3d129a165a9323a32b5",
      "original_position" : 556,
      "path" : "src/validation.cpp",
      "position" : 594,
      "pull_request_review_id" : 275290370,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314198443",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r314209941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314209941"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would make for a slightly smaller diff to say `CTxMemPoolEntry& entry = *ws.m_entry;` and only declare it after `m_entry` has been reset (and `assert(wx.m_entry);` beforehand in `Finalize` to keep the static analysis tools happy, I suppose)",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-08-15T08:03:26Z",
      "diff_hunk" : "@@ -423,21 +423,132 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n     return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n }\n \n-/**\n- * @param[out] coins_to_uncache   Return any outpoints which were not previously present in the\n- *                                coins cache, but were added as a result of validating the tx\n- *                                for mempool acceptance. This allows the caller to optionally\n- *                                remove the cache additions if the associated transaction ends\n- *                                up being rejected by the mempool.\n- */\n-static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n-                              bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+namespace {\n+\n+class MemPoolAccept\n {\n-    const CTransaction& tx = *ptx;\n-    const uint256 hash = tx.GetHash();\n-    AssertLockHeld(cs_main);\n-    LOCK(pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n+public:\n+    MemPoolAccept(CTxMemPool& mempool) : m_pool(mempool), m_view(&m_dummy), m_viewmempool(pcoinsTip.get(), m_pool),\n+        m_limit_ancestors(gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT)),\n+        m_limit_ancestor_size(gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000),\n+        m_limit_descendants(gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT)),\n+        m_limit_descendant_size(gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000) {}\n+\n+    // We put the arguments we're handed into a struct, so we can pass them\n+    // around easier.\n+    struct ATMPArgs {\n+        const CChainParams& m_chainparams;\n+        CValidationState &m_state;\n+        bool* m_missing_inputs;\n+        const int64_t m_accept_time;\n+        std::list<CTransactionRef>* m_replaced_transactions;\n+        const bool m_bypass_limits;\n+        const CAmount& m_absurd_fee;\n+        /*\n+         * Return any outpoints which were not previously present in the coins\n+         * cache, but were added as a result of validating the tx for mempool\n+         * acceptance. This allows the caller to optionally remove the cache\n+         * additions if the associated transaction ends up being rejected by\n+         * the mempool.\n+         */\n+        std::vector<COutPoint>& m_coins_to_uncache;\n+        const bool m_test_accept;\n+    };\n+\n+    // Single transaction acceptance\n+    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+private:\n+    // All the intermediate state that gets passed between the various levels\n+    // of checking a given transaction.\n+    struct Workspace {\n+        Workspace(const CTransactionRef& ptx) : m_ptx(ptx), m_hash(ptx->GetHash()) {}\n+        std::set<uint256> m_conflicts;\n+        CTxMemPool::setEntries m_all_conflicting;\n+        CTxMemPool::setEntries m_ancestors;\n+        std::unique_ptr<CTxMemPoolEntry> m_entry;\n+\n+        bool m_replacement_transaction;\n+        CAmount m_modified_fees;\n+        CAmount m_conflicting_fees;\n+        size_t m_conflicting_size;\n+\n+        const CTransactionRef& m_ptx;\n+        const uint256& m_hash;\n+    };\n+\n+    // Run the policy checks on a given transaction, excluding any script checks.\n+    // Looks up inputs, calculates feerate, considers replacement, evaluates\n+    // package limits, etc. As this function can be invoked for \"free\" by a peer,\n+    // only tests that are fast should be done here (to avoid CPU DoS).\n+    bool PreChecks(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n+    // Run the script checks using our policy flags. As this can be slow, we should\n+    // only invoke this on transactions that have otherwise passed policy checks.\n+    bool PolicyScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Re-run the script checks, using consensus flags, and try to cache the\n+    // result in the scriptcache. This should be done after\n+    // PolicyScriptChecks(). This requires that all inputs either be in our\n+    // utxo set or in the mempool.\n+    bool ConsensusScriptChecks(ATMPArgs& args, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    // Try to add the transaction to the mempool, removing any conflicts first.\n+    // Returns true if the transaction is in the mempool after any size\n+    // limiting is performed, false otherwise.\n+    bool Finalize(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+\n+    // Compare a package's feerate against minimum allowed.\n+    bool CheckFeeRate(size_t package_size, CAmount package_fee, CValidationState& state)\n+    {\n+        CAmount mempoolRejectFee = m_pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n+        if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+        }\n+\n+        if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+        }\n+        return true;\n+    }\n+\n+private:\n+    CTxMemPool& m_pool;\n+    CCoinsViewCache m_view;\n+    CCoinsViewMemPool m_viewmempool;\n+    CCoinsView m_dummy;\n+\n+    // The package limits in effect at the time of invocation.\n+    const size_t m_limit_ancestors;\n+    const size_t m_limit_ancestor_size;\n+    const size_t m_limit_descendants;\n+    const size_t m_limit_descendant_size;\n+};\n+\n+bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n+{\n+    const CTransactionRef& ptx = ws.m_ptx;\n+    const CTransaction& tx = *ws.m_ptx;\n+    const uint256& hash = ws.m_hash;\n+\n+    // Copy/alias what we need out of args\n+    CValidationState &state = args.m_state;\n+    bool* pfMissingInputs = args.m_missing_inputs;\n+    const int64_t nAcceptTime = args.m_accept_time;\n+    const bool bypass_limits = args.m_bypass_limits;\n+    const CAmount& nAbsurdFee = args.m_absurd_fee;\n+    std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;\n+\n+    // Alias what we need out of ws\n+    std::set<uint256>& setConflicts = ws.m_conflicts;\n+    CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n+    CTxMemPool::setEntries& setAncestors = ws.m_ancestors;\n+    std::unique_ptr<CTxMemPoolEntry>& entry = ws.m_entry;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r314209941",
      "id" : 314209941,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNDIwOTk0MQ==",
      "original_commit_id" : "0840a1d2e2270c06342710c4ebfaac1c41652dab",
      "original_position" : 138,
      "path" : "src/validation.cpp",
      "position" : 138,
      "pull_request_review_id" : 275290370,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314209941",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-08-15T17:10:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-521720053",
      "id" : 521720053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyMTcyMDA1Mw==",
      "updated_at" : "2019-08-15T17:10:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/521720053",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Oops. (For future reference, if you accidentally push master to your branch because, say, you didn't actually finish the rebase before you pushed, then the PR will autoclose.)",
      "created_at" : "2019-09-03T19:36:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-527606973",
      "id" : 527606973,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzYwNjk3Mw==",
      "updated_at" : "2019-09-03T19:39:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527606973",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r320450089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320450089"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason you remove this comment here?",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-09-03T19:54:07Z",
      "diff_hunk" : "@@ -514,353 +624,393 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n-        CCoinsViewMemPool viewMemPool(&coins_cache, pool);\n-        view.SetBackend(viewMemPool);\n-\n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    LockPoints lp;\n+    m_view.SetBackend(m_viewmempool);\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (CoinsTip().cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+    CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n+\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (coins_cache.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!m_view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    m_view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // we have all inputs cached now, so switch back to dummy (to protect\n+    // against bugs where we pull more inputs from disk that miss being added\n+    // to coins_to_uncache)\n+    m_view.SetBackend(m_dummy);\n \n-        // Only accept BIP68 sequence locked transactions that can be mined in the next\n-        // block; we don't want our mempool filled up with transactions that can't\n-        // be mined yet.\n-        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-        // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+    // Only accept BIP68 sequence locked transactions that can be mined in the next\n+    // block; we don't want our mempool filled up with transactions that can't\n+    // be mined yet.\n+    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+    // CoinsViewCache instead of create its own\n+    if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n-        CAmount nFees = 0;\n-        if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n-            return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n-        }\n+    CAmount nFees = 0;\n+    if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), nFees)) {\n+        return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n+    }\n \n-        // Check for non-standard pay-to-script-hash in inputs\n-        if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+    // Check for non-standard pay-to-script-hash in inputs\n+    if (fRequireStandard && !AreInputsStandard(tx, m_view))\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        // Check for non-standard witness in P2WSH\n-        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+    // Check for non-standard witness in P2WSH\n+    if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, m_view))\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n-        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+    int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n-        // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-        CAmount nModifiedFees = nFees;\n-        pool.ApplyDelta(hash, nModifiedFees);\n+    // nModifiedFees includes any fee deltas from PrioritiseTransaction\n+    nModifiedFees = nFees;\n+    m_pool.ApplyDelta(hash, nModifiedFees);\n \n-        // Keep track of transactions that spend a coinbase, which we re-scan\n-        // during reorgs to ensure COINBASE_MATURITY is still met.\n-        bool fSpendsCoinbase = false;\n-        for (const CTxIn &txin : tx.vin) {\n-            const Coin &coin = view.AccessCoin(txin.prevout);\n-            if (coin.IsCoinBase()) {\n-                fSpendsCoinbase = true;\n-                break;\n-            }\n+    // Keep track of transactions that spend a coinbase, which we re-scan\n+    // during reorgs to ensure COINBASE_MATURITY is still met.\n+    bool fSpendsCoinbase = false;\n+    for (const CTxIn &txin : tx.vin) {\n+        const Coin &coin = m_view.AccessCoin(txin.prevout);\n+        if (coin.IsCoinBase()) {\n+            fSpendsCoinbase = true;\n+            break;\n         }\n+    }\n \n-        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n-                              fSpendsCoinbase, nSigOpsCost, lp);\n-        unsigned int nSize = entry.GetTxSize();\n+    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+            fSpendsCoinbase, nSigOpsCost, lp));\n+    unsigned int nSize = entry->GetTxSize();\n \n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n-        if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n-        }\n-\n-        // No transactions are allowed below minRelayTxFee except from disconnected blocks\n-        if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n-        }\n+    // No transactions are allowed below minRelayTxFee except from disconnected\n+    // blocks\n+    if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n-        if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n+    if (nAbsurdFee && nFees > nAbsurdFee)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n-        // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-        std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            setAncestors.clear();\n-            // If CalculateMemPoolAncestors fails second time, we want the original error string.\n-            std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n-            }\n-        }\n-\n-        // A transaction that spends outputs that would be replaced by it is invalid. Now\n-        // that we have the set of all ancestors we can detect this\n-        // pathological case by making sure setConflicts and setAncestors don't\n-        // intersect.\n-        for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    // Calculate in-mempool ancestors, up to a limit.\n+    std::string errString;\n+    if (!m_pool.CalculateMemPoolAncestors(*entry, setAncestors, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants, m_limit_descendant_size, errString)) {\n+        setAncestors.clear();\n+        // If CalculateMemPoolAncestors fails second time, we want the original error string.\n+        std::string dummy_err_string;\n+        // If the new transaction is relatively small (up to 40k weight)\n+        // and has at most one ancestor (ie ancestor limit of 2, including\n+        // the new transaction), allow it if its parent has exactly the\n+        // descendant limit descendants.\n+        //\n+        // This allows protocols which rely on distrusting counterparties\n+        // being able to broadcast descendants of an unconfirmed transaction\n+        // to be secure by simply only having two immediately-spendable\n+        // outputs - one for each counterparty. For more info on the uses for\n+        // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n+        if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n+                !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+        }\n+    }\n+\n+    // A transaction that spends outputs that would be replaced by it is invalid. Now\n+    // that we have the set of all ancestors we can detect this\n+    // pathological case by making sure setConflicts and setAncestors don't\n+    // intersect.\n+    for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    {\n+        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        if (setConflicts.count(hashAncestor))\n         {\n-            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n-            if (setConflicts.count(hashAncestor))\n-            {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n-            }\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+                    strprintf(\"%s spends conflicting transaction %s\",\n+                        hash.ToString(),\n+                        hashAncestor.ToString()));\n         }\n+    }\n \n-        // Check if it's economically rational to mine this transaction rather\n-        // than the ones it replaces.\n-        CAmount nConflictingFees = 0;\n-        size_t nConflictingSize = 0;\n-        uint64_t nConflictingCount = 0;\n-        CTxMemPool::setEntries allConflicting;\n-\n-        // If we don't hold the lock allConflicting might be incomplete; the\n-        // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n-        // mempool consistency for us.\n-        const bool fReplacementTransaction = setConflicts.size();\n-        if (fReplacementTransaction)\n-        {\n-            CFeeRate newFeeRate(nModifiedFees, nSize);\n-            std::set<uint256> setConflictsParents;\n-            const int maxDescendantsToVisit = 100;\n-            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n-            for (const auto& mi : setIterConflicting) {\n-                // Don't allow the replacement to reduce the feerate of the\n-                // mempool.\n-                //\n-                // We usually don't want to accept replacements with lower\n-                // feerates than what they replaced as that would lower the\n-                // feerate of the next block. Requiring that the feerate always\n-                // be increased is also an easy-to-reason about way to prevent\n-                // DoS attacks via replacements.\n-                //\n-                // We only consider the feerates of transactions being directly\n-                // replaced, not their indirect descendants. While that does\n-                // mean high feerate children are ignored when deciding whether\n-                // or not to replace, we do require the replacement to pay more\n-                // overall fees too, mitigating most cases.\n-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-                if (newFeeRate <= oldFeeRate)\n-                {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                                  hash.ToString(),\n-                                  newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()));\n-                }\n-\n-                for (const CTxIn &txin : mi->GetTx().vin)\n-                {\n-                    setConflictsParents.insert(txin.prevout.hash);\n-                }\n+    // Check if it's economically rational to mine this transaction rather\n+    // than the ones it replaces.\n+    nConflictingFees = 0;\n+    nConflictingSize = 0;\n+    uint64_t nConflictingCount = 0;\n \n-                nConflictingCount += mi->GetCountWithDescendants();\n-            }\n-            // This potentially overestimates the number of actual descendants\n-            // but we just want to be conservative to avoid doing too much\n-            // work.\n-            if (nConflictingCount <= maxDescendantsToVisit) {\n-                // If not too many to replace, then calculate the set of\n-                // transactions that would have to be evicted\n-                for (CTxMemPool::txiter it : setIterConflicting) {\n-                    pool.CalculateDescendants(it, allConflicting);\n-                }\n-                for (CTxMemPool::txiter it : allConflicting) {\n-                    nConflictingFees += it->GetModifiedFee();\n-                    nConflictingSize += it->GetTxSize();\n-                }\n-            } else {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n-                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+    // If we don't hold the lock allConflicting might be incomplete; the\n+    // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n+    // mempool consistency for us.\n+    fReplacementTransaction = setConflicts.size();\n+    if (fReplacementTransaction)\n+    {\n+        CFeeRate newFeeRate(nModifiedFees, nSize);\n+        std::set<uint256> setConflictsParents;\n+        const int maxDescendantsToVisit = 100;\n+        const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n+        for (const auto& mi : setIterConflicting) {\n+            // Don't allow the replacement to reduce the feerate of the\n+            // mempool.\n+            //\n+            // We usually don't want to accept replacements with lower\n+            // feerates than what they replaced as that would lower the\n+            // feerate of the next block. Requiring that the feerate always\n+            // be increased is also an easy-to-reason about way to prevent\n+            // DoS attacks via replacements.\n+            //\n+            // We only consider the feerates of transactions being directly\n+            // replaced, not their indirect descendants. While that does\n+            // mean high feerate children are ignored when deciding whether\n+            // or not to replace, we do require the replacement to pay more\n+            // overall fees too, mitigating most cases.\n+            CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n-                            nConflictingCount,\n-                            maxDescendantsToVisit));\n+                            newFeeRate.ToString(),\n+                            oldFeeRate.ToString()));\n             }\n \n-            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            for (const CTxIn &txin : mi->GetTx().vin)\n             {\n-                // We don't want to accept replacements that require low\n-                // feerate junk to be mined first. Ideally we'd keep track of\n-                // the ancestor feerates and make the decision based on that,\n-                // but for now requiring all new inputs to be confirmed works.\n-                if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n-                {\n-                    // Rather than check the UTXO set - potentially expensive -\n-                    // it's cheaper to just check if the new input refers to a\n-                    // tx that's in the mempool.\n-                    if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n-                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j));\n-                    }\n-                }\n+                setConflictsParents.insert(txin.prevout.hash);\n             }\n \n-            // The replacement must pay greater fees than the transactions it\n-            // replaces - if we did the bandwidth used by those conflicting\n-            // transactions would not be paid for.\n-            if (nModifiedFees < nConflictingFees)\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+            nConflictingCount += mi->GetCountWithDescendants();\n+        }\n+        // This potentially overestimates the number of actual descendants\n+        // but we just want to be conservative to avoid doing too much\n+        // work.\n+        if (nConflictingCount <= maxDescendantsToVisit) {\n+            // If not too many to replace, then calculate the set of\n+            // transactions that would have to be evicted\n+            for (CTxMemPool::txiter it : setIterConflicting) {\n+                m_pool.CalculateDescendants(it, allConflicting);\n             }\n-\n-            // Finally in addition to paying more fees than the conflicts the\n-            // new transaction must pay for its own bandwidth.\n-            CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                              hash.ToString(),\n-                              FormatMoney(nDeltaFees),\n-                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+            for (CTxMemPool::txiter it : allConflicting) {\n+                nConflictingFees += it->GetModifiedFee();\n+                nConflictingSize += it->GetTxSize();\n             }\n+        } else {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n+                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                        hash.ToString(),\n+                        nConflictingCount,\n+                        maxDescendantsToVisit));\n         }\n \n-        constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n-\n-        // Check against previous transactions\n-        // The first loop above does all the inexpensive checks.\n-        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n-        // Helps prevent CPU exhaustion denial-of-service attacks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r320450089",
      "id" : 320450089,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDQ1MDA4OQ==",
      "original_commit_id" : "5bacbfa0c91d70ca358dba096b1a59466edfad87",
      "original_position" : 593,
      "path" : "src/validation.cpp",
      "position" : 593,
      "pull_request_review_id" : 283224736,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320450089",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r320451462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320451462"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not in particular, I think with the refactor the structure made it more clear that we do the CPU intensive operations after the non-CPU intensive ones, but I can resurrect this comment in `AcceptSingleTransaction`.",
      "commit_id" : "ef79e05e18d5be2da19b46a908127f39995561ab",
      "created_at" : "2019-09-03T19:57:45Z",
      "diff_hunk" : "@@ -514,353 +624,393 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n     }\n \n-    {\n-        CCoinsView dummy;\n-        CCoinsViewCache view(&dummy);\n-\n-        LockPoints lp;\n-        CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n-        CCoinsViewMemPool viewMemPool(&coins_cache, pool);\n-        view.SetBackend(viewMemPool);\n-\n-        // do all inputs exist?\n-        for (const CTxIn& txin : tx.vin) {\n-            if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n-                coins_to_uncache.push_back(txin.prevout);\n-            }\n+    LockPoints lp;\n+    m_view.SetBackend(m_viewmempool);\n \n-            // Note: this call may add txin.prevout to the coins cache\n-            // (CoinsTip().cacheCoins) by way of FetchCoin(). It should be removed\n-            // later (via coins_to_uncache) if this tx turns out to be invalid.\n-            if (!view.HaveCoin(txin.prevout)) {\n-                // Are inputs missing because we already have the tx?\n-                for (size_t out = 0; out < tx.vout.size(); out++) {\n-                    // Optimistically just do efficient check of cache for outputs\n-                    if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n-                    }\n-                }\n-                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n-                if (pfMissingInputs) {\n-                    *pfMissingInputs = true;\n+    CCoinsViewCache& coins_cache = ::ChainstateActive().CoinsTip();\n+    // do all inputs exist?\n+    for (const CTxIn& txin : tx.vin) {\n+        if (!coins_cache.HaveCoinInCache(txin.prevout)) {\n+            coins_to_uncache.push_back(txin.prevout);\n+        }\n+\n+        // Note: this call may add txin.prevout to the coins cache\n+        // (coins_cache.cacheCoins) by way of FetchCoin(). It should be removed\n+        // later (via coins_to_uncache) if this tx turns out to be invalid.\n+        if (!m_view.HaveCoin(txin.prevout)) {\n+            // Are inputs missing because we already have the tx?\n+            for (size_t out = 0; out < tx.vout.size(); out++) {\n+                // Optimistically just do efficient check of cache for outputs\n+                if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n                 }\n-                return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n+            // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n+            if (pfMissingInputs) {\n+                *pfMissingInputs = true;\n+            }\n+            return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n         }\n+    }\n \n-        // Bring the best block into scope\n-        view.GetBestBlock();\n+    // Bring the best block into scope\n+    m_view.GetBestBlock();\n \n-        // we have all inputs cached now, so switch back to dummy, so we don't need to keep lock on mempool\n-        view.SetBackend(dummy);\n+    // we have all inputs cached now, so switch back to dummy (to protect\n+    // against bugs where we pull more inputs from disk that miss being added\n+    // to coins_to_uncache)\n+    m_view.SetBackend(m_dummy);\n \n-        // Only accept BIP68 sequence locked transactions that can be mined in the next\n-        // block; we don't want our mempool filled up with transactions that can't\n-        // be mined yet.\n-        // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n-        // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+    // Only accept BIP68 sequence locked transactions that can be mined in the next\n+    // block; we don't want our mempool filled up with transactions that can't\n+    // be mined yet.\n+    // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n+    // CoinsViewCache instead of create its own\n+    if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n \n-        CAmount nFees = 0;\n-        if (!Consensus::CheckTxInputs(tx, state, view, GetSpendHeight(view), nFees)) {\n-            return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n-        }\n+    CAmount nFees = 0;\n+    if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), nFees)) {\n+        return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n+    }\n \n-        // Check for non-standard pay-to-script-hash in inputs\n-        if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+    // Check for non-standard pay-to-script-hash in inputs\n+    if (fRequireStandard && !AreInputsStandard(tx, m_view))\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        // Check for non-standard witness in P2WSH\n-        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+    // Check for non-standard witness in P2WSH\n+    if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, m_view))\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n \n-        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n+    int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n-        // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-        CAmount nModifiedFees = nFees;\n-        pool.ApplyDelta(hash, nModifiedFees);\n+    // nModifiedFees includes any fee deltas from PrioritiseTransaction\n+    nModifiedFees = nFees;\n+    m_pool.ApplyDelta(hash, nModifiedFees);\n \n-        // Keep track of transactions that spend a coinbase, which we re-scan\n-        // during reorgs to ensure COINBASE_MATURITY is still met.\n-        bool fSpendsCoinbase = false;\n-        for (const CTxIn &txin : tx.vin) {\n-            const Coin &coin = view.AccessCoin(txin.prevout);\n-            if (coin.IsCoinBase()) {\n-                fSpendsCoinbase = true;\n-                break;\n-            }\n+    // Keep track of transactions that spend a coinbase, which we re-scan\n+    // during reorgs to ensure COINBASE_MATURITY is still met.\n+    bool fSpendsCoinbase = false;\n+    for (const CTxIn &txin : tx.vin) {\n+        const Coin &coin = m_view.AccessCoin(txin.prevout);\n+        if (coin.IsCoinBase()) {\n+            fSpendsCoinbase = true;\n+            break;\n         }\n+    }\n \n-        CTxMemPoolEntry entry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n-                              fSpendsCoinbase, nSigOpsCost, lp);\n-        unsigned int nSize = entry.GetTxSize();\n+    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+            fSpendsCoinbase, nSigOpsCost, lp));\n+    unsigned int nSize = entry->GetTxSize();\n \n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+    if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n-        CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n-        if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nModifiedFees, mempoolRejectFee));\n-        }\n-\n-        // No transactions are allowed below minRelayTxFee except from disconnected blocks\n-        if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", nModifiedFees, ::minRelayTxFee.GetFee(nSize)));\n-        }\n+    // No transactions are allowed below minRelayTxFee except from disconnected\n+    // blocks\n+    if (!bypass_limits && !CheckFeeRate(nSize, nModifiedFees, state)) return false;\n \n-        if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n+    if (nAbsurdFee && nFees > nAbsurdFee)\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n-        // Calculate in-mempool ancestors, up to a limit.\n-        CTxMemPool::setEntries setAncestors;\n-        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n-        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n-        std::string errString;\n-        if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            setAncestors.clear();\n-            // If CalculateMemPoolAncestors fails second time, we want the original error string.\n-            std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n-            }\n-        }\n-\n-        // A transaction that spends outputs that would be replaced by it is invalid. Now\n-        // that we have the set of all ancestors we can detect this\n-        // pathological case by making sure setConflicts and setAncestors don't\n-        // intersect.\n-        for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    // Calculate in-mempool ancestors, up to a limit.\n+    std::string errString;\n+    if (!m_pool.CalculateMemPoolAncestors(*entry, setAncestors, m_limit_ancestors, m_limit_ancestor_size, m_limit_descendants, m_limit_descendant_size, errString)) {\n+        setAncestors.clear();\n+        // If CalculateMemPoolAncestors fails second time, we want the original error string.\n+        std::string dummy_err_string;\n+        // If the new transaction is relatively small (up to 40k weight)\n+        // and has at most one ancestor (ie ancestor limit of 2, including\n+        // the new transaction), allow it if its parent has exactly the\n+        // descendant limit descendants.\n+        //\n+        // This allows protocols which rely on distrusting counterparties\n+        // being able to broadcast descendants of an unconfirmed transaction\n+        // to be secure by simply only having two immediately-spendable\n+        // outputs - one for each counterparty. For more info on the uses for\n+        // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n+        if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n+                !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+        }\n+    }\n+\n+    // A transaction that spends outputs that would be replaced by it is invalid. Now\n+    // that we have the set of all ancestors we can detect this\n+    // pathological case by making sure setConflicts and setAncestors don't\n+    // intersect.\n+    for (CTxMemPool::txiter ancestorIt : setAncestors)\n+    {\n+        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        if (setConflicts.count(hashAncestor))\n         {\n-            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n-            if (setConflicts.count(hashAncestor))\n-            {\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n-            }\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+                    strprintf(\"%s spends conflicting transaction %s\",\n+                        hash.ToString(),\n+                        hashAncestor.ToString()));\n         }\n+    }\n \n-        // Check if it's economically rational to mine this transaction rather\n-        // than the ones it replaces.\n-        CAmount nConflictingFees = 0;\n-        size_t nConflictingSize = 0;\n-        uint64_t nConflictingCount = 0;\n-        CTxMemPool::setEntries allConflicting;\n-\n-        // If we don't hold the lock allConflicting might be incomplete; the\n-        // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n-        // mempool consistency for us.\n-        const bool fReplacementTransaction = setConflicts.size();\n-        if (fReplacementTransaction)\n-        {\n-            CFeeRate newFeeRate(nModifiedFees, nSize);\n-            std::set<uint256> setConflictsParents;\n-            const int maxDescendantsToVisit = 100;\n-            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n-            for (const auto& mi : setIterConflicting) {\n-                // Don't allow the replacement to reduce the feerate of the\n-                // mempool.\n-                //\n-                // We usually don't want to accept replacements with lower\n-                // feerates than what they replaced as that would lower the\n-                // feerate of the next block. Requiring that the feerate always\n-                // be increased is also an easy-to-reason about way to prevent\n-                // DoS attacks via replacements.\n-                //\n-                // We only consider the feerates of transactions being directly\n-                // replaced, not their indirect descendants. While that does\n-                // mean high feerate children are ignored when deciding whether\n-                // or not to replace, we do require the replacement to pay more\n-                // overall fees too, mitigating most cases.\n-                CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-                if (newFeeRate <= oldFeeRate)\n-                {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                                  hash.ToString(),\n-                                  newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()));\n-                }\n-\n-                for (const CTxIn &txin : mi->GetTx().vin)\n-                {\n-                    setConflictsParents.insert(txin.prevout.hash);\n-                }\n+    // Check if it's economically rational to mine this transaction rather\n+    // than the ones it replaces.\n+    nConflictingFees = 0;\n+    nConflictingSize = 0;\n+    uint64_t nConflictingCount = 0;\n \n-                nConflictingCount += mi->GetCountWithDescendants();\n-            }\n-            // This potentially overestimates the number of actual descendants\n-            // but we just want to be conservative to avoid doing too much\n-            // work.\n-            if (nConflictingCount <= maxDescendantsToVisit) {\n-                // If not too many to replace, then calculate the set of\n-                // transactions that would have to be evicted\n-                for (CTxMemPool::txiter it : setIterConflicting) {\n-                    pool.CalculateDescendants(it, allConflicting);\n-                }\n-                for (CTxMemPool::txiter it : allConflicting) {\n-                    nConflictingFees += it->GetModifiedFee();\n-                    nConflictingSize += it->GetTxSize();\n-                }\n-            } else {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n-                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+    // If we don't hold the lock allConflicting might be incomplete; the\n+    // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n+    // mempool consistency for us.\n+    fReplacementTransaction = setConflicts.size();\n+    if (fReplacementTransaction)\n+    {\n+        CFeeRate newFeeRate(nModifiedFees, nSize);\n+        std::set<uint256> setConflictsParents;\n+        const int maxDescendantsToVisit = 100;\n+        const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n+        for (const auto& mi : setIterConflicting) {\n+            // Don't allow the replacement to reduce the feerate of the\n+            // mempool.\n+            //\n+            // We usually don't want to accept replacements with lower\n+            // feerates than what they replaced as that would lower the\n+            // feerate of the next block. Requiring that the feerate always\n+            // be increased is also an easy-to-reason about way to prevent\n+            // DoS attacks via replacements.\n+            //\n+            // We only consider the feerates of transactions being directly\n+            // replaced, not their indirect descendants. While that does\n+            // mean high feerate children are ignored when deciding whether\n+            // or not to replace, we do require the replacement to pay more\n+            // overall fees too, mitigating most cases.\n+            CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n-                            nConflictingCount,\n-                            maxDescendantsToVisit));\n+                            newFeeRate.ToString(),\n+                            oldFeeRate.ToString()));\n             }\n \n-            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            for (const CTxIn &txin : mi->GetTx().vin)\n             {\n-                // We don't want to accept replacements that require low\n-                // feerate junk to be mined first. Ideally we'd keep track of\n-                // the ancestor feerates and make the decision based on that,\n-                // but for now requiring all new inputs to be confirmed works.\n-                if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n-                {\n-                    // Rather than check the UTXO set - potentially expensive -\n-                    // it's cheaper to just check if the new input refers to a\n-                    // tx that's in the mempool.\n-                    if (pool.exists(tx.vin[j].prevout.hash)) {\n-                        return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n-                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j));\n-                    }\n-                }\n+                setConflictsParents.insert(txin.prevout.hash);\n             }\n \n-            // The replacement must pay greater fees than the transactions it\n-            // replaces - if we did the bandwidth used by those conflicting\n-            // transactions would not be paid for.\n-            if (nModifiedFees < nConflictingFees)\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+            nConflictingCount += mi->GetCountWithDescendants();\n+        }\n+        // This potentially overestimates the number of actual descendants\n+        // but we just want to be conservative to avoid doing too much\n+        // work.\n+        if (nConflictingCount <= maxDescendantsToVisit) {\n+            // If not too many to replace, then calculate the set of\n+            // transactions that would have to be evicted\n+            for (CTxMemPool::txiter it : setIterConflicting) {\n+                m_pool.CalculateDescendants(it, allConflicting);\n             }\n-\n-            // Finally in addition to paying more fees than the conflicts the\n-            // new transaction must pay for its own bandwidth.\n-            CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-            if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n-            {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n-                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                              hash.ToString(),\n-                              FormatMoney(nDeltaFees),\n-                              FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+            for (CTxMemPool::txiter it : allConflicting) {\n+                nConflictingFees += it->GetModifiedFee();\n+                nConflictingSize += it->GetTxSize();\n             }\n+        } else {\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n+                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                        hash.ToString(),\n+                        nConflictingCount,\n+                        maxDescendantsToVisit));\n         }\n \n-        constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n-\n-        // Check against previous transactions\n-        // The first loop above does all the inexpensive checks.\n-        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n-        // Helps prevent CPU exhaustion denial-of-service attacks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#discussion_r320451462",
      "id" : 320451462,
      "in_reply_to_id" : 320450089,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDQ1MTQ2Mg==",
      "original_commit_id" : "5bacbfa0c91d70ca358dba096b1a59466edfad87",
      "original_position" : 593,
      "path" : "src/validation.cpp",
      "position" : 593,
      "pull_request_review_id" : 283226587,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16400",
      "updated_at" : "2019-09-03T20:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320451462",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Could squash the commits?\r\n\r\n\r\nre-ACK 4c176230dbe1d6c7f507f9983dc40c48b39766ba (did the rebase myself and came to the same result)\r\n\r\n<details><summary>Show signature and timestamp</summary>\r\n\r\nSignature:\r\n\r\n```\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA512\r\n\r\nre-ACK 4c176230dbe1d6c7f507f9983dc40c48b39766ba (did the rebase myself and came to the same result)\r\n-----BEGIN PGP SIGNATURE-----\r\n\r\niQGzBAEBCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\r\npUgkugv9F0lQN2nYMHaZYwMzt6PRXjCwd/IslX9phZJlT9vZewf/nRk8kArEaaaX\r\nxYuku345NFSk5wjmMLx0ZkGKAdn2GFvi+oONYh953nL+Jqf9C9sLT3yLU1AwEnlR\r\npWL+UpjSRGDJGQNvdhe/1Q7c2/ZtLEkZSQkm3HHskMj9MF2pik/sOX9gGwpDGTL8\r\n+QOLeFlmC9O8nUTjbs6AYQexjvLsS7gAVAfYW8DWeJsmHbVe/GY5bjRpJj5FTBWD\r\nod7gWTs7TVg88tstH8w2EI0L04aHDsoAEc22UpxFRA/w7sGHuNxmrBUBjrxoEI3P\r\n4GYRr7uQXVXg9rpTrMYIkMkwv3xOOtVslMZDLKzg9QqdKWrkbK29hogHHnaquPJd\r\nJrBvAkLQL2CNorNH3YOJDnIVb0gawZTS9L/T3TrtOeeGd+BlQj/1waY2HxNP1DVi\r\n1IMH2A2RAPrpzz3CTKQI9bwtCAV42uJ5bDiAUppcoU0GlymqvvguYjrfC/up8Iar\r\nurmEkETC\r\n=GMTX\r\n-----END PGP SIGNATURE-----\r\n```\r\n\r\n[Timestamp of file with hash `4006c7685a375c330b238c9bed57e7537aef882d3af5b0be44fcdd0b893c1c57  -`](https://opentimestamps.org/info/?004f70656e54696d657374616d7073000050726f6f6600bf89e2e884e8929401084006c7685a375c330b238c9bed57e7537aef882d3af5b0be44fcdd0b893c1c57f010ff353df36217e3810f6441c556b57cbc08fff01016c93da2e9563868804cdf5c27d7578108f1045d6ec7eff008cb96d2f9755cb3d20083dfe30d2ef90c8e292868747470733a2f2f66696e6e65792e63616c656e6461722e657465726e69747977616c6c2e636f6dfff010b7b3648f50ea8975e14c2f2137389fc808f1045d6ec7eff008aef72afae0a3eb7b0083dfe30d2ef90c8e2c2b68747470733a2f2f626f622e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267fff010bdbbb1a87dd79b5015db5a82cfb80f2608f1045d6ec7eff008eab51fad6facf9ba0083dfe30d2ef90c8e2e2d68747470733a2f2f616c6963652e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267f010c62d654ac901ed65ba5ba3f0413cde4208f1045d6ec7eff008428391419dc67cc70083dfe30d2ef90c8e232268747470733a2f2f6274632e63616c656e6461722e636174616c6c6178792e636f6d)\r\n\r\n</details>\r\n\r\n",
      "created_at" : "2019-09-03T20:07:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-527618316",
      "id" : 527618316,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzYxODMxNg==",
      "updated_at" : "2019-09-03T20:07:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527618316",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Squashed",
      "created_at" : "2019-09-03T20:10:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-527619485",
      "id" : 527619485,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzYxOTQ4NQ==",
      "updated_at" : "2019-09-03T20:10:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527619485",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-09-07T03:17:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-529067164",
      "id" : 529067164,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyOTA2NzE2NA==",
      "updated_at" : "2019-09-07T03:17:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529067164",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> The motivation behind this refactor is to allow implementation of a package relay system (#14895)\r\n\r\nBumped the milestone to 0.20: as noted by @fanquake, as this is preparation work for a feature, it doesn't make a lot of sense to merge this last-minute for 0.19, so I think we should merge this early in the 0.20 release cycle.\r\n(on the other hand this has two ACKs so if people feel this is ready for merge already feel free to disagree)",
      "created_at" : "2019-09-11T07:01:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-530250266",
      "id" : 530250266,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMDI1MDI2Ng==",
      "updated_at" : "2019-09-11T07:01:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/530250266",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I think it makes sense to merge this for 0.19 to make policy backports to 0.19 easier\r\n\r\n@sdaftuar Are you still working on this?",
      "created_at" : "2019-09-11T08:32:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-530279679",
      "id" : 530279679,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMDI3OTY3OQ==",
      "updated_at" : "2019-09-11T08:32:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/530279679",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I independently figured weâd wait until 0.20 for the same reason @laanwj gave, but I can get this rebased sooner for consideration in 0.19.",
      "created_at" : "2019-09-11T08:38:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-530281623",
      "id" : 530281623,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMDI4MTYyMw==",
      "updated_at" : "2019-09-11T08:38:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/530281623",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased (old version is [16400.2](https://github.com/sdaftuar/bitcoin/commits/16400.2))",
      "created_at" : "2019-09-16T15:39:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-531833684",
      "id" : 531833684,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMTgzMzY4NA==",
      "updated_at" : "2019-09-16T15:39:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/531833684",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK 4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d (did the rebase myself and arrived at the same result, mod whitespace)\r\n\r\n<details><summary>Show signature and timestamp</summary>\r\n\r\nSignature:\r\n\r\n```\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA512\r\n\r\nre-ACK 4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d (did the rebase myself and arrived at the same result, mod whitespace)\r\n-----BEGIN PGP SIGNATURE-----\r\n\r\niQGzBAEBCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\r\npUjSRAv9Gg+QHZvblyy4FHN6sRMj+h49EyMuE4ZZfQIbdISoiIQggyDYUQpi1S8K\r\ngtLYc71DYaMO7eNec+pmrBvEiwM3VUFMUePuO3ZE6cNkL8ch3VKdkm8/M9vLriDk\r\ncJjqYKEe+dCUj/mLIzCRZUxs13P0DaQjowiiqbhckwgfejXSILu6Gb34Ykto07Eo\r\n2N9LUOCT5yPX+oxCOLKi2ekKBcUPl1FfZpWTf+8BwQGzXCE7SwJYBbeDVBWdW9TG\r\n5iSrEyoPaLyXJdkDV4SMqwDoaGeK2iTAczh8smM+fpDh6v5m0OYYEtOg/GvN+11z\r\nTJkkrVecwoThJI/qjuWw3PPQGJR/7Rehpo7gf+RBpbp/0KzYspw7JKhS+U30EBjq\r\nGloMYN94xQzkxxs3K166bl0SPo+AePDdFM+JBmisTwCiBUbFXF6RIZklA+vqZpM6\r\nOsG4WgOUHjPO3q0PrNtdd0fl6HtCu19dbasfURcJ6fYprNmwPdqgpc11Mq202ajg\r\nmJKxJZDS\r\n=8KLl\r\n-----END PGP SIGNATURE-----\r\n```\r\n\r\n[Timestamp of file with hash `1e4042da15dcf1e1e7c77742a411deedbfd643673230755ac10c03edcad1c0d0  -`](https://opentimestamps.org/info/?004f70656e54696d657374616d7073000050726f6f6600bf89e2e884e8929401081e4042da15dcf1e1e7c77742a411deedbfd643673230755ac10c03edcad1c0d0f01071786b5ee7d8274bf75a5d3d1e1e095908fff010089eb94fe4d849b6450d044dfc6d7b0a08f1045d7fd189f008f8ab65d491dd70250083dfe30d2ef90c8e2e2d68747470733a2f2f616c6963652e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267fff010232c3e9f0eabcf46ee1d9bacd45a369808f1045d7fd189f008578b78e2b43ba19a0083dfe30d2ef90c8e2c2b68747470733a2f2f626f622e6274632e63616c656e6461722e6f70656e74696d657374616d70732e6f7267fff01063c2c2b3e2f690db1c24ccbf715a5df708f1045d7fd18af0089597ea3985366f250083dfe30d2ef90c8e292868747470733a2f2f66696e6e65792e63616c656e6461722e657465726e69747977616c6c2e636f6df010ae8ac22aed398c16cd19405f9c63090808f1045d7fd189f00875835996b2024e600083dfe30d2ef90c8e232268747470733a2f2f6274632e63616c656e6461722e636174616c6c6178792e636f6d)\r\n\r\n</details>\r\n",
      "created_at" : "2019-09-16T18:17:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-531895366",
      "id" : 531895366,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMTg5NTM2Ng==",
      "updated_at" : "2019-09-16T18:17:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/531895366",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 4a87c5cfdf7dd72d999ebeaf17db6695a7c6298d",
      "created_at" : "2019-09-18T14:15:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16400#issuecomment-532704588",
      "id" : 532704588,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16400",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMjcwNDU4OA==",
      "updated_at" : "2019-09-18T14:15:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/532704588",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   }
]
