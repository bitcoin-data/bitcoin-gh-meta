[
   {
      "author_association" : "NONE",
      "body" : "The more I look at that constructor the less sense it makes. When are you passing pointer at compile time? \r\nWhy does the check for end being at least at begin or after happen after we've 'set' m_size to a very large value? \r\nShouldn't this constructor throw in that case? Or at least, I don't know, somehow indicate that it has an invalid state? \r\nBecause using a span constructed with invalid pointers would result in invoking UB eg: if end() - 1 is dereferenced. \r\nWhere is that pointer? Not in a range that starts at begin(), that's all we know. I'm pretty sure that breaks the whole STL library without much of a warning. \r\n\r\nEDIT: I've talked to other devs. So I understand a bit better. It's a narrow contract in std::span. \r\nMakes sense so far. And this is a \"drop-in\" implementation, so the goal is for it to work the same with Span and std::span. \r\nWhich is great. The thing is: if it's UB now we can detect it and make sure we don't execute invalid code. \r\nIf it's UB with std::span we can't do anything. \r\nIf it's UB now, we do nothing about it, then it's UB in std::span it doesn't have to behave the same way anyway, or in any way for that matter.\r\n\r\nTL;DR: can we please keep those assertion in the non \"DEBUG\" build? Because chances are until a user plays with it it's not gonna break, and I'd argue we want stuff to break in a manner that is evident to everyone involved. \r\nIt's a luxury we lose as soon as we use standard library feature. ",
      "created_at" : "2021-06-20T15:01:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/22289#issuecomment-864567632",
      "id" : 864567632,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22289",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NDU2NzYzMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-20T15:30:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864567632",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7462994?v=4",
         "events_url" : "https://api.github.com/users/ViralTaco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ViralTaco/followers",
         "following_url" : "https://api.github.com/users/ViralTaco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ViralTaco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ViralTaco",
         "id" : 7462994,
         "login" : "ViralTaco",
         "node_id" : "MDQ6VXNlcjc0NjI5OTQ=",
         "organizations_url" : "https://api.github.com/users/ViralTaco/orgs",
         "received_events_url" : "https://api.github.com/users/ViralTaco/received_events",
         "repos_url" : "https://api.github.com/users/ViralTaco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ViralTaco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ViralTaco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ViralTaco"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ">  It's a luxury we lose as soon as we use standard library feature.\r\n\r\nNo, even with the standard library you can check for UB by using sanitizers (UBSan, ASan, MSan, valgrind, ...)",
      "created_at" : "2021-06-20T15:46:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/22289#issuecomment-864573539",
      "id" : 864573539,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22289",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NDU3MzUzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-20T15:46:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864573539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> > It's a luxury we lose as soon as we use standard library feature.\r\n> \r\n> No, even with the standard library you can check for UB by using sanitizers (UBSan, ASan, MSan, valgrind, ...)\r\n\r\nYes, that would work most of the time. It's not a wide contract, though. I was saying here we could make it an explicit requirement, with std::span we can't. \r\nPlease don't rely on any of those tools to detect ALL UB, though. They can miss some. They have. \r\nCode can compile and run fine for years, and stop working one day. It's a lot harder to fix a bug than it is to prevent it, in my experience. ",
      "created_at" : "2021-06-20T16:08:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/22289#issuecomment-864576660",
      "id" : 864576660,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22289",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NDU3NjY2MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-20T16:08:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864576660",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7462994?v=4",
         "events_url" : "https://api.github.com/users/ViralTaco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ViralTaco/followers",
         "following_url" : "https://api.github.com/users/ViralTaco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ViralTaco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ViralTaco",
         "id" : 7462994,
         "login" : "ViralTaco",
         "node_id" : "MDQ6VXNlcjc0NjI5OTQ=",
         "organizations_url" : "https://api.github.com/users/ViralTaco/orgs",
         "received_events_url" : "https://api.github.com/users/ViralTaco/received_events",
         "repos_url" : "https://api.github.com/users/ViralTaco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ViralTaco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ViralTaco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ViralTaco"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'd prefer not to deviate from the std::span interface. Spans are used in some very tight loops, where performance matters. They're intended to be so cheap that they're not worse than just passing a begin pointer and length around all the time.",
      "created_at" : "2021-06-20T20:06:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/22289#issuecomment-864605126",
      "id" : 864605126,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22289",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NDYwNTEyNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-20T23:41:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864605126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ">  Please don't rely on any of those tools to detect ALL UB, though. They can miss some. They have.\r\n\r\nIt was just a list of examples, not an exhaustive list. There is also a standard library debug option, which covers iterators: https://libcxx.llvm.org//DesignDocs/DebugMode.html#iterator-debugging-checks. So when we switch to `std::span` this debug option might or might not debug spans, too.\r\n\r\nAlso, the existing `ASSERT_IF_DEBUG` doesn't catch *ALL UB* either.\r\n\r\n> I was saying here we could make it an explicit requirement, with std::span we can't.\r\n\r\nThe requirement exists for both explicitly, but it is only possible (in the general case) to catch this with a runtime check. I don't think this is a (theoretical) reason to avoid switching to `std::span`, unless you can show a likely bug that is caught by this runtime check and won't be caught by any of our existing sanitizers while using `std::span`.",
      "created_at" : "2021-06-21T05:30:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/22289#issuecomment-864740105",
      "id" : 864740105,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22289",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NDc0MDEwNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-21T05:30:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864740105",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> I'd prefer not to deviate from the std::span interface. Spans are used in some very tight loops, where performance matters. They're intended to be so cheap that they're not worse than just passing a begin pointer and length around all the time.\r\n\r\nI realized that, that's why I made a pull request just adding documentation. In this case it makes sense to avoid a redondant check (even if I have a personal preference for safety; in this case it has a real cost in terms of percieved complexity). \r\n\r\n> Also, the existing ASSERT_IF_DEBUG doesn't catch ALL UB either.\r\nIt doesn't catch any UB, technically. std::size_t is unsigned so if the number is negative it uses modulo arithmetic, iirc. \r\n\r\nThat's not the UB part. The UB part would be trying to use that span after it was created with that invalid state. \r\nIt's perfectly legal, and valid to create Span with begin coming after end. It's UB with std::span because std::span comes with a standard definition. \r\n\r\n> 3) Constructs a span that is a view over the range [first, last); [â¦]\r\nThe behavior is undefined if [first, last) is not a valid range, [â¦]\r\n\r\ncf: https://en.cppreference.com/w/cpp/container/span/span\r\n\r\nWhich is why my proposed change is just documentation. In this case it's all that is needed to keep the same behavior as std::span whilst making it obvious. \r\n\r\nI was confused by the \"weird\" macros. In hindsight it makes more sense. \r\nEnough sense to conceide that the code doesn't need changing, but a comment wouldn't hurt. (In my case it would have saved a couple hours of confusion). \r\n\r\nSomeone had to point out to me \"They're testing for the narrow contract in debug builds\". \r\nThat's what is happening; It's not obvious when reading the code `ASSERT_IF_DEBUG` reads to me exactly like `assert` which already asserts only if `NDEBUG` isn't defined. \r\n\r\nStill not sure about the `CONSTEXPR_IF_NOT_DEBUG` I'm assuming it just avoids Ill formed NDR \r\nIt could be named `CONSTEXPR_IF_NO_ASSERT` but that's needlessly nitpicky at this point. ",
      "created_at" : "2021-06-21T17:49:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/22289#issuecomment-865227753",
      "id" : 865227753,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22289",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NTIyNzc1Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-21T17:49:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865227753",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7462994?v=4",
         "events_url" : "https://api.github.com/users/ViralTaco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ViralTaco/followers",
         "following_url" : "https://api.github.com/users/ViralTaco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ViralTaco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ViralTaco",
         "id" : 7462994,
         "login" : "ViralTaco",
         "node_id" : "MDQ6VXNlcjc0NjI5OTQ=",
         "organizations_url" : "https://api.github.com/users/ViralTaco/orgs",
         "received_events_url" : "https://api.github.com/users/ViralTaco/received_events",
         "repos_url" : "https://api.github.com/users/ViralTaco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ViralTaco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ViralTaco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ViralTaco"
      }
   }
]
