{
   "assignee" : null,
   "assignees" : [],
   "author_association" : "CONTRIBUTOR",
   "body" : "_Hansel and Gretel\r\nleft bread crumb trails as they went\r\nbut birds ate them all._\r\n\r\nThis Pull Request improves the asymptotic complexity of many of the mempool's algorithms as well as makes them more performant in practice.\r\n\r\nIn the mempool we have a lot of algorithms which depend on rather computationally expensive state tracking. The state tracking algorithms we use make a lot of algorithms inefficient because we're inserting into various sets that grow with the number of ancestors and descendants, or we may have to iterate multiple times of data we've already seen.\r\n\r\nTo address these inefficiencies, we can closely limit the maximum possible data we iterate and reject transactions above the limits.\r\n\r\nHowever, a rational miner/user will purchase faster hardware and raise these limits to be able to collect more fee revenue or process more transactions. Further, changes coming from around the ecosystem (lightning, OP_SECURETHEBAG) have critical use cases which benefit when the mempool has fewer limitations.\r\n\r\nRather than use expensive state tracking, we can do something simpler. Like Hansel and Gretel, we can leave breadcrumbs in the mempool as we traverse it, so we can know if we are going somewhere we've already been. Luckily, in bitcoind there are no birds!\r\n\r\nThese breadcrumbs are a uint64_t epoch per CTxMemPoolEntry. (64 bits is enough that it will *never* overflow). The mempool also has a counter.\r\n\r\nEvery time we begin traversing the mempool, and we need some help tracking state, we increment the mempool's counter. Any CTxMemPoolEntry with an epoch less than the MemPools has not yet been touched, and should be traversed and have it's epoch set higher.\r\n\r\nGiven the one-to-one mapping between CTxMemPool entries and transactions, this is a safe way to cache data.\r\n\r\nUsing these bread-crumbs allows us to get rid of many of the std::set accumulators in favor of a std::vector as we no longer rely on the de-duplicative properties of std::set.\r\n\r\nWe can also improve many of the related algorithms to no longer make heavy use of heapstack based processing.\r\n\r\nThe overall changes are not that big. It's 302 additions and 208 deletions. You could review it all at once, especially for a Concept Ack. But I've carefully done them in small steps to permit careful analysis of the changes. So I'd recommend giving the final state of the PR a read over first to get familiar with the end-goal (it won't take long), and then step through commit-by-commit so you can be convinced of the correctness for more thorough code reviewers.\r\n\r\n**But is it good in practice?** Yes! Basic benchmarks show it being 5% faster on the AssembleBlock benchmark, and 14.5% faster on MempoolEviction, but they aren't that tough. Tougher benchmarks, as described below, show a **>2x speedup**. \r\n\r\n> PR #17292, adds a motivating benchmark for the Epoch Mempool.\r\n> \r\n> ./src/bench/bench_bitcoin --filter=ComplexMemPool --scaling=5\r\n> \r\n> Before:\r\n> \r\n>     # Benchmark, evals, iterations, total, min, max, median\r\n>     ComplexMemPool, 5, 5, 6.62715, 0.264409, 0.265441, 0.2654\r\n> \r\n> After:\r\n> \r\n>     # Benchmark, evals, iterations, total, min, max, median\r\n>     ComplexMemPool, 5, 5, 3.07116, 0.122246, 0.12351, 0.122783\r\n> \r\n> This shows a > 2x speedup on this difficult benchmark (~2.15x across total, min, max, median).\r\n> \r\n> Note: For scientific purity, I created it \"single shot blind\". That is, I did not modify the test at all after running it on the new branch (I had to run it on master to fix bugs / adjust the expected iters for a second parameter, and then adjust the internal params to get it to be about a second).\r\n\r\n**What's the catch?** The specific downsides of this approach are twofold:\r\n\r\n1) We need to store an extra 8 bytes per CTxMemPoolEntry\r\n2) Some of the algorithms are a little bit less obvious & are \"less safe\" to call concurrently (e.g., from a recursive call, not necessarily in parallel)\r\n\r\nBut for these two specific downsides:\r\n\r\n1) The 8 bytes could be reduced to 4 (with code to reset all CTxMemPoolEntries near overflow, but then we would need to more carefully check that we won't overflow the epoch in a recursive call.\r\n2) The 8 bytes could be a 4 byte index into a table of 8 (or 4, or even fewer) Byte epochs + back pointer, at expense of indirection like vTxHashes. Then we would only ever need as many epochs as the things we walk per-epoch.\r\n3) We can replace the epoch with an atomic<epoch>, which would allow for new parallel graph traversal algorithms to build descendants more quickly\r\n4) Some algorithms benefit from recursive epoch use\r\n\r\nSo overall, I felt the potential benefits outweigh the risks.\r\n\r\n\r\n**What's next?**\r\nI've submitted this a bit early for review to gain concept acks on the approach, independent testing, and feedback on methodologies for testing, as well as to collect more worst-case edge conditions to put into benchmarks. It's not quite a WIP -- the code passes tests and is \"clean\", but it should receive intense scrutiny before accepting.",
   "closed_at" : "2020-01-15T03:44:04Z",
   "closed_by" : {
      "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
      "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
      "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/JeremyRubin",
      "id" : 886523,
      "login" : "JeremyRubin",
      "node_id" : "MDQ6VXNlcjg4NjUyMw==",
      "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
      "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
      "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/JeremyRubin"
   },
   "comments" : 16,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17268/comments",
   "created_at" : "2019-10-26T21:22:15Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17268/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/pull/17268",
   "id" : 512887125,
   "labels" : [
      {
         "color" : "fef2c0",
         "default" : false,
         "description" : null,
         "id" : 164208572,
         "name" : "Mempool",
         "node_id" : "MDU6TGFiZWwxNjQyMDg1NzI=",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool"
      },
      {
         "color" : "c7def8",
         "default" : false,
         "description" : null,
         "id" : 118378960,
         "name" : "Mining",
         "node_id" : "MDU6TGFiZWwxMTgzNzg5NjA=",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Mining"
      },
      {
         "color" : "5319e7",
         "default" : false,
         "description" : null,
         "id" : 82428251,
         "name" : "TX fees and policy",
         "node_id" : "MDU6TGFiZWw4MjQyODI1MQ==",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/TX%20fees%20and%20policy"
      },
      {
         "color" : "6060aa",
         "default" : false,
         "description" : null,
         "id" : 118379652,
         "name" : "Validation",
         "node_id" : "MDU6TGFiZWwxMTgzNzk2NTI=",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17268/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDExOlB1bGxSZXF1ZXN0MzMyODAyNzMw",
   "number" : 17268,
   "pull_request" : {
      "diff_url" : "https://github.com/bitcoin/bitcoin/pull/17268.diff",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17268",
      "patch_url" : "https://github.com/bitcoin/bitcoin/pull/17268.patch",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17268"
   },
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "closed",
   "title" : "Epoch Mempool",
   "updated_at" : "2020-01-15T03:44:04Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17268",
   "user" : {
      "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
      "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
      "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/JeremyRubin",
      "id" : 886523,
      "login" : "JeremyRubin",
      "node_id" : "MDQ6VXNlcjg4NjUyMw==",
      "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
      "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
      "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/JeremyRubin"
   }
}
